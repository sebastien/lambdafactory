@import reporter
@import interfaces

@class PassContext
    
	@property context  = []
	@property reporter = None

    # REWRITE: @constructor reporter=reporter.DefaultReporter
	@constructor reporter=(reporter DefaultReporter)
		
	@end

	
	@group ContextAccessors
	
		@method filterContext interface
		@as internal
			@embed Python
			|return filter(lambda x:isinstance(x,interface), self.context) 
			@end
		@end
		
		@method findInContext interface
		@as internal
			var res = filterContext(interface)
			if res
				return res[-1]
			else
				return None
			end
		@end
		
		@method isIn interface
			return findInContext (interface ) != None
		@end
		
		@method getCurrentClosure
			return findInContext (interfaces IClosure)
		@end
		
		@method getCurrentFunction
			return findInContext (interfaces IFunction)
		@end

		@method getCurrentMethod
			return findInContext (interfaces IMethod)
		@end

		@method getCurrentClass
			return findInContext (interfaces IClass)
		@end

		@method getCurrentClassParents theClass
			var parents = []
			if theClass is None
				theClass = getCurrentClass()
			end
			var current_class = theClass
			for parent_class_ref in current_class getSuperClasses()
				var parent_class_name = parent_class_ref getReferenceName()
				var resolution = resolve ( parent_class_name, current_class )
				var target, context = resolution
				parent_class = target value
				# TODO: assert parent
				parents append (parent_class)
			end
		@end
		
	@end
	
	@group Resolution
	
		@method resolve referenceOrName, contextOrDataFlow=None
			if contextOrDataFlow is None
				contextOrDataFlow = getCurrentContext() getDataFlow()
			if isinstance( contextOrDataFlow, interfaces IElement )
				contextOrDataFlow = contextOrDataFlow getDataFlow()
			end
			if isinstance(referenceOrName, interfaces IReference)
				referenceOrName = referenceOrName getReferenceName()
			end
			return contextOrDataFlow resolve (referenceOrName)
		@end
	@end
@end

@class Pass

	@property isWalking = False
	
	@property matches  = []
	
	@method walk element
		# Is the element a Context ? -> walk slots
		if isinstance(element, interfaces IContext)
		end
		# Is the element a Process ? -> walk operations
		if isintance(element, interfaces IProcess)
		end
		# Is the element matched -> walk it
		# TODO: assert not isWalking
		print element
	@end
	
	@method isHandled element:IElement
	| Tells if the pass handles the given element. This basically iterates
	| on the 'handles' property values (which are interfaces), when one
	| interface matches the given 'element', then the corresponding 'doXXX'
	| method is invoked, where 'XXX' is the interface
	| name (without the leading 'I').
		for interface in handles
			# REWRITE: element is an interface
			if isinstance(element, interface)
				# REWRITE return self `(interface getClass() getName())
				return getattr(self, interface __class__ __name__ [1:])
			end
		end
	@end
	
@end

# ============================================================================
#
# Transform Asynchronous Invocations Pass
#
# ============================================================================

@class TransformAsynchronousInvocations: Pass

	@property matches = [ interfaces IClosure ]
	
	@constructor
		super()
	@end
	
@end

# EOF	