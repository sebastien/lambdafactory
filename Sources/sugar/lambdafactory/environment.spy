@module lambdafactory.environment
@import os, sys
@import DefaultReporter from lambdafactory.reporter
@import Factory from lambdafactory.modelbase

@class Importer
| The Environment importer class acts like a "hub" for language-specific
| importers. It will try, according to the current environment settings,
| to resolve a module absolute name and return a program model object
| corresponding to the given module.

	@property environment
	
	@constructor environment
		self environment = environment
	@end

	@method findSugarModule moduleName
		var paths = [ os getcwd() ]
		if os environ get "SUGARPATH"
			paths extend (os environ get "SUGARPATH" split ":")
		end
		var module_path = moduleName replace (".", "/")
		for path in paths
			for ext in ".sg .sjs .sjava .spnuts .spy" split()
				if os path exists(module_path + ext)
					return module_path + ext
				end
			end
		end
		return None
	@end

	@method importModule moduleName
		var module_path = findSugarModule(moduleName)
		if module_path
			environment reporter info ("Importing module", moduleName, "from", module_path)
			var module = environment parseModule (module_path, moduleName)
			environment getProgram() addModule(module)
			environment reporter info ("done.")
		end
	@end

@end

@class Language
	
	@property name:String
	@property basePath:String
	@property runtime:<Class|None>
	@property importer:<Class|None>
	@property writer:<Class|None>
	@property reader:<Class|None>
	@property runner:<Class|None>
	@property environment
	@property readExtensions = []
	
	@constructor name, environment
		self environment = environment
		self name = name
		self basePath = basePath
		self runtime  = loadModule "runtime"
		self importer = loadModule "importer"
		self writer   = loadModule "writer"
		self reader   = loadModule "reader"
		self runner   = loadModule "runner"
	@end

	@method addRecognizedExtension extension
		readExtensions append (extension lower())
	@end

	@method recognizes path
		var extension = os path splitext (path)[-1][1:] lower()
		return extension in readExtensions
	@end
		
	@method loadModule moduleName
	| Dynamically loads the language module
		try
			# print ("import lambdafactory.languages." + name + "." + moduleName + " as m")
			exec ("import lambdafactory.languages." + name + "." + moduleName + " as m")
			var module = eval "m"
			return getattr(module, "MAIN_CLASS")
		catch e
			environment report error ("Language " + name + ", cannot import module " + moduleName + ": " + str(e))
			return None
		end
	@end

@end

@class Environment
	
	@property factory=None
	@property program=None
	@property parsers={}
	@property passes=[]
	@property writer=None
	@property report=DefaultReporter
	@property importer=None
	@property languages={}
	# FIXME: This should be a pass
	@property resolver=None
	
	@constructor
		importer = new Importer(self)
		factory  = new Factory()
		program  = factory createProgram ()
	@end

	@method addParser parser, extensions
		for ext in extensions
			parsers[ext lower()] = parser
		end
	@end

	@method addImporter importer
		# TODO: Support for multiple importers
		# self importer = importer
	@end
	
	@method addPass programPass
		passes append (programPass)
	@end
	
	@method getPass name
		for p in passes
			if p getName() == name
				return p
			end
		end
	@end
	
	@method getPasses
		return passes
	@end
	
	@method getProgram
		return program
	@end
	
	@method getFactory
		return program getFactory()
	@end
	
	@method importModule name
		return importer importModule(name)
	@end

	@method parseFile path
		var extension = os path splitext (path)[-1][1:] lower()
		var parser = parsers get (extension)
		var source_and_module = parser parse(path)
		return source_and_module[1]
	@end
	
	# FIXME: The language should be initialized for the environment
	@method listAvailableLanguages
	| Returns a list of available languages
		var base_dir = os path join(os path dirname(os path abspath (__file__)),"languages")
		var languages = []
		for name in os listdir(base_dir)
			if os path isdir(os path join(base_dir, name))
				languages append (name)
			end
		end
		return languages
	@end
	
	@method loadLanguages
		for language in listAvailableLanguages()
			loadLanguage(language)
		end
	@end

	@method loadLanguage name
	@as internal
	| Loads the given language plug-in and returns a dictionary containing
	| its features.
		if not (name in languages keys())
			languages[name] = new Language(name, self)
		end
		return languages[name]
	@end

@end
