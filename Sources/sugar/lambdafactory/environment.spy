@module lambdafactory.environment
@import os, sys
@import DefaultReporter from lambdafactory.reporter
@import Factory from lambdafactory.modelbase
@import PassContext from lambdafactory.passes

# ------------------------------------------------------------------------------
#
# IMPORTER
#
# ------------------------------------------------------------------------------

@class Importer
| The Environment importer class acts like a "hub" for language-specific
| importers. It will try, according to the current environment settings,
| to resolve a module absolute name and return a program model object
| corresponding to the given module.

	@property environment
	
	@constructor environment
		self environment = environment
	@end

	@method findSugarModule moduleName
		var paths = []
		for path in environment libraryPaths
			paths append (path)
		end
		if os environ get "SUGARPATH"
			paths extend (os environ get "SUGARPATH" split ":")
		end
		var module_path = moduleName replace (".", os path sep)
		for path in paths
			# We normalize the path, so that paths like . and ~/ work fine
			path = os path abspath ( os path expandvars ( os path expanduser (path)))
			for ext in ".sg .sjs .sjava .spnuts .spy" split()
				var file_path = os path join(path, module_path + ext)
				if os path exists(file_path)
					return file_path
				end
			end
		end
		return None
	@end

	@method importModule moduleName
		var module_path = findSugarModule(moduleName)
		if module_path
			environment report info ("Importing module", moduleName, "from", module_path, "...")
			environment report indent()
			# The module is automatically addded to the program
			var module = environment parseFile (module_path)
			module setImported(True)
			environment report dedent()
			return module
		else
			environment report error ("Module not found:", moduleName)
		end
	@end

@end

# ------------------------------------------------------------------------------
#
# LANGUAGE
#
# ------------------------------------------------------------------------------

@class Language
	
	@property name:String
	@property basePath:String
	@property runtime:<Class|None>
	@property importer:<Class|None>
	@property writer:<Class|None>
	@property reader:<Class|None>
	@property runner:<Class|None>
	@property environment
	@property readExtensions = []
	
	@constructor name, environment
		self environment = environment
		self name = name
		self basePath = basePath
		self runtime  = loadModule "runtime"
		self importer = loadModule "importer"
		self writer   = loadModule "writer"
		self reader   = loadModule "reader"
		self runner   = loadModule "runner"
	@end


	@method addRecognizedExtension extension
		readExtensions append (extension lower())
	@end

	@method recognizes path
		var extension = os path splitext (path)[-1][1:] lower()
		return extension in readExtensions
	@end

	@method loadModule moduleName
	| Dynamically loads the language module
		try
			# print ("import lambdafactory.languages." + name + "." + moduleName + " as m")
			exec ("import lambdafactory.languages." + name + "." + moduleName + " as m")
			var module = eval "m"
			return getattr(module, "MAIN_CLASS")
		catch e
			var error = str(e)
			if not (error startswith "No module")
				environment report error ("Language " + name + ", cannot import module " + moduleName + ": " + str(e))
			end
			return None
		end
	@end

@end

# ------------------------------------------------------------------------------
#
# ENVIRONMENT
#
# ------------------------------------------------------------------------------

@class Environment
|
| Passes
| ======
|
| Passes are lists of passes (see 'lambdafactory.passes') that transform the
| program. The order of passe is important, as some passes depend on each other.
| It is up to the 'lambdafactory.main.Command' subclass to set up the passes
| appropriately.

	@property factory=None
	@property program=None
	@property parsers={}
	@property passes=[]
	@property writer=None
	@property report=DefaultReporter
	@property importer=None
	@property languages={}
	@property libraryPaths   = []
	@property options={}
	# FIXME: This should be a pass
	@property resolver=None
	
	@constructor
		importer = new Importer(self)
		factory  = new Factory()
		program  = factory createProgram ()
	@end

	@method addLibraryPath path:String
		libraryPaths append(path)
	@end

	@method addParser parser, extensions
		for ext in extensions
			parsers[ext lower()] = parser
		end
	@end

	@method addImporter importer
		# TODO: Support for multiple importers
		# self importer = importer
	@end

	@method addPass programPass
		passes append (programPass)
		programPass setEnvironment(self)
	@end
	
	@method getPass name
		name = name lower()
		for p in passes
			if p getName() lower() == name 
				return p
			end
		end
	@end

	@method getPasses
		return passes
	@end
	
	@method runPasses
		for p in passes
			p run()
		end
	@end
	
	@method getProgram
		return program
	@end
	
	@method getFactory
		return factory
	@end
	
	@method importModule name
		return importer importModule(name)
	@end

	@method parseFile path, moduleName=None
		var extension = os path splitext (path)[-1][1:] lower()
		var parser = parsers get (extension)
		var source_and_module = parser parse( path, moduleName)
		return source_and_module[1]
	@end

	@method parseSource source, extenstion, moduleName=None
		var parser = parsers get (extenstion)
		var source_and_module = parser parseSource( source, moduleName)
		return source_and_module[1]
	@end
	
	# FIXME: The language should be initialized for the environment
	@method listAvailableLanguages
	| Returns a list of available languages
		var base_dir = os path join(os path dirname(os path abspath (__file__)),"languages")
		var languages = []
		for name in os listdir(base_dir)
			if os path isdir(os path join(base_dir, name))
				languages append (name)
			end
		end
		return languages
	@end
	
	@method loadLanguages
		for language in listAvailableLanguages()
			loadLanguage(language)
		end
	@end

	@method loadLanguage name
	@as internal
	| Loads the given language plug-in and returns a dictionary containing
	| its features.
		if not (name in languages keys())
			languages[name] = new Language(name, self)
		end
		return languages[name]
	@end

@end
