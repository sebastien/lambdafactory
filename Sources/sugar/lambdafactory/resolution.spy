@module lambdafactory.resolution
@import lambdafactory.interfaces as interfaces
@import Pass from lambdafactory.passes

# ============================================================================
#
# BasicDataFlow
#
# ============================================================================

@class BasicDataFlow: Pass
| The basic dataflow pass will associate DataFlow objects to elements which
| don't have any already, and will make sure that Context slots are defined
| in the dataflow, as well as allocations.
|
| It is safe to apply this pass more than once on the program, but as it will
| keep the existing dataflow information, you should make sure that if you
| modified the program model in the meantime, you clear the dataflow out of the
| elements that you changed.
|
| TODO: Implement an 'invalidateDataFlow' when an operation is replaced/deleted,
| so that we ensure that the DF remains consitent.
|
| Rules:
| 
| - DataFlows are created for Context and Processes
| - DataFlowSlots begin with nothing or an allocation
| - DataFlowSlots operations are the operations that reference the slot (stage 2)
|
| Stages:
|
| 1) Create dataflows for Contexts, Processes, Importations and Allocations
| 2) Properly flow classes (so that resolution in parents can happen)
| 3) Attaches operations that reference a value to the original slot (this
|    prepares the path for the typing pass)

	@shared HANDLES = [
		interfaces IProgram
		interfaces IModule
		interfaces IClass
		interfaces IMethod
		interfaces IClosure
		interfaces IProcess
		interfaces IContext
		interfaces IAllocation
		interfaces IOperation
		interfaces IValue
	]
	@shared NAME    = "Resolution"

	@constructor
		Pass __init__ (self)
	@end

	@method getParentDataFlow
	| Returns the dataflow of the parent element. It is supposed to exist.
		if self hasParentElement()
			return self getParentElement() getDataFlow()
		else
			return None
		end
	@end

	@method ensureDataFlow element
	@as internal
	| Ensures that the given element has an attached DataFlow
		var dataflow = element getDataFlow()
		if not dataflow
			dataflow = self getFactory() createDataFlow(element)
			dataflow setParent ( getParentDataFlow() )
			element setDataFlow( dataflow )
		end
		return dataflow
	@end

	@method onProgram element
		# Programs have thir own dataflows
		var dataflow = ensureDataFlow (element)
		# FIXME: Factor this in some specific file
		dataflow declareEnvironment("Undefined", None)
		dataflow declareEnvironment("True", None)
		dataflow declareEnvironment("False", None)
		dataflow declareEnvironment("Null", None)
		# TODO: We register modules in the dataflow
	@end

	@method onModule element
		# Modules have thir own dataflows
		var dataflow = ensureDataFlow (element)
		onContext(element)
	@end

	@method onClass element
		# Programs have thir own dataflows
		var dataflow = ensureDataFlow (element)
		dataflow declareEnvironment("super", None)
		dataflow declareEnvironment("self", None)
		onContext(element)
	@end

	@method onMethod element
		# Programs have thir own dataflows
		var dataflow = ensureDataFlow (element)
		dataflow declareEnvironment("super", None)
		dataflow declareEnvironment("self", None)
		onClosure(element)
	@end

	@method onClosure element
		var dataflow = ensureDataFlow (element)
		for argument in element getArguments()
			dataflow declareArgument(argument getName(), argument)
		end
	@end

	@method onProcess element
		# Processes have thir own dataflows
		var dataflow = ensureDataFlow (element)
	@end

	@method onContext element
		# Contexts have thir own dataflows
		var dataflow = ensureDataFlow (element)
		for name_and_value in element getSlots()
			dataflow declareVariable(name_and_value[0], name_and_value[1], element)
		end
	@end

	@method onAllocation element
		onOperation(element)
		var dataflow = element getDataFlow()
		var name = element getSlotToAllocate() getName()
		dataflow declareVariable( name, element getDefaultValue(), element)
	@end

	@method onOperation element
		var dataflow = element getDataFlow()
		if not dataflow
			dataflow = getParentDataFlow()
			element setDataFlow(dataflow)
		end
	@end

	@method onValue element
		var dataflow = element getDataFlow()
		if not dataflow
			dataflow = getParentDataFlow()
			element setDataFlow(dataflow)
		end
	@end

@end

@class DataFlowBinding: Pass
| This pass will target classes, resolving their parent classes and binding the
| dataflow slot to the proper value. If the binding fails, an exception will be
| raised, meaning that either the passes were not set up properly, or that the
| resolution has failed (and there is an inconsistency in the program model).

	@shared HANDLES = [
		interfaces IModule
		interfaces IClass
	]
	@shared NAME    = "ClassParentsResolution"

	@constructor
		Pass __init__ (self)
	@end

	@method onModule element
	| Processes the module import operations and adds them to the module
	| dataflow
		var imports = element getImportOperations()
		var FAILED =  tuple([None,None])
		for i in imports
			if isinstance(i, interfaces IImportModuleOperation)
				var absolute_name  = i getImportedModuleName()
				var alias          = i getAlias()
				var slot_and_value = self resolveAbsolute(absolute_name)
				if slot_and_value == FAILED
					self environment report error ("Imported module not found in scope:", absolute_name, "in", element getName())
				if alias
					element getDataFlow() declareImported ( alias, slot_and_value[1], i)
					assert (element getDataFlow() getElement() == element)
					assert (element getDataFlow() resolve (alias)[0] getDataFlow() == element getDataFlow() )
					assert (element getDataFlow() resolve (alias)[0] getDataFlow() getElement() == element)
				end
			if isinstance(i, interfaces IImportSymbolOperation)
				var module_name = i getImportOrigin()
				var symbol_name = i getImportedElement()
				var slot_and_value = self resolveAbsolute(module_name)
				if slot_and_value == FAILED
					self environment report error ("Imported module not found in scope:", module_name, "in", element getName())
				else
					var symbol_slot_and_value = self resolve ( symbol_name, slot_and_value[1] )
					if symbol_slot_and_value == FAILED
						self environment report error ("Symbol not found in module scope:", symbol_name, "in", module_name)
					else
						var alias = i getAlias()
						var value = symbol_slot_and_value[1]
						assert (element getDataFlow() getElement() == element)
						if alias
							element getDataFlow() declareImported ( alias, value, i)
							assert (element getDataFlow() resolve (alias)[0] getDataFlow() == element getDataFlow() )
							assert (element getDataFlow() resolve (alias)[0] getDataFlow() getElement() == element)
						else
							element getDataFlow() declareImported ( symbol_name, value, i)
							assert (element getDataFlow() resolve (symbol_name)[0] getDataFlow() == element getDataFlow() )
							assert (element getDataFlow() resolve (symbol_name)[0] getDataFlow() getElement() == element)
						end
					end
				end
			else
				# TEST: When resolution works well, self should not be necessary
				self environment report error ("DataFlowBinding: operation not implemented " + repr(i))
			end
		end
	@end

	@method onClass element
		for parent_class_ref in element getParentClasses()
			var slot_and_value = self resolveLocalOrAbsolute(parent_class_ref)
			if not slot_and_value[0]
				self environment report error ("Parent class not found:", parent_class_ref getReferenceName(), "in", element getName())
			else
				var parent_class = slot_and_value[1]
				assert (isinstance(parent_class, interfaces IClass))
				element getDataFlow() addSource (parent_class getDataFlow())
				#for slot in parent_class getDataFlow() getSlots()
				#	assert (element getDataFlow() resolve (slot getName())[0])
				#end
			end
		end
	@end

@end

# EOF
