@module lambdafactory.passes
@import lambdafactory.reporter as reporter
@import lambdafactory.interfaces as interfaces

# ============================================================================
#
# Pass Context
#
# ============================================================================

@class PassContext
| The 'PassContext' represents the current state of one or more passes when
| walking the program. It offers access to the 'environment' (gives access
| to the program and various passes).
|
| A single context can be shared among various passes.
    
	@property environment = None
	@property context     = []
	@property programPass = None

    # REWRITE: @constructor reporter=reporter.DefaultReporter
	@constructor environment=None, programPass=None
		self environment = environment
		self programPass = programPass
	@end

	@method setEnvironment environment
		self environment = environment
	@end

	@method setPass programPass
		self programPass = programPass
	@end

	@method run
		walk ( environment getProgram() )
	@end

	@method handle element
	| Handles a sungle element, without recursing through its children
		var handle = programPass getHandler(element)
		if handle
			return handle (element)
		else
			return None
		end
	@end

	@method walk element
	| Walks the given element, recursively walking the child elements when the
	| handler does not return False
		# REWRITE: context push(element)
		context append (element)
		var continue_walking = True
		# We iterate on the program passes, if every pass 
		# FIXME: There should be only one pass/context
		var handle = programPass getHandler(element)
		if handle
			# TODO: Optimize by removing passes not interested in
			# going deeper
			if handle (element) != False
				continue_walking = True
			end
		end
		# If we continue the walking, then we recurse on context slots and
		# in operations (if we're in a process).
		if continue_walking != False
			# Is the element a Program ? -> walk modules
			if isinstance(element, interfaces IProgram)
				for module in element getModules()
					walk (module)
				end
			end
			# Is the element a Context ? -> walk slots
			if isinstance(element, interfaces IContext)
				for name_and_value in element getSlots()
					walk (name_and_value[1])
				end
			end
			# Is the element a Process ? -> walk operations
			if isinstance(element, interfaces IProcess)
				for operation in element getOperations()
					walk (operation)
				end
			end
			# Is the element an Operation ? -> walk arguments
			if isinstance(element, interfaces IOperation)
				for op_arg in element getOpArguments()
					# TODO: Rewrite me
					if type(op_arg) in [tuple, list]
						for arg in op_arg
							assert (isinstance(arg, interfaces IElement))
							walk(arg)
						end
					else
						walk (op_arg)
					end
				end
			end
		end
		context pop()
	@end

	@group ContextAccessors
	
		@method filterContext interface
		@as internal
			@embed Python
			|return filter(lambda x:isinstance(x,interface), self.context) 
			@end
		@end
		
		@method filter list, interface
		@as internal
			@embed Python
			|return filter(lambda x:isinstance(x,interface), list) 
			@end
		@end
		
		@method findInContext interface
		@as internal
			var res = filterContext(interface)
			if res
				return res[-1]
			else
				return None
			end
		@end

		@method getParentElement
		@as alias
			return context[-2]
		@end

		@method hasParentElement
			return len(context) > 1
		@end

		@method getCurrentElement
		@as alias
			return context[-1]
		@end
		
		@method getProgram
		@as alias
			return environment getProgram()
		@end

		@method getFactory
		@as alias
			return environment getFactory()
		@end

		@method isIn interface
			return findInContext (interface ) != None
		@end
		
		@method getCurrentClosure
			return findInContext (interfaces IClosure)
		@end
		
		@method getCurrentFunction
			return findInContext (interfaces IFunction)
		@end

		@method getCurrentModule
			return findInContext (interfaces IModule)
		@end

		@method getCurrentDataFlow
			var i = len(context) - 1
			while i >= 0
				var dataflow = context[i] getDataFlow()
				if dataflow
					return dataflow
				end
				i -= 1
			end
			return None
		@end

		@method getCurrentMethod
			return findInContext (interfaces IMethod)
		@end

		@method getCurrentContext
			return findInContext (interfaces IContext)
		@end

		@method getCurrentClass
			return findInContext (interfaces IClass)
		@end

		@method getCurrentProcess
			return findInContext (interfaces IProcess)
		@end
		
		@method getCurrentClassParents theClass=None
			var parents = []
			if theClass is None
				theClass = getCurrentClass()
			end
			if not theClass
				return tuple([])
			end
			var current_class = theClass
			for parent_class_ref in current_class getParentClasses()
				var parent_class_name = parent_class_ref getReferenceName()
				var resolution = resolve ( parent_class_name, current_class getParent () )
				# We resolve the parent_class_name in the 'current_class' parent context, as resolving
				# directly in class may have context clashes (like you have an operation or attribute
				# with the same name as the parent_class_name).
				var slot, parent_class = resolution
				# TODO: assert parent
				if parent_class
					assert (isinstance(parent_class, interfaces IClass))
					parents append (parent_class)
				else
					environment report error ("Unable to resolve parent class:", parent_class_name, "from", current_class getName())
				end
			end
			return parents
		@end

		@method getCurrentClassAncestors theClass=None
			var ancestors = []
			if theClass is None
				theClass = self getCurrentClass()
			end
			if not theClass
				return tuple([])
			end
			var parents = getCurrentClassParents(theClass)
			for parent in parents
				# FIXME: This is necessary, so I'm not sure this works
				# properly...
				if not (parent in ancestors)
					for ancestor in getCurrentClassAncestors(parent)
						if not (ancestor in ancestors)
							ancestors append(ancestor)
						end
					end
				end
			end
			ancestors extend(parents)
			return ancestors
		@end

	@end
	
	@method annotate value, name, content=None
		value addAnnotation (environment factory annotation (name, content))
	@end

	@group Resolution

		@method resolve referenceOrName, contextOrDataFlow=None
		| Resolves the given 'IReference' or String sing the given context
		| ('IContext') or dataflow ('IDataFlow'). This usually requires that
		| you've applied a pass to create the dataflow (see the
		| 'lambdafactory.resolution.BasicDataFlow' pass).
			if contextOrDataFlow is None
				contextOrDataFlow = getCurrentDataFlow()
			if isinstance( contextOrDataFlow, interfaces IElement )
				contextOrDataFlow = contextOrDataFlow getDataFlow()
			end
			if isinstance(referenceOrName, interfaces IReference)
				referenceOrName = referenceOrName getReferenceName()
			end
			if contextOrDataFlow
				return contextOrDataFlow resolve (referenceOrName)
			else
				# TODO: Issue a warning because the resolution pass was not made
				return [None, None]
			end
		@end

		@method resolveAbsolute referenceOrName
		| Resolves the given reference or string expressed in absolute style
		|('.'-separated list of names), starting from the root dataflow (the program
		| dataflow).
			var program          = getProgram()
			var program_dataflow = program getDataFlow()
			var slot_and_value   = None
			var matching_module  = None
			if not program_dataflow
				raise ERR_NO_DATAFLOW_AVAILABLE
			end
			if isinstance(referenceOrName, interfaces IReference)
				referenceOrName = referenceOrName getReferenceName()
			end
			# We get the module with the name that matches most of the reference
			# name
			# FIXME: There might be some edge cases with functions having the
			# same name as a child module (then creating ambiguity)
			for module in program getModules()
				var mname       = module getName()
				var mname_len   = len(mname)
				# DEBUG:
				#environment report info ("LOOKING FOR ", referenceOrName, "in", mname, matching_module)
				if mname == referenceOrName
					matching_module = module
					return tuple([None, module])
				end
				# We see if the referenceOrName starts with the current module
				# name, meaning it is a submodule.
				var match_index = mname find (referenceOrName) 
				if match_index == 0 and referenceOrName startswith (mname) and referenceOrName[mname_len] == "."
					if not matching_module
						matching_module = module
					if len(module getName()) > len(matching_module getName())
						matching_module = module
					end
				end
			end
			if not matching_module
				return tuple([None,None])
			else
				var symbol_name = referenceOrName
				# We do a resolution from the current data flow
				slot_and_value = current_dataflow resolve (ref_name)
				if not slot_and_value[1]
					# If it fails, we fail the resolution
					return slot_and_value
				else
					# Otherwise we proceed
					current_dataflow = slot_and_value[0] getDataFlow()
				end
			end
			# We now have the proper slot and value
			return slot_and_value
		@end

		@method resolveAbsoluteOrLocal referenceOrName, contextOrDataFlow=None
		| Tries an absolute resolution first, then will look in the local scope if
		| it fails.
			var slot_and_value = resolveAbsolute (referenceOrName)
			if not slot_and_value[0]
				return resolve(referenceOrName, contextOrDataFlow)
			else
				return slot_and_value
			end
		@end

		@method resolveLocalOrAbsolute referenceOrName, contextOrDataFlow=None
		| Tries a local resolution first, then will look in the program scope if
		| it fails.
			var slot_and_value = resolve(referenceOrName, contextOrDataFlow)
			if not slot_and_value[0]
				return resolveAbsolute (referenceOrName)
			else
				return slot_and_value
			end
		@end

	@end

@end

# ============================================================================
#
# Abstract Pass
#
# ============================================================================

# FIXME: Maybe we should aggregate PassContext and Pass... have to study this in
# detail
@class Pass: PassContext

	@shared   HANDLES  = []
	@shared   NAME     = ""

	@constructor 
		PassContext __init__ (self)
		setPass(self)
	@end

	@method getHandler element:IElement
	| Tells if the pass handles the given element. This basically iterates
	| on the 'handles' property values (which are interfaces), when one
	| interface matches the given 'element', then the corresponding 'onXXX'
	| method is invoked, where 'XXX' is the interface
	| name (without the leading 'I').
		for interface in HANDLES
			# REWRITE: element is an interface
			if isinstance(element, interface)
				# REWRITE return self `(interface getClass() getName())
				var handler_name = "on" + interface __name__ [1:]
				if not hasattr(self, handler_name)
					self environment report error ("Handler does not define pass for:", handler_name)
					raise ERR_PASS_HANDLER_NOT_DEFINED(handler_name)
				end
				return getattr(self, handler_name )
			end
		end
		return None
	@end

	@method getName
	| Returns the name of this pass
		return NAME
	@end

@end

# ============================================================================
#
# Global Runtime Pass
#
# ============================================================================

@class ExtendJSRuntime: Pass
| This pass is like an importation and will simply bind the symbols

	@shared HANDLES  = [ interfaces IProgram, interfaces IModule ]
	@shared NAME     = "GlobalRuntime"
	@shared FUNCTIONS = [
		"assert"
		"access"
		"car"
		"cdr"
		"cons"
		"createMapFromItems"
		"error"
		"filter"
		"getChildrenOf"
		"getClass"
		"getClasses"
		"getClassOf"
		"getMethod"
		"getMethodOf"
		"getParentClass"
		"getSuperMethod"
		"invoke"
		"isDefined"
		"isFunction"
		"isIn"
		"isInstance"
		"isList"
		"isMap"
		"isString"
		"iterate"
		"len"
		"map"
		"print"
		"range"
		"reduce"
		"slice"
		"sliceArguments"
	]

	@property runtime

	@constructor
		Pass __init__ (self)
	@end

	@method onProgram program
		runtime = environment factory createModule ("extend")
		runtime addAnnotation (environment factory annotation ("shadow"))
		for f in FUNCTIONS
			var fun = environment factory createFunction (f)
			fun addAnnotation (environment factory annotation ("shadow"))
			runtime setSlot (f, fun)
		end
		program addModule (runtime)
	@end

	@method onModule module
		var imports = module getImportOperations()
		module addImportOperation (environment factory importSymbols (runtime getSlotNames(), runtime getAbsoluteName ()))
		return False
	@end

@end

# ============================================================================
#
# Importation Pass
#
# ============================================================================

@class Importation: Pass
| The importation pass will look for importation operations ('IImportation'),
| will try to resolve the importations (according to the current environment)
| and will trigger the loading and parsing of each module into the current
| program.

	@shared HANDLES = [ interfaces IModule ]
	@shared NAME    = "Importation"

	@constructor
		Pass __init__ (self)
	@end

	@method onModule module

		var imports = module getImportOperations()
		for i in imports
			if isinstance(i, interfaces IImportModuleOperation)
				var imported_module_name = i getImportedModuleName()
				var imported_module_origin = i getAlias()
				var imported_module = environment importModule (imported_module_name)
			if isinstance(i, interfaces IImportSymbolOperation)
				var imported_module_name = i getImportOrigin()
				var imported_module = environment importModule (imported_module_name)
			if isinstance(i, interfaces IImportSymbolsOperation)
				var imported_module_name = i getImportOrigin()
				var imported_module = environment importModule (imported_module_name)
			else
				environment report error ("Importation pass: operation not implemented " + repr(i))
			end
		end
		return False
	@end
	
@end

# ============================================================================
#
# Documentation Pass
#
# ============================================================================

@class DocumentationPass: Pass
| The documentation pass will run SDoc on all the modules declared in this
| program, creating an HTML file.

	@shared   HANDLES = [ interfaces IModule ]
	@shared   NAME    = "Documentation"
	@property sdocArguments
	@property sdocDocumenter

	@constructor args=[]
		Pass __init__ (self)
		sdocArguments = args
		@embed Python
		|import sdoc.main
		|self.sdocDocumenter = sdoc.main.LambdaFactoryDocumenter()
		@end
	@end

	@method onModule module
		sdocDocumenter documentModule (module)
	@end

	@method asHTML title=None
	| Returns the HTML document generated by this pass
		return sdocDocumenter toHTML(title)
	@end

@end

# ============================================================================
#
# Transform Asynchronous Invocations Pass
#
# ============================================================================

@class TransformAsynchronousInvocations: Pass

	@shared HANDLES = [ interfaces IClosure ]
	@shared NAME    = "AsynchronousInvocationsExpansion"
@end

# EOF
