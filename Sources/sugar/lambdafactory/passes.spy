@module lambdafactory.passes
@import reporter
@import interfaces

# ============================================================================
#
# Pass Context
#
# ============================================================================

@class PassContext
| The 'PassContext' represents the current state of one or more passes when
| walking the program. It offers access to the 'environment' (gives access
| to the program and various passes).
|
| A single context can be shared among various passes.
    
	@property environment = None
	@property context     = []

    # REWRITE: @constructor reporter=reporter.DefaultReporter
	@constructor environment
		self environment = environment
	@end

	@method run
		walk ( environment getProgram() )
	@end
	
	@method walk element
		# REWRITE: context push(element)
		context append (element)
		var continue_walking = True
		# We iterate on the program passes, if every pass 
		for program_pass in environment getPasses()
			var handle = program_pass getHandle(element)
			if handle
				# TODO: Optimize by removing passes not interested in
				# going deeper
				if handle (self, element) != False
					continue_walking = True
				end
			end
		end
		# If we continue the walking, then we recurse on context slots and
		# in operations (if we're in a process).
		if continue_walking != False
			# Is the element a Context ? -> walk slots
			if isinstance(element, interfaces IProgram)
				for module in element getModules()
					walk (module)
				end
			end
			# Is the element a Context ? -> walk slots
			if isinstance(element, interfaces IContext)
				for name_and_value in element getSlots()
					walk (name_and_value[1])
				end
			end
			# Is the element a Process ? -> walk operations
			if isinstance(element, interfaces IProcess)
				for operation in element getOperations()
					walk (operation)
				end
			end
		end
		context pop()
	@end

	@group ContextAccessors
	
		@method filterContext interface
		@as internal
			@embed Python
			|return filter(lambda x:isinstance(x,interface), self.context) 
			@end
		@end
		
		@method filter list, interface
		@as internal
			@embed Python
			|return filter(lambda x:isinstance(x,interface), list) 
			@end
		@end
		
		@method findInContext interface
		@as internal
			var res = filterContext(interface)
			if res
				return res[-1]
			else
				return None
			end
		@end
		
		@method isIn interface
			return findInContext (interface ) != None
		@end
		
		@method getCurrentClosure
			return findInContext (interfaces IClosure)
		@end
		
		@method getCurrentFunction
			return findInContext (interfaces IFunction)
		@end

		@method getCurrentMethod
			return findInContext (interfaces IMethod)
		@end

		@method getCurrentClass
			return findInContext (interfaces IClass)
		@end

		@method getCurrentProcess
			return findInContext (interfaces IProcess)
		@end
		
		@method getCurrentClassParents theClass
			var parents = []
			if theClass is None
				theClass = getCurrentClass()
			end
			var current_class = theClass
			for parent_class_ref in current_class getParentClasses()
				var parent_class_name = parent_class_ref getReferenceName()
				var resolution = resolve ( parent_class_name, current_class )
				var target, context = resolution
				parent_class = target value
				# TODO: assert parent
				parents append (parent_class)
			end
		@end
		
	@end
	
	@group Resolution
	
		@method resolve referenceOrName, contextOrDataFlow=None
			if contextOrDataFlow is None
				contextOrDataFlow = getCurrentContext() getDataFlow()
			if isinstance( contextOrDataFlow, interfaces IElement )
				contextOrDataFlow = contextOrDataFlow getDataFlow()
			end
			if isinstance(referenceOrName, interfaces IReference)
				referenceOrName = referenceOrName getReferenceName()
			end
			return contextOrDataFlow resolve (referenceOrName)
		@end
	@end
@end

# ============================================================================
#
# Abstract Pass
#
# ============================================================================

@class Pass
	
	@shared HANDLES  = []
	@shared NAME     = ""
	
	@constructor
	@end

	@method getHandle element:IElement
	| Tells if the pass handles the given element. This basically iterates
	| on the 'handles' property values (which are interfaces), when one
	| interface matches the given 'element', then the corresponding 'onXXX'
	| method is invoked, where 'XXX' is the interface
	| name (without the leading 'I').
		for interface in HANDLES
			# REWRITE: element is an interface
			if isinstance(element, interface)
				# REWRITE return self `(interface getClass() getName())
				var handler_name = "on" + interface __name__ [1:]
				if not hasattr(self, handler_name)
					raise ERR_PASS_HANDLER_NOT_DEFINED(handler_name)
				end
				return getattr(self, handler_name )
			end
		end
		return None
	@end

@end

# ============================================================================
#
# Importation Pass
#
# ============================================================================

@class ImportationPass: Pass
| The importation pass will look for importation operations ('IImportation'),
| will try to resolve the importations (according to the current environment)
| and will trigger the loading and parsing of each module into the current
| program.

	@shared HANDLES = [ interfaces IModule ]
	@shared NAME    = "Importation"

	@constructor
		Pass __init__ (self)
	@end
	
	@method getModuleImportations context, module
		var module_init = module getSlot(interfaces Constants ModuleInit)
		return context filter(module_init getOperations(), interfaces IImportOperation)
	@end

	@method onModule context, module
		var imports = getModuleImportations(context, module)
		for i in imports
			if isinstance(i, interfaces IImportModuleOperation)
				var imported_module_name = i getImportedModuleName()
				var imported_module_origin = i getAlias()
				var imported = context environment importModule (imported_module_name)
			if isinstance(i, interfaces IImportSymbolOperation)
				var imported_module_name = i getImportOrigin()
				var imported_module = context environment importModule (imported_module_name)
			else
				context environment report error ("ImportationPass: operation not implemented " + repr(i))
			end
		end
		return False
	@end
	
@end

# ============================================================================
#
# Transform Asynchronous Invocations Pass
#
# ============================================================================

@class TransformAsynchronousInvocations: Pass

	@shared HANDLES = [ interfaces IClosure ]
	@shared NAME    = "AsynchronousInvocationsExpansion"
@end

# EOF	
