# -----------------------------------------------------------------------------
# Project   : LambdaFactory
# -----------------------------------------------------------------------------
# Author    : Sebastien Pierre                               <sebastien@ivy.fr>
# License   : Revised BSD License
# -----------------------------------------------------------------------------
# Creation  : 02-Nov-2006
# Last mod  : 25-Apr-2009
# -----------------------------------------------------------------------------
@module lambdafactory.model
| This module is the default implementation of the LambdaFactory interfaces.
| It defines objects that allow you to build a complete OO program model on
| which you can apply transformation passes, and from which you can generate
| code using the different back-ends.
@import * from lambdafactory.interfaces
@import pprint
@import sys
@import lambdafactory.modeltypes

# ------------------------------------------------------------------------------
#
# Data Flow Elements
#
# ------------------------------------------------------------------------------

@class DataFlowSlot: IDataFlowSlot

	@property name
	@property value
	@property origin
	@property abstractType
	@property slotType
	@property operations = []
	@property dataflow
	
 	@constructor name, value, origin, slotType
		self name = name
		self value = value
		self origin = origin
		self slotType = slotType
	@end

	@method setDataFlow dataflow
		self dataflow = dataflow
	@end

	@method getDataFlow
		return dataflow
	@end

	@method getName
		return name
	@end
		
	@method getValue
		return value
	@end

	@method getOrigin
		return origin
	@end

	@method getAbstractType
		return abstractType
	@end

	@method addOperation operation
	| Adds an operation made to this dataflow slot.
		operations append(operation)
	@end

	@method isImported
		return slotType == DataFlow IMPORTED
	@end

	@method isLocal
		return slotType == DataFlow LOCAL
	@end

	@method isArgument
		return slotType == DataFlow ARGUMENT
	@end

	@method isEnvironment
		return slotType == DataFlow ENVIRONMENT
	@end

	@method __repr__
		@embed Python
		|return '<Slot("%s"=%s):%s@%s%s>' % (self.name, self.value, "TYPE", self.slotType, self.origin)
		@end
	@end

@end

@class DataFlow: IDataFlow
| The DataFlow are ''dynamic contexts'' bound to the various program model
| elements. DataFlows are typically owned by elements which implement
| 'IContext', and are linked together by rules defined in the 'Resolver'
| class.
|
| The dataflow bound to most expressions is the one of the enclosing closure
| (wether it is a function, or method. The dataflow of a method is bound to
| its parent class, which dataflow is also bound to the parent class dataflow.
|
| While 'DataFlow' and 'Context' may appear very similar, they are not the
| same: contexts are elements that keep track of declared slots, while the
| dataflow make use of the context to weave the elements togeher.


	@shared ARGUMENT    = "Argument"
	@shared ENVIRONMENT = "Environment"
	@shared LOCAL       = "Local"
	@shared IMPORTED    = "Imported"

	@property program:<IProgram>
	@property element:<IElement>
	@property parent:<IDataFlow>
	@property sources:<[IDafaFlow]>      = []
	@property destinations:<[IDafaFlow]> = []
	@property slots:<[IDataFlowSlot>     = []
	@property children:<[IDataFlow]>     = []
	
	@constructor element, parent=Undefined
		# FIXME: Resolution should happen in pass, no program required
		self element  = element
		self children = []
		if parent
			setParent (parent)
		end
		element setDataFlow(self)
	@end
	
	# FIXME: Argument should be 'element' rather than 'value'
	@method declareArgument  name, value
		self _declare(name, value, None, ARGUMENT)
	@end
	
	@method  declareEnvironment name, value
		self _declare(name, value, None, ENVIRONMENT)
	@end
	
	@method  declareVariable name, value, origin
		self _declare(name, value, origin, LOCAL)
	@end
	
	@method  declareImported  name, value, origin
		self _declare(name, value, origin, IMPORTED)
	@end

	@method  _declare name, value, origin, slotType
	| Declares the given slot with the given name, value, origin
	| and type. This is used internaly by the other 'declare' methods.
		var previous_slot = getSlot(name)
		if previous_slot
			# FIXME: Maybe trigger a warning when resetting the slot
			slots remove(previous_slot)
		end
		addSlot(new DataFlowSlot(name, value, [origin], slotType))
	@end

	@method addSource dataflow
		if not (dataflow in sources)
			sources append (dataflow)
			dataflow addDestination( self )
		end
	@end

	@method getSources
		return sources
	@end

	@method addDestination dataflow
	@as internal
		if not (dataflow in destinations)
			destinations append (dataflow)
			dataflow addSource( self )
		end
	@end

	@method getDestinations
		return destinations
	@end

	@method addSlot slot
		# FIXME: Assert no duplicate slot
		self slots append(slot)
		slot setDataFlow(self)
	@end

	@method getSlots
	| Returns the slots defiend for this dataflow.
		return slots
	@end

	@method _getAvailableSlots slotList=({})
		for slot in slots
			if not slotList get (slot getName())
				slotList[slot getName()] = slot
			end
		end
		if parent
			parent _getAvailableSlots (slotList)
		end
		return slotList
	@end

	@method getAvailableSlots
		return _getAvailableSlots() values()
	@end

	@method getSourcesSlots slots=None
	| Returns the list of slots defined in the sources, using the sources axis.
		if slots is None
			slots = {}
		else
			for slot in getSlots()
				if slots get(slot getName()) is None
					slots [slot getName()] = slot
				end
			end
		end
		for source in getSources()
			source getSourcesSlots( slots)
		end
		return slots values()
	@end

	@method getAvailableSlotNames
		return _getAvailableSlots() keys()
	@end

	@method hasSlot name
		for slot in slots
			if slot getName() == name
				return slot
			end
		end
		return False
	@end
	
	
	@method getSlot name
		return hasSlot (name)
	@end

	@method getElement
		return element
	@end

	@method getParent
		return parent
	@end

	@method getRoot
		if parent
			return parent getRoot()
		else
			return self
		end
	@end

	@method unsetParent
		if parent
			self parent removeChild (self)
			self parent = None
		end
	@end

	@method setParent parent
		assert (self parent is None or parent == self parent)
		if parent
			self parent = parent
			self parent addChild(self)
		end
	@end

	@method addChild child
		assert (not (child in children))
		children append(child)
	@end
	
	@method getChildren
		return children
	@end

	@method resolveInSources name
		if sources
			for source in getSources()
				var slot_and_value = source resolveLocally (name)
				if slot_and_value[1] != None
					return slot_and_value
				end
				slot_and_value = source resolveInSources (name)
				if slot_and_value[1] != None
					return slot_and_value
				end
			end
			return tuple([None,None])
		else
			return tuple([None,None])
		end
	@end

	@method resolveLocally name
		var slot = getSlot(name)
		if slot
			return tuple([slot, slot getValue()])
		else
			return tuple([None, None])
		end
	@end

	@method resolve name
	| Returns a couple '(DataFlow slot, IElement)' or '(None,None)'
	| corresponding to the resolution of the given 'name' in this dataflow. The
	| slot is the slot that holds the element, and the given element is the
	| element value bound to the slot.
	|
	| The resolution scheme first looks into this datalfow, see if the slot
	| is defined. It then looks in the sources, sequentially and if this fails,
	| it will look into the parent.
	|
	| Alternative resolution schemes can be implemented depending on the target
	| programming languages semantics, but this resolution operation should
	| always be implemented in the same way. If you wish to have another
	| way of doing resolution, you should provide a specific method in the
	| DataFlow implementation, and also maybe provide more specific resolution
	| operation in the 'PassContext' class.
		var slot = getSlot(name)
		if slot
			return tuple([slot, slot getValue()])
		end
		if sources
			var slot_and_value = resolveInSources (name)
			if slot_and_value[0] != None
				return slot_and_value
			end
		end
		if parent
			var r = parent resolve(name)
			if r[0] != None
				return r
			end
		end
		return tuple([None, None])
	@end

	
	@method defines name
		var slot = getSlot(name)
		if slot
			return tuple([slot, element])
		else
			for child in getChildren()
				var res = child defines(name)
				# FIXME: I think it should be child.getSlot(name), child
				if res
					return child
				end
			end
		end
		return tuple([None,None])
	@end

@end

# ------------------------------------------------------------------------------
#
# Program Model Elements
#
# ------------------------------------------------------------------------------

@class Element
| The Element class is a generic class that implements many of the
| functionalities required to implement the full LambdaFactory program model.
|
| Property defined in this class may not be relevant to every subclass, but at
| least they provide a common infrastructure and limit the number of
| subclasses.

	@shared COUNT               = 0
	@property id                = Undefined
	@property name              = Undefined
	@property source            = Undefined
	@property annotations       = []
	@property abstractType      = Undefined
	@property resultAbtractType = Undefined
	@property sourceLocation    = [-1,-1,-1]
	@property dataflow          = Undefined
	@property parent            = Undefined
	
	@constructor name=Undefined
		self name = name
		id   = COUNT
		COUNT += 1
	@end
	
	@method setName name
		self name = name
	@end
	
	@method getName
		assert (isinstance(self,IReferencable) or isinstance(self,IAnnotation))
		return self name
	@end

	@method hasName
		return isinstance(self,IReferencable) or isinstance(self,IAnnotation)
	@end

	@method getParent
		return parent
	@end

	@method hasParent
		if parent
			return parent
		else
			return False
		end
	@end

	@method setParent parent
		assert (self parent is None or parent == self parent)
		self parent = parent
	@end

	@method detach
		if parent
			# FIXME: Maybe do something
			self parent = None
		end
		return self
	@end
	
	@method setSource source
		self source = source
	@end

	@method getSource
		return source
	@end

	@method addAnnotation annotation:IAnnotation
		if not annotation
			return None
		end
		if type(annotation) in [tuple, list]
			map(addAnnotation, annotation)
		else
			assert (isinstance(annotation, IAnnotation))
			annotations append (annotation)
		end
	@end

	@method getAnnotations withName=None
		@embed Python
		|if not withName: return self.annotations
		|return [a for a in self.annotations if a.getName() == withName]
		@end
	@end

	@method hasAnnotation withName
		var annotations = getAnnotations (withName)
		return len(annotations) > 0
	@end

	@method removeAnnotation withName
		var new_annotations = []
		for annotation in annotations
			if annotation getName () != withName
				new_annotations append (annotation)
			end
		end
		annotations = new_annotations
	@end

	@method setAnnotation name, content
		var annotation = getAnnotation (withName)
		if not annotation
			# FIXME: Should get factory instead
			annotation = new Annotation(name, content)
			self annotations append (annotation)
		else
			annotation setContent (content)
		end
		return self
	@end

	@method getAnnotation withName
		var annotations = getAnnotations (withName)
		if annotations
			return annotations[0]
		else
			return None
		end
	@end
	
	@method setDocumentation documentation
		addAnnotation(documentation)
	@end

	@method getDocumentation
		return getAnnotation "documentation"
	@end
	
	@method getDataFlow
		return dataflow
	@end
	
	@method setDataFlow f
		dataflow = f
	@end
	
	# FIXME: To deprecate
	@method hasDataFlow
		return dataflow
	@end
	
	@method ownsDataFlow
		raise "Not implemented"
	@end

	@method getAbstractType
		if abstractType is None
			abstractType = modeltypes typeForValue (self)
		end
		return abstractType
	@end
	
	@method setAbstractType abstractType
		self abstractType = abstractType
	@end
	
	@method getResultAbstractType
		# TODO: Assert this is evaluable
		return resultAbtractType
	@end
	
	@method setResultAbstractType abstractType
		# TODO: Assert this is evaluable
		resultAbtractType = abstractType
	@end
	
	@method prettyList
		return pprint pprint(asList())
	@end

	@method asList
		return [self __class__ __name__]
	@end

	@method _copy arguments...
		# REWRITE ME
		var copy = None
		@embed Python
		|copy = self.__class__(*arguments)
		@end
		copy name   = name
		copy source = source
		for annotation in annotations
			copy addAnnotation (annotation copy() detach())
		end
		copy abstractType = abstractType
		copy resultAbtractType = resultAbtractType
		copy sourceLocation = sourceLocation
		if dataflow
			copy dataflow = dataflow clone() attach (copy)
		end
		return copy
	@end

@end

# ------------------------------------------------------------------------------
#
# Annotation/Documentation elements
#
# ------------------------------------------------------------------------------


@class Annotation: Element, IAnnotation

	@property content
	
	@constructor name=None, content=None
		#REWRITE: super()
		Element __init__ ( self, name )
		self name = name
		self content = content
	@end
	
	@method getContent
		return content
	@end

	@method setContent content
		self content = content
		return self
	@end
@end

@class Comment: Annotation, IComment
	@constructor content=None
		#REWRITE: super("comment", content)
		Annotation __init__ ( self,  "comment", content)
	@end
@end

@class Documentation: Annotation, IDocumentation
	@constructor content=None
		#REWRITE: super("documentation", content)
		Annotation __init__ ( self,  "documentation", content)
	@end
@end

# ------------------------------------------------------------------------------
#
# Structural Elements (Context, Class, Interface, Module, Program)
#
# ------------------------------------------------------------------------------

@class Context: Element
	
	@property slots     = []
	@property slotIndex = {}
	@property parent    = Undefined
	@property abstract  = False
	
	@constructor name=Undefined
		#REWRITE: super( name )
		Element __init__ ( self,  name)
	@end

	@method setAbstract isAbstract
		abstract = isAbstract
	@end
	
	@method isAbstract
		return abstract
	@end
	
	@method setSlot name, evaluable, assignParent=True
		if not isinstance(evaluable, IAssignable)
			raise ERR_SLOT_VALUE_NOT_ASSIGNABLE
		end
		if assignParent and isinstance(evaluable, IContext) or hasattr(evaluable,"setParent")
			evaluable setParent ( self )
		end
		if slotIndex get (name) is Undefined
			slots append [name, evaluable]
			slotIndex [name] = len(slots) - 1
		else
			var slot = slots [slotIndex[name]]
			slot[1]  = evaluable
			# TODO: Optimize by removing from index instead
			slots remove (slot)
			slots append (slot)
			var i = 0
			while i < len(slots)
				slotIndex[slots[i][0]] = i
				i += 1
			end
		end
	@end

	@method hasSlot name
		for slot in slots
			if slot[0] == name
				return True
			end
		end
		return False
	@end

	@method getSlot name
		# We get the last slot instead of the first one
		var i = len(slots) - 1
		for slot in slots
			if slot[0] == name
				return slot[1]
			end
		end
		raise ERR_SLOT_NOT_FOUND
	@end
	
	@method getSlots
		return slots
	@end

	@method getSlotNames
		var res = []
		for slot in slots
			res append (slot[0])
		end
		return res
	@end

	@method setParent context:Context
		parent = context
	@end
	
	@method getParent
		return parent
	@end

	@method getAbsoluteName
		if name
			if parent
				var parent_name =  parent getAbsoluteName ()
				if parent_name
					return parent_name + "." + name
				else
					return name
				end
			end
		else
			return Undefined
		end
	@end

@end

@class Class: Context, IClass, IReferencable, IAssignable

	@property parentClasses:<[IClass]> = []
	
	@constructor name=Undefined, parentClasses=Undefined
		#REWRITE: super( name )
		Context __init__ ( self,  name)
		if parentClasses != Undefined
			setParentClasses(parentClasses)
		end
	@end
	
	@method slotValuesImplementing interface, without=Undefined
		var res = []
		for slot in getSlots()
			var value = slot[1]
			if without == Undefined or not isinstance(value, without)
				if isinstance(value, interface)
					res append (value)
				end
			end
		end
		return res
	@end


	# REWRITE (Sugar macros)
	# % for e in "Attributes ClassAttributes Operations Constructors" split()
	#	@method get%{e}
	#		return slotValuesImplementing(I%{e})
	#	@end
	# % end

	@method getAttributes
		return slotValuesImplementing(IAttribute, IClassAttribute)
	@end

	@method getAttributeMethods
		return slotValuesImplementing(IAttributeMethod)
	@end
	
	@method getAccessors
		return slotValuesImplementing(IAccessor)
	@end

	@method getMutator
		return slotValuesImplementing(IMutator)
	@end

	@method getClassAttributes
		return slotValuesImplementing(IClassAttribute)
	@end

	@method getOperations
		return slotValuesImplementing(IInvocable)
	@end
	
	@method getConstructors
		return slotValuesImplementing(IConstructor)
	@end
	
	@method getDestructors
		return slotValuesImplementing(IDestructor)
	@end
	
	@method getMethods
		return slotValuesImplementing( IMethod)
	@end
	
	@method getInstanceMethods
		return slotValuesImplementing(IInstanceMethod)
	@end
	
	@method getClassMethods
		return slotValuesImplementing(IClassMethod)
	@end
		
	@method getParentClasses
		return parentClasses
	@end

	@method setParentClasses classes
		parentClasses = []
		for the_class in classes
			if not (isinstance(the_class, IReference) or isinstance(the_class, IResolution))
				raise ERR_PARENT_CLASS_REFERENCE_EXPECTED
			end
			parentClasses append (the_class)
		end
	@end

	@method getInheritedLike protocol
		res = {}
		for slot in getDataFlow() getSourcesSlots()
			if isinstance(slot getValue(), protocol)
				res[slot getName()] = slot getValue()
			end
		end
		return res
	@end

	@method getInheritedSlots
		var r = []
		for slot in getDataFlow() getSourcesSlots()
			r append ([slot getName(), slot getValue()])
		end
		return r
	@end

	@method getInheritedClassMethods
	| Returns the inherited class methods as a dict of slots
		return getInheritedLike(IClassMethod)
	@end

	@method getInheritedClassAttributes
		return getInheritedLike(IClassAttribute)
	@end

@end

@class Interface: Class, IInterface
@end

@class Module: Context, IModule, IAssignable, IReferencable

	@property importOperations = []
	@property imported = False
	
	@constructor name=Undefined
		#REWRITE: super( name )
		Context __init__ ( self,  name)
	@end
	
	@method getParentName
	| Returns 'grandparentname.parentname'
		return "." join (name split "." [0:-1]) or None
	@end

	@method getAbsoluteName
	| A module name is already absolute, so 'getAbsoluteName' is the same as
	| 'getName'
		return name
	@end

	@method isImported
		return imported
	@end
	
	@method setImported value=True
		imported = value
	@end

	@method addImportOperation operation
		importOperations append (operation)
		operation setParent ( self )
	@end
	
	@method mergeWith module
		for op in module getImportOperations ()
			op detach ()
			addImportOperation (op)
		end
		for an in module annotations
			an detach ()
			self addAnnotation (an)
		end
		for slot in module getSlots ()
			var name, value = slot
			value detach ()
			setSlot (name, value)
		end
	@end

	@method getImportOperations
		return importOperations
	@end

	@method getClasses
		@embed Python
		| return [value for name, value in self.getSlots() if isinstance(value, IClass)]
		@end
	@end

@end

# TODO: Add more features here
@class Program: Context, IProgram

	@property factory
	@property modules = []

	@constructor name=Undefined
		#REWRITE: super( name )
		Context __init__ ( self,  name)
	@end

	@method addModule module
		var same_name_module = Undefined
		for existing_module in modules
			if module  == existing_module -> raise (ERR_MODULE_ADDED_TWICE(module))
			if module getAbsoluteName () == existing_module getAbsoluteName ()
				same_name_module = existing_module
				#TODO: break
			end
		end
		if same_name_module
			same_name_module mergeWith (module)
		else
			modules append (module)
			module setParent (self)
		end
	@end

	@method getModule moduleAbsoluteName
		for module in modules
			if module getName() == moduleAbsoluteName
				return module
			end
		end
	@end 

	@method getModules
		return modules
	@end 
	
	@method getModuleNames
		var res = []
		for m in modules
			res append ( m getName() )
		end
		return res
	@end 

	@method setFactory factory
	| Sets the factory that was used to create this program
		self factory = factory
	@end
	
	@method getFactory
	| Gets the factory that was used to create this program. It can be
	| used to create more elements in the program.
		return factory
	@end
	
@end

# ------------------------------------------------------------------------------
#
# Dynamic Elements (Processes)
#
# ------------------------------------------------------------------------------

@class Process: Context, IContext, IProcess, IAbstractable

	@property operations = []
	@constructor name=Undefined
		#REWRITE: super(name)
		Context __init__ ( self,  name)
	@end
	
	@method addOperation operation:IOperation
		if isAbstract()
			raise ERR_ABSTRACT_PROCESS_NO_OPERATIONS
		end
		if not isinstance(operation, IOperation)
			raise ERR_NOT_AN_OPERATION
		end
		operation setParent(self)
		operations append (operation)
	@end

	@method getOperations:<[IOperation]>
		return operations
	@end

	@method asList
		var res = []
		for o in operations
			res append(o asList())
		end
		return tuple( [self __class__ __name__, tuple(operations)] )
	@end

@end

@class Group: Process, IGroup
@end

@class Block: Group, IBlock
@end

@class Closure: Process, IAssignable, IClosure, IEvaluable
	
	@property arguments = Undefined
	@property returnTypeDescription = Undefined

	@constructor arguments, name=Undefined
		#REWRITE: super(name)
		Process __init__ ( self,  name)
		setArguments(arguments)
	@end

	@method setArguments arguments
		self arguments = []
		if arguments
			for argument in arguments
				if not isinstance(argument, ISlot)
					raise ERR_CLOSURE_ARGUMENT_NOT_SLOT
				end
				self arguments append(argument)
			end
		end
	@end
	
	@method  getArguments
		return arguments
	@end
	
	@method getArgument index
		return arguments[index]
	@end

	@method getReturnTypeDescription
		return returnTypeDescription
	@end

	@method setReturnTypeDescription description
		returnTypeDescription = description
	@end

@end

@class Function: Closure, IFunction, IReferencable

	@constructor name, arguments
		#REWRITE: super arguments, name)
		Closure __init__ ( self,  arguments, name)
	@end

	@method getAbsoluteName
		if getParent ()
			return getParent () getAbsoluteName () + "." + name
		else
			return name
		end
	@end

@end

@class Method: Function, IMethod
@end

@class Accessor: Method, IAccessor
@end

@class Mutator: Method, IMutator
@end

@class Constructor: Method, IConstructor

	@constructor arguments
		#REWRITE: super(arguments, Constants Constructor)
		Method __init__ ( self, Constants Constructor, arguments)
	@end
@end

@class Destructor: Method, IDestructor

	@constructor
		#REWRITE: super([], Constants Destructor)
		Method __init__ ( self, Constants Destructor,  [] )
	@end

@end

@class ClassMethod: Method, IClassMethod
@end


@class InstanceMethod: Method, IInstanceMethod
@end

# ------------------------------------------------------------------------------
#
# Operation Elements
#
# ------------------------------------------------------------------------------

@class Operation: Element, IEvaluable, IOperation

	@shared   ARGS:List = Undefined
	@property opArguments:<[IElement]> = []
	
	@constructor arguments...
		Element __init__ ( self )
		self setOpArguments(arguments)
	@end

	@method copy
		# FIXME: Rewrite this using a standard way
		var op_copy = None
		var op_arguments = []
		# REWRITE
		op_copy = Element _copy(self)
		for a in opArguments
			# FIXME: This does not work when a is a list
			op_copy addOpArgument (a copy() detach())
		end
		return op_copy
	@end

	@method setOpArguments arguments
		#if not len(arguments) <= len.ARGS
		#	raise ModelException("Too many arguments: %s expected %s, got %s" \
		#	%  len.ARGS), len(arguments)))
		opArguments = []
		for a in arguments
			addOpArgument(a)
		end
	@end

	@method setOpArgument i, argument
		#if not i < len.ARGS)
		#	raise ModelException("Too many arguments: %s expected %s, got %s" \
		#	%  len.ARGS), len(arguments)))
		#if not self._isInstance(argument, self.ARGS[i]
		#	raise ModelException("Incompatible argument:  %s expected arg %s as  %s, got %s" \
		#	%  offset, self.ARGS[i], argument))
		while len(opArguments) < i
			opArguments append(None)
		end
		opArguments [i] = argument
	@end

	@method addOpArgument argument
		#offset = len opArguments)
		#if offset > len.ARGS
		#	raise ModelException("Too many arguments: %s expected args %s as %s, got %s" \
		#	%  offset, len.ARGS), offset + 1))
		#if not self._isInstance(argument, self.ARGS[offset]
		#	raise ModelException("Incompatible argument:  %s expected arg %s as  %s, got %s" \
		#	%  offset, self.ARGS[offset], argument))
		opArguments append (argument)
		_setOpArgumentParent(argument)
	@end

	@method _setOpArgumentParent value
	| Sets the value parent to this
		if type(value) in [tuple, list]
			map(_setOpArgumentParent, value)
		else
			# FIXME: This should always be true
			if isinstance (value, Element )
				value setParent(self)
			end
		end
	@end

	@method getOpArguments
		return opArguments
	@end
	
	@method getOpArgument i
		return opArguments[i]
	@end

	@method asList
		var args = []
		for a in opArguments
			if not type(a) in [tuple,list]
				if a
					args append (a asList())
				else
					args append(a)
				end
			else
				args append(a)
			end
		end
		return tuple([self __class__ __name__, tuple(args)])
	@end
@end

@class Assignation: Operation, IAssignation, IEvaluable

	@method getTarget
		return self getOpArgument(0)
	@end
	
	@method getAssignedValue
		return self getOpArgument(1)
	@end
	
@end

@class Allocation: Operation, IAllocation, IEvaluable

	@method getSlotToAllocate
		return self getOpArgument(0)
	@end

	@method getDefaultValue
		return self getOpArgument(1)
	@end
	
@end

@class Resolution: Operation, IResolution, IEvaluable, IReferencable

	@method getReference
		return self getOpArgument(0)
	@end
	
	@method getContext
		return self getOpArgument(1)
	@end
@end

@class Computation: Operation, IComputation, IEvaluable

	@constructor arguments...
		@embed Python
		|Operation.__init__(self, *arguments)
		@end
	@end
	
@end

@class Invocation: Operation, IInvocation, IEvaluable

	@method isByPositionOnly
		for arg in getOpArgument(1)
			if arg isByName() or arg isAsMap()
				return False
			end
		end
		return True
	@end
	
@end

@class Instanciation: Operation, IInstanciation, IEvaluable
@end

@class Selection: Operation, ISelection

	@method addRule evaluable
		res = getOpArguments()
		if not res
			res = []
			self addOpArgument(res)
		else
			res = res[0]
		end
		res append (evaluable)
		_setOpArgumentParent(evaluable)
	@end

	@method getRules
		if opArguments
			return self getOpArgument(0)
		else
			return []
		end
	@end
@end


@class Evaluation: Operation, IEvaluation
@end

@class AccessOperation: Operation, IAccessOperation
@end

@class SliceOperation: Operation, ISliceOperation
@end

@class MatchProcessOperation: Operation, IMatchProcessOperation
@end

@class MatchExpressionOperation: Operation, IMatchExpressionOperation
@end

@class Iteration: Operation, IIteration
@end

@class Enumeration: Operation, IEnumeration
@end

@class Repetition: Operation, IRepetition
@end

@class Termination: Operation, ITermination

	@method getReturnedEvaluable
		return self getOpArgument(0)
	@end
@end

@class Breaking: Operation, IBreaking
@end

@class Except: Operation, IExcept
@end

@class Interception: Operation, IInterception

	@constructor tryProcess, catchProcess=None, finallyProcess=None
		Operation __init__( self,  tryProcess, catchProcess, finallyProcess )
	@end
@end

@class ImportOperation: Operation, IImportOperation
	
	@constructor arguments...
		@embed Python
		|Operation.__init__(self, *arguments)
		@end
	@end
	
@end

@class ImportSymbolOperation: Operation, IImportSymbolOperation

	@constructor arguments...
		@embed Python
		|Operation.__init__(self, *arguments)
		@end
	@end
	
@end

@class ImportSymbolsOperation: Operation, IImportSymbolsOperation
	
	@constructor arguments...
		@embed Python
		|Operation.__init__(self, *arguments)
		@end
	@end
	
@end

@class ImportModuleOperation: Operation, IImportModuleOperation
	
	@constructor arguments...
		@embed Python
		|Operation.__init__(self, *arguments)
		@end
	@end
	
@end

@class ImportModulesOperation: Operation, IImportModulesOperation
	
	@constructor arguments...
		@embed Python
		|Operation.__init__(self, *arguments)
		@end
	@end
	
@end

@class Embed: Operation, IEmbed

	@property language = Undefined
	@property code     = None
	
	@constructor lang=None, code=None
		Operation __init__( self )
		self language = lang
		self code = code
	@end
	
	@method getLanguage
		return language
	@end

	@method setLanguage language
		self language = language
	@end
	
	@method getCode
		return self code
	@end

	@method setCode code
		self code = code
	@end
@end

@class EmbedTemplate: Embed, IEmbedTemplate
@end


# ------------------------------------------------------------------------------
#
# VALUES
#
# ------------------------------------------------------------------------------

@class Value: Element, IValue, IEvaluable, IAssignable
@end

@class Literal: Value, ILiteral

	@property actualValue = Undefined

	@constructor actualValue = Undefined
		Value __init__ (self)
		self actualValue = actualValue
	@end
	
	@method getActualValue
		return actualValue
	@end

	@method copy
		var value_copy = Value _copy ( self )
		# FIXME: Maybe set parent ?
		value_copy actualValue = actualValue
		return value_copy
	@end

@end

@class Number: Literal, INumber
@end

@class String: Literal, IString
@end

@class List: Value, IList

	@property values = []
	
	@constructor
		Value __init__ (self)
	@end

	@method addValue value:IElement
		values append (value)
		value setParent(self)
	@end
	
	@method getValues
		return values
	@end

	@method getValue i
		return values[i]
	@end

	@method copy
		var values_copy = []
		# REWRITE: super
		var list_copy = Value _copy ( self )
		for v in values
			list_copy addValue (v copy() detach())
		end
		return list_copy
	@end

@end

@class Dict: Value, IDict

	@property items:<[(IElement,IElement)]> = []
	
	@constructor
		Value __init__(self)
	@end
	
	@method setValue key:IElement, value:IElement
		items append([key,value])
	@end
	
	@method getItems
		return items
	@end

@end

@class Reference: Value, IReference

	@property referenceName:String
	
	@constructor name:String
		Value __init__ (self)
		self referenceName = name
	@end
	
	@method getReferenceName
		return self referenceName
	@end
	
	@method asList
		return tuple([self __class__ __name__, referenceName])
	@end

	@method copy
		# REWRITE: super
		var ref_copy = Value _copy ( self, name )
		ref_copy referenceName = referenceName
		return ref_copy
	@end
@end

@class AbsoluteReference: Reference, IAbsoluteReference

	@property referenceName:String
	
	@constructor name:String
		Reference __init__ (self, name)
	@end
		
@end

@class Operator: Reference, IOperator

	@property priority = 0

	@constructor operator, priority
		Reference __init__ (self, operator )
		setPriority(priority)
	@end
	
	@method getPriority
		return priority
	@end
	
	@method setPriority priority
		self priority = priority
	@end
	
@end

@class Slot:Element, ISlot

	@property defaultValue:IElement = None
	@property typeDescription = Undefined
	
	@constructor name, typeDescription
		Element __init__ ( self, name )
		self typeDescription = typeDescription
	@end

	@method getTypeDescription
		return typeDescription
	@end

	@method setDefaultValue value
		defaultValue = value
	@end

	@method getDefaultValue
		return defaultValue
	@end

@end


@class Argument: Slot, IArgument

	# FIXME: This should rather be a state
	@property rest = False
	@property keywordRest = False
	@property optional = False

	@constructor name, typeDescription
		Slot __init__ (self, name, typeDescription)
	@end

	@method isOptional
		return optional
	@end

	@method setOptional value
		optional = value and value
	@end

	@method isRest
		return rest
	@end

	@method setRest value
		rest = value and value
	@end

	@method isKeywordsRest
		return rest
	@end

	@method setKeywordsRest value
		rest = value and value
	@end

@end

@class Parameter: Element, IParameter

	@property name    = None
	@property value   = None
	@property _asList = False
	@property _asMap  = False
	
	@constructor name=None, value=None
		Element __init__ ( self, name )
		self name  = name
		self value = value
	@end
	
	@method isByName
		return name != None
	@end
	
	@method getName
		return name
	@end
	
	@method setByName n:String
		self name = n
	@end
	
	@method getValue
		return value
	@end

	@method getDefaultValue
	| An alias for getValue()
		return value
	@end
	
	@method setValue v
		value = v
	@end
	
	@method isAsList
		return _asList
	@end
	
	@method isAsMap
		return _asMap
	@end
	
	@method setAsList v:Boolean=True
		_asMap  = False
		_asList = True
	@end
	
	@method setAsMap  v:Boolean=True
		_asMap  = True
		_asList = False
	@end
	
@end

@class Attribute: Slot, IAttribute
	
	@constructor name, typeDescription, value=None
		Slot __init__ (self, name, typeDescription)
		setDefaultValue ( value )
	@end

@end

@class ClassAttribute: Attribute, IClassAttribute
@end

@class ModuleAttribute: Attribute, IModuleAttribute
@end

# EOF - vim: tw=80 ts=4 sw=4 noet
