@module lambdafactory.main
| Command-line interface and main module for LambdaFactory
@import os, sys, optparse, tempfile
@import Environment from lambdafactory.environment
@import FileSplitter from lambdafactory.modelwriter
@import lambdafactory.passes as passes
@import lambdafactory.resolution as resolution
@import StringIO from StringIO

@class Command

	@shared OPT_LANG       = "Specifies the target language (js, java, pnuts, actionscript)"
	@shared OPT_OUTPUT     = "Specifies the output where the files will be generated (stdout, file or folder)"
	@shared OPT_VERBOSE    = "Verbose parsing output (useful for debugging)"
	@shared OPT_API        = "Generates SDoc API documentation (give the apifilename)"
	@shared OPT_TEST       = "Tells wether the source code is valid or not"
	@shared OPT_DEFINE     = "Defines a specific target (for @specific)"
	@shared OPT_RUN        = "Directly runs the script (default)"
	@shared OPT_COMPILE    = "Compiles the given code to the output (current) directory"
	@shared OPT_RUNTIME    = "Outputs the runtime as well when compiled"
	@shared OPT_VERSION    = "Ensures that Sugar is at least of the given version"
	@shared OPT_SOURCE     = "Directly gives the source"
	@shared OPT_MODULE     = "Specifies the module name"
	
	@property programName
	@property environment:Environment
	
	@constructor programName="lambdaf"
		self programName = programName
		createEnvironment()
		environment loadLanguages()
		setupEnvironment()
		setupPasses()
	@end

 	@method runAsString args
	| Runs Sugar, but instead of printing the result to the given
	| output, it returns a Python string with the result. It is very useful
	| when embedding LambdaFactory somewhere.
		var output = new StringIO()
		run (args, output)
		return "" + output getvalue()
	@end
	
	@method run arguments, output=sys stdout
		if type(arguments) != list
			arguments = list(arguments)
		end
		var status        = 0
		var option_parser = optparse OptionParser()
		var options       = []
		var args          = []
		@embed Python
		|option_parser.add_option("-r", "--run",  action="store_true", dest="run", default=True,
		|	help=self.OPT_RUN)
		|option_parser.add_option("-c", "--compile", action="store_true", dest="compile",
		|help=self.OPT_COMPILE)
		|option_parser.add_option("-R", "--runtime", action="store_true", dest="runtime",
		|help=self.OPT_RUNTIME)
		|option_parser.add_option("-l", "--lang", action="store", dest="lang",
		|	help=self.OPT_LANG)
		|option_parser.add_option("-o", "--output", action="store", dest="output", 
		|	help=self.OPT_OUTPUT)
		|option_parser.add_option("-v", "--verbose", action="store_true", dest="verbose",
		|	help=self.OPT_VERBOSE)
		|option_parser.add_option("-m", "--module", action="store", dest="module",
		|	help=self.OPT_MODULE)
		|option_parser.add_option("-a", "--api", action="store", dest="api",
		|	help=self.OPT_API)
		|option_parser.add_option("-t", "--test", action="store_true", dest="test", 
		|	help=self.OPT_TEST)
		|option_parser.add_option("-s", "--source", action="store", dest="source", 
		|	help=self.OPT_SOURCE)
		|option_parser.add_option("-D", "--define", action="append", dest="targets", 
		|	help=self.OPT_DEFINE)
		|option_parser.add_option("-V", None, action="store", dest="version", 
		|	help=self.OPT_VERSION)
		|options, args = option_parser.parse_args(args=arguments)
		@end
		var language = options lang
		if options source
			parseSource(args[0], options source, options module)
		else
			var source_path = args[0]
			parseFile(source_path, options module)
			# REWRITE: language = options get "lang" ? guessLanguage(source_path) ? raise ERR_NOT_LANGUAGE_SPECIFIED
			# We get the language to which we'd like to translate the program to
			if not language
				language = guessLanguage(source_path)
			end
		end
		transformProgram()
		if not language
			raise ERR_NO_LANGUAGE_SPECIFIED
		end
		# We compile, run or simply test
		if options compile
			var program_source = writeProgram (language)
			if not options output
				output write( program_source + "\n" )
			if os path isdir (options output)
				var splitter = FileSplitter(options output)
				splitter fromString ( program_source )
			else
				var f = file(options output, mode = "a")
				f write(program_source)
			end
		if options run
			var program_source = writeProgram (language, True)
			var file_and_path = tempfile mkstemp()
			os write(file_and_path[0],program_source )
			os close(file_and_path[0])
			var args_str = " " join(args[1:])
			var interpreter = None
			var path = file_and_path[1]
			var compilers = None
			# FIXME: LambdaFactory should support compilers and runners
			if (options lang in ["js","javascript"] or not options lang)
				interpreter = os getenv("SUGAR_JS") or "js"
				command = interpreter + " " + path + " " + args_str
			else
				raise ERR_NO_RUNTIME_AVAILABLE(language)
			end
			status = (os system(command) / 256) or status
			os unlink(path)
		end
	@end
	
	@method parseFile sourcePath, moduleName=None
		return environment parseFile (sourcePath, moduleName) 
	@end

	@method parseSource source, extension, moduleName=None
		return environment parseSource (source, extension, moduleName) 
	@end
		
	@method transformProgram
		environment runPasses()
		# FIXME: This should be a pass
		environment resolver flow (environment getProgram())
	@end
	
	@method guessLanguage sourcePath
		for name_and_value in environment languages items()
			if name_and_value[1] recognizes (sourcePath)
				return name_and_value[0]
			end
		end
		return None
	@end
	
	@method writeProgram inLanguage, includeRuntime=False
		var language = environment loadLanguage (inLanguage)
		# FIXME: The language should be initialized for the environment
		var writer   = language writer()
		# FIXME: Writer should take environ
		writer report = environment report
		var program_source = writer write (environment getProgram ())
		if includeRuntime
			program_source = writer getRuntimeSource() + program_source
		end
		return program_source
	@end
	
	@method createEnvironment
		environment = Environment()
	@end
	
	@method setupEnvironment
	@end

	@method setupPasses
		# Passes:
		#  Importation
		environment addPass (new passes ImportationPass() )
		environment addPass (new resolution ResolutionPass())
		#  Resolution
		# environment addPass (new passes ResolutionPass() )
		#  Typing
		# environment addPass (new passes TypingPass() )
	@end
	
@end

# EOF
