== LambdaFactory Refactoring
== What to do until 1.0

Strategy for making LambdaFactory self-hosted:

 - Parallel re-implementation
 - Rewrite Interfaces first, with a proper hierarchy and S-Expressions support
 - Properly model the relations between Element, DataFlow (Scope), Types
   (Abstract=typecast,Concrete=Element,Info=Type Description elements)
 - Implement modelbase after the interfaces
 - Write a small S-Expression parser to create modelbases
 - Design a flexible "pass" module, with "traits" that can be assigned to 
 - Front-End and Back-Ends easily integrated into LF
 - Common command-line interface
 - Importance of elements name: some are (classes, functions, modules), some
   aren't (program, closure, iterations, selection, etc)
 - Importations should go into the module "meta" (like version and stuff), and
   not into module init

Conceptual model
================

Ideas

    - A program is composed of elements (''program model elements'')

    - Each element represents either a structural (program, module, class, block),
      procedural (closure, functions, methods), operational (conditionals,
      repetitions, instanciations) or state-related (globals, variables,
      attributes) element.

    - Each element has an associated abstract type, and an associated concrete
      type, which may be itself. For instance, the concrete type of a 'Class'
      program element is the program element itself (or is it ?)

Add a resolution scheme:

 - Program, Scope
   Program uses Namespace (modules)
   Scope uses the context (and dataflow)

 - Resolution should happen for a specific operation: if the resolved symbol is
   declared later in the current scope or a child scope, then it may not be
   available (see 'bug-scoping.sg' in Sugar)

>   [Abstract Type] <------+
>       |                  |
>       |                  |
>       |                  |
>       |   +-------[Dataflow Slot]
>       |   |              |
>       |   |              |
>       |   v              |
>   [Element] ------> [Dataflow] <---+
>       |                            |
>       |                            |
>   (is process)                  (alter)
>       |                            |
>       |                            |
>       +---> [Operations] ----------+
>                  |
>                  (when evaluable)
>                  |
>           [Result Abstract Type]

Passes:

  [ ] Element pass
  [ ] Data-flow pass


Refactoring the module architecture
===================================

>   lambdafactory                      (main package)
>   
>       main.spy                       (main, command-line interface)
>   
>       model                          (the core)
>           interfaces.spy             (program model interface)
>           base.spy                   (default implementation)
>			typesystem.py              (the type system)
>   
>       passes                         (transformation passes)
>           resolving.spy              (add dataflow pass)
>           typing.spy                 (add type information pass)
>           async.spy                  (rewrite asynchronous invocations)
>           sdoc.spy                   (create documentation)
>           uml.spy                    (UML diagram)
>   
>       languages                      (available languages)
>           javascript
>				runtime/               (language-specific files)
>               	runtime.js         (specific runtime library)
>               importer.spy           (importing mechanisms)
>               writer.spy             (code generation)
>               reader.spy             (source code reading)
>               runner.spy             (interpreter/compiler wrapper)
>				interfaces.spy         (additional interfaces)
>           actionscript
>               runtime.as
>               importer.spy
>               writer.spy
>               runner.spy
>           python
>               runtime.py
>               importer.spy
>                writer.spy
>                 runner.spy
>   
>         library                       (default lambda-factory library)
>             core
>                 datatypes.sg
>                operations.sg

# EOF - sw=4 ts=4 et syn=kiwi
