<html>
<!-- Document generated by SDoc <http://www.ivy.fr/sdoc> -->
<head>
<title>Python API documentation (SDoc)</title>

<style type="text/css" media="screen">
/* css-main-snip */
html, body {
	background : #fcfcf6;
	color: #000000;
	font: 8pt/14pt "Lucida Grande", "Lucida", Helvetica, sans-serif;
	padding: 0;
	margin: 0;
}


a, a:active, a:link, a:visited, a:hover {
	color: #404040;
	text-decoration: none;
}

a:active, a:focus {
	background-color: #eae08c;
	color: white;
	border: 0;
	padding: 2px;
}

a:hover {
	color: #8fb216;
}

code {
	color: #8fb216;
}

pre {
	padding-top: 5pt;
	padding-bottom: 5pt;
	background: #f0f0f0;
	color: #8fb216;
}

/* css-main-snip */
/* css-classes-snip */
#descriptions {
	padding: 0;
	margin: 0;
	margin-left: 380px;
}

#modules {
	padding: 0;
	padding: 1pt;
	padding-left: 5pt;
	font-size: 7pt;
	color: #A0A0A0;
	background: #404040;
	border-bottom: 2px solid #f0f0f0;
}

#modules a {
	color: white;
}

#api {
	display: block;
	width: 360px;
	float: left;
	padding:0;
	padding-left: 5pt;
	padding-right: 10pt;
	background: white;
	border-right: 1px solid #f0f0f0;
	overflow: auto;
	height: 100%;

}

#hidden {
	padding: 0;
	margin: 0;
	display: none;
}

#sdoc .de {
	display: none;
	padding: 5pt;
}

#sdoc .re {
	padding-bottom: 5pt;
}


#sdoc .t {
	padding-top: 10pt;
	font-weight: bold;
	border-bottom: 1px solid #f0f0f0;
	color: #505050;
}

#sdoc .prefix {
	color: #D0C0C0;
	font-style: italic;
	padding-right: 5px;
}

#sdoc .noattributes {
	color: #D0C0C0;
	font-style: italic;
}

#sdoc .n, #sdoc .n a {
	color: #cdb425;
}

#sdoc .n {
	font-weight: bold;
	margin-top: 1em;
}

#sdoc .special {
	font-weight: bold;
}

#sdoc .special.__bases__ {
	font-weight: normal;
	color: #cdb425;
}

#sdoc .u, #sdoc .u a {
	color: #b0c0c0;
	font-style: italic;
}
#sdoc .ds {
	border-top: 1px solid #f0f0f0;
	border-bottom: 1px solid #f0f0f0;
	background: white;
	padding: 5pt;
	color: #808080;
}

#sdoc table caption {
	font: 8pt/14pt "Lucida Grande", "Lucida", Helvetica, sans-serif;
	font-weight: bold;
}

#sdoc table tr td {
	font: 8pt/14pt "Lucida Grande", "Lucida", Helvetica, sans-serif;
	color: #808080;
}

#sdoc .ro, #sdoc .cr {
	padding-left: 10pt;
	padding-top: 8pt;
	color: #404040;
	width: 150px;
	border-left: 1px solid #f0f0f0;
	float: left;
}

#sdoc .cr {
	margin-left: 10pt;
	display: none;
}


/* css-classes-snip */
</style>

<script type="text/javascript">
// javascript-snip

var displays    = [];
var selected    = undefined;
var description = undefined;
var hidden      = undefined;
var content     = undefined;

function dO( from_id, to_id )
{
	if ( to_id == undefined ) { to_id = from_id ; from_id = undefined; }
	if ( hidden  == undefined ) hidden  = document.getElementById("hidden");
	if ( content == undefined ) content = document.getElementById("api");
	// We get the target element and the associated description element
	var element  = document.getElementById(to_id);
	var felement = document.getElementById(from_id);
	var level    = 0;
	if ( felement != undefined )
	{
		level        = felement.getAttribute("level");
		if ( !level ) { level = 0; }
		else { level = parseInt(level); }
	}
	else
	{
		level = 0;
	}
	// We show the element description
	dS(to_id);
	// We show the element
	if (element)
	{
		if ( element == selected ) return;
		// We re-order the content nodes anyway
		element.parentNode.removeChild(element);
		element.setAttribute("level", level + 1);
		content.appendChild(element);
		// Ensure that the node is visible
		element.style.display  = "block";
		// And its description
		// We hide the old ones
		while ( displays.length > 0 && displays.length > level )
		{
			var hiding_id = displays.pop()
			var hiding_el = document.getElementById(hiding_id);
			if ( hiding_el != element )
			{
				hiding_el.parentNode.removeChild(hiding_el);
				hidden.appendChild(hiding_el);
			}
		}
		// And update the state
		displays.push(to_id);
		selected = element;
	}
}

function dS( eid )
{
	var delement = document.getElementById("d_" + eid);
	if ( delement != undefined && delement != description )
	{
		delement.style.display = "block";
		if ( description != undefined ) description.style.display = "none";
		description = delement;
	}
	else if ( delement == undefined )
	{
		alert("ERROR: Description not found for id 'd_" + eid + "'");
	}
}
// javascript-snip

</script>
</head>
<body onLoad="javascript:dO('a');">
<!-- body -->
<div id="sdoc">
<div id='modules'>
<!-- modules-snip -->
API : <a href='javascript:dO("a");'>lambdafactory.interfaces</a> &bull; <a href='javascript:dO("vs");'>lambdafactory.modelbase</a> &bull; <a href='javascript:dO("Ht");'>lambdafactory.modelwriter</a> &bull; <a href='javascript:dO("Ev");'>lambdafactory.modeltypes</a> &bull; <a href='javascript:dO("Zv");'>lambdafactory.typecast</a> &bull; <a href='javascript:dO("mA");'>lambdafactory.passes</a> &bull; <a href='javascript:dO("UA");'>lambdafactory.reporter</a>
<!-- modules-snip -->
</div>
<div id='api'><!-- main element will be displayed here --></div>
<div id='descriptions'>
	<!-- descriptions-snip -->
	<div id='d_c' class='de'><h1>tuple</h1><div class='re'><code>()</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_d' class='de'><h1>str</h1><div class='re'><code>'__init__'</code></div><div class='ds'><p>str(object) -&gt; string</p><p>Return a nice string representation of the object. If the argument is a string, the return value is the same object.</p></div></div><div id='d_e' class='de'><h1>str</h1><div class='re'><code>'__current__'</code></div><div class='ds'><p>str(object) -&gt; string</p><p>Return a nice string representation of the object. If the argument is a string, the return value is the same object.</p></div></div><div id='d_f' class='de'><h1>str</h1><div class='re'><code>'__currentvalue__'</code></div><div class='ds'><p>str(object) -&gt; string</p><p>Return a nice string representation of the object. If the argument is a string, the return value is the same object.</p></div></div><div id='d_g' class='de'><h1>str</h1><div class='re'><code>'__destroy__'</code></div><div class='ds'><p>str(object) -&gt; string</p><p>Return a nice string representation of the object. If the argument is a string, the return value is the same object.</p></div></div><div id='d_h' class='de'><h1>str</h1><div class='re'><code>'__main__'</code></div><div class='ds'><p>str(object) -&gt; string</p><p>Return a nice string representation of the object. If the argument is a string, the return value is the same object.</p></div></div><div id='d_i' class='de'><h1>str</h1><div class='re'><code>'__moduleinit__'</code></div><div class='ds'><p>str(object) -&gt; string</p><p>Return a nice string representation of the object. If the argument is a string, the return value is the same object.</p></div></div><div id='d_j' class='de'><h1>int</h1><div class='re'></div><div class='ds'><p>int(x[, base]) -&gt; integer</p><p>Convert a string or number to an integer, if possible. A floating point argument will be truncated towards zero (this does not include a string representation of a floating point number!) When converting a string, use the optional base. It is an error to supply a base when converting a non-string. If the argument is outside the integer range a long object will be returned instead.</p></div></div><div id='d_b' class='de'><h1>Class <span class='n'>Constants</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_l' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IReference at 0x5bf5d0&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_m' class='de'><h1>Method <span class='n'>getAbsoluteName</span></h1><div class='re'><code>getAbsoluteName( self )</code></div><div class='ds'><p>Returns the absolute name for this element</p></div></div><div id='d_n' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_o' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_p' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_q' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><p>Returns the local name for this referencable element</p></div></div><div id='d_r' class='de'><h1>Method <span class='n'>getReferenceName</span></h1><div class='re'><code>getReferenceName( self )</code></div><div class='ds'><p>Returns the name which this reference contains. The name is used by the resolution operation to actually resolve a value from the name.</p></div></div><div id='d_s' class='de'><h1>Method <span class='n'>getResultAbstractType</span></h1><div class='re'><code>getResultAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type of the result of the evaluation of this evaluable</p></div></div><div id='d_t' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_u' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_v' class='de'><h1>Method <span class='n'>setResultAbstractType</span></h1><div class='re'><code>setResultAbstractType( self, abstractType )</code></div><div class='ds'><p>Sets the abstract type for this operation result. This is usually invoked in the typing phase.</p></div></div><div id='d_k' class='de'><h1>Class <span class='n'>IAbsoluteReference</span></h1><div class='re'></div><div class='ds'><p>An absolute reference is a specific kind of reference that does not necessarily resolve in the current context, but will rather use the program root context as a starting point.</p></div></div><div id='d_x' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IClass at 0x5bf780&gt;, &lt;class lambdafactory.interfaces.IAbstractable at 0x5bf480&gt;)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_y' class='de'><h1>Method <span class='n'>getAbsoluteName</span></h1><div class='re'><code>getAbsoluteName( self )</code></div><div class='ds'><p>Returns the absolute name for this element</p></div></div><div id='d_z' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_A' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_B' class='de'><h1>Method <span class='n'>getAttributes</span></h1><div class='re'><code>getAttributes( self )</code></div><div class='ds'><p>Returns the (non-class) attributes defined within this class.</p></div></div><div id='d_C' class='de'><h1>Method <span class='n'>getClassAttributes</span></h1><div class='re'><code>getClassAttributes( self )</code></div><div class='ds'><p>Returns the class attributes defined within this class.</p></div></div><div id='d_D' class='de'><h1>Method <span class='n'>getClassMethods</span></h1><div class='re'><code>getClassMethods( self )</code></div><div class='ds'><p>Returns the class method defined within this class.</p></div></div><div id='d_E' class='de'><h1>Method <span class='n'>getConstructors</span></h1><div class='re'><code>getConstructors( self )</code></div><div class='ds'><p>Returns the constructors for this class</p></div></div><div id='d_F' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_G' class='de'><h1>Method <span class='n'>getDestructors</span></h1><div class='re'><code>getDestructors( self )</code></div><div class='ds'><p>Returns the destructors for this class</p></div></div><div id='d_H' class='de'><h1>Method <span class='n'>getInstanceMethods</span></h1><div class='re'><code>getInstanceMethods( self )</code></div><div class='ds'><p>Returns the instance methods defined within this class.</p></div></div><div id='d_I' class='de'><h1>Method <span class='n'>getMethods</span></h1><div class='re'><code>getMethods( self )</code></div><div class='ds'><p>Returns the methods defined within this class.</p></div></div><div id='d_J' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><p>Returns this class name. It can be <code>None</code> if the class is anonymous.</p></div></div><div id='d_K' class='de'><h1>Method <span class='n'>getOperations</span></h1><div class='re'><code>getOperations( self )</code></div><div class='ds'><p>Returns the operations (methods and class methods) defined within this class.</p></div></div><div id='d_L' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns the parent context for this context (if any)</p></div></div><div id='d_M' class='de'><h1>Method <span class='n'>getParentClasses</span></h1><div class='re'><code>getParentClasses( self )</code></div><div class='ds'><p>Returns the list of inherited classes references.</p></div></div><div id='d_N' class='de'><h1>Method <span class='n'>getSlot</span></h1><div class='re'><code>getSlot( self, name )</code></div><div class='ds'><p>Returns the given evaluable bound to named slot.</p></div></div><div id='d_O' class='de'><h1>Method <span class='n'>getSlots</span></h1><div class='re'><code>getSlots( self )</code></div><div class='ds'><p>Returns (key, evaluable) pairs representing the slots within this context.</p></div></div><div id='d_P' class='de'><h1>Method <span class='n'>hasSlot</span></h1><div class='re'><code>hasSlot( self, name )</code></div><div class='ds'><p>Tells if the context has a slot with the given name.</p></div></div><div id='d_Q' class='de'><h1>Method <span class='n'>isAbstract</span></h1><div class='re'><code>isAbstract( self )</code></div><div class='ds'><p>Tells wether the given abstractable is abstract or not.</p></div></div><div id='d_R' class='de'><h1>Method <span class='n'>setAbstract</span></h1><div class='re'><code>setAbstract( self, isAbstract )</code></div><div class='ds'><p>Sets wether the given abstractable is abstract or not.</p></div></div><div id='d_S' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_T' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_U' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, context )</code></div><div class='ds'><p>Sets the parent context for this context.</p></div></div><div id='d_V' class='de'><h1>Method <span class='n'>setParentClasses</span></h1><div class='re'><code>setParentClasses( self )</code></div><div class='ds'><p>gives the list of parent classes that will</p></div></div><div id='d_W' class='de'><h1>Method <span class='n'>setSlot</span></h1><div class='re'><code>setSlot( self, name, evaluable )</code></div><div class='ds'><p>Binds the given evaluable to the named slot.</p></div></div><div id='d_w' class='de'><h1>Class <span class='n'>IAbstractClass</span></h1><div class='re'></div><div class='ds'><p>An abstract @protocol is a @protocol that has at least one abstract element.</p></div></div><div id='d_Y' class='de'><h1>Method <span class='n'>isAbstract</span></h1><div class='re'><code>isAbstract( self )</code></div><div class='ds'><p>Tells wether the given abstractable is abstract or not.</p></div></div><div id='d_Z' class='de'><h1>Method <span class='n'>setAbstract</span></h1><div class='re'><code>setAbstract( self, isAbstract )</code></div><div class='ds'><p>Sets wether the given abstractable is abstract or not.</p></div></div><div id='d_X' class='de'><h1>Class <span class='n'>IAbstractable</span></h1><div class='re'></div><div class='ds'><p>An abstractable element is an element that is allow to have no underlying implementation. Abstract element are typically interfaces, methods, functions, operations, and sometimes modules and @protocoles.</p></div></div><div id='d_bb' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.ISubsetOperation at 0x5bfcc0&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_cb' class='de'><h1>Method <span class='n'>getIndex</span></h1><div class='re'><code>getIndex( self )</code></div><div class='ds'><p>Returns evaluable that will return the access index</p></div></div><div id='d_db' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><p>Adds an argument to this operation. This should do checking of arguments (by expected internal type and number).</p></div></div><div id='d_eb' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_fb' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_gb' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_hb' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><p>Returns the ith arguments to this operation.</p></div></div><div id='d_ib' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><p>Returns the arguments to this operation.</p></div></div><div id='d_jb' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><p>Returns the <em>internal types</em> for this operations arguments. This is typically the list of interfaces or @protocols that the arguments must comply to.</p></div></div><div id='d_kb' class='de'><h1>Method <span class='n'>getTarget</span></h1><div class='re'><code>getTarget( self )</code></div><div class='ds'><p>Returns the operation target.</p></div></div><div id='d_lb' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_mb' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_nb' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><p>Sets the given argument of this operation, by argument index.</p></div></div><div id='d_ob' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.IEvaluable at 0x5bf3f0&gt;, &lt;class lambdafactory.interfaces.IEvaluable at 0x5bf3f0&gt;]</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='d_ab' class='de'><h1>Class <span class='n'>IAccessOperation</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_qb' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IOperation at 0x5bfa50&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_rb' class='de'><h1>Method <span class='n'>getDefaultValue</span></h1><div class='re'><code>getDefaultValue( self )</code></div><div class='ds'><p>Returns the expression that assigns the @methodault value.</p></div></div><div id='d_sb' class='de'><h1>Method <span class='n'>getSlotToAllocate</span></h1><div class='re'><code>getSlotToAllocate( self )</code></div><div class='ds'><p>Returns slot to be allocated by this operation.</p></div></div><div id='d_tb' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><p>Adds an argument to this operation. This should do checking of arguments (by expected internal type and number).</p></div></div><div id='d_ub' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_vb' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_wb' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_xb' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><p>Returns the ith arguments to this operation.</p></div></div><div id='d_yb' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><p>Returns the arguments to this operation.</p></div></div><div id='d_zb' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><p>Returns the <em>internal types</em> for this operations arguments. This is typically the list of interfaces or @protocols that the arguments must comply to.</p></div></div><div id='d_Ab' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_Bb' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_Cb' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><p>Sets the given argument of this operation, by argument index.</p></div></div><div id='d_Db' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.ISlot at 0x5bf660&gt;, &lt;class lambdafactory.interfaces.IEvaluable at 0x5bf3f0&gt;]</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='d_pb' class='de'><h1>Class <span class='n'>IAllocation</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Fb' class='de'><h1>Method <span class='n'>getContent</span></h1><div class='re'><code>getContent( self )</code></div><div class='ds'><p>Returns the content of this annotation.</p></div></div><div id='d_Gb' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><p>Returns the name of this annotation.</p></div></div><div id='d_Eb' class='de'><h1>Class <span class='n'>IAnnotation</span></h1><div class='re'></div><div class='ds'><p>An annotation is some information that is not used for the actual program, but annotates/gives meta-information about is elements.</p></div></div><div id='d_Ib' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.ISlot at 0x5bf660&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Jb' class='de'><h1>Method <span class='n'>getDefaultValue</span></h1><div class='re'><code>getDefaultValue( self )</code></div><div class='ds'><p>Returns the @methodault value for this slot.</p></div></div><div id='d_Kb' class='de'><h1>Method <span class='n'>isKeywords</span></h1><div class='re'><code>isKeywords( self )</code></div><div class='ds'><p>Tells if the argument is keywords list or not.</p></div></div><div id='d_Lb' class='de'><h1>Method <span class='n'>isOptional</span></h1><div class='re'><code>isOptional( self )</code></div><div class='ds'><p>Tells if the argument is optional or not.</p></div></div><div id='d_Mb' class='de'><h1>Method <span class='n'>isRest</span></h1><div class='re'><code>isRest( self )</code></div><div class='ds'><p>Tells if the argument is variable or not.</p></div></div><div id='d_Nb' class='de'><h1>Method <span class='n'>setDefaultValue</span></h1><div class='re'><code>setDefaultValue( self, value )</code></div><div class='ds'><p>Sets the @methodault value for this argument.</p></div></div><div id='d_Ob' class='de'><h1>Method <span class='n'>setKeywords</span></h1><div class='re'><code>setKeywords( self, value )</code></div><div class='ds'><p>Sets this argument as keywords list or not.</p></div></div><div id='d_Pb' class='de'><h1>Method <span class='n'>setOptional</span></h1><div class='re'><code>setOptional( self, value )</code></div><div class='ds'><p>Sets this argument as optional or not.</p></div></div><div id='d_Qb' class='de'><h1>Method <span class='n'>setRest</span></h1><div class='re'><code>setRest( self, value )</code></div><div class='ds'><p>Sets this argument as variable or not.</p></div></div><div id='d_Rb' class='de'><h1>Method <span class='n'>getAbsoluteName</span></h1><div class='re'><code>getAbsoluteName( self )</code></div><div class='ds'><p>Returns the absolute name for this element</p></div></div><div id='d_Sb' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><p>Returns the local name for this referencable element</p></div></div><div id='d_Tb' class='de'><h1>Method <span class='n'>getTypeDescription</span></h1><div class='re'><code>getTypeDescription( self )</code></div><div class='ds'><p>Returns type information (constraints) that are associated to this argument.</p></div></div><div id='d_Hb' class='de'><h1>Class <span class='n'>IArgument</span></h1><div class='re'></div><div class='ds'><p>Arguments are slots which can be interpreted in different ways.</p><p>When an argument is <span class='term'>optional</span>, it does not need to be defined in the invocation. When an argument is <span class='term'>variable</span>, it means it references the rest of the arguments lists. When an argument is <span class='term'>keywords</span>, it will reference the named arguments of the rest of the arguments list.</p></div></div><div id='d_Ub' class='de'><h1>Class <span class='n'>IAssignable</span></h1><div class='re'></div><div class='ds'><p>Assignable elements are elements that can be bound to slots. In many languages, only a subset of elements can be assigned. For instance, in Java, you cannot assign a package to something:</p><pre>  Object my_package = java.lang.Object</pre><p>while in some other languages (like JavaScript), you could do that.</p></div></div><div id='d_Wb' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IOperation at 0x5bfa50&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Xb' class='de'><h1>Method <span class='n'>getAssignedValue</span></h1><div class='re'><code>getAssignedValue( self )</code></div><div class='ds'><p>Returns this assigned evaluable.</p></div></div><div id='d_Yb' class='de'><h1>Method <span class='n'>getTarget</span></h1><div class='re'><code>getTarget( self )</code></div><div class='ds'><p>Returns this assignation target reference, which can be an evaluable (in case you assign to self.something, or a reference)</p></div></div><div id='d_Zb' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><p>Adds an argument to this operation. This should do checking of arguments (by expected internal type and number).</p></div></div><div id='d_ac' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_bc' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_cc' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_dc' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><p>Returns the ith arguments to this operation.</p></div></div><div id='d_ec' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><p>Returns the arguments to this operation.</p></div></div><div id='d_fc' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><p>Returns the <em>internal types</em> for this operations arguments. This is typically the list of interfaces or @protocols that the arguments must comply to.</p></div></div><div id='d_gc' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_hc' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_ic' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><p>Sets the given argument of this operation, by argument index.</p></div></div><div id='d_jc' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.IEvaluable at 0x5bf3f0&gt;, &lt;class lambdafactory.interfaces.IEvaluable at 0x5bf3f0&gt;]</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='d_Vb' class='de'><h1>Class <span class='n'>IAssignation</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_lc' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.ISlot at 0x5bf660&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_mc' class='de'><h1>Method <span class='n'>getDefaultValue</span></h1><div class='re'><code>getDefaultValue( self )</code></div><div class='ds'><p>Gets the @methodault value for this attribute</p></div></div><div id='d_nc' class='de'><h1>Method <span class='n'>setDefaultValue</span></h1><div class='re'><code>setDefaultValue( self )</code></div><div class='ds'><p>Sets the @methodault value for this attribute</p></div></div><div id='d_oc' class='de'><h1>Method <span class='n'>getAbsoluteName</span></h1><div class='re'><code>getAbsoluteName( self )</code></div><div class='ds'><p>Returns the absolute name for this element</p></div></div><div id='d_pc' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><p>Returns the local name for this referencable element</p></div></div><div id='d_qc' class='de'><h1>Method <span class='n'>getTypeDescription</span></h1><div class='re'><code>getTypeDescription( self )</code></div><div class='ds'><p>Returns type information (constraints) that are associated to this argument.</p></div></div><div id='d_kc' class='de'><h1>Class <span class='n'>IAttribute</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_sc' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IGroup at 0x5bf8a0&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_tc' class='de'><h1>Method <span class='n'>addOperation</span></h1><div class='re'><code>addOperation( self, operation )</code></div><div class='ds'><p>Adds the given operation as a child of this process.</p></div></div><div id='d_uc' class='de'><h1>Method <span class='n'>getOperations</span></h1><div class='re'><code>getOperations( self )</code></div><div class='ds'><p>Returns the list of operations in this process.</p></div></div><div id='d_rc' class='de'><h1>Class <span class='n'>IBlock</span></h1><div class='re'></div><div class='ds'><p>A block is a specific type of (sub) process.</p></div></div><div id='d_wc' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IInterruption at 0x5bfed0&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_xc' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><p>Adds an argument to this operation. This should do checking of arguments (by expected internal type and number).</p></div></div><div id='d_yc' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_zc' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_Ac' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_Bc' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><p>Returns the ith arguments to this operation.</p></div></div><div id='d_Cc' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><p>Returns the arguments to this operation.</p></div></div><div id='d_Dc' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><p>Returns the <em>internal types</em> for this operations arguments. This is typically the list of interfaces or @protocols that the arguments must comply to.</p></div></div><div id='d_Ec' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_Fc' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_Gc' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><p>Sets the given argument of this operation, by argument index.</p></div></div><div id='d_Hc' class='de'><h1>list</h1><div class='re'><code>[]</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='d_vc' class='de'><h1>Class <span class='n'>IBreaking</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Jc' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IContext at 0x5bf750&gt;, &lt;class lambdafactory.interfaces.IReferencable at 0x5bf3c0&gt;)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Kc' class='de'><h1>Method <span class='n'>getAttributes</span></h1><div class='re'><code>getAttributes( self )</code></div><div class='ds'><p>Returns the (non-class) attributes defined within this class.</p></div></div><div id='d_Lc' class='de'><h1>Method <span class='n'>getClassAttributes</span></h1><div class='re'><code>getClassAttributes( self )</code></div><div class='ds'><p>Returns the class attributes defined within this class.</p></div></div><div id='d_Mc' class='de'><h1>Method <span class='n'>getClassMethods</span></h1><div class='re'><code>getClassMethods( self )</code></div><div class='ds'><p>Returns the class method defined within this class.</p></div></div><div id='d_Nc' class='de'><h1>Method <span class='n'>getConstructors</span></h1><div class='re'><code>getConstructors( self )</code></div><div class='ds'><p>Returns the constructors for this class</p></div></div><div id='d_Oc' class='de'><h1>Method <span class='n'>getDestructors</span></h1><div class='re'><code>getDestructors( self )</code></div><div class='ds'><p>Returns the destructors for this class</p></div></div><div id='d_Pc' class='de'><h1>Method <span class='n'>getInstanceMethods</span></h1><div class='re'><code>getInstanceMethods( self )</code></div><div class='ds'><p>Returns the instance methods defined within this class.</p></div></div><div id='d_Qc' class='de'><h1>Method <span class='n'>getMethods</span></h1><div class='re'><code>getMethods( self )</code></div><div class='ds'><p>Returns the methods defined within this class.</p></div></div><div id='d_Rc' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><p>Returns this class name. It can be <code>None</code> if the class is anonymous.</p></div></div><div id='d_Sc' class='de'><h1>Method <span class='n'>getOperations</span></h1><div class='re'><code>getOperations( self )</code></div><div class='ds'><p>Returns the operations (methods and class methods) defined within this class.</p></div></div><div id='d_Tc' class='de'><h1>Method <span class='n'>getParentClasses</span></h1><div class='re'><code>getParentClasses( self )</code></div><div class='ds'><p>Returns the list of inherited classes references.</p></div></div><div id='d_Uc' class='de'><h1>Method <span class='n'>setParentClasses</span></h1><div class='re'><code>setParentClasses( self )</code></div><div class='ds'><p>gives the list of parent classes that will</p></div></div><div id='d_Vc' class='de'><h1>Method <span class='n'>getAbsoluteName</span></h1><div class='re'><code>getAbsoluteName( self )</code></div><div class='ds'><p>Returns the absolute name for this element</p></div></div><div id='d_Wc' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_Xc' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_Yc' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_Zc' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns the parent context for this context (if any)</p></div></div><div id='d_ad' class='de'><h1>Method <span class='n'>getSlot</span></h1><div class='re'><code>getSlot( self, name )</code></div><div class='ds'><p>Returns the given evaluable bound to named slot.</p></div></div><div id='d_bd' class='de'><h1>Method <span class='n'>getSlots</span></h1><div class='re'><code>getSlots( self )</code></div><div class='ds'><p>Returns (key, evaluable) pairs representing the slots within this context.</p></div></div><div id='d_cd' class='de'><h1>Method <span class='n'>hasSlot</span></h1><div class='re'><code>hasSlot( self, name )</code></div><div class='ds'><p>Tells if the context has a slot with the given name.</p></div></div><div id='d_dd' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_ed' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_fd' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, context )</code></div><div class='ds'><p>Sets the parent context for this context.</p></div></div><div id='d_gd' class='de'><h1>Method <span class='n'>setSlot</span></h1><div class='re'><code>setSlot( self, name, evaluable )</code></div><div class='ds'><p>Binds the given evaluable to the named slot.</p></div></div><div id='d_Ic' class='de'><h1>Class <span class='n'>IClass</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_id' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IAttribute at 0x5bf6c0&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_jd' class='de'><h1>Method <span class='n'>getAbsoluteName</span></h1><div class='re'><code>getAbsoluteName( self )</code></div><div class='ds'><p>Returns the absolute name for this element</p></div></div><div id='d_kd' class='de'><h1>Method <span class='n'>getDefaultValue</span></h1><div class='re'><code>getDefaultValue( self )</code></div><div class='ds'><p>Gets the @methodault value for this attribute</p></div></div><div id='d_ld' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><p>Returns the local name for this referencable element</p></div></div><div id='d_md' class='de'><h1>Method <span class='n'>getTypeDescription</span></h1><div class='re'><code>getTypeDescription( self )</code></div><div class='ds'><p>Returns type information (constraints) that are associated to this argument.</p></div></div><div id='d_nd' class='de'><h1>Method <span class='n'>setDefaultValue</span></h1><div class='re'><code>setDefaultValue( self )</code></div><div class='ds'><p>Sets the @methodault value for this attribute</p></div></div><div id='d_hd' class='de'><h1>Class <span class='n'>IClassAttribute</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_pd' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IMethod at 0x5bf960&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_qd' class='de'><h1>Method <span class='n'>addOperation</span></h1><div class='re'><code>addOperation( self, operation )</code></div><div class='ds'><p>Adds the given operation as a child of this process.</p></div></div><div id='d_rd' class='de'><h1>Method <span class='n'>endsWithTermination</span></h1><div class='re'><code>endsWithTermination( self )</code></div><div class='ds'><p>Returns true if this function ends with a termination operation. This is especially useful for back-ends which want to know if they have to insert an explicit <code>return</code> at the end (like Java).</p></div></div><div id='d_sd' class='de'><h1>Method <span class='n'>getAbsoluteName</span></h1><div class='re'><code>getAbsoluteName( self )</code></div><div class='ds'><p>Returns the absolute name for this element</p></div></div><div id='d_td' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_ud' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_vd' class='de'><h1>Method <span class='n'>getArguments</span></h1><div class='re'><code>getArguments( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_wd' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_xd' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><p>Returns this @protocol name. It can be <code>None</code> if the @protocol is anonymous.</p></div></div><div id='d_yd' class='de'><h1>Method <span class='n'>getOperations</span></h1><div class='re'><code>getOperations( self )</code></div><div class='ds'><p>Returns the list of operations in this process.</p></div></div><div id='d_zd' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns the parent context for this context (if any)</p></div></div><div id='d_Ad' class='de'><h1>Method <span class='n'>getSlot</span></h1><div class='re'><code>getSlot( self, name )</code></div><div class='ds'><p>Returns the given evaluable bound to named slot.</p></div></div><div id='d_Bd' class='de'><h1>Method <span class='n'>getSlots</span></h1><div class='re'><code>getSlots( self )</code></div><div class='ds'><p>Returns (key, evaluable) pairs representing the slots within this context.</p></div></div><div id='d_Cd' class='de'><h1>Method <span class='n'>hasExplicitTermination</span></h1><div class='re'><code>hasExplicitTermination( self )</code></div><div class='ds'><p>Returns true if this function has an operation with a termination, otherwise return false.</p></div></div><div id='d_Dd' class='de'><h1>Method <span class='n'>hasSlot</span></h1><div class='re'><code>hasSlot( self, name )</code></div><div class='ds'><p>Tells if the context has a slot with the given name.</p></div></div><div id='d_Ed' class='de'><h1>Method <span class='n'>isAbstract</span></h1><div class='re'><code>isAbstract( self )</code></div><div class='ds'><p>Tells wether the given abstractable is abstract or not.</p></div></div><div id='d_Fd' class='de'><h1>Method <span class='n'>setAbstract</span></h1><div class='re'><code>setAbstract( self, isAbstract )</code></div><div class='ds'><p>Sets wether the given abstractable is abstract or not.</p></div></div><div id='d_Gd' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_Hd' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_Id' class='de'><h1>Method <span class='n'>setArguments</span></h1><div class='re'><code>setArguments( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Jd' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, context )</code></div><div class='ds'><p>Sets the parent context for this context.</p></div></div><div id='d_Kd' class='de'><h1>Method <span class='n'>setSlot</span></h1><div class='re'><code>setSlot( self, name, evaluable )</code></div><div class='ds'><p>Binds the given evaluable to the named slot.</p></div></div><div id='d_od' class='de'><h1>Class <span class='n'>IClassMethod</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Md' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IProcess at 0x5bf870&gt;, &lt;class lambdafactory.interfaces.IContext at 0x5bf750&gt;)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Nd' class='de'><h1>Method <span class='n'>getArguments</span></h1><div class='re'><code>getArguments( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Od' class='de'><h1>Method <span class='n'>setArguments</span></h1><div class='re'><code>setArguments( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Pd' class='de'><h1>Method <span class='n'>addOperation</span></h1><div class='re'><code>addOperation( self, operation )</code></div><div class='ds'><p>Adds the given operation as a child of this process.</p></div></div><div id='d_Qd' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_Rd' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_Sd' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_Td' class='de'><h1>Method <span class='n'>getOperations</span></h1><div class='re'><code>getOperations( self )</code></div><div class='ds'><p>Returns the list of operations in this process.</p></div></div><div id='d_Ud' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns the parent context for this context (if any)</p></div></div><div id='d_Vd' class='de'><h1>Method <span class='n'>getSlot</span></h1><div class='re'><code>getSlot( self, name )</code></div><div class='ds'><p>Returns the given evaluable bound to named slot.</p></div></div><div id='d_Wd' class='de'><h1>Method <span class='n'>getSlots</span></h1><div class='re'><code>getSlots( self )</code></div><div class='ds'><p>Returns (key, evaluable) pairs representing the slots within this context.</p></div></div><div id='d_Xd' class='de'><h1>Method <span class='n'>hasSlot</span></h1><div class='re'><code>hasSlot( self, name )</code></div><div class='ds'><p>Tells if the context has a slot with the given name.</p></div></div><div id='d_Yd' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_Zd' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_ae' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, context )</code></div><div class='ds'><p>Sets the parent context for this context.</p></div></div><div id='d_be' class='de'><h1>Method <span class='n'>setSlot</span></h1><div class='re'><code>setSlot( self, name, evaluable )</code></div><div class='ds'><p>Binds the given evaluable to the named slot.</p></div></div><div id='d_Ld' class='de'><h1>Class <span class='n'>IClosure</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_de' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IAnnotation at 0x5bf210&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_ee' class='de'><h1>Method <span class='n'>getContent</span></h1><div class='re'><code>getContent( self )</code></div><div class='ds'><p>Returns the content of this annotation.</p></div></div><div id='d_fe' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><p>Returns the name of this annotation.</p></div></div><div id='d_ce' class='de'><h1>Class <span class='n'>IComment</span></h1><div class='re'></div><div class='ds'><p>A comment is an annotation that can occur anywhere in a source file.</p></div></div><div id='d_he' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IOperation at 0x5bfa50&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_ie' class='de'><h1>Method <span class='n'>getLeftOperand</span></h1><div class='re'><code>getLeftOperand( self )</code></div><div class='ds'><p>Returns the left operand of this computation.</p></div></div><div id='d_je' class='de'><h1>Method <span class='n'>getOperand</span></h1><div class='re'><code>getOperand( self )</code></div><div class='ds'><p>Returns the left operand of this computation.</p></div></div><div id='d_ke' class='de'><h1>Method <span class='n'>getOperands</span></h1><div class='re'><code>getOperands( self )</code></div><div class='ds'><p>Returns the left (and right, if any) operands of this computation.</p></div></div><div id='d_le' class='de'><h1>Method <span class='n'>getOperator</span></h1><div class='re'><code>getOperator( self )</code></div><div class='ds'><p>Gets the operator for this computation</p></div></div><div id='d_me' class='de'><h1>Method <span class='n'>getRightOperand</span></h1><div class='re'><code>getRightOperand( self )</code></div><div class='ds'><p>Returns the right operand of this computation (if any)</p></div></div><div id='d_ne' class='de'><h1>Method <span class='n'>setLeftOperand</span></h1><div class='re'><code>setLeftOperand( self, operand )</code></div><div class='ds'><p>Sets the left operand of this computation.</p></div></div><div id='d_oe' class='de'><h1>Method <span class='n'>setOperator</span></h1><div class='re'><code>setOperator( self, operator )</code></div><div class='ds'><p>Sets the operator for this computation</p></div></div><div id='d_pe' class='de'><h1>Method <span class='n'>setRightOperand</span></h1><div class='re'><code>setRightOperand( self, operand )</code></div><div class='ds'><p>Sets the right operand of this computation</p></div></div><div id='d_qe' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><p>Adds an argument to this operation. This should do checking of arguments (by expected internal type and number).</p></div></div><div id='d_re' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_se' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_te' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_ue' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><p>Returns the ith arguments to this operation.</p></div></div><div id='d_ve' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><p>Returns the arguments to this operation.</p></div></div><div id='d_we' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><p>Returns the <em>internal types</em> for this operations arguments. This is typically the list of interfaces or @protocols that the arguments must comply to.</p></div></div><div id='d_xe' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_ye' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_ze' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><p>Sets the given argument of this operation, by argument index.</p></div></div><div id='d_Ae' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.IOperator at 0x5bf630&gt;, &lt;class lambdafactory.interfaces.IEvaluable at 0x5bf3f0&gt;, &lt;class lambdafactory.interfaces.IEvaluable at 0x5bf3f0&gt;]</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='d_ge' class='de'><h1>Class <span class='n'>IComputation</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Ce' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IMethod at 0x5bf960&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_De' class='de'><h1>Method <span class='n'>addOperation</span></h1><div class='re'><code>addOperation( self, operation )</code></div><div class='ds'><p>Adds the given operation as a child of this process.</p></div></div><div id='d_Ee' class='de'><h1>Method <span class='n'>endsWithTermination</span></h1><div class='re'><code>endsWithTermination( self )</code></div><div class='ds'><p>Returns true if this function ends with a termination operation. This is especially useful for back-ends which want to know if they have to insert an explicit <code>return</code> at the end (like Java).</p></div></div><div id='d_Fe' class='de'><h1>Method <span class='n'>getAbsoluteName</span></h1><div class='re'><code>getAbsoluteName( self )</code></div><div class='ds'><p>Returns the absolute name for this element</p></div></div><div id='d_Ge' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_He' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_Ie' class='de'><h1>Method <span class='n'>getArguments</span></h1><div class='re'><code>getArguments( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Je' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_Ke' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><p>Returns this @protocol name. It can be <code>None</code> if the @protocol is anonymous.</p></div></div><div id='d_Le' class='de'><h1>Method <span class='n'>getOperations</span></h1><div class='re'><code>getOperations( self )</code></div><div class='ds'><p>Returns the list of operations in this process.</p></div></div><div id='d_Me' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns the parent context for this context (if any)</p></div></div><div id='d_Ne' class='de'><h1>Method <span class='n'>getSlot</span></h1><div class='re'><code>getSlot( self, name )</code></div><div class='ds'><p>Returns the given evaluable bound to named slot.</p></div></div><div id='d_Oe' class='de'><h1>Method <span class='n'>getSlots</span></h1><div class='re'><code>getSlots( self )</code></div><div class='ds'><p>Returns (key, evaluable) pairs representing the slots within this context.</p></div></div><div id='d_Pe' class='de'><h1>Method <span class='n'>hasExplicitTermination</span></h1><div class='re'><code>hasExplicitTermination( self )</code></div><div class='ds'><p>Returns true if this function has an operation with a termination, otherwise return false.</p></div></div><div id='d_Qe' class='de'><h1>Method <span class='n'>hasSlot</span></h1><div class='re'><code>hasSlot( self, name )</code></div><div class='ds'><p>Tells if the context has a slot with the given name.</p></div></div><div id='d_Re' class='de'><h1>Method <span class='n'>isAbstract</span></h1><div class='re'><code>isAbstract( self )</code></div><div class='ds'><p>Tells wether the given abstractable is abstract or not.</p></div></div><div id='d_Se' class='de'><h1>Method <span class='n'>setAbstract</span></h1><div class='re'><code>setAbstract( self, isAbstract )</code></div><div class='ds'><p>Sets wether the given abstractable is abstract or not.</p></div></div><div id='d_Te' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_Ue' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_Ve' class='de'><h1>Method <span class='n'>setArguments</span></h1><div class='re'><code>setArguments( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_We' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, context )</code></div><div class='ds'><p>Sets the parent context for this context.</p></div></div><div id='d_Xe' class='de'><h1>Method <span class='n'>setSlot</span></h1><div class='re'><code>setSlot( self, name, evaluable )</code></div><div class='ds'><p>Binds the given evaluable to the named slot.</p></div></div><div id='d_Be' class='de'><h1>Class <span class='n'>IConstructor</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Ze' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IElement at 0x5bf360&gt;, &lt;class lambdafactory.interfaces.IDataFlowOwner at 0x5bf330&gt;)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_af' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns the parent context for this context (if any)</p></div></div><div id='d_bf' class='de'><h1>Method <span class='n'>getSlot</span></h1><div class='re'><code>getSlot( self, name )</code></div><div class='ds'><p>Returns the given evaluable bound to named slot.</p></div></div><div id='d_cf' class='de'><h1>Method <span class='n'>getSlots</span></h1><div class='re'><code>getSlots( self )</code></div><div class='ds'><p>Returns (key, evaluable) pairs representing the slots within this context.</p></div></div><div id='d_df' class='de'><h1>Method <span class='n'>hasSlot</span></h1><div class='re'><code>hasSlot( self, name )</code></div><div class='ds'><p>Tells if the context has a slot with the given name.</p></div></div><div id='d_ef' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, context )</code></div><div class='ds'><p>Sets the parent context for this context.</p></div></div><div id='d_ff' class='de'><h1>Method <span class='n'>setSlot</span></h1><div class='re'><code>setSlot( self, name, evaluable )</code></div><div class='ds'><p>Binds the given evaluable to the named slot.</p></div></div><div id='d_gf' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_hf' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_if' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_jf' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_kf' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_Ye' class='de'><h1>Class <span class='n'>IContext</span></h1><div class='re'></div><div class='ds'><p>A context is an element that has slots, which bind evaluable elements (aka values) to names.</p></div></div><div id='d_mf' class='de'><h1>Method <span class='n'>addChild</span></h1><div class='re'><code>addChild( self, child )</code></div><div class='ds'><p>Adds the given dataflow as a child of this dataflow.</p></div></div><div id='d_nf' class='de'><h1>Method <span class='n'>addParent</span></h1><div class='re'><code>addParent( self, parent )</code></div><div class='ds'><p>Add the given dataflow as a parent of this dataflow.</p></div></div><div id='d_of' class='de'><h1>Method <span class='n'>declareArgument</span></h1><div class='re'><code>declareArgument( self, name, value )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_pf' class='de'><h1>Method <span class='n'>declareEnvironment</span></h1><div class='re'><code>declareEnvironment( self, name, value )</code></div><div class='ds'><p>Declares an environment variable with the given name, value and origin.</p></div></div><div id='d_qf' class='de'><h1>Method <span class='n'>declareVariable</span></h1><div class='re'><code>declareVariable( self, name, value, origin=None )</code></div><div class='ds'><p>Declares a (local) variable with the given name, value and origin</p></div></div><div id='d_rf' class='de'><h1>Method <span class='n'>defines</span></h1><div class='re'><code>defines( self, name )</code></div><div class='ds'><p>Tells if this dataflow, or any of its child dataflows defines the given name (symbol)</p></div></div><div id='d_sf' class='de'><h1>Method <span class='n'>getChildren</span></h1><div class='re'><code>getChildren( self )</code></div><div class='ds'><p>Returns a list of the child dataflows for this dataflow.</p></div></div><div id='d_tf' class='de'><h1>Method <span class='n'>getParents</span></h1><div class='re'><code>getParents( self )</code></div><div class='ds'><p>Returns the list of parent dataflows for this dataflow.</p></div></div><div id='d_uf' class='de'><h1>Method <span class='n'>getSlot</span></h1><div class='re'><code>getSlot( self, name )</code></div><div class='ds'><p>Returns the slot with the given name, if any.</p></div></div><div id='d_vf' class='de'><h1>Method <span class='n'>getSlots</span></h1><div class='re'><code>getSlots( self )</code></div><div class='ds'><p>Returns the lsit of slots @methodiend for this dataflow.</p></div></div><div id='d_wf' class='de'><h1>Method <span class='n'>hasSlot</span></h1><div class='re'><code>hasSlot( self, name )</code></div><div class='ds'><p>Tells if this dataflow @methodines a slot with the given name.</p></div></div><div id='d_xf' class='de'><h1>Method <span class='n'>resolve</span></h1><div class='re'><code>resolve( self, name )</code></div><div class='ds'><p>Returns a couple <code>(DataFlow slot, IElement)</code> or <code>(None,None)</code> corresponding to the resolution of the given <code>name</code> in this dataflow.</p></div></div><div id='d_lf' class='de'><h1>Class <span class='n'>IDataFlow</span></h1><div class='re'></div><div class='ds'><p>The DataFlow are &ldquo;<span class='quote'>dynamic contexts</span>&rdquo; bound to the various program model elements. DataFlows are typically owned by elements which implement <code>IContext</code>, and are linked together by rules defined in the <code>Resolver</code> @protocol.</p><p>The dataflow bound to most expressions is the one of the enclosing closure (whether it is a function, or method. The dataflow of a method is bound to its parent @protocol, which dataflow is also bound to the parent @protocol dataflow.</p><p>While <code>DataFlow</code> and <code>Context</code> may appear very similar, they are not the same: contexts are elements that keep track of declared slots, while the dataflow make use of the context to weave the elements togeher.</p></div></div><div id='d_yf' class='de'><h1>Class <span class='n'>IDataFlowOwner</span></h1><div class='re'></div><div class='ds'><p>DataFlow owners are elements that have their own dataflow. IContext are typical examples of elements that are dataflow owners</p></div></div><div id='d_Af' class='de'><h1>Method <span class='n'>addOperation</span></h1><div class='re'><code>addOperation( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Bf' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Cf' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Df' class='de'><h1>Method <span class='n'>getOperations</span></h1><div class='re'><code>getOperations( self )</code></div><div class='ds'><p>Returns the (ordered) list of operations that affected the slot. Operations usually constrain the dataflow abstract type, and exception/warnings/errors may be raised by the type system when a type constraint fails.</p></div></div><div id='d_Ef' class='de'><h1>Method <span class='n'>getOrigin</span></h1><div class='re'><code>getOrigin( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Ff' class='de'><h1>Method <span class='n'>getOriginalValue</span></h1><div class='re'><code>getOriginalValue( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_zf' class='de'><h1>Class <span class='n'>IDataFlowSlot</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Hf' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IMethod at 0x5bf960&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_If' class='de'><h1>Method <span class='n'>addOperation</span></h1><div class='re'><code>addOperation( self, operation )</code></div><div class='ds'><p>Adds the given operation as a child of this process.</p></div></div><div id='d_Jf' class='de'><h1>Method <span class='n'>endsWithTermination</span></h1><div class='re'><code>endsWithTermination( self )</code></div><div class='ds'><p>Returns true if this function ends with a termination operation. This is especially useful for back-ends which want to know if they have to insert an explicit <code>return</code> at the end (like Java).</p></div></div><div id='d_Kf' class='de'><h1>Method <span class='n'>getAbsoluteName</span></h1><div class='re'><code>getAbsoluteName( self )</code></div><div class='ds'><p>Returns the absolute name for this element</p></div></div><div id='d_Lf' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_Mf' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_Nf' class='de'><h1>Method <span class='n'>getArguments</span></h1><div class='re'><code>getArguments( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Of' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_Pf' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><p>Returns this @protocol name. It can be <code>None</code> if the @protocol is anonymous.</p></div></div><div id='d_Qf' class='de'><h1>Method <span class='n'>getOperations</span></h1><div class='re'><code>getOperations( self )</code></div><div class='ds'><p>Returns the list of operations in this process.</p></div></div><div id='d_Rf' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns the parent context for this context (if any)</p></div></div><div id='d_Sf' class='de'><h1>Method <span class='n'>getSlot</span></h1><div class='re'><code>getSlot( self, name )</code></div><div class='ds'><p>Returns the given evaluable bound to named slot.</p></div></div><div id='d_Tf' class='de'><h1>Method <span class='n'>getSlots</span></h1><div class='re'><code>getSlots( self )</code></div><div class='ds'><p>Returns (key, evaluable) pairs representing the slots within this context.</p></div></div><div id='d_Uf' class='de'><h1>Method <span class='n'>hasExplicitTermination</span></h1><div class='re'><code>hasExplicitTermination( self )</code></div><div class='ds'><p>Returns true if this function has an operation with a termination, otherwise return false.</p></div></div><div id='d_Vf' class='de'><h1>Method <span class='n'>hasSlot</span></h1><div class='re'><code>hasSlot( self, name )</code></div><div class='ds'><p>Tells if the context has a slot with the given name.</p></div></div><div id='d_Wf' class='de'><h1>Method <span class='n'>isAbstract</span></h1><div class='re'><code>isAbstract( self )</code></div><div class='ds'><p>Tells wether the given abstractable is abstract or not.</p></div></div><div id='d_Xf' class='de'><h1>Method <span class='n'>setAbstract</span></h1><div class='re'><code>setAbstract( self, isAbstract )</code></div><div class='ds'><p>Sets wether the given abstractable is abstract or not.</p></div></div><div id='d_Yf' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_Zf' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_ag' class='de'><h1>Method <span class='n'>setArguments</span></h1><div class='re'><code>setArguments( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_bg' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, context )</code></div><div class='ds'><p>Sets the parent context for this context.</p></div></div><div id='d_cg' class='de'><h1>Method <span class='n'>setSlot</span></h1><div class='re'><code>setSlot( self, name, evaluable )</code></div><div class='ds'><p>Binds the given evaluable to the named slot.</p></div></div><div id='d_Gf' class='de'><h1>Class <span class='n'>IDestructor</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_eg' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IValue at 0x5bf4b0&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_fg' class='de'><h1>Method <span class='n'>getItems</span></h1><div class='re'><code>getItems( self )</code></div><div class='ds'><p>Returns the items contained in this dict</p></div></div><div id='d_gg' class='de'><h1>Method <span class='n'>setValue</span></h1><div class='re'><code>setValue( self, key, value )</code></div><div class='ds'><p>Sets the value to be associated to the given key (which must be an evaluable).</p></div></div><div id='d_hg' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_ig' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_jg' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_kg' class='de'><h1>Method <span class='n'>getResultAbstractType</span></h1><div class='re'><code>getResultAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type of the result of the evaluation of this evaluable</p></div></div><div id='d_lg' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_mg' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_ng' class='de'><h1>Method <span class='n'>setResultAbstractType</span></h1><div class='re'><code>setResultAbstractType( self, abstractType )</code></div><div class='ds'><p>Sets the abstract type for this operation result. This is usually invoked in the typing phase.</p></div></div><div id='d_dg' class='de'><h1>Class <span class='n'>IDict</span></h1><div class='re'></div><div class='ds'><p>A dictionary is a binding of key to values. It may or may not be ordered, depending on the implementation/model semantics.</p></div></div><div id='d_pg' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IAnnotation at 0x5bf210&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_qg' class='de'><h1>Method <span class='n'>getContent</span></h1><div class='re'><code>getContent( self )</code></div><div class='ds'><p>Returns the content of this annotation.</p></div></div><div id='d_rg' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><p>Returns the name of this annotation.</p></div></div><div id='d_og' class='de'><h1>Class <span class='n'>IDocumentation</span></h1><div class='re'></div><div class='ds'><p>Documentation is often attached to various language elements. Documentation can be found in coments (as in Java), or be directly embedded as values (as in Python).</p></div></div><div id='d_tg' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_ug' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_vg' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_wg' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_xg' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_sg' class='de'><h1>Class <span class='n'>IElement</span></h1><div class='re'></div><div class='ds'><p>The core @protocol for every element.</p></div></div><div id='d_zg' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IOperation at 0x5bfa50&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Ag' class='de'><h1>Method <span class='n'>getCode</span></h1><div class='re'><code>getCode( self )</code></div><div class='ds'><p>Returns the embedded code string.</p></div></div><div id='d_Bg' class='de'><h1>Method <span class='n'>getLanguage</span></h1><div class='re'><code>getLanguage( self )</code></div><div class='ds'><p>Returns the language in which the emebedded code is written.</p></div></div><div id='d_Cg' class='de'><h1>Method <span class='n'>setCode</span></h1><div class='re'><code>setCode( self, code )</code></div><div class='ds'><p>Sets the code of this embed operation.</p></div></div><div id='d_Dg' class='de'><h1>Method <span class='n'>setLanguage</span></h1><div class='re'><code>setLanguage( self, language )</code></div><div class='ds'><p>Sets the language in which the emebedded code is written.</p></div></div><div id='d_Eg' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><p>Adds an argument to this operation. This should do checking of arguments (by expected internal type and number).</p></div></div><div id='d_Fg' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_Gg' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_Hg' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_Ig' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><p>Returns the ith arguments to this operation.</p></div></div><div id='d_Jg' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><p>Returns the arguments to this operation.</p></div></div><div id='d_Kg' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><p>Returns the <em>internal types</em> for this operations arguments. This is typically the list of interfaces or @protocols that the arguments must comply to.</p></div></div><div id='d_Lg' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_Mg' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_Ng' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><p>Sets the given argument of this operation, by argument index.</p></div></div><div id='d_Og' class='de'><h1>list</h1><div class='re'><code>[]</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='d_yg' class='de'><h1>Class <span class='n'>IEmbed</span></h1><div class='re'></div><div class='ds'><p>An embedded operation represents a bit of verbatim code written in a different language. This allows for embedding code written specifically in a target language (which may happen for optimizing stuff, for instance).</p></div></div><div id='d_Qg' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IEmbed at 0x5bff90&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Rg' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><p>Adds an argument to this operation. This should do checking of arguments (by expected internal type and number).</p></div></div><div id='d_Sg' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_Tg' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_Ug' class='de'><h1>Method <span class='n'>getCode</span></h1><div class='re'><code>getCode( self )</code></div><div class='ds'><p>Returns the embedded code string.</p></div></div><div id='d_Vg' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_Wg' class='de'><h1>Method <span class='n'>getLanguage</span></h1><div class='re'><code>getLanguage( self )</code></div><div class='ds'><p>Returns the language in which the emebedded code is written.</p></div></div><div id='d_Xg' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><p>Returns the ith arguments to this operation.</p></div></div><div id='d_Yg' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><p>Returns the arguments to this operation.</p></div></div><div id='d_Zg' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><p>Returns the <em>internal types</em> for this operations arguments. This is typically the list of interfaces or @protocols that the arguments must comply to.</p></div></div><div id='d_ah' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_bh' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_ch' class='de'><h1>Method <span class='n'>setCode</span></h1><div class='re'><code>setCode( self, code )</code></div><div class='ds'><p>Sets the code of this embed operation.</p></div></div><div id='d_dh' class='de'><h1>Method <span class='n'>setLanguage</span></h1><div class='re'><code>setLanguage( self, language )</code></div><div class='ds'><p>Sets the language in which the emebedded code is written.</p></div></div><div id='d_eh' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><p>Sets the given argument of this operation, by argument index.</p></div></div><div id='d_Pg' class='de'><h1>Class <span class='n'>IEmbedTemplate</span></h1><div class='re'></div><div class='ds'><p>The <code>EmbedTemplate</code> is embedded (<code>Embed</code>) that contains template expressions. It's up to the model writer to know how to expand the template to convert it to the target language.</p></div></div><div id='d_gh' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IOperation at 0x5bfa50&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_hh' class='de'><h1>Method <span class='n'>getEnd</span></h1><div class='re'><code>getEnd( self )</code></div><div class='ds'><p>Returns this enumeration end.</p></div></div><div id='d_ih' class='de'><h1>Method <span class='n'>getStart</span></h1><div class='re'><code>getStart( self )</code></div><div class='ds'><p>Returns this enumeration start.</p></div></div><div id='d_jh' class='de'><h1>Method <span class='n'>getStep</span></h1><div class='re'><code>getStep( self )</code></div><div class='ds'><p>Returns this enumeration step.</p></div></div><div id='d_kh' class='de'><h1>Method <span class='n'>setStep</span></h1><div class='re'><code>setStep( self, value )</code></div><div class='ds'><p>Sets this enumeration step</p></div></div><div id='d_lh' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><p>Adds an argument to this operation. This should do checking of arguments (by expected internal type and number).</p></div></div><div id='d_mh' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_nh' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_oh' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_ph' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><p>Returns the ith arguments to this operation.</p></div></div><div id='d_qh' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><p>Returns the arguments to this operation.</p></div></div><div id='d_rh' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><p>Returns the <em>internal types</em> for this operations arguments. This is typically the list of interfaces or @protocols that the arguments must comply to.</p></div></div><div id='d_sh' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_th' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_uh' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><p>Sets the given argument of this operation, by argument index.</p></div></div><div id='d_vh' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.IEvaluable at 0x5bf3f0&gt;, &lt;class lambdafactory.interfaces.IEvaluable at 0x5bf3f0&gt;, &lt;class lambdafactory.interfaces.IEvaluable at 0x5bf3f0&gt;]</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='d_fh' class='de'><h1>Class <span class='n'>IEnumeration</span></h1><div class='re'></div><div class='ds'><p>An enumeration produces values between a start and an end value, with the given step.</p></div></div><div id='d_xh' class='de'><h1>Method <span class='n'>getResultAbstractType</span></h1><div class='re'><code>getResultAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type of the result of the evaluation of this evaluable</p></div></div><div id='d_yh' class='de'><h1>Method <span class='n'>setResultAbstractType</span></h1><div class='re'><code>setResultAbstractType( self, abstractType )</code></div><div class='ds'><p>Sets the abstract type for this operation result. This is usually invoked in the typing phase.</p></div></div><div id='d_wh' class='de'><h1>Class <span class='n'>IEvaluable</span></h1><div class='re'></div><div class='ds'><p>An evaluable is an element that can produce a value. Evaluable elements then have associated type information.</p></div></div><div id='d_Ah' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IOperation at 0x5bfa50&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Bh' class='de'><h1>Method <span class='n'>getEvaluable</span></h1><div class='re'><code>getEvaluable( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Ch' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><p>Adds an argument to this operation. This should do checking of arguments (by expected internal type and number).</p></div></div><div id='d_Dh' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_Eh' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_Fh' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_Gh' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><p>Returns the ith arguments to this operation.</p></div></div><div id='d_Hh' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><p>Returns the arguments to this operation.</p></div></div><div id='d_Ih' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><p>Returns the <em>internal types</em> for this operations arguments. This is typically the list of interfaces or @protocols that the arguments must comply to.</p></div></div><div id='d_Jh' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_Kh' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_Lh' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><p>Sets the given argument of this operation, by argument index.</p></div></div><div id='d_Mh' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.IEvaluable at 0x5bf3f0&gt;, &lt;class lambdafactory.interfaces.IEvaluable at 0x5bf3f0&gt;]</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='d_Nh' class='de'><h1>list</h1><div class='re'><code>['Evaluable']</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='d_zh' class='de'><h1>Class <span class='n'>IEvaluation</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Ph' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IInterruption at 0x5bfed0&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Qh' class='de'><h1>Method <span class='n'>getValue</span></h1><div class='re'><code>getValue( self )</code></div><div class='ds'><p>Returns the termination return evaluable.</p></div></div><div id='d_Rh' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><p>Adds an argument to this operation. This should do checking of arguments (by expected internal type and number).</p></div></div><div id='d_Sh' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_Th' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_Uh' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_Vh' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><p>Returns the ith arguments to this operation.</p></div></div><div id='d_Wh' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><p>Returns the arguments to this operation.</p></div></div><div id='d_Xh' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><p>Returns the <em>internal types</em> for this operations arguments. This is typically the list of interfaces or @protocols that the arguments must comply to.</p></div></div><div id='d_Yh' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_Zh' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_ai' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><p>Sets the given argument of this operation, by argument index.</p></div></div><div id='d_bi' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.IEvaluable at 0x5bf3f0&gt;]</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='d_Oh' class='de'><h1>Class <span class='n'>IExcept</span></h1><div class='re'></div><div class='ds'><p>An interruption that raises some value</p></div></div><div id='d_di' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IClosure at 0x5bf900&gt;, &lt;class lambdafactory.interfaces.IReferencable at 0x5bf3c0&gt;, &lt;class lambdafactory.interfaces.IAbstractable at 0x5bf480&gt;)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_ei' class='de'><h1>Method <span class='n'>endsWithTermination</span></h1><div class='re'><code>endsWithTermination( self )</code></div><div class='ds'><p>Returns true if this function ends with a termination operation. This is especially useful for back-ends which want to know if they have to insert an explicit <code>return</code> at the end (like Java).</p></div></div><div id='d_fi' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><p>Returns this @protocol name. It can be <code>None</code> if the @protocol is anonymous.</p></div></div><div id='d_gi' class='de'><h1>Method <span class='n'>hasExplicitTermination</span></h1><div class='re'><code>hasExplicitTermination( self )</code></div><div class='ds'><p>Returns true if this function has an operation with a termination, otherwise return false.</p></div></div><div id='d_hi' class='de'><h1>Method <span class='n'>addOperation</span></h1><div class='re'><code>addOperation( self, operation )</code></div><div class='ds'><p>Adds the given operation as a child of this process.</p></div></div><div id='d_ii' class='de'><h1>Method <span class='n'>getAbsoluteName</span></h1><div class='re'><code>getAbsoluteName( self )</code></div><div class='ds'><p>Returns the absolute name for this element</p></div></div><div id='d_ji' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_ki' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_li' class='de'><h1>Method <span class='n'>getArguments</span></h1><div class='re'><code>getArguments( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_mi' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_ni' class='de'><h1>Method <span class='n'>getOperations</span></h1><div class='re'><code>getOperations( self )</code></div><div class='ds'><p>Returns the list of operations in this process.</p></div></div><div id='d_oi' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns the parent context for this context (if any)</p></div></div><div id='d_pi' class='de'><h1>Method <span class='n'>getSlot</span></h1><div class='re'><code>getSlot( self, name )</code></div><div class='ds'><p>Returns the given evaluable bound to named slot.</p></div></div><div id='d_qi' class='de'><h1>Method <span class='n'>getSlots</span></h1><div class='re'><code>getSlots( self )</code></div><div class='ds'><p>Returns (key, evaluable) pairs representing the slots within this context.</p></div></div><div id='d_ri' class='de'><h1>Method <span class='n'>hasSlot</span></h1><div class='re'><code>hasSlot( self, name )</code></div><div class='ds'><p>Tells if the context has a slot with the given name.</p></div></div><div id='d_si' class='de'><h1>Method <span class='n'>isAbstract</span></h1><div class='re'><code>isAbstract( self )</code></div><div class='ds'><p>Tells wether the given abstractable is abstract or not.</p></div></div><div id='d_ti' class='de'><h1>Method <span class='n'>setAbstract</span></h1><div class='re'><code>setAbstract( self, isAbstract )</code></div><div class='ds'><p>Sets wether the given abstractable is abstract or not.</p></div></div><div id='d_ui' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_vi' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_wi' class='de'><h1>Method <span class='n'>setArguments</span></h1><div class='re'><code>setArguments( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_xi' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, context )</code></div><div class='ds'><p>Sets the parent context for this context.</p></div></div><div id='d_yi' class='de'><h1>Method <span class='n'>setSlot</span></h1><div class='re'><code>setSlot( self, name, evaluable )</code></div><div class='ds'><p>Binds the given evaluable to the named slot.</p></div></div><div id='d_ci' class='de'><h1>Class <span class='n'>IFunction</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Ai' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IProcess at 0x5bf870&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Bi' class='de'><h1>Method <span class='n'>addOperation</span></h1><div class='re'><code>addOperation( self, operation )</code></div><div class='ds'><p>Adds the given operation as a child of this process.</p></div></div><div id='d_Ci' class='de'><h1>Method <span class='n'>getOperations</span></h1><div class='re'><code>getOperations( self )</code></div><div class='ds'><p>Returns the list of operations in this process.</p></div></div><div id='d_zi' class='de'><h1>Class <span class='n'>IGroup</span></h1><div class='re'></div><div class='ds'><p>A block is a group of operations that share a common aspect. Groups are more likely to be used by program passes to further structure the program.</p><p>Groups should generally not have their own context, as opposed to blocks which generally have a context of their own.</p></div></div><div id='d_Ei' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IImportOperation at 0x5bfa80&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Fi' class='de'><h1>Method <span class='n'>getAlias</span></h1><div class='re'><code>getAlias( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Gi' class='de'><h1>Method <span class='n'>getImportedModuleName</span></h1><div class='re'><code>getImportedModuleName( self )</code></div><div class='ds'><p>Returns the list of names representing the modules to load</p></div></div><div id='d_Hi' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><p>Adds an argument to this operation. This should do checking of arguments (by expected internal type and number).</p></div></div><div id='d_Ii' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_Ji' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_Ki' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_Li' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><p>Returns the ith arguments to this operation.</p></div></div><div id='d_Mi' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><p>Returns the arguments to this operation.</p></div></div><div id='d_Ni' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><p>Returns the <em>internal types</em> for this operations arguments. This is typically the list of interfaces or @protocols that the arguments must comply to.</p></div></div><div id='d_Oi' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_Pi' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_Qi' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><p>Sets the given argument of this operation, by argument index.</p></div></div><div id='d_Ri' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.IEvaluable at 0x5bf3f0&gt;, &lt;class lambdafactory.interfaces.IEvaluable at 0x5bf3f0&gt;]</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='d_Si' class='de'><h1>list</h1><div class='re'><code>['ImportedModuleName', 'Alias']</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='d_Di' class='de'><h1>Class <span class='n'>IImportModuleOperation</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Ui' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IImportOperation at 0x5bfa80&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Vi' class='de'><h1>Method <span class='n'>getImportedModuleNames</span></h1><div class='re'><code>getImportedModuleNames( self )</code></div><div class='ds'><p>Returns the list of names representing the modules to load</p></div></div><div id='d_Wi' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><p>Adds an argument to this operation. This should do checking of arguments (by expected internal type and number).</p></div></div><div id='d_Xi' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_Yi' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_Zi' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_aj' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><p>Returns the ith arguments to this operation.</p></div></div><div id='d_bj' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><p>Returns the arguments to this operation.</p></div></div><div id='d_cj' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><p>Returns the <em>internal types</em> for this operations arguments. This is typically the list of interfaces or @protocols that the arguments must comply to.</p></div></div><div id='d_dj' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_ej' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_fj' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><p>Sets the given argument of this operation, by argument index.</p></div></div><div id='d_gj' class='de'><h1>list</h1><div class='re'><code>[[&lt;class lambdafactory.interfaces.IEvaluable at 0x5bf3f0&gt;]]</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='d_hj' class='de'><h1>list</h1><div class='re'><code>['ImportedModuleNames']</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='d_Ti' class='de'><h1>Class <span class='n'>IImportModulesOperation</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_jj' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IOperation at 0x5bfa50&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_kj' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><p>Adds an argument to this operation. This should do checking of arguments (by expected internal type and number).</p></div></div><div id='d_lj' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_mj' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_nj' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_oj' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><p>Returns the ith arguments to this operation.</p></div></div><div id='d_pj' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><p>Returns the arguments to this operation.</p></div></div><div id='d_qj' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><p>Returns the <em>internal types</em> for this operations arguments. This is typically the list of interfaces or @protocols that the arguments must comply to.</p></div></div><div id='d_rj' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_sj' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_tj' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><p>Sets the given argument of this operation, by argument index.</p></div></div><div id='d_ij' class='de'><h1>Class <span class='n'>IImportOperation</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_vj' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IImportOperation at 0x5bfa80&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_wj' class='de'><h1>Method <span class='n'>getAlias</span></h1><div class='re'><code>getAlias( self )</code></div><div class='ds'><p>Returns the (optional) alias which will allow to reference the element.</p></div></div><div id='d_xj' class='de'><h1>Method <span class='n'>getImportOrigin</span></h1><div class='re'><code>getImportOrigin( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_yj' class='de'><h1>Method <span class='n'>getImportedElement</span></h1><div class='re'><code>getImportedElement( self )</code></div><div class='ds'><p>Returns a reference or a resolution that will allow to get the imported element.</p></div></div><div id='d_zj' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><p>Adds an argument to this operation. This should do checking of arguments (by expected internal type and number).</p></div></div><div id='d_Aj' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_Bj' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_Cj' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_Dj' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><p>Returns the ith arguments to this operation.</p></div></div><div id='d_Ej' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><p>Returns the arguments to this operation.</p></div></div><div id='d_Fj' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><p>Returns the <em>internal types</em> for this operations arguments. This is typically the list of interfaces or @protocols that the arguments must comply to.</p></div></div><div id='d_Gj' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_Hj' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_Ij' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><p>Sets the given argument of this operation, by argument index.</p></div></div><div id='d_Jj' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.IEvaluable at 0x5bf3f0&gt;, &lt;class lambdafactory.interfaces.IEvaluable at 0x5bf3f0&gt;, &lt;class lambdafactory.interfaces.IEvaluable at 0x5bf3f0&gt;]</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='d_Kj' class='de'><h1>list</h1><div class='re'><code>['ImportedElement', 'ImportOrigin', 'Alias']</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='d_uj' class='de'><h1>Class <span class='n'>IImportSymbolOperation</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Mj' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IImportOperation at 0x5bfa80&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Nj' class='de'><h1>Method <span class='n'>getImportOrigin</span></h1><div class='re'><code>getImportOrigin( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Oj' class='de'><h1>Method <span class='n'>getImportedElements</span></h1><div class='re'><code>getImportedElements( self )</code></div><div class='ds'><p>Returns a reference or a resolution that will allow to get the imported element.</p></div></div><div id='d_Pj' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><p>Adds an argument to this operation. This should do checking of arguments (by expected internal type and number).</p></div></div><div id='d_Qj' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_Rj' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_Sj' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_Tj' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><p>Returns the ith arguments to this operation.</p></div></div><div id='d_Uj' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><p>Returns the arguments to this operation.</p></div></div><div id='d_Vj' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><p>Returns the <em>internal types</em> for this operations arguments. This is typically the list of interfaces or @protocols that the arguments must comply to.</p></div></div><div id='d_Wj' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_Xj' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_Yj' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><p>Sets the given argument of this operation, by argument index.</p></div></div><div id='d_Zj' class='de'><h1>list</h1><div class='re'><code>[[&lt;class lambdafactory.interfaces.IEvaluable at 0x5bf3f0&gt;], &lt;class lambdafactory.interfaces.IEvaluable at 0x5bf3f0&gt;]</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='d_ak' class='de'><h1>list</h1><div class='re'><code>['ImportedElements', 'ImportOrigin']</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='d_Lj' class='de'><h1>Class <span class='n'>IImportSymbolsOperation</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_ck' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IMethod at 0x5bf960&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_dk' class='de'><h1>Method <span class='n'>addOperation</span></h1><div class='re'><code>addOperation( self, operation )</code></div><div class='ds'><p>Adds the given operation as a child of this process.</p></div></div><div id='d_ek' class='de'><h1>Method <span class='n'>endsWithTermination</span></h1><div class='re'><code>endsWithTermination( self )</code></div><div class='ds'><p>Returns true if this function ends with a termination operation. This is especially useful for back-ends which want to know if they have to insert an explicit <code>return</code> at the end (like Java).</p></div></div><div id='d_fk' class='de'><h1>Method <span class='n'>getAbsoluteName</span></h1><div class='re'><code>getAbsoluteName( self )</code></div><div class='ds'><p>Returns the absolute name for this element</p></div></div><div id='d_gk' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_hk' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_ik' class='de'><h1>Method <span class='n'>getArguments</span></h1><div class='re'><code>getArguments( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_jk' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_kk' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><p>Returns this @protocol name. It can be <code>None</code> if the @protocol is anonymous.</p></div></div><div id='d_lk' class='de'><h1>Method <span class='n'>getOperations</span></h1><div class='re'><code>getOperations( self )</code></div><div class='ds'><p>Returns the list of operations in this process.</p></div></div><div id='d_mk' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns the parent context for this context (if any)</p></div></div><div id='d_nk' class='de'><h1>Method <span class='n'>getSlot</span></h1><div class='re'><code>getSlot( self, name )</code></div><div class='ds'><p>Returns the given evaluable bound to named slot.</p></div></div><div id='d_ok' class='de'><h1>Method <span class='n'>getSlots</span></h1><div class='re'><code>getSlots( self )</code></div><div class='ds'><p>Returns (key, evaluable) pairs representing the slots within this context.</p></div></div><div id='d_pk' class='de'><h1>Method <span class='n'>hasExplicitTermination</span></h1><div class='re'><code>hasExplicitTermination( self )</code></div><div class='ds'><p>Returns true if this function has an operation with a termination, otherwise return false.</p></div></div><div id='d_qk' class='de'><h1>Method <span class='n'>hasSlot</span></h1><div class='re'><code>hasSlot( self, name )</code></div><div class='ds'><p>Tells if the context has a slot with the given name.</p></div></div><div id='d_rk' class='de'><h1>Method <span class='n'>isAbstract</span></h1><div class='re'><code>isAbstract( self )</code></div><div class='ds'><p>Tells wether the given abstractable is abstract or not.</p></div></div><div id='d_sk' class='de'><h1>Method <span class='n'>setAbstract</span></h1><div class='re'><code>setAbstract( self, isAbstract )</code></div><div class='ds'><p>Sets wether the given abstractable is abstract or not.</p></div></div><div id='d_tk' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_uk' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_vk' class='de'><h1>Method <span class='n'>setArguments</span></h1><div class='re'><code>setArguments( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_wk' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, context )</code></div><div class='ds'><p>Sets the parent context for this context.</p></div></div><div id='d_xk' class='de'><h1>Method <span class='n'>setSlot</span></h1><div class='re'><code>setSlot( self, name, evaluable )</code></div><div class='ds'><p>Binds the given evaluable to the named slot.</p></div></div><div id='d_bk' class='de'><h1>Class <span class='n'>IInstanceMethod</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_yk' class='de'><h1>Class <span class='n'>IInstanciable</span></h1><div class='re'></div><div class='ds'><p>Instanciable is a property of some elements that allows them to be instanciated. Conceptually, an instanciation could be considered as a specific kind of invocation.</p></div></div><div id='d_Ak' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IOperation at 0x5bfa50&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Bk' class='de'><h1>Method <span class='n'>getArguments</span></h1><div class='re'><code>getArguments( self )</code></div><div class='ds'><p>Returns evaluable arguments.</p></div></div><div id='d_Ck' class='de'><h1>Method <span class='n'>getInstanciable</span></h1><div class='re'><code>getInstanciable( self )</code></div><div class='ds'><p>Returns the instanciable used in this operation.</p></div></div><div id='d_Dk' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><p>Adds an argument to this operation. This should do checking of arguments (by expected internal type and number).</p></div></div><div id='d_Ek' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_Fk' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_Gk' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_Hk' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><p>Returns the ith arguments to this operation.</p></div></div><div id='d_Ik' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><p>Returns the arguments to this operation.</p></div></div><div id='d_Jk' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><p>Returns the <em>internal types</em> for this operations arguments. This is typically the list of interfaces or @protocols that the arguments must comply to.</p></div></div><div id='d_Kk' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_Lk' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_Mk' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><p>Sets the given argument of this operation, by argument index.</p></div></div><div id='d_Nk' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.IEvaluable at 0x5bf3f0&gt;, [&lt;class lambdafactory.interfaces.IEvaluable at 0x5bf3f0&gt;]]</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='d_zk' class='de'><h1>Class <span class='n'>IInstanciation</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Pk' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IOperation at 0x5bfa50&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Qk' class='de'><h1>Method <span class='n'>getConclusion</span></h1><div class='re'><code>getConclusion( self )</code></div><div class='ds'><p>Returns the process that will conclude the interception (finally)</p></div></div><div id='d_Rk' class='de'><h1>Method <span class='n'>getIntercept</span></h1><div class='re'><code>getIntercept( self )</code></div><div class='ds'><p>Returns the process that will do the interception</p></div></div><div id='d_Sk' class='de'><h1>Method <span class='n'>getProcess</span></h1><div class='re'><code>getProcess( self )</code></div><div class='ds'><p>Returns the process that we will intercept interruptions from.</p></div></div><div id='d_Tk' class='de'><h1>Method <span class='n'>setConclusion</span></h1><div class='re'><code>setConclusion( self, process )</code></div><div class='ds'><p>Sets the process that will conclude the interception (finally)</p></div></div><div id='d_Uk' class='de'><h1>Method <span class='n'>setIntercept</span></h1><div class='re'><code>setIntercept( self, process )</code></div><div class='ds'><p>Sets the process that will do the interception</p></div></div><div id='d_Vk' class='de'><h1>Method <span class='n'>setProcess</span></h1><div class='re'><code>setProcess( self, process )</code></div><div class='ds'><p>Sets the process from which interruptions will be intercepted.</p></div></div><div id='d_Wk' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><p>Adds an argument to this operation. This should do checking of arguments (by expected internal type and number).</p></div></div><div id='d_Xk' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_Yk' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_Zk' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_al' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><p>Returns the ith arguments to this operation.</p></div></div><div id='d_bl' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><p>Returns the arguments to this operation.</p></div></div><div id='d_cl' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><p>Returns the <em>internal types</em> for this operations arguments. This is typically the list of interfaces or @protocols that the arguments must comply to.</p></div></div><div id='d_dl' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_el' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_fl' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><p>Sets the given argument of this operation, by argument index.</p></div></div><div id='d_gl' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.IProcess at 0x5bf870&gt;, &lt;class lambdafactory.interfaces.IProcess at 0x5bf870&gt;, &lt;class lambdafactory.interfaces.IProcess at 0x5bf870&gt;]</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='d_Ok' class='de'><h1>Class <span class='n'>IInterception</span></h1><div class='re'></div><div class='ds'><p>An interception allows to intercept interruptions that propagage from an enclosed process to parent contexts.</p></div></div><div id='d_il' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IAbstractClass at 0x5bf7b0&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_jl' class='de'><h1>Method <span class='n'>getAbsoluteName</span></h1><div class='re'><code>getAbsoluteName( self )</code></div><div class='ds'><p>Returns the absolute name for this element</p></div></div><div id='d_kl' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_ll' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_ml' class='de'><h1>Method <span class='n'>getAttributes</span></h1><div class='re'><code>getAttributes( self )</code></div><div class='ds'><p>Returns the (non-class) attributes defined within this class.</p></div></div><div id='d_nl' class='de'><h1>Method <span class='n'>getClassAttributes</span></h1><div class='re'><code>getClassAttributes( self )</code></div><div class='ds'><p>Returns the class attributes defined within this class.</p></div></div><div id='d_ol' class='de'><h1>Method <span class='n'>getClassMethods</span></h1><div class='re'><code>getClassMethods( self )</code></div><div class='ds'><p>Returns the class method defined within this class.</p></div></div><div id='d_pl' class='de'><h1>Method <span class='n'>getConstructors</span></h1><div class='re'><code>getConstructors( self )</code></div><div class='ds'><p>Returns the constructors for this class</p></div></div><div id='d_ql' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_rl' class='de'><h1>Method <span class='n'>getDestructors</span></h1><div class='re'><code>getDestructors( self )</code></div><div class='ds'><p>Returns the destructors for this class</p></div></div><div id='d_sl' class='de'><h1>Method <span class='n'>getInstanceMethods</span></h1><div class='re'><code>getInstanceMethods( self )</code></div><div class='ds'><p>Returns the instance methods defined within this class.</p></div></div><div id='d_tl' class='de'><h1>Method <span class='n'>getMethods</span></h1><div class='re'><code>getMethods( self )</code></div><div class='ds'><p>Returns the methods defined within this class.</p></div></div><div id='d_ul' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><p>Returns this class name. It can be <code>None</code> if the class is anonymous.</p></div></div><div id='d_vl' class='de'><h1>Method <span class='n'>getOperations</span></h1><div class='re'><code>getOperations( self )</code></div><div class='ds'><p>Returns the operations (methods and class methods) defined within this class.</p></div></div><div id='d_wl' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns the parent context for this context (if any)</p></div></div><div id='d_xl' class='de'><h1>Method <span class='n'>getParentClasses</span></h1><div class='re'><code>getParentClasses( self )</code></div><div class='ds'><p>Returns the list of inherited classes references.</p></div></div><div id='d_yl' class='de'><h1>Method <span class='n'>getSlot</span></h1><div class='re'><code>getSlot( self, name )</code></div><div class='ds'><p>Returns the given evaluable bound to named slot.</p></div></div><div id='d_zl' class='de'><h1>Method <span class='n'>getSlots</span></h1><div class='re'><code>getSlots( self )</code></div><div class='ds'><p>Returns (key, evaluable) pairs representing the slots within this context.</p></div></div><div id='d_Al' class='de'><h1>Method <span class='n'>hasSlot</span></h1><div class='re'><code>hasSlot( self, name )</code></div><div class='ds'><p>Tells if the context has a slot with the given name.</p></div></div><div id='d_Bl' class='de'><h1>Method <span class='n'>isAbstract</span></h1><div class='re'><code>isAbstract( self )</code></div><div class='ds'><p>Tells wether the given abstractable is abstract or not.</p></div></div><div id='d_Cl' class='de'><h1>Method <span class='n'>setAbstract</span></h1><div class='re'><code>setAbstract( self, isAbstract )</code></div><div class='ds'><p>Sets wether the given abstractable is abstract or not.</p></div></div><div id='d_Dl' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_El' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_Fl' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, context )</code></div><div class='ds'><p>Sets the parent context for this context.</p></div></div><div id='d_Gl' class='de'><h1>Method <span class='n'>setParentClasses</span></h1><div class='re'><code>setParentClasses( self )</code></div><div class='ds'><p>gives the list of parent classes that will</p></div></div><div id='d_Hl' class='de'><h1>Method <span class='n'>setSlot</span></h1><div class='re'><code>setSlot( self, name, evaluable )</code></div><div class='ds'><p>Binds the given evaluable to the named slot.</p></div></div><div id='d_hl' class='de'><h1>Class <span class='n'>IInterface</span></h1><div class='re'></div><div class='ds'><p>An interface is an abstract @protocol that only has abstract elements.</p></div></div><div id='d_Jl' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IOperation at 0x5bfa50&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Kl' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><p>Adds an argument to this operation. This should do checking of arguments (by expected internal type and number).</p></div></div><div id='d_Ll' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_Ml' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_Nl' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_Ol' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><p>Returns the ith arguments to this operation.</p></div></div><div id='d_Pl' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><p>Returns the arguments to this operation.</p></div></div><div id='d_Ql' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><p>Returns the <em>internal types</em> for this operations arguments. This is typically the list of interfaces or @protocols that the arguments must comply to.</p></div></div><div id='d_Rl' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_Sl' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_Tl' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><p>Sets the given argument of this operation, by argument index.</p></div></div><div id='d_Il' class='de'><h1>Class <span class='n'>IInterruption</span></h1><div class='re'></div><div class='ds'><p>An interruption can be be used to halt the process.</p></div></div><div id='d_Vl' class='de'><h1>Method <span class='n'>getArguments</span></h1><div class='re'><code>getArguments( self )</code></div><div class='ds'><p>Returns a list of arguments (which are names associated with optional type information.</p></div></div><div id='d_Ul' class='de'><h1>Class <span class='n'>IInvocable</span></h1><div class='re'></div><div class='ds'><p>An invocable can be used in an invocation operation.</p></div></div><div id='d_Xl' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IOperation at 0x5bfa50&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Yl' class='de'><h1>Method <span class='n'>getArguments</span></h1><div class='re'><code>getArguments( self )</code></div><div class='ds'><p>Returns evaluable arguments.</p></div></div><div id='d_Zl' class='de'><h1>Method <span class='n'>getTarget</span></h1><div class='re'><code>getTarget( self )</code></div><div class='ds'><p>Returns the invocation target reference.</p></div></div><div id='d_am' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><p>Adds an argument to this operation. This should do checking of arguments (by expected internal type and number).</p></div></div><div id='d_bm' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_cm' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_dm' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_em' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><p>Returns the ith arguments to this operation.</p></div></div><div id='d_fm' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><p>Returns the arguments to this operation.</p></div></div><div id='d_gm' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><p>Returns the <em>internal types</em> for this operations arguments. This is typically the list of interfaces or @protocols that the arguments must comply to.</p></div></div><div id='d_hm' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_im' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_jm' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><p>Sets the given argument of this operation, by argument index.</p></div></div><div id='d_km' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.IEvaluable at 0x5bf3f0&gt;, [&lt;class lambdafactory.interfaces.IEvaluable at 0x5bf3f0&gt;]]</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='d_Wl' class='de'><h1>Class <span class='n'>IInvocation</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_mm' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IOperation at 0x5bfa50&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_nm' class='de'><h1>Method <span class='n'>getClosure</span></h1><div class='re'><code>getClosure( self )</code></div><div class='ds'><p>Returns the closure that will be applied to the iterator.</p></div></div><div id='d_om' class='de'><h1>Method <span class='n'>getIterator</span></h1><div class='re'><code>getIterator( self )</code></div><div class='ds'><p>Returns this iteration iterator.</p></div></div><div id='d_pm' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><p>Adds an argument to this operation. This should do checking of arguments (by expected internal type and number).</p></div></div><div id='d_qm' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_rm' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_sm' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_tm' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><p>Returns the ith arguments to this operation.</p></div></div><div id='d_um' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><p>Returns the arguments to this operation.</p></div></div><div id='d_vm' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><p>Returns the <em>internal types</em> for this operations arguments. This is typically the list of interfaces or @protocols that the arguments must comply to.</p></div></div><div id='d_wm' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_xm' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_ym' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><p>Sets the given argument of this operation, by argument index.</p></div></div><div id='d_zm' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.IEvaluable at 0x5bf3f0&gt;, &lt;class lambdafactory.interfaces.IEvaluable at 0x5bf3f0&gt;]</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='d_lm' class='de'><h1>Class <span class='n'>IIteration</span></h1><div class='re'></div><div class='ds'><p>An iteration is the multiple application of a process given a set of values produced by an iterator.</p></div></div><div id='d_Bm' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IValue at 0x5bf4b0&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Cm' class='de'><h1>Method <span class='n'>addValue</span></h1><div class='re'><code>addValue( self, value )</code></div><div class='ds'><p>Adds a value to this list.</p></div></div><div id='d_Dm' class='de'><h1>Method <span class='n'>getValues</span></h1><div class='re'><code>getValues( self )</code></div><div class='ds'><p>Returns the values within this list.</p></div></div><div id='d_Em' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_Fm' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_Gm' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_Hm' class='de'><h1>Method <span class='n'>getResultAbstractType</span></h1><div class='re'><code>getResultAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type of the result of the evaluation of this evaluable</p></div></div><div id='d_Im' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_Jm' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_Km' class='de'><h1>Method <span class='n'>setResultAbstractType</span></h1><div class='re'><code>setResultAbstractType( self, abstractType )</code></div><div class='ds'><p>Sets the abstract type for this operation result. This is usually invoked in the typing phase.</p></div></div><div id='d_Am' class='de'><h1>Class <span class='n'>IList</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Mm' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IValue at 0x5bf4b0&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Nm' class='de'><h1>Method <span class='n'>getActualValue</span></h1><div class='re'><code>getActualValue( self )</code></div><div class='ds'><p>Returns the (implementation language) value for this literal</p></div></div><div id='d_Om' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_Pm' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_Qm' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_Rm' class='de'><h1>Method <span class='n'>getResultAbstractType</span></h1><div class='re'><code>getResultAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type of the result of the evaluation of this evaluable</p></div></div><div id='d_Sm' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_Tm' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_Um' class='de'><h1>Method <span class='n'>setResultAbstractType</span></h1><div class='re'><code>setResultAbstractType( self, abstractType )</code></div><div class='ds'><p>Sets the abstract type for this operation result. This is usually invoked in the typing phase.</p></div></div><div id='d_Lm' class='de'><h1>Class <span class='n'>ILiteral</span></h1><div class='re'></div><div class='ds'><p>A literal is a value that does not need a context to be evaluated. The evaluation is direct.</p></div></div><div id='d_Wm' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IMatchOperation at 0x5bfd50&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Xm' class='de'><h1>Method <span class='n'>getExpression</span></h1><div class='re'><code>getExpression( self )</code></div><div class='ds'><p>Returns the process that will be executed if the rule matches.</p></div></div><div id='d_Ym' class='de'><h1>Method <span class='n'>setExpression</span></h1><div class='re'><code>setExpression( self, v )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Zm' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><p>Adds an argument to this operation. This should do checking of arguments (by expected internal type and number).</p></div></div><div id='d_an' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_bn' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_cn' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_dn' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><p>Returns the ith arguments to this operation.</p></div></div><div id='d_en' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><p>Returns the arguments to this operation.</p></div></div><div id='d_fn' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><p>Returns the <em>internal types</em> for this operations arguments. This is typically the list of interfaces or @protocols that the arguments must comply to.</p></div></div><div id='d_gn' class='de'><h1>Method <span class='n'>getPredicate</span></h1><div class='re'><code>getPredicate( self )</code></div><div class='ds'><p>Returns the evaluable that acts as a predicate for this operation.</p></div></div><div id='d_hn' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_in' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_jn' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><p>Sets the given argument of this operation, by argument index.</p></div></div><div id='d_kn' class='de'><h1>Method <span class='n'>setPredicate</span></h1><div class='re'><code>setPredicate( self, v )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_ln' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.IEvaluable at 0x5bf3f0&gt;, &lt;class lambdafactory.interfaces.IEvaluable at 0x5bf3f0&gt;]</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='d_Vm' class='de'><h1>Class <span class='n'>IMatchExpressionOperation</span></h1><div class='re'></div><div class='ds'><p>A match expression is a predicate that is associated to an expression. This is typically used in conditional expressions like in C:</p><pre>int a = ( b==2 ? 1 : 2 )</pre></div></div><div id='d_nn' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IOperation at 0x5bfa50&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_on' class='de'><h1>Method <span class='n'>getPredicate</span></h1><div class='re'><code>getPredicate( self )</code></div><div class='ds'><p>Returns the evaluable that acts as a predicate for this operation.</p></div></div><div id='d_pn' class='de'><h1>Method <span class='n'>setPredicate</span></h1><div class='re'><code>setPredicate( self, v )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_qn' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><p>Adds an argument to this operation. This should do checking of arguments (by expected internal type and number).</p></div></div><div id='d_rn' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_sn' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_tn' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_un' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><p>Returns the ith arguments to this operation.</p></div></div><div id='d_vn' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><p>Returns the arguments to this operation.</p></div></div><div id='d_wn' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><p>Returns the <em>internal types</em> for this operations arguments. This is typically the list of interfaces or @protocols that the arguments must comply to.</p></div></div><div id='d_xn' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_yn' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_zn' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><p>Sets the given argument of this operation, by argument index.</p></div></div><div id='d_mn' class='de'><h1>Class <span class='n'>IMatchOperation</span></h1><div class='re'></div><div class='ds'><p>A match operation is the binding of an expression and a process.</p></div></div><div id='d_Bn' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IMatchOperation at 0x5bfd50&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Cn' class='de'><h1>Method <span class='n'>getProcess</span></h1><div class='re'><code>getProcess( self )</code></div><div class='ds'><p>Returns the process that will be executed if the rule matches.</p></div></div><div id='d_Dn' class='de'><h1>Method <span class='n'>setProcess</span></h1><div class='re'><code>setProcess( self, v )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_En' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><p>Adds an argument to this operation. This should do checking of arguments (by expected internal type and number).</p></div></div><div id='d_Fn' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_Gn' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_Hn' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_In' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><p>Returns the ith arguments to this operation.</p></div></div><div id='d_Jn' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><p>Returns the arguments to this operation.</p></div></div><div id='d_Kn' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><p>Returns the <em>internal types</em> for this operations arguments. This is typically the list of interfaces or @protocols that the arguments must comply to.</p></div></div><div id='d_Ln' class='de'><h1>Method <span class='n'>getPredicate</span></h1><div class='re'><code>getPredicate( self )</code></div><div class='ds'><p>Returns the evaluable that acts as a predicate for this operation.</p></div></div><div id='d_Mn' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_Nn' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_On' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><p>Sets the given argument of this operation, by argument index.</p></div></div><div id='d_Pn' class='de'><h1>Method <span class='n'>setPredicate</span></h1><div class='re'><code>setPredicate( self, v )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Qn' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.IEvaluable at 0x5bf3f0&gt;, &lt;class lambdafactory.interfaces.IProcess at 0x5bf870&gt;]</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='d_An' class='de'><h1>Class <span class='n'>IMatchProcessOperation</span></h1><div class='re'></div><div class='ds'><p>A match process is a predicate associate to a process, which is typically used for implementing <code>if</code>, <code>else</code>, etc.</p></div></div><div id='d_Sn' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IFunction at 0x5bf930&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Tn' class='de'><h1>Method <span class='n'>addOperation</span></h1><div class='re'><code>addOperation( self, operation )</code></div><div class='ds'><p>Adds the given operation as a child of this process.</p></div></div><div id='d_Un' class='de'><h1>Method <span class='n'>endsWithTermination</span></h1><div class='re'><code>endsWithTermination( self )</code></div><div class='ds'><p>Returns true if this function ends with a termination operation. This is especially useful for back-ends which want to know if they have to insert an explicit <code>return</code> at the end (like Java).</p></div></div><div id='d_Vn' class='de'><h1>Method <span class='n'>getAbsoluteName</span></h1><div class='re'><code>getAbsoluteName( self )</code></div><div class='ds'><p>Returns the absolute name for this element</p></div></div><div id='d_Wn' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_Xn' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_Yn' class='de'><h1>Method <span class='n'>getArguments</span></h1><div class='re'><code>getArguments( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Zn' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_ao' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><p>Returns this @protocol name. It can be <code>None</code> if the @protocol is anonymous.</p></div></div><div id='d_bo' class='de'><h1>Method <span class='n'>getOperations</span></h1><div class='re'><code>getOperations( self )</code></div><div class='ds'><p>Returns the list of operations in this process.</p></div></div><div id='d_co' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns the parent context for this context (if any)</p></div></div><div id='d_do' class='de'><h1>Method <span class='n'>getSlot</span></h1><div class='re'><code>getSlot( self, name )</code></div><div class='ds'><p>Returns the given evaluable bound to named slot.</p></div></div><div id='d_eo' class='de'><h1>Method <span class='n'>getSlots</span></h1><div class='re'><code>getSlots( self )</code></div><div class='ds'><p>Returns (key, evaluable) pairs representing the slots within this context.</p></div></div><div id='d_fo' class='de'><h1>Method <span class='n'>hasExplicitTermination</span></h1><div class='re'><code>hasExplicitTermination( self )</code></div><div class='ds'><p>Returns true if this function has an operation with a termination, otherwise return false.</p></div></div><div id='d_go' class='de'><h1>Method <span class='n'>hasSlot</span></h1><div class='re'><code>hasSlot( self, name )</code></div><div class='ds'><p>Tells if the context has a slot with the given name.</p></div></div><div id='d_ho' class='de'><h1>Method <span class='n'>isAbstract</span></h1><div class='re'><code>isAbstract( self )</code></div><div class='ds'><p>Tells wether the given abstractable is abstract or not.</p></div></div><div id='d_io' class='de'><h1>Method <span class='n'>setAbstract</span></h1><div class='re'><code>setAbstract( self, isAbstract )</code></div><div class='ds'><p>Sets wether the given abstractable is abstract or not.</p></div></div><div id='d_jo' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_ko' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_lo' class='de'><h1>Method <span class='n'>setArguments</span></h1><div class='re'><code>setArguments( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_mo' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, context )</code></div><div class='ds'><p>Sets the parent context for this context.</p></div></div><div id='d_no' class='de'><h1>Method <span class='n'>setSlot</span></h1><div class='re'><code>setSlot( self, name, evaluable )</code></div><div class='ds'><p>Binds the given evaluable to the named slot.</p></div></div><div id='d_Rn' class='de'><h1>Class <span class='n'>IMethod</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_po' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IContext at 0x5bf750&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_qo' class='de'><h1>Method <span class='n'>addImportOperation</span></h1><div class='re'><code>addImportOperation( self, operation )</code></div><div class='ds'><p>Returns the list of import operations declared in this module</p></div></div><div id='d_ro' class='de'><h1>Method <span class='n'>getClasses</span></h1><div class='re'><code>getClasses( self )</code></div><div class='ds'><p>Returns the list of classes defined in this module. This is mainly a convenience function.</p></div></div><div id='d_so' class='de'><h1>Method <span class='n'>getImportOperations</span></h1><div class='re'><code>getImportOperations( self )</code></div><div class='ds'><p>Returns the list of import operations declared in this module</p></div></div><div id='d_to' class='de'><h1>Method <span class='n'>getParentName</span></h1><div class='re'><code>getParentName( self )</code></div><div class='ds'><p>Returns the parent name of this module (if any)</p></div></div><div id='d_uo' class='de'><h1>Method <span class='n'>isImported</span></h1><div class='re'><code>isImported( self )</code></div><div class='ds'><p>A stub module is a module that does not have any bound implementation. Stub modules are typically used by Programs when adding a module such as <code>a.b.c</code> where <code>a</code> and <code>a.b</code> will be stub modules unless they were or will be imported.</p></div></div><div id='d_vo' class='de'><h1>Method <span class='n'>setImported</span></h1><div class='re'><code>setImported( self, value=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_wo' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_xo' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_yo' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_zo' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns the parent context for this context (if any)</p></div></div><div id='d_Ao' class='de'><h1>Method <span class='n'>getSlot</span></h1><div class='re'><code>getSlot( self, name )</code></div><div class='ds'><p>Returns the given evaluable bound to named slot.</p></div></div><div id='d_Bo' class='de'><h1>Method <span class='n'>getSlots</span></h1><div class='re'><code>getSlots( self )</code></div><div class='ds'><p>Returns (key, evaluable) pairs representing the slots within this context.</p></div></div><div id='d_Co' class='de'><h1>Method <span class='n'>hasSlot</span></h1><div class='re'><code>hasSlot( self, name )</code></div><div class='ds'><p>Tells if the context has a slot with the given name.</p></div></div><div id='d_Do' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_Eo' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_Fo' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, context )</code></div><div class='ds'><p>Sets the parent context for this context.</p></div></div><div id='d_Go' class='de'><h1>Method <span class='n'>setSlot</span></h1><div class='re'><code>setSlot( self, name, evaluable )</code></div><div class='ds'><p>Binds the given evaluable to the named slot.</p></div></div><div id='d_oo' class='de'><h1>Class <span class='n'>IModule</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Io' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IAttribute at 0x5bf6c0&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Jo' class='de'><h1>Method <span class='n'>getAbsoluteName</span></h1><div class='re'><code>getAbsoluteName( self )</code></div><div class='ds'><p>Returns the absolute name for this element</p></div></div><div id='d_Ko' class='de'><h1>Method <span class='n'>getDefaultValue</span></h1><div class='re'><code>getDefaultValue( self )</code></div><div class='ds'><p>Gets the @methodault value for this attribute</p></div></div><div id='d_Lo' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><p>Returns the local name for this referencable element</p></div></div><div id='d_Mo' class='de'><h1>Method <span class='n'>getTypeDescription</span></h1><div class='re'><code>getTypeDescription( self )</code></div><div class='ds'><p>Returns type information (constraints) that are associated to this argument.</p></div></div><div id='d_No' class='de'><h1>Method <span class='n'>setDefaultValue</span></h1><div class='re'><code>setDefaultValue( self )</code></div><div class='ds'><p>Sets the @methodault value for this attribute</p></div></div><div id='d_Ho' class='de'><h1>Class <span class='n'>IModuleAttribute</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Po' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.ILiteral at 0x5bf4e0&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Qo' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_Ro' class='de'><h1>Method <span class='n'>getActualValue</span></h1><div class='re'><code>getActualValue( self )</code></div><div class='ds'><p>Returns the (implementation language) value for this literal</p></div></div><div id='d_So' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_To' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_Uo' class='de'><h1>Method <span class='n'>getResultAbstractType</span></h1><div class='re'><code>getResultAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type of the result of the evaluation of this evaluable</p></div></div><div id='d_Vo' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_Wo' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_Xo' class='de'><h1>Method <span class='n'>setResultAbstractType</span></h1><div class='re'><code>setResultAbstractType( self, abstractType )</code></div><div class='ds'><p>Sets the abstract type for this operation result. This is usually invoked in the typing phase.</p></div></div><div id='d_Oo' class='de'><h1>Class <span class='n'>INumber</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Zo' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IElement at 0x5bf360&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_ap' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><p>Adds an argument to this operation. This should do checking of arguments (by expected internal type and number).</p></div></div><div id='d_bp' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><p>Returns the ith arguments to this operation.</p></div></div><div id='d_cp' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><p>Returns the arguments to this operation.</p></div></div><div id='d_dp' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><p>Returns the <em>internal types</em> for this operations arguments. This is typically the list of interfaces or @protocols that the arguments must comply to.</p></div></div><div id='d_ep' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><p>Sets the given argument of this operation, by argument index.</p></div></div><div id='d_fp' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_gp' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_hp' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_ip' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_jp' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_Yo' class='de'><h1>Class <span class='n'>IOperation</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_lp' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IReference at 0x5bf5d0&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_mp' class='de'><h1>Method <span class='n'>getPriority</span></h1><div class='re'><code>getPriority( self )</code></div><div class='ds'><p>Gets the priority for this operator</p></div></div><div id='d_np' class='de'><h1>Method <span class='n'>setPriority</span></h1><div class='re'><code>setPriority( self, priority )</code></div><div class='ds'><p>Sets the priority for this operator</p></div></div><div id='d_op' class='de'><h1>Method <span class='n'>getAbsoluteName</span></h1><div class='re'><code>getAbsoluteName( self )</code></div><div class='ds'><p>Returns the absolute name for this element</p></div></div><div id='d_pp' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_qp' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_rp' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_sp' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><p>Returns the local name for this referencable element</p></div></div><div id='d_tp' class='de'><h1>Method <span class='n'>getReferenceName</span></h1><div class='re'><code>getReferenceName( self )</code></div><div class='ds'><p>Returns the name which this reference contains. The name is used by the resolution operation to actually resolve a value from the name.</p></div></div><div id='d_up' class='de'><h1>Method <span class='n'>getResultAbstractType</span></h1><div class='re'><code>getResultAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type of the result of the evaluation of this evaluable</p></div></div><div id='d_vp' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_wp' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_xp' class='de'><h1>Method <span class='n'>setResultAbstractType</span></h1><div class='re'><code>setResultAbstractType( self, abstractType )</code></div><div class='ds'><p>Sets the abstract type for this operation result. This is usually invoked in the typing phase.</p></div></div><div id='d_kp' class='de'><h1>Class <span class='n'>IOperator</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_zp' class='de'><h1>Method <span class='n'>addOperation</span></h1><div class='re'><code>addOperation( self, operation )</code></div><div class='ds'><p>Adds the given operation as a child of this process.</p></div></div><div id='d_Ap' class='de'><h1>Method <span class='n'>getOperations</span></h1><div class='re'><code>getOperations( self )</code></div><div class='ds'><p>Returns the list of operations in this process.</p></div></div><div id='d_yp' class='de'><h1>Class <span class='n'>IProcess</span></h1><div class='re'></div><div class='ds'><p>A process is a sequence of operations.</p></div></div><div id='d_Cp' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IContext at 0x5bf750&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Dp' class='de'><h1>Method <span class='n'>addModule</span></h1><div class='re'><code>addModule( self, module )</code></div><div class='ds'><p>Adds a module to this program. The module will be registered in the global module catalogue.</p></div></div><div id='d_Ep' class='de'><h1>Method <span class='n'>getFactory</span></h1><div class='re'><code>getFactory( self )</code></div><div class='ds'><p>Gets the factory that was used to create this program. It can be used to create more elements in the program.</p></div></div><div id='d_Fp' class='de'><h1>Method <span class='n'>getModule</span></h1><div class='re'><code>getModule( self, moduleAbsoluteName )</code></div><div class='ds'><p>Returns the module (if any) with the given absolute name</p></div></div><div id='d_Gp' class='de'><h1>Method <span class='n'>getModules</span></h1><div class='re'><code>getModules( self )</code></div><div class='ds'><p>Returns the list of modules declared/imported in this program</p></div></div><div id='d_Hp' class='de'><h1>Method <span class='n'>setFactory</span></h1><div class='re'><code>setFactory( self, factory )</code></div><div class='ds'><p>Sets the factory that was used to create this program</p></div></div><div id='d_Ip' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_Jp' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_Kp' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_Lp' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns the parent context for this context (if any)</p></div></div><div id='d_Mp' class='de'><h1>Method <span class='n'>getSlot</span></h1><div class='re'><code>getSlot( self, name )</code></div><div class='ds'><p>Returns the given evaluable bound to named slot.</p></div></div><div id='d_Np' class='de'><h1>Method <span class='n'>getSlots</span></h1><div class='re'><code>getSlots( self )</code></div><div class='ds'><p>Returns (key, evaluable) pairs representing the slots within this context.</p></div></div><div id='d_Op' class='de'><h1>Method <span class='n'>hasSlot</span></h1><div class='re'><code>hasSlot( self, name )</code></div><div class='ds'><p>Tells if the context has a slot with the given name.</p></div></div><div id='d_Pp' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_Qp' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_Rp' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, context )</code></div><div class='ds'><p>Sets the parent context for this context.</p></div></div><div id='d_Sp' class='de'><h1>Method <span class='n'>setSlot</span></h1><div class='re'><code>setSlot( self, name, evaluable )</code></div><div class='ds'><p>Binds the given evaluable to the named slot.</p></div></div><div id='d_Bp' class='de'><h1>Class <span class='n'>IProgram</span></h1><div class='re'></div><div class='ds'><p>The program is the core context and entry point for almost every operation offered by LambdaFactory.</p></div></div><div id='d_Up' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IAssignable at 0x5bf390&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Vp' class='de'><h1>Method <span class='n'>getAbsoluteName</span></h1><div class='re'><code>getAbsoluteName( self )</code></div><div class='ds'><p>Returns the absolute name for this element</p></div></div><div id='d_Wp' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><p>Returns the local name for this referencable element</p></div></div><div id='d_Tp' class='de'><h1>Class <span class='n'>IReferencable</span></h1><div class='re'></div><div class='ds'><p>A referencable is an element that can be referenced either by id (it is unique and stable), or by a name (which is also not supposed to change).</p><p>Types are good examples of referencables: they have an <em>absolute name</em> (like <code>Data.List</code>), but can also be bound to slots within contexts which give them "local names" (like <code>List := Data.List</code>)</p></div></div><div id='d_Yp' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IValue at 0x5bf4b0&gt;, &lt;class lambdafactory.interfaces.IReferencable at 0x5bf3c0&gt;)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Zp' class='de'><h1>Method <span class='n'>getReferenceName</span></h1><div class='re'><code>getReferenceName( self )</code></div><div class='ds'><p>Returns the name which this reference contains. The name is used by the resolution operation to actually resolve a value from the name.</p></div></div><div id='d_aq' class='de'><h1>Method <span class='n'>getAbsoluteName</span></h1><div class='re'><code>getAbsoluteName( self )</code></div><div class='ds'><p>Returns the absolute name for this element</p></div></div><div id='d_bq' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_cq' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_dq' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_eq' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><p>Returns the local name for this referencable element</p></div></div><div id='d_fq' class='de'><h1>Method <span class='n'>getResultAbstractType</span></h1><div class='re'><code>getResultAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type of the result of the evaluation of this evaluable</p></div></div><div id='d_gq' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_hq' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_iq' class='de'><h1>Method <span class='n'>setResultAbstractType</span></h1><div class='re'><code>setResultAbstractType( self, abstractType )</code></div><div class='ds'><p>Sets the abstract type for this operation result. This is usually invoked in the typing phase.</p></div></div><div id='d_Xp' class='de'><h1>Class <span class='n'>IReference</span></h1><div class='re'></div><div class='ds'><p>A reference is a name that can be converted into a value using a resolution operation (for instance).</p></div></div><div id='d_kq' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IOperation at 0x5bfa50&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_lq' class='de'><h1>Method <span class='n'>getCondition</span></h1><div class='re'><code>getCondition( self )</code></div><div class='ds'><p>Gets the expression that is the condition for this repetition.</p></div></div><div id='d_mq' class='de'><h1>Method <span class='n'>getProcess</span></h1><div class='re'><code>getProcess( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_nq' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><p>Adds an argument to this operation. This should do checking of arguments (by expected internal type and number).</p></div></div><div id='d_oq' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_pq' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_qq' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_rq' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><p>Returns the ith arguments to this operation.</p></div></div><div id='d_sq' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><p>Returns the arguments to this operation.</p></div></div><div id='d_tq' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><p>Returns the <em>internal types</em> for this operations arguments. This is typically the list of interfaces or @protocols that the arguments must comply to.</p></div></div><div id='d_uq' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_vq' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_wq' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><p>Sets the given argument of this operation, by argument index.</p></div></div><div id='d_xq' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.IEvaluable at 0x5bf3f0&gt;, &lt;class lambdafactory.interfaces.IProcess at 0x5bf870&gt;]</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='d_jq' class='de'><h1>Class <span class='n'>IRepetition</span></h1><div class='re'></div><div class='ds'><p>A repetition is the repetitive execution of a process according to a predicate expression which can be modified by the process.</p></div></div><div id='d_zq' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IOperation at 0x5bfa50&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Aq' class='de'><h1>Method <span class='n'>getContext</span></h1><div class='re'><code>getContext( self )</code></div><div class='ds'><p>Returns the (optional) context in which the resolution should occur.</p></div></div><div id='d_Bq' class='de'><h1>Method <span class='n'>getReference</span></h1><div class='re'><code>getReference( self )</code></div><div class='ds'><p>Returns the reference to be resolved.</p></div></div><div id='d_Cq' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><p>Adds an argument to this operation. This should do checking of arguments (by expected internal type and number).</p></div></div><div id='d_Dq' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_Eq' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_Fq' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_Gq' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><p>Returns the ith arguments to this operation.</p></div></div><div id='d_Hq' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><p>Returns the arguments to this operation.</p></div></div><div id='d_Iq' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><p>Returns the <em>internal types</em> for this operations arguments. This is typically the list of interfaces or @protocols that the arguments must comply to.</p></div></div><div id='d_Jq' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_Kq' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_Lq' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><p>Sets the given argument of this operation, by argument index.</p></div></div><div id='d_Mq' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.IReferencable at 0x5bf3c0&gt;, &lt;class lambdafactory.interfaces.IEvaluable at 0x5bf3f0&gt;]</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='d_yq' class='de'><h1>Class <span class='n'>IResolution</span></h1><div class='re'></div><div class='ds'><p>A resolution resolves a reference into a value.</p></div></div><div id='d_Oq' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IOperation at 0x5bfa50&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Pq' class='de'><h1>Method <span class='n'>addRule</span></h1><div class='re'><code>addRule( self, evaluable )</code></div><div class='ds'><p>Adds a rule to this operation.</p></div></div><div id='d_Qq' class='de'><h1>Method <span class='n'>getRules</span></h1><div class='re'><code>getRules( self )</code></div><div class='ds'><p>Returns the ordered set of rule for this selection.</p></div></div><div id='d_Rq' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><p>Adds an argument to this operation. This should do checking of arguments (by expected internal type and number).</p></div></div><div id='d_Sq' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_Tq' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_Uq' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_Vq' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><p>Returns the ith arguments to this operation.</p></div></div><div id='d_Wq' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><p>Returns the arguments to this operation.</p></div></div><div id='d_Xq' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><p>Returns the <em>internal types</em> for this operations arguments. This is typically the list of interfaces or @protocols that the arguments must comply to.</p></div></div><div id='d_Yq' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_Zq' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_ar' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><p>Sets the given argument of this operation, by argument index.</p></div></div><div id='d_br' class='de'><h1>list</h1><div class='re'><code>[[&lt;class lambdafactory.interfaces.IMatchOperation at 0x5bfd50&gt;]]</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='d_Nq' class='de'><h1>Class <span class='n'>ISelection</span></h1><div class='re'></div><div class='ds'><p>Selections are the abstract objects behind <code>if</code>, <code>select</code> or pattern-matching operations. Each selection has match operations as arguments, which bind a subprocess to a predicate expression.</p></div></div><div id='d_dr' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.ISubsetOperation at 0x5bfcc0&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_er' class='de'><h1>Method <span class='n'>getSliceEnd</span></h1><div class='re'><code>getSliceEnd( self )</code></div><div class='ds'><p>Returns evaluable that will return the slice end</p></div></div><div id='d_fr' class='de'><h1>Method <span class='n'>getSliceStart</span></h1><div class='re'><code>getSliceStart( self )</code></div><div class='ds'><p>Returns evaluable that will return the slice start</p></div></div><div id='d_gr' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><p>Adds an argument to this operation. This should do checking of arguments (by expected internal type and number).</p></div></div><div id='d_hr' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_ir' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_jr' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_kr' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><p>Returns the ith arguments to this operation.</p></div></div><div id='d_lr' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><p>Returns the arguments to this operation.</p></div></div><div id='d_mr' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><p>Returns the <em>internal types</em> for this operations arguments. This is typically the list of interfaces or @protocols that the arguments must comply to.</p></div></div><div id='d_nr' class='de'><h1>Method <span class='n'>getTarget</span></h1><div class='re'><code>getTarget( self )</code></div><div class='ds'><p>Returns the operation target.</p></div></div><div id='d_or' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_pr' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_qr' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><p>Sets the given argument of this operation, by argument index.</p></div></div><div id='d_rr' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.IEvaluable at 0x5bf3f0&gt;, &lt;class lambdafactory.interfaces.IEvaluable at 0x5bf3f0&gt;, &lt;class lambdafactory.interfaces.IEvaluable at 0x5bf3f0&gt;]</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='d_cr' class='de'><h1>Class <span class='n'>ISliceOperation</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_tr' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IReferencable at 0x5bf3c0&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_ur' class='de'><h1>Method <span class='n'>getTypeDescription</span></h1><div class='re'><code>getTypeDescription( self )</code></div><div class='ds'><p>Returns type information (constraints) that are associated to this argument.</p></div></div><div id='d_vr' class='de'><h1>Method <span class='n'>getAbsoluteName</span></h1><div class='re'><code>getAbsoluteName( self )</code></div><div class='ds'><p>Returns the absolute name for this element</p></div></div><div id='d_wr' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><p>Returns the local name for this referencable element</p></div></div><div id='d_sr' class='de'><h1>Class <span class='n'>ISlot</span></h1><div class='re'></div><div class='ds'><p>An argument is a reference with additional type information.</p></div></div><div id='d_yr' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.ILiteral at 0x5bf4e0&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_zr' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_Ar' class='de'><h1>Method <span class='n'>getActualValue</span></h1><div class='re'><code>getActualValue( self )</code></div><div class='ds'><p>Returns the (implementation language) value for this literal</p></div></div><div id='d_Br' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_Cr' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_Dr' class='de'><h1>Method <span class='n'>getResultAbstractType</span></h1><div class='re'><code>getResultAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type of the result of the evaluation of this evaluable</p></div></div><div id='d_Er' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_Fr' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_Gr' class='de'><h1>Method <span class='n'>setResultAbstractType</span></h1><div class='re'><code>setResultAbstractType( self, abstractType )</code></div><div class='ds'><p>Sets the abstract type for this operation result. This is usually invoked in the typing phase.</p></div></div><div id='d_xr' class='de'><h1>Class <span class='n'>IString</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Ir' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IOperation at 0x5bfa50&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Jr' class='de'><h1>Method <span class='n'>getTarget</span></h1><div class='re'><code>getTarget( self )</code></div><div class='ds'><p>Returns the operation target.</p></div></div><div id='d_Kr' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><p>Adds an argument to this operation. This should do checking of arguments (by expected internal type and number).</p></div></div><div id='d_Lr' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_Mr' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_Nr' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_Or' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><p>Returns the ith arguments to this operation.</p></div></div><div id='d_Pr' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><p>Returns the arguments to this operation.</p></div></div><div id='d_Qr' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><p>Returns the <em>internal types</em> for this operations arguments. This is typically the list of interfaces or @protocols that the arguments must comply to.</p></div></div><div id='d_Rr' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_Sr' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_Tr' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><p>Sets the given argument of this operation, by argument index.</p></div></div><div id='d_Hr' class='de'><h1>Class <span class='n'>ISubsetOperation</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Vr' class='de'><h1>Method <span class='n'>getColumn</span></h1><div class='re'><code>getColumn( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Wr' class='de'><h1>Method <span class='n'>getLine</span></h1><div class='re'><code>getLine( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Xr' class='de'><h1>Method <span class='n'>getOffset</span></h1><div class='re'><code>getOffset( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Ur' class='de'><h1>Class <span class='n'>ISyntactic</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Zr' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IOperation at 0x5bfa50&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_as' class='de'><h1>Method <span class='n'>getReturnedEvaluable</span></h1><div class='re'><code>getReturnedEvaluable( self )</code></div><div class='ds'><p>Returns the termination return evaluable.</p></div></div><div id='d_bs' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><p>Adds an argument to this operation. This should do checking of arguments (by expected internal type and number).</p></div></div><div id='d_cs' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_ds' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_es' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_fs' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><p>Returns the ith arguments to this operation.</p></div></div><div id='d_gs' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><p>Returns the arguments to this operation.</p></div></div><div id='d_hs' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><p>Returns the <em>internal types</em> for this operations arguments. This is typically the list of interfaces or @protocols that the arguments must comply to.</p></div></div><div id='d_is' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_js' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_ks' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><p>Sets the given argument of this operation, by argument index.</p></div></div><div id='d_ls' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.IEvaluable at 0x5bf3f0&gt;]</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='d_Yr' class='de'><h1>Class <span class='n'>ITermination</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_ns' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IElement at 0x5bf360&gt;, &lt;class lambdafactory.interfaces.IEvaluable at 0x5bf3f0&gt;)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_os' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_ps' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_qs' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_rs' class='de'><h1>Method <span class='n'>getResultAbstractType</span></h1><div class='re'><code>getResultAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type of the result of the evaluation of this evaluable</p></div></div><div id='d_ss' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_ts' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_us' class='de'><h1>Method <span class='n'>setResultAbstractType</span></h1><div class='re'><code>setResultAbstractType( self, abstractType )</code></div><div class='ds'><p>Sets the abstract type for this operation result. This is usually invoked in the typing phase.</p></div></div><div id='d_ms' class='de'><h1>Class <span class='n'>IValue</span></h1><div class='re'></div><div class='ds'><p>A value represents an atomic element of the language, like a number, a string, or a name (that can resolved by the language, acts as key for data structures, etc.).</p></div></div><div id='d_a' class='de'><h1>Module <span class='n'>lambdafactory.interfaces</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_xs' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self, module=<module 'lambdafactory.model' from '/Users/sebastien/Local/Python/lambdafactory/model.pyc'> )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_ys' class='de'><h1>Method <span class='n'>_arg</span></h1><div class='re'><code>_arg( self, name, typeinfo=None, optional=False )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_zs' class='de'><h1>Method <span class='n'>_attr</span></h1><div class='re'><code>_attr( self, name, typeinfo=None, value=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_As' class='de'><h1>Method <span class='n'>_classattr</span></h1><div class='re'><code>_classattr( self, name, typeinfo=None, value=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Bs' class='de'><h1>Method <span class='n'>_dict</span></h1><div class='re'><code>_dict( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Cs' class='de'><h1>Method <span class='n'>_getImplementation</span></h1><div class='re'><code>_getImplementation( self, name )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Ds' class='de'><h1>Method <span class='n'>_list</span></h1><div class='re'><code>_list( self, *args )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Es' class='de'><h1>Method <span class='n'>_moduleattr</span></h1><div class='re'><code>_moduleattr( self, name, typeinfo=None, value=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Fs' class='de'><h1>Method <span class='n'>_number</span></h1><div class='re'><code>_number( self, number )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Gs' class='de'><h1>Method <span class='n'>_op</span></h1><div class='re'><code>_op( self, symbol, priority=0 )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Hs' class='de'><h1>Method <span class='n'>_ref</span></h1><div class='re'><code>_ref( self, name )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Is' class='de'><h1>Method <span class='n'>_slot</span></h1><div class='re'><code>_slot( self, name, typeinfo=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Js' class='de'><h1>Method <span class='n'>_string</span></h1><div class='re'><code>_string( self, value )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Ks' class='de'><h1>Method <span class='n'>access</span></h1><div class='re'><code>access( self, target, _index )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Ls' class='de'><h1>Method <span class='n'>allocate</span></h1><div class='re'><code>allocate( self, slot, value=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Ms' class='de'><h1>Method <span class='n'>annotation</span></h1><div class='re'><code>annotation( self, name, content )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Ns' class='de'><h1>Method <span class='n'>assign</span></h1><div class='re'><code>assign( self, name, evaluable )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Os' class='de'><h1>Method <span class='n'>breaks</span></h1><div class='re'><code>breaks( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Ps' class='de'><h1>Method <span class='n'>comment</span></h1><div class='re'><code>comment( self, content )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Qs' class='de'><h1>Method <span class='n'>compute</span></h1><div class='re'><code>compute( self, operatorName, leftOperand, rightOperand=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Rs' class='de'><h1>Method <span class='n'>createBlock</span></h1><div class='re'><code>createBlock( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Ss' class='de'><h1>Method <span class='n'>createClass</span></h1><div class='re'><code>createClass( self, name, inherited=() )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Ts' class='de'><h1>Method <span class='n'>createClassMethod</span></h1><div class='re'><code>createClassMethod( self, name, arguments=() )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Us' class='de'><h1>Method <span class='n'>createClosure</span></h1><div class='re'><code>createClosure( self, arguments )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Vs' class='de'><h1>Method <span class='n'>createConstructor</span></h1><div class='re'><code>createConstructor( self, arguments=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Ws' class='de'><h1>Method <span class='n'>createDestructor</span></h1><div class='re'><code>createDestructor( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Xs' class='de'><h1>Method <span class='n'>createFunction</span></h1><div class='re'><code>createFunction( self, name, arguments )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Ys' class='de'><h1>Method <span class='n'>createInterface</span></h1><div class='re'><code>createInterface( self, name, inherited=() )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Zs' class='de'><h1>Method <span class='n'>createMethod</span></h1><div class='re'><code>createMethod( self, name, arguments=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_at' class='de'><h1>Method <span class='n'>createModule</span></h1><div class='re'><code>createModule( self, name )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_bt' class='de'><h1>Method <span class='n'>createProgram</span></h1><div class='re'><code>createProgram( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_ct' class='de'><h1>Method <span class='n'>doc</span></h1><div class='re'><code>doc( self, content )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_dt' class='de'><h1>Method <span class='n'>embed</span></h1><div class='re'><code>embed( self, lang, code )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_et' class='de'><h1>Method <span class='n'>embedTemplate</span></h1><div class='re'><code>embedTemplate( self, lang, code )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_ft' class='de'><h1>Method <span class='n'>enumerate</span></h1><div class='re'><code>enumerate( self, start, end, step=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_gt' class='de'><h1>Method <span class='n'>evaluate</span></h1><div class='re'><code>evaluate( self, evaluable )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_ht' class='de'><h1>Method <span class='n'>exception</span></h1><div class='re'><code>exception( self, exception )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_it' class='de'><h1>Method <span class='n'>importModule</span></h1><div class='re'><code>importModule( self, name, alias )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_jt' class='de'><h1>Method <span class='n'>importModules</span></h1><div class='re'><code>importModules( self, names )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_kt' class='de'><h1>Method <span class='n'>importSymbol</span></h1><div class='re'><code>importSymbol( self, name, origin, alias )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_lt' class='de'><h1>Method <span class='n'>importSymbols</span></h1><div class='re'><code>importSymbols( self, names, origin )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_mt' class='de'><h1>Method <span class='n'>instanciate</span></h1><div class='re'><code>instanciate( self, evaluable, *arguments )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_nt' class='de'><h1>Method <span class='n'>intercept</span></h1><div class='re'><code>intercept( self, tryProcess, catchProcess=None, finallyProcess=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_ot' class='de'><h1>Method <span class='n'>invoke</span></h1><div class='re'><code>invoke( self, evaluable, *arguments )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_pt' class='de'><h1>Method <span class='n'>iterate</span></h1><div class='re'><code>iterate( self, evaluable, process )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_qt' class='de'><h1>Method <span class='n'>matchExpression</span></h1><div class='re'><code>matchExpression( self, evaluable, expression )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_rt' class='de'><h1>Method <span class='n'>matchProcess</span></h1><div class='re'><code>matchProcess( self, evaluable, process )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_st' class='de'><h1>Method <span class='n'>repeat</span></h1><div class='re'><code>repeat( self, condition, process )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_tt' class='de'><h1>Method <span class='n'>resolve</span></h1><div class='re'><code>resolve( self, reference, context=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_ut' class='de'><h1>Method <span class='n'>returns</span></h1><div class='re'><code>returns( self, evaluable )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_vt' class='de'><h1>Method <span class='n'>select</span></h1><div class='re'><code>select( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_wt' class='de'><h1>Method <span class='n'>slice</span></h1><div class='re'><code>slice( self, target, _start, _end=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_ws' class='de'><h1>Class <span class='n'>Factory</span></h1><div class='re'></div><div class='ds'><p>This class takes a module and look for classes with the same name as the <code>createXXX</code> methods and instanciates them.</p><p>For instance, if you define a module with classes like <code>Value</code>, <code>Literal</code>, <code>Invocation</code>, <code>Function</code>, etc. you just have to give this module to the factory constructor and it will be used to generate the given element.</p></div></div><div id='d_yt' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self, someClass, expectedClass, argument )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_zt' class='de'><h1>wrapper_descriptor</h1><div class='re'></div><div class='ds'><div class="section"><h1 class="heading"><span class="number"><span class="level0">1<span class="lastDot dot">.</span></span></span><span class='term'>getitem</span>_(y) &lt;==&gt; x[y]</h1><div class="level1"></div></div></div></div><div id='d_At' class='de'><h1>wrapper_descriptor</h1><div class='re'></div><div class='ds'><div class="section"><h1 class="heading"><span class="number"><span class="level0">1<span class="lastDot dot">.</span></span></span><span class='term'>repr</span>_() &lt;==&gt; repr(x)</h1><div class="level1"></div></div></div></div><div id='d_Bt' class='de'><h1>wrapper_descriptor</h1><div class='re'></div><div class='ds'><div class="section"><h1 class="heading"><span class="number"><span class="level0">1<span class="lastDot dot">.</span></span></span><span class='term'>str</span>_() &lt;==&gt; str(x)</h1><div class="level1"></div></div></div></div><div id='d_Ct' class='de'><h1>getset_descriptor</h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Dt' class='de'><h1>member_descriptor</h1><div class='re'></div><div class='ds'><p>exception message</p></div></div><div id='d_xt' class='de'><h1>Class <span class='n'>ModelBadArgument</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Ft' class='de'><h1>wrapper_descriptor</h1><div class='re'></div><div class='ds'><div class="section"><h1 class="heading"><span class="number"><span class="level0">1<span class="lastDot dot">.</span></span></span><span class='term'>init</span><span class='term'>(...) initializes x; see x.</span><span class='term'>class</span><span class='term'>.</span><span class='term'>doc</span>_ for signature</h1><div class="level1"></div></div></div></div><div id='d_Et' class='de'><h1>Class <span class='n'>ModelException</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Gt' class='de'><h1>Function <span class='n'>assertImplements</span></h1><div class='re'><code>assertImplements( v, i )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_vs' class='de'><h1>Module <span class='n'>lambdafactory.modelbase</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Jt' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self, reporter=<lambdafactory.reporter.Reporter instance at 0x11aa058> )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Kt' class='de'><h1>Method <span class='n'>_document</span></h1><div class='re'><code>_document( self, element )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Lt' class='de'><h1>Method <span class='n'>_filterContext</span></h1><div class='re'><code>_filterContext( self, interface )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Mt' class='de'><h1>Method <span class='n'>_format</span></h1><div class='re'><code>_format( self, *values )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Nt' class='de'><h1>Method <span class='n'>_getContextsAsString</span></h1><div class='re'><code>_getContextsAsString( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Ot' class='de'><h1>Method <span class='n'>_unique</span></h1><div class='re'><code>_unique( self, name )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Pt' class='de'><h1>Method <span class='n'>getCurrentClass</span></h1><div class='re'><code>getCurrentClass( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Qt' class='de'><h1>Method <span class='n'>getCurrentClassAncestors</span></h1><div class='re'><code>getCurrentClassAncestors( self, theClass=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Rt' class='de'><h1>Method <span class='n'>getCurrentClassParents</span></h1><div class='re'><code>getCurrentClassParents( self, theClass=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_St' class='de'><h1>Method <span class='n'>getCurrentClosure</span></h1><div class='re'><code>getCurrentClosure( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Tt' class='de'><h1>Method <span class='n'>getCurrentContext</span></h1><div class='re'><code>getCurrentContext( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Ut' class='de'><h1>Method <span class='n'>getCurrentDataFlow</span></h1><div class='re'><code>getCurrentDataFlow( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Vt' class='de'><h1>Method <span class='n'>getCurrentFunction</span></h1><div class='re'><code>getCurrentFunction( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Wt' class='de'><h1>Method <span class='n'>getCurrentMethod</span></h1><div class='re'><code>getCurrentMethod( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Xt' class='de'><h1>Method <span class='n'>getCurrentModule</span></h1><div class='re'><code>getCurrentModule( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Yt' class='de'><h1>Method <span class='n'>isIn</span></h1><div class='re'><code>isIn( self, interface )</code></div><div class='ds'><p>Tells wether the current element is in a context where at least one of the parent elements define the given interface. It returns <code>-1</code> when no element implements the interface, and otherwise returns the offset of the element, starting from the most recent context.</p><p>To know if you're currently in an assignation: <pre>self.isIn(interfaces.IAssignation)
</pre></p></div></div><div id='d_Zt' class='de'><h1>Method <span class='n'>isInClassMethod</span></h1><div class='re'><code>isInClassMethod( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_au' class='de'><h1>Method <span class='n'>isInInstanceMethod</span></h1><div class='re'><code>isInInstanceMethod( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_bu' class='de'><h1>Method <span class='n'>resolve</span></h1><div class='re'><code>resolve( self, name, dataflow=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_cu' class='de'><h1>Method <span class='n'>resolveAbsoluteOrLocal</span></h1><div class='re'><code>resolveAbsoluteOrLocal( self, name, dataflow=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_du' class='de'><h1>Method <span class='n'>write</span></h1><div class='re'><code>write( self, element )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_eu' class='de'><h1>Method <span class='n'>writeProgram</span></h1><div class='re'><code>writeProgram( self, programElement )</code></div><div class='ds'><p>Writes a Program element.</p></div></div><div id='d_fu' class='de'><h1>tuple</h1><div class='re'><code>('Program', 'Module', 'Class', 'Destructor', 'Constructor', 'ClassMethod', 'Method', 'Function', 'Closure', 'Block', 'ModuleAttribute', 'ClassAttribute', 'Attribute', 'Argument', 'Operator', 'Reference', 'Number', 'String', 'List', 'Dict', 'Enumeration', 'Allocation', 'Assignation', 'Computation', 'Invocation', 'Instanciation', 'Resolution', 'Selection', 'Repetition', 'Iteration', 'AccessOperation', 'SliceOperation', 'Evaluation', 'Termination', 'Breaking', 'Except', 'Interception', 'ImportSymbolOperation', 'ImportSymbolsOperation', 'ImportModuleOperation', 'ImportModulesOperation', 'Embed')</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_gu' class='de'><h1>str</h1><div class='re'><code>'8&lt; ---[%s]---'</code></div><div class='ds'><p>str(object) -&gt; string</p><p>Return a nice string representation of the object. If the argument is a string, the return value is the same object.</p></div></div><div id='d_It' class='de'><h1>Class <span class='n'>AbstractWriter</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_iu' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self, outputDir )</code></div><div class='ds'><p>Initializes the file splitter with the given output directory.</p></div></div><div id='d_ju' class='de'><h1>Method <span class='n'>end</span></h1><div class='re'><code>end( self )</code></div><div class='ds'><p>Callback invoked after a <code>fromXXX</code> method was invoked.</p></div></div><div id='d_ku' class='de'><h1>Method <span class='n'>fromLines</span></h1><div class='re'><code>fromLines( self, lines, addEOL=False )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_lu' class='de'><h1>Method <span class='n'>fromStream</span></h1><div class='re'><code>fromStream( self, stream, addEOL=False )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_mu' class='de'><h1>Method <span class='n'>fromString</span></h1><div class='re'><code>fromString( self, text )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_nu' class='de'><h1>Method <span class='n'>newFile</span></h1><div class='re'><code>newFile( self, path )</code></div><div class='ds'><p>Callback invoked by a <code>fromXXX</code> method, indicating that the lines should be written to a file.</p></div></div><div id='d_ou' class='de'><h1>Method <span class='n'>start</span></h1><div class='re'><code>start( self )</code></div><div class='ds'><p>Callback invoked when a <code>fromXXX</code> method is invoked.</p></div></div><div id='d_pu' class='de'><h1>Method <span class='n'>writeLine</span></h1><div class='re'><code>writeLine( self, line )</code></div><div class='ds'><p>Writes the given line to the current file.</p></div></div><div id='d_hu' class='de'><h1>Class <span class='n'>FileSplitter</span></h1><div class='re'></div><div class='ds'><p>Some languages (like Java or ActionScript) may generate multiple files for one single module. The FileSplitter makes it easy for front-end to produce multiple file from a single file or text generated by the LambdaFactory back-end writers.</p></div></div><div id='d_ru' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.modelwriter.AbstractWriter at 0x1147870&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_su' class='de'><h1>Method <span class='n'>writeAllocation</span></h1><div class='re'><code>writeAllocation( self, allocation )</code></div><div class='ds'><p>Writes an allocation operation.</p></div></div><div id='d_tu' class='de'><h1>Method <span class='n'>writeArgument</span></h1><div class='re'><code>writeArgument( self, argElement )</code></div><div class='ds'><p>Writes an argument element.</p></div></div><div id='d_uu' class='de'><h1>Method <span class='n'>writeAssignation</span></h1><div class='re'><code>writeAssignation( self, assignation )</code></div><div class='ds'><p>Writes an assignation operation.</p></div></div><div id='d_vu' class='de'><h1>Method <span class='n'>writeAttribute</span></h1><div class='re'><code>writeAttribute( self, element )</code></div><div class='ds'><p>Writes an argument element.</p></div></div><div id='d_wu' class='de'><h1>Method <span class='n'>writeBlock</span></h1><div class='re'><code>writeBlock( self, block )</code></div><div class='ds'><p>Writes a block element.</p></div></div><div id='d_xu' class='de'><h1>Method <span class='n'>writeClass</span></h1><div class='re'><code>writeClass( self, classElement )</code></div><div class='ds'><p>Writes a class element.</p></div></div><div id='d_yu' class='de'><h1>Method <span class='n'>writeClassAttribute</span></h1><div class='re'><code>writeClassAttribute( self, element )</code></div><div class='ds'><p>Writes an argument element.</p></div></div><div id='d_zu' class='de'><h1>Method <span class='n'>writeClassMethod</span></h1><div class='re'><code>writeClassMethod( self, methodElement )</code></div><div class='ds'><p>Writes a class method element.</p></div></div><div id='d_Au' class='de'><h1>Method <span class='n'>writeClosure</span></h1><div class='re'><code>writeClosure( self, closure )</code></div><div class='ds'><p>Writes a closure element.</p></div></div><div id='d_Bu' class='de'><h1>Method <span class='n'>writeComputation</span></h1><div class='re'><code>writeComputation( self, computation )</code></div><div class='ds'><p>Writes a computation operation.</p></div></div><div id='d_Cu' class='de'><h1>Method <span class='n'>writeConstructor</span></h1><div class='re'><code>writeConstructor( self, element )</code></div><div class='ds'><p>Writes a method element.</p></div></div><div id='d_Du' class='de'><h1>Method <span class='n'>writeDestructor</span></h1><div class='re'><code>writeDestructor( self, element )</code></div><div class='ds'><p>Writes a method element.</p></div></div><div id='d_Eu' class='de'><h1>Method <span class='n'>writeDict</span></h1><div class='re'><code>writeDict( self, element )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Fu' class='de'><h1>Method <span class='n'>writeEnumeration</span></h1><div class='re'><code>writeEnumeration( self, operation )</code></div><div class='ds'><p>Writes an enumeration operation.</p></div></div><div id='d_Gu' class='de'><h1>Method <span class='n'>writeEvaluation</span></h1><div class='re'><code>writeEvaluation( self, operation )</code></div><div class='ds'><p>Writes an evaluation operation.</p></div></div><div id='d_Hu' class='de'><h1>Method <span class='n'>writeFunction</span></h1><div class='re'><code>writeFunction( self, function )</code></div><div class='ds'><p>Writes a function element.</p></div></div><div id='d_Iu' class='de'><h1>Method <span class='n'>writeImportModuleOperation</span></h1><div class='re'><code>writeImportModuleOperation( self, element )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Ju' class='de'><h1>Method <span class='n'>writeImportModulesOperation</span></h1><div class='re'><code>writeImportModulesOperation( self, element )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Ku' class='de'><h1>Method <span class='n'>writeImportSymbolOperation</span></h1><div class='re'><code>writeImportSymbolOperation( self, element )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Lu' class='de'><h1>Method <span class='n'>writeImportSymbolsOperation</span></h1><div class='re'><code>writeImportSymbolsOperation( self, element )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Mu' class='de'><h1>Method <span class='n'>writeInvocation</span></h1><div class='re'><code>writeInvocation( self, invocation )</code></div><div class='ds'><p>Writes an invocation operation.</p></div></div><div id='d_Nu' class='de'><h1>Method <span class='n'>writeIteration</span></h1><div class='re'><code>writeIteration( self, iteration )</code></div><div class='ds'><p>Writes a iteration operation.</p></div></div><div id='d_Ou' class='de'><h1>Method <span class='n'>writeList</span></h1><div class='re'><code>writeList( self, element )</code></div><div class='ds'><p>Writes a list element.</p></div></div><div id='d_Pu' class='de'><h1>Method <span class='n'>writeMethod</span></h1><div class='re'><code>writeMethod( self, methodElement )</code></div><div class='ds'><p>Writes a method element.</p></div></div><div id='d_Qu' class='de'><h1>Method <span class='n'>writeModule</span></h1><div class='re'><code>writeModule( self, moduleElement )</code></div><div class='ds'><p>Writes a Module element.</p></div></div><div id='d_Ru' class='de'><h1>Method <span class='n'>writeNumber</span></h1><div class='re'><code>writeNumber( self, number )</code></div><div class='ds'><p>Writes a number element.</p></div></div><div id='d_Su' class='de'><h1>Method <span class='n'>writeOperator</span></h1><div class='re'><code>writeOperator( self, operator )</code></div><div class='ds'><p>Writes an operator element.</p></div></div><div id='d_Tu' class='de'><h1>Method <span class='n'>writeReference</span></h1><div class='re'><code>writeReference( self, element )</code></div><div class='ds'><p>Writes an argument element.</p></div></div><div id='d_Uu' class='de'><h1>Method <span class='n'>writeRepetition</span></h1><div class='re'><code>writeRepetition( self, repetition )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Vu' class='de'><h1>Method <span class='n'>writeResolution</span></h1><div class='re'><code>writeResolution( self, resolution )</code></div><div class='ds'><p>Writes a resolution operation.</p></div></div><div id='d_Wu' class='de'><h1>Method <span class='n'>writeSelection</span></h1><div class='re'><code>writeSelection( self, selection )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Xu' class='de'><h1>Method <span class='n'>writeSliceOperation</span></h1><div class='re'><code>writeSliceOperation( self, operation )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Yu' class='de'><h1>Method <span class='n'>writeString</span></h1><div class='re'><code>writeString( self, element )</code></div><div class='ds'><p>Writes a string element.</p></div></div><div id='d_Zu' class='de'><h1>Method <span class='n'>writeTermination</span></h1><div class='re'><code>writeTermination( self, termination )</code></div><div class='ds'><p>Writes a termination operation.</p></div></div><div id='d_av' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self, reporter=<lambdafactory.reporter.Reporter instance at 0x11aa058> )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_bv' class='de'><h1>Method <span class='n'>_document</span></h1><div class='re'><code>_document( self, element )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_cv' class='de'><h1>Method <span class='n'>_filterContext</span></h1><div class='re'><code>_filterContext( self, interface )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_dv' class='de'><h1>Method <span class='n'>_format</span></h1><div class='re'><code>_format( self, *values )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_ev' class='de'><h1>Method <span class='n'>_getContextsAsString</span></h1><div class='re'><code>_getContextsAsString( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_fv' class='de'><h1>Method <span class='n'>_unique</span></h1><div class='re'><code>_unique( self, name )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_gv' class='de'><h1>Method <span class='n'>getCurrentClass</span></h1><div class='re'><code>getCurrentClass( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_hv' class='de'><h1>Method <span class='n'>getCurrentClassAncestors</span></h1><div class='re'><code>getCurrentClassAncestors( self, theClass=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_iv' class='de'><h1>Method <span class='n'>getCurrentClassParents</span></h1><div class='re'><code>getCurrentClassParents( self, theClass=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_jv' class='de'><h1>Method <span class='n'>getCurrentClosure</span></h1><div class='re'><code>getCurrentClosure( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_kv' class='de'><h1>Method <span class='n'>getCurrentContext</span></h1><div class='re'><code>getCurrentContext( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_lv' class='de'><h1>Method <span class='n'>getCurrentDataFlow</span></h1><div class='re'><code>getCurrentDataFlow( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_mv' class='de'><h1>Method <span class='n'>getCurrentFunction</span></h1><div class='re'><code>getCurrentFunction( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_nv' class='de'><h1>Method <span class='n'>getCurrentMethod</span></h1><div class='re'><code>getCurrentMethod( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_ov' class='de'><h1>Method <span class='n'>getCurrentModule</span></h1><div class='re'><code>getCurrentModule( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_pv' class='de'><h1>Method <span class='n'>isIn</span></h1><div class='re'><code>isIn( self, interface )</code></div><div class='ds'><p>Tells wether the current element is in a context where at least one of the parent elements define the given interface. It returns <code>-1</code> when no element implements the interface, and otherwise returns the offset of the element, starting from the most recent context.</p><p>To know if you're currently in an assignation: <pre>self.isIn(interfaces.IAssignation)
</pre></p></div></div><div id='d_qv' class='de'><h1>Method <span class='n'>isInClassMethod</span></h1><div class='re'><code>isInClassMethod( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_rv' class='de'><h1>Method <span class='n'>isInInstanceMethod</span></h1><div class='re'><code>isInInstanceMethod( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_sv' class='de'><h1>Method <span class='n'>resolve</span></h1><div class='re'><code>resolve( self, name, dataflow=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_tv' class='de'><h1>Method <span class='n'>resolveAbsoluteOrLocal</span></h1><div class='re'><code>resolveAbsoluteOrLocal( self, name, dataflow=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_uv' class='de'><h1>Method <span class='n'>write</span></h1><div class='re'><code>write( self, element )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_vv' class='de'><h1>Method <span class='n'>writeProgram</span></h1><div class='re'><code>writeProgram( self, programElement )</code></div><div class='ds'><p>Writes a Program element.</p></div></div><div id='d_qu' class='de'><h1>Class <span class='n'>Writer</span></h1><div class='re'></div><div class='ds'><p>This is the default writer implementation that outputs a text-based program representation. You can call the main @write method to get the representatio of any model element.</p></div></div><div id='d_wv' class='de'><h1>Function <span class='n'>_flatten</span></h1><div class='re'><code>_flatten( value, res )</code></div><div class='ds'><p>Flatten helper operation. See @flatten.</p></div></div><div id='d_xv' class='de'><h1>Function <span class='n'>_format</span></h1><div class='re'><code>_format( value, level=-1 )</code></div><div class='ds'><p>Format helper operation. See @format.</p></div></div><div id='d_yv' class='de'><h1>Function <span class='n'>flatten</span></h1><div class='re'><code>flatten( *lists )</code></div><div class='ds'><p>Flattens the given lists in a single list.</p></div></div><div id='d_zv' class='de'><h1>Function <span class='n'>format</span></h1><div class='re'><code>format( *values )</code></div><div class='ds'><p>Formats a combination of string ang tuples. Strings are joined by newlines, and the content of the inner tuples gets indented</p></div></div><div id='d_Av' class='de'><h1>Function <span class='n'>notEmpty</span></h1><div class='re'><code>notEmpty( p )</code></div><div class='ds'><p>Returns None if the given parameter is empty.</p></div></div><div id='d_Bv' class='de'><h1>str</h1><div class='re'><code>'\t'</code></div><div class='ds'><p>str(object) -&gt; string</p><p>Return a nice string representation of the object. If the argument is a string, the return value is the same object.</p></div></div><div id='d_Cv' class='de'><h1>str</h1><div class='re'><code>']---'</code></div><div class='ds'><p>str(object) -&gt; string</p><p>Return a nice string representation of the object. If the argument is a string, the return value is the same object.</p></div></div><div id='d_Dv' class='de'><h1>str</h1><div class='re'><code>'8&lt; ---['</code></div><div class='ds'><p>str(object) -&gt; string</p><p>Return a nice string representation of the object. If the argument is a string, the return value is the same object.</p></div></div><div id='d_Ht' class='de'><h1>Module <span class='n'>lambdafactory.modelwriter</span></h1><div class='re'></div><div class='ds'><p>The <em>model writer</em> modules define a default program model to text conversion class and a set of useful functions to help writing program model to text translators.</p><p>Model writers can be used to convert a program model to source code in a specific language. As writer are stateful, you can add many checkings and transformations while writing a program, or parts of it.</p></div></div><div id='d_Gv' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.modeltypes.TypeCollection at 0x1127f90&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Hv' class='de'><h1>Method <span class='n'>getType</span></h1><div class='re'><code>getType( self, name )</code></div><div class='ds'><p>Returns the type with the given name, or None if it does not exist.</p></div></div><div id='d_Fv' class='de'><h1>Class <span class='n'>Behaviour</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Jv' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.modeltypes.TypeCollection at 0x1127f90&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Kv' class='de'><h1>Method <span class='n'>getType</span></h1><div class='re'><code>getType( self, name )</code></div><div class='ds'><p>Returns the type with the given name, or None if it does not exist.</p></div></div><div id='d_Iv' class='de'><h1>Class <span class='n'>Data</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Mv' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.modeltypes.TypeCollection at 0x1127f90&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Nv' class='de'><h1>Method <span class='n'>getType</span></h1><div class='re'><code>getType( self, name )</code></div><div class='ds'><p>Returns the type with the given name, or None if it does not exist.</p></div></div><div id='d_Lv' class='de'><h1>Class <span class='n'>Operations</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Pv' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.modeltypes.TypeCollection at 0x1127f90&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Qv' class='de'><h1>Method <span class='n'>getType</span></h1><div class='re'><code>getType( self, name )</code></div><div class='ds'><p>Returns the type with the given name, or None if it does not exist.</p></div></div><div id='d_Ov' class='de'><h1>Class <span class='n'>Runtime</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Sv' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.modeltypes.TypeCollection at 0x1127f90&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Tv' class='de'><h1>Method <span class='n'>getType</span></h1><div class='re'><code>getType( self, name )</code></div><div class='ds'><p>Returns the type with the given name, or None if it does not exist.</p></div></div><div id='d_Rv' class='de'><h1>Class <span class='n'>Structure</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Vv' class='de'><h1>Method <span class='n'>getType</span></h1><div class='re'><code>getType( self, name )</code></div><div class='ds'><p>Returns the type with the given name, or None if it does not exist.</p></div></div><div id='d_Uv' class='de'><h1>Class <span class='n'>TypeCollection</span></h1><div class='re'></div><div class='ds'><p>A type collection is a class that contains type definitions which can be easily retrieved using the @getType method.</p></div></div><div id='d_Wv' class='de'><h1>Function <span class='n'>typeForValue</span></h1><div class='re'><code>typeForValue( value, noneIs=<lambdafactory.typecast.Symbolic instance at 0x7bc238> )</code></div><div class='ds'><p>Associates a type with the given value. This basically creates a typecast instance/subtype, using the types defined in this module, using the given value which is a program element (implements interfaces defined in LF <code>interfaces</code> module).</p></div></div><div id='d_Xv' class='de'><h1>NoneType</h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Yv' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.modeltypes.Data at 0x11325a0&gt;, &lt;class lambdafactory.modeltypes.Operations at 0x11329f0&gt;, &lt;class lambdafactory.modeltypes.Structure at 0x1132a20&gt;, &lt;class lambdafactory.modeltypes.Behaviour at 0x1132a50&gt;, &lt;class lambdafactory.modeltypes.Runtime at 0x1132a80&gt;)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Ev' class='de'><h1>Module <span class='n'>lambdafactory.modeltypes</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_bw' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.typecast.Sequence at 0x11328d0&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_cw' class='de'><h1>Method <span class='n'>__call__</span></h1><div class='re'><code>__call__( self )</code></div><div class='ds'><p>A type instance can be used as a class to construct a new type, which will be cloned from the current type.</p></div></div><div id='d_dw' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self, *args )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_ew' class='de'><h1>Method <span class='n'>__str__</span></h1><div class='re'><code>__str__( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_fw' class='de'><h1>Method <span class='n'>add</span></h1><div class='re'><code>add( self, theType )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_gw' class='de'><h1>Method <span class='n'>asString</span></h1><div class='re'><code>asString( self, fromTypes=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_hw' class='de'><h1>Method <span class='n'>clone</span></h1><div class='re'><code>clone( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_iw' class='de'><h1>Method <span class='n'>concreteType</span></h1><div class='re'><code>concreteType( self )</code></div><div class='ds'><p>Returns the <span class='term'>concrete type</span> for this abstract type.</p></div></div><div id='d_jw' class='de'><h1>Method <span class='n'>definedBy</span></h1><div class='re'><code>definedBy( self, definition=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_kw' class='de'><h1>Method <span class='n'>elements</span></h1><div class='re'><code>elements( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_lw' class='de'><h1>Method <span class='n'>extend</span></h1><div class='re'><code>extend( self, othertype )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_mw' class='de'><h1>Method <span class='n'>isLike</span></h1><div class='re'><code>isLike( self, otherType )</code></div><div class='ds'><p>The other type is like this one if the other is a sequence with the same length and that all elements are like the corresponding elements of this sequence.</p></div></div><div id='d_nw' class='de'><h1>Method <span class='n'>isSameAs</span></h1><div class='re'><code>isSameAs( self, otherType )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_ow' class='de'><h1>Method <span class='n'>isSubtypeOf</span></h1><div class='re'><code>isSubtypeOf( self, otherType )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_pw' class='de'><h1>Method <span class='n'>length</span></h1><div class='re'><code>length( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_qw' class='de'><h1>Method <span class='n'>name</span></h1><div class='re'><code>name( self, name=None )</code></div><div class='ds'><p>Returns/sets the name for this type. By defaults, types are unnamed.</p></div></div><div id='d_rw' class='de'><h1>Method <span class='n'>result</span></h1><div class='re'><code>result( self )</code></div><div class='ds'><p>Returns the result for this type. This is usually just the type itself, except for processes types.</p></div></div><div id='d_sw' class='de'><h1>Method <span class='n'>setConcreteType</span></h1><div class='re'><code>setConcreteType( self, value )</code></div><div class='ds'><p>Sets the <span class='term'>concrete type</span> for this abstract type. The concrete type is a value which represents the type. For instance, if this type represents a class, then the concrete type would be the class instance.</p></div></div><div id='d_tw' class='de'><h1>Method <span class='n'>setName</span></h1><div class='re'><code>setName( self, name )</code></div><div class='ds'><p>Sets the name of this type</p></div></div><div id='d_uw' class='de'><h1>Method <span class='n'>subtype</span></h1><div class='re'><code>subtype( self, name )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_aw' class='de'><h1>Class <span class='n'>Arguments</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_ww' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.typecast.Type at 0x11327e0&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_xw' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self, contentType, name=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_yw' class='de'><h1>Method <span class='n'>asString</span></h1><div class='re'><code>asString( self, fromTypes=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_zw' class='de'><h1>Method <span class='n'>content</span></h1><div class='re'><code>content( self )</code></div><div class='ds'><p>Returns the type for the content of this array.</p></div></div><div id='d_Aw' class='de'><h1>Method <span class='n'>isLike</span></h1><div class='re'><code>isLike( self, otherType )</code></div><div class='ds'><p>Othertype must be an Array with a content type that is the same type as the content type.</p></div></div><div id='d_Bw' class='de'><h1>Method <span class='n'>isSameAs</span></h1><div class='re'><code>isSameAs( self, otherType )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Cw' class='de'><h1>Method <span class='n'>isSubtypeOf</span></h1><div class='re'><code>isSubtypeOf( self, otherType )</code></div><div class='ds'><p>Othertype must be an Array with a content type that is a subtype of this content type.</p></div></div><div id='d_Dw' class='de'><h1>Method <span class='n'>setContentType</span></h1><div class='re'><code>setContentType( self, theType )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Ew' class='de'><h1>Method <span class='n'>__call__</span></h1><div class='re'><code>__call__( self )</code></div><div class='ds'><p>A type instance can be used as a class to construct a new type, which will be cloned from the current type.</p></div></div><div id='d_Fw' class='de'><h1>Method <span class='n'>__str__</span></h1><div class='re'><code>__str__( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Gw' class='de'><h1>Method <span class='n'>clone</span></h1><div class='re'><code>clone( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Hw' class='de'><h1>Method <span class='n'>concreteType</span></h1><div class='re'><code>concreteType( self )</code></div><div class='ds'><p>Returns the <span class='term'>concrete type</span> for this abstract type.</p></div></div><div id='d_Iw' class='de'><h1>Method <span class='n'>definedBy</span></h1><div class='re'><code>definedBy( self, definition=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Jw' class='de'><h1>Method <span class='n'>name</span></h1><div class='re'><code>name( self, name=None )</code></div><div class='ds'><p>Returns/sets the name for this type. By defaults, types are unnamed.</p></div></div><div id='d_Kw' class='de'><h1>Method <span class='n'>result</span></h1><div class='re'><code>result( self )</code></div><div class='ds'><p>Returns the result for this type. This is usually just the type itself, except for processes types.</p></div></div><div id='d_Lw' class='de'><h1>Method <span class='n'>setConcreteType</span></h1><div class='re'><code>setConcreteType( self, value )</code></div><div class='ds'><p>Sets the <span class='term'>concrete type</span> for this abstract type. The concrete type is a value which represents the type. For instance, if this type represents a class, then the concrete type would be the class instance.</p></div></div><div id='d_Mw' class='de'><h1>Method <span class='n'>setName</span></h1><div class='re'><code>setName( self, name )</code></div><div class='ds'><p>Sets the name of this type</p></div></div><div id='d_Nw' class='de'><h1>Method <span class='n'>subtype</span></h1><div class='re'><code>subtype( self, name )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_vw' class='de'><h1>Class <span class='n'>Array</span></h1><div class='re'></div><div class='ds'><p>A sequence is simply an ordered set of types.</p></div></div><div id='d_Pw' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.typecast.Type at 0x11327e0&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Qw' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self, length, name=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Rw' class='de'><h1>Method <span class='n'>asString</span></h1><div class='re'><code>asString( self, fromType=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Sw' class='de'><h1>Method <span class='n'>clone</span></h1><div class='re'><code>clone( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Tw' class='de'><h1>Method <span class='n'>isLike</span></h1><div class='re'><code>isLike( self, otherType )</code></div><div class='ds'><p>The other type is like this Cell if the other type is a cell of the same length as this one.</p></div></div><div id='d_Uw' class='de'><h1>Method <span class='n'>isSameAs</span></h1><div class='re'><code>isSameAs( self, otherType )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Vw' class='de'><h1>Method <span class='n'>isSubtypeOf</span></h1><div class='re'><code>isSubtypeOf( self, otherType )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Ww' class='de'><h1>Method <span class='n'>length</span></h1><div class='re'><code>length( self )</code></div><div class='ds'><p>Returns the length (in bytes) for this cell.</p></div></div><div id='d_Xw' class='de'><h1>Method <span class='n'>__call__</span></h1><div class='re'><code>__call__( self )</code></div><div class='ds'><p>A type instance can be used as a class to construct a new type, which will be cloned from the current type.</p></div></div><div id='d_Yw' class='de'><h1>Method <span class='n'>__str__</span></h1><div class='re'><code>__str__( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Zw' class='de'><h1>Method <span class='n'>concreteType</span></h1><div class='re'><code>concreteType( self )</code></div><div class='ds'><p>Returns the <span class='term'>concrete type</span> for this abstract type.</p></div></div><div id='d_ax' class='de'><h1>Method <span class='n'>definedBy</span></h1><div class='re'><code>definedBy( self, definition=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_bx' class='de'><h1>Method <span class='n'>name</span></h1><div class='re'><code>name( self, name=None )</code></div><div class='ds'><p>Returns/sets the name for this type. By defaults, types are unnamed.</p></div></div><div id='d_cx' class='de'><h1>Method <span class='n'>result</span></h1><div class='re'><code>result( self )</code></div><div class='ds'><p>Returns the result for this type. This is usually just the type itself, except for processes types.</p></div></div><div id='d_dx' class='de'><h1>Method <span class='n'>setConcreteType</span></h1><div class='re'><code>setConcreteType( self, value )</code></div><div class='ds'><p>Sets the <span class='term'>concrete type</span> for this abstract type. The concrete type is a value which represents the type. For instance, if this type represents a class, then the concrete type would be the class instance.</p></div></div><div id='d_ex' class='de'><h1>Method <span class='n'>setName</span></h1><div class='re'><code>setName( self, name )</code></div><div class='ds'><p>Sets the name of this type</p></div></div><div id='d_fx' class='de'><h1>Method <span class='n'>subtype</span></h1><div class='re'><code>subtype( self, name )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Ow' class='de'><h1>Class <span class='n'>Cell</span></h1><div class='re'></div><div class='ds'><p>A cell type represents a memory unit. It has a size (in bytes) the represents the length in memory.</p></div></div><div id='d_hx' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.typecast.Map at 0x1132960&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_ix' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self, *args, **kwargs )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_jx' class='de'><h1>Method <span class='n'>clone</span></h1><div class='re'><code>clone( self, clone=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_kx' class='de'><h1>Method <span class='n'>element</span></h1><div class='re'><code>element( self, key )</code></div><div class='ds'><p>Returns the element associated with the given key, or <code>None</code> if it does not exist.</p></div></div><div id='d_lx' class='de'><h1>Method <span class='n'>elements</span></h1><div class='re'><code>elements( self )</code></div><div class='ds'><p>Returns a dict of the elements in this map.</p></div></div><div id='d_mx' class='de'><h1>Method <span class='n'>extends</span></h1><div class='re'><code>extends( self, parent )</code></div><div class='ds'><p>Add a new parent from which this Context inherits.</p></div></div><div id='d_nx' class='de'><h1>Method <span class='n'>fullName</span></h1><div class='re'><code>fullName( self )</code></div><div class='ds'><p>Returns the fully qualified name for this context, by concateniating the chain of parents name with <code>.</code></p></div></div><div id='d_ox' class='de'><h1>Method <span class='n'>parent</span></h1><div class='re'><code>parent( self, parent=None )</code></div><div class='ds'><p>Returns the main parent for this context.</p></div></div><div id='d_px' class='de'><h1>Method <span class='n'>parents</span></h1><div class='re'><code>parents( self )</code></div><div class='ds'><p>Returns a context parents, as a mutable list.</p></div></div><div id='d_qx' class='de'><h1>Method <span class='n'>__call__</span></h1><div class='re'><code>__call__( self )</code></div><div class='ds'><p>A type instance can be used as a class to construct a new type, which will be cloned from the current type.</p></div></div><div id='d_rx' class='de'><h1>Method <span class='n'>__str__</span></h1><div class='re'><code>__str__( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_sx' class='de'><h1>Method <span class='n'>add</span></h1><div class='re'><code>add( self, name, theType )</code></div><div class='ds'><p>This is a <em>deprecated</em> methods that is simply an alias for <code>Map.set</code>.</p></div></div><div id='d_tx' class='de'><h1>Method <span class='n'>asString</span></h1><div class='re'><code>asString( self, fromTypes=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_ux' class='de'><h1>Method <span class='n'>concreteType</span></h1><div class='re'><code>concreteType( self )</code></div><div class='ds'><p>Returns the <span class='term'>concrete type</span> for this abstract type.</p></div></div><div id='d_vx' class='de'><h1>Method <span class='n'>definedBy</span></h1><div class='re'><code>definedBy( self, definition=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_wx' class='de'><h1>Method <span class='n'>elementNames</span></h1><div class='re'><code>elementNames( self )</code></div><div class='ds'><p>Returns the list of slots/elements defined in this map.</p></div></div><div id='d_xx' class='de'><h1>Method <span class='n'>get</span></h1><div class='re'><code>get( self, name )</code></div><div class='ds'><p>Returns the type for the slot with the given name.</p></div></div><div id='d_yx' class='de'><h1>Method <span class='n'>isLike</span></h1><div class='re'><code>isLike( self, otherType )</code></div><div class='ds'><p>The other type is like this one if the other is a sequence with the same length and that all elements are like the corresponding elements of this sequence.</p></div></div><div id='d_zx' class='de'><h1>Method <span class='n'>isSameAs</span></h1><div class='re'><code>isSameAs( self, otherType )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Ax' class='de'><h1>Method <span class='n'>isSubtypeOf</span></h1><div class='re'><code>isSubtypeOf( self, otherType )</code></div><div class='ds'><p>The other type is a subtype of this one if for each element of this type, we find that the other type has a subtype.</p></div></div><div id='d_Bx' class='de'><h1>Method <span class='n'>name</span></h1><div class='re'><code>name( self, name=None )</code></div><div class='ds'><p>Returns/sets the name for this type. By defaults, types are unnamed.</p></div></div><div id='d_Cx' class='de'><h1>Method <span class='n'>result</span></h1><div class='re'><code>result( self )</code></div><div class='ds'><p>Returns the result for this type. This is usually just the type itself, except for processes types.</p></div></div><div id='d_Dx' class='de'><h1>Method <span class='n'>set</span></h1><div class='re'><code>set( self, name, theType )</code></div><div class='ds'><p>Sets the slot with the given <code>name</code> to have a value of the given type (<code>theType</code>).</p></div></div><div id='d_Ex' class='de'><h1>Method <span class='n'>setConcreteType</span></h1><div class='re'><code>setConcreteType( self, value )</code></div><div class='ds'><p>Sets the <span class='term'>concrete type</span> for this abstract type. The concrete type is a value which represents the type. For instance, if this type represents a class, then the concrete type would be the class instance.</p></div></div><div id='d_Fx' class='de'><h1>Method <span class='n'>setName</span></h1><div class='re'><code>setName( self, name )</code></div><div class='ds'><p>Sets the name of this type</p></div></div><div id='d_Gx' class='de'><h1>Method <span class='n'>subtype</span></h1><div class='re'><code>subtype( self, name )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_gx' class='de'><h1>Class <span class='n'>Context</span></h1><div class='re'></div><div class='ds'><p>The Context type is the type that will probably be the most used in OO languages. A context can inherit from other contexts, in which case there is an explicit subtyping relationship.</p></div></div><div id='d_Ix' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Jx' class='de'><h1>Method <span class='n'>register</span></h1><div class='re'><code>register( self, name, _type )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Kx' class='de'><h1>Method <span class='n'>resolve</span></h1><div class='re'><code>resolve( self, typeName )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Hx' class='de'><h1>Class <span class='n'>Environment</span></h1><div class='re'></div><div class='ds'><p>The environment stores types and names them. This allows to easily retrieve types from a given name.</p></div></div><div id='d_Lx' class='de'><h1>Class <span class='n'>InvalidArgument</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Nx' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.typecast.Type at 0x11327e0&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Ox' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self, **kwargs )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Px' class='de'><h1>Method <span class='n'>add</span></h1><div class='re'><code>add( self, name, theType )</code></div><div class='ds'><p>This is a <em>deprecated</em> methods that is simply an alias for <code>Map.set</code>.</p></div></div><div id='d_Qx' class='de'><h1>Method <span class='n'>asString</span></h1><div class='re'><code>asString( self, fromTypes=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Rx' class='de'><h1>Method <span class='n'>clone</span></h1><div class='re'><code>clone( self, clone=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Sx' class='de'><h1>Method <span class='n'>element</span></h1><div class='re'><code>element( self, key )</code></div><div class='ds'><p>Returns the element associated to the given key.</p></div></div><div id='d_Tx' class='de'><h1>Method <span class='n'>elementNames</span></h1><div class='re'><code>elementNames( self )</code></div><div class='ds'><p>Returns the list of slots/elements defined in this map.</p></div></div><div id='d_Ux' class='de'><h1>Method <span class='n'>elements</span></h1><div class='re'><code>elements( self )</code></div><div class='ds'><p>Returns a dict of the elements in this map. Do not modify it.</p></div></div><div id='d_Vx' class='de'><h1>Method <span class='n'>get</span></h1><div class='re'><code>get( self, name )</code></div><div class='ds'><p>Returns the type for the slot with the given name.</p></div></div><div id='d_Wx' class='de'><h1>Method <span class='n'>isLike</span></h1><div class='re'><code>isLike( self, otherType )</code></div><div class='ds'><p>The other type is like this one if the other is a sequence with the same length and that all elements are like the corresponding elements of this sequence.</p></div></div><div id='d_Xx' class='de'><h1>Method <span class='n'>isSameAs</span></h1><div class='re'><code>isSameAs( self, otherType )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Yx' class='de'><h1>Method <span class='n'>isSubtypeOf</span></h1><div class='re'><code>isSubtypeOf( self, otherType )</code></div><div class='ds'><p>The other type is a subtype of this one if for each element of this type, we find that the other type has a subtype.</p></div></div><div id='d_Zx' class='de'><h1>Method <span class='n'>set</span></h1><div class='re'><code>set( self, name, theType )</code></div><div class='ds'><p>Sets the slot with the given <code>name</code> to have a value of the given type (<code>theType</code>).</p></div></div><div id='d_ay' class='de'><h1>Method <span class='n'>__call__</span></h1><div class='re'><code>__call__( self )</code></div><div class='ds'><p>A type instance can be used as a class to construct a new type, which will be cloned from the current type.</p></div></div><div id='d_by' class='de'><h1>Method <span class='n'>__str__</span></h1><div class='re'><code>__str__( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_cy' class='de'><h1>Method <span class='n'>concreteType</span></h1><div class='re'><code>concreteType( self )</code></div><div class='ds'><p>Returns the <span class='term'>concrete type</span> for this abstract type.</p></div></div><div id='d_dy' class='de'><h1>Method <span class='n'>definedBy</span></h1><div class='re'><code>definedBy( self, definition=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_ey' class='de'><h1>Method <span class='n'>name</span></h1><div class='re'><code>name( self, name=None )</code></div><div class='ds'><p>Returns/sets the name for this type. By defaults, types are unnamed.</p></div></div><div id='d_fy' class='de'><h1>Method <span class='n'>result</span></h1><div class='re'><code>result( self )</code></div><div class='ds'><p>Returns the result for this type. This is usually just the type itself, except for processes types.</p></div></div><div id='d_gy' class='de'><h1>Method <span class='n'>setConcreteType</span></h1><div class='re'><code>setConcreteType( self, value )</code></div><div class='ds'><p>Sets the <span class='term'>concrete type</span> for this abstract type. The concrete type is a value which represents the type. For instance, if this type represents a class, then the concrete type would be the class instance.</p></div></div><div id='d_hy' class='de'><h1>Method <span class='n'>setName</span></h1><div class='re'><code>setName( self, name )</code></div><div class='ds'><p>Sets the name of this type</p></div></div><div id='d_iy' class='de'><h1>Method <span class='n'>subtype</span></h1><div class='re'><code>subtype( self, name )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Mx' class='de'><h1>Class <span class='n'>Map</span></h1><div class='re'></div><div class='ds'><p>A map is simply an unordered set of types, mapped to names.</p></div></div><div id='d_ky' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.typecast.Type at 0x11327e0&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_ly' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self, *args )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_my' class='de'><h1>Method <span class='n'>_ensureIntegrity</span></h1><div class='re'><code>_ensureIntegrity( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_ny' class='de'><h1>Method <span class='n'>add</span></h1><div class='re'><code>add( self, theType )</code></div><div class='ds'><p>Adds the given type as an element to this process. The last added type becomes the result if one type was already added, the argument otherwise.</p></div></div><div id='d_oy' class='de'><h1>Method <span class='n'>arguments</span></h1><div class='re'><code>arguments( self, args=None )</code></div><div class='ds'><p>Returns the arguments of this process encapsulated in a sequence if there is more than one argument.</p></div></div><div id='d_py' class='de'><h1>Method <span class='n'>asString</span></h1><div class='re'><code>asString( self, fromTypes=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_qy' class='de'><h1>Method <span class='n'>clone</span></h1><div class='re'><code>clone( self, clone=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_ry' class='de'><h1>Method <span class='n'>elements</span></h1><div class='re'><code>elements( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_sy' class='de'><h1>Method <span class='n'>isLike</span></h1><div class='re'><code>isLike( self, otherType )</code></div><div class='ds'><p>The other type is like this one if the other is a sequence with the same length and that all elements are like the corresponding elements of this sequence.</p></div></div><div id='d_ty' class='de'><h1>Method <span class='n'>isSameAs</span></h1><div class='re'><code>isSameAs( self, otherType )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_uy' class='de'><h1>Method <span class='n'>isSubtypeOf</span></h1><div class='re'><code>isSubtypeOf( self, otherType )</code></div><div class='ds'><p>The other type is like this one if the other is a sequence with the same length and that all elements are like the corresponding elements of this sequence.</p></div></div><div id='d_vy' class='de'><h1>Method <span class='n'>peel</span></h1><div class='re'><code>peel( self )</code></div><div class='ds'><p>If this process is (A, B)-&gt;C, will return (B)-&gt;C. You cannot peel a process that is (B)-&gt;C.</p></div></div><div id='d_wy' class='de'><h1>Method <span class='n'>result</span></h1><div class='re'><code>result( self, result=None )</code></div><div class='ds'><p>If there is not at least 2 addded types, the result is Nothing.</p></div></div><div id='d_xy' class='de'><h1>Method <span class='n'>__call__</span></h1><div class='re'><code>__call__( self )</code></div><div class='ds'><p>A type instance can be used as a class to construct a new type, which will be cloned from the current type.</p></div></div><div id='d_yy' class='de'><h1>Method <span class='n'>__str__</span></h1><div class='re'><code>__str__( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_zy' class='de'><h1>Method <span class='n'>concreteType</span></h1><div class='re'><code>concreteType( self )</code></div><div class='ds'><p>Returns the <span class='term'>concrete type</span> for this abstract type.</p></div></div><div id='d_Ay' class='de'><h1>Method <span class='n'>definedBy</span></h1><div class='re'><code>definedBy( self, definition=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_By' class='de'><h1>Method <span class='n'>name</span></h1><div class='re'><code>name( self, name=None )</code></div><div class='ds'><p>Returns/sets the name for this type. By defaults, types are unnamed.</p></div></div><div id='d_Cy' class='de'><h1>Method <span class='n'>setConcreteType</span></h1><div class='re'><code>setConcreteType( self, value )</code></div><div class='ds'><p>Sets the <span class='term'>concrete type</span> for this abstract type. The concrete type is a value which represents the type. For instance, if this type represents a class, then the concrete type would be the class instance.</p></div></div><div id='d_Dy' class='de'><h1>Method <span class='n'>setName</span></h1><div class='re'><code>setName( self, name )</code></div><div class='ds'><p>Sets the name of this type</p></div></div><div id='d_Ey' class='de'><h1>Method <span class='n'>subtype</span></h1><div class='re'><code>subtype( self, name )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_jy' class='de'><h1>Class <span class='n'>Process</span></h1><div class='re'></div><div class='ds'><p>A process generates values by processing (optional) arguments.</p></div></div><div id='d_Fy' class='de'><h1>Class <span class='n'>SemanticError</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Hy' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.typecast.Type at 0x11327e0&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Iy' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self, *args )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Jy' class='de'><h1>Method <span class='n'>add</span></h1><div class='re'><code>add( self, theType )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Ky' class='de'><h1>Method <span class='n'>asString</span></h1><div class='re'><code>asString( self, fromTypes=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Ly' class='de'><h1>Method <span class='n'>elements</span></h1><div class='re'><code>elements( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_My' class='de'><h1>Method <span class='n'>extend</span></h1><div class='re'><code>extend( self, othertype )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Ny' class='de'><h1>Method <span class='n'>isLike</span></h1><div class='re'><code>isLike( self, otherType )</code></div><div class='ds'><p>The other type is like this one if the other is a sequence with the same length and that all elements are like the corresponding elements of this sequence.</p></div></div><div id='d_Oy' class='de'><h1>Method <span class='n'>isSameAs</span></h1><div class='re'><code>isSameAs( self, otherType )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Py' class='de'><h1>Method <span class='n'>isSubtypeOf</span></h1><div class='re'><code>isSubtypeOf( self, otherType )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Qy' class='de'><h1>Method <span class='n'>length</span></h1><div class='re'><code>length( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Ry' class='de'><h1>Method <span class='n'>__call__</span></h1><div class='re'><code>__call__( self )</code></div><div class='ds'><p>A type instance can be used as a class to construct a new type, which will be cloned from the current type.</p></div></div><div id='d_Sy' class='de'><h1>Method <span class='n'>__str__</span></h1><div class='re'><code>__str__( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Ty' class='de'><h1>Method <span class='n'>clone</span></h1><div class='re'><code>clone( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Uy' class='de'><h1>Method <span class='n'>concreteType</span></h1><div class='re'><code>concreteType( self )</code></div><div class='ds'><p>Returns the <span class='term'>concrete type</span> for this abstract type.</p></div></div><div id='d_Vy' class='de'><h1>Method <span class='n'>definedBy</span></h1><div class='re'><code>definedBy( self, definition=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Wy' class='de'><h1>Method <span class='n'>name</span></h1><div class='re'><code>name( self, name=None )</code></div><div class='ds'><p>Returns/sets the name for this type. By defaults, types are unnamed.</p></div></div><div id='d_Xy' class='de'><h1>Method <span class='n'>result</span></h1><div class='re'><code>result( self )</code></div><div class='ds'><p>Returns the result for this type. This is usually just the type itself, except for processes types.</p></div></div><div id='d_Yy' class='de'><h1>Method <span class='n'>setConcreteType</span></h1><div class='re'><code>setConcreteType( self, value )</code></div><div class='ds'><p>Sets the <span class='term'>concrete type</span> for this abstract type. The concrete type is a value which represents the type. For instance, if this type represents a class, then the concrete type would be the class instance.</p></div></div><div id='d_Zy' class='de'><h1>Method <span class='n'>setName</span></h1><div class='re'><code>setName( self, name )</code></div><div class='ds'><p>Sets the name of this type</p></div></div><div id='d_az' class='de'><h1>Method <span class='n'>subtype</span></h1><div class='re'><code>subtype( self, name )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Gy' class='de'><h1>Class <span class='n'>Sequence</span></h1><div class='re'></div><div class='ds'><p>A sequence is simply an ordered set of types.</p></div></div><div id='d_cz' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.typecast.Type at 0x11327e0&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_dz' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self, name )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_ez' class='de'><h1>Method <span class='n'>asString</span></h1><div class='re'><code>asString( self, fromType=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_fz' class='de'><h1>Method <span class='n'>clone</span></h1><div class='re'><code>clone( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_gz' class='de'><h1>Method <span class='n'>__call__</span></h1><div class='re'><code>__call__( self )</code></div><div class='ds'><p>A type instance can be used as a class to construct a new type, which will be cloned from the current type.</p></div></div><div id='d_hz' class='de'><h1>Method <span class='n'>__str__</span></h1><div class='re'><code>__str__( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_iz' class='de'><h1>Method <span class='n'>concreteType</span></h1><div class='re'><code>concreteType( self )</code></div><div class='ds'><p>Returns the <span class='term'>concrete type</span> for this abstract type.</p></div></div><div id='d_jz' class='de'><h1>Method <span class='n'>definedBy</span></h1><div class='re'><code>definedBy( self, definition=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_kz' class='de'><h1>Method <span class='n'>isLike</span></h1><div class='re'><code>isLike( self, otherType )</code></div><div class='ds'><p>Generic implementation of isLike. You should always call this method in subclasses, as it implements basic type systems rules such as isLike(Any).</p></div></div><div id='d_lz' class='de'><h1>Method <span class='n'>isSameAs</span></h1><div class='re'><code>isSameAs( self, otherType )</code></div><div class='ds'><p>Generic implementation of isSameAs. You should always call this method in subclasses.</p></div></div><div id='d_mz' class='de'><h1>Method <span class='n'>isSubtypeOf</span></h1><div class='re'><code>isSubtypeOf( self, otherType )</code></div><div class='ds'><p>Generic implementation of isSubtypeOf. You should always call this method in subclasses, as it implements basic type systems rules such as isSubtypeOf(Any).</p></div></div><div id='d_nz' class='de'><h1>Method <span class='n'>name</span></h1><div class='re'><code>name( self, name=None )</code></div><div class='ds'><p>Returns/sets the name for this type. By defaults, types are unnamed.</p></div></div><div id='d_oz' class='de'><h1>Method <span class='n'>result</span></h1><div class='re'><code>result( self )</code></div><div class='ds'><p>Returns the result for this type. This is usually just the type itself, except for processes types.</p></div></div><div id='d_pz' class='de'><h1>Method <span class='n'>setConcreteType</span></h1><div class='re'><code>setConcreteType( self, value )</code></div><div class='ds'><p>Sets the <span class='term'>concrete type</span> for this abstract type. The concrete type is a value which represents the type. For instance, if this type represents a class, then the concrete type would be the class instance.</p></div></div><div id='d_qz' class='de'><h1>Method <span class='n'>setName</span></h1><div class='re'><code>setName( self, name )</code></div><div class='ds'><p>Sets the name of this type</p></div></div><div id='d_rz' class='de'><h1>Method <span class='n'>subtype</span></h1><div class='re'><code>subtype( self, name )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_bz' class='de'><h1>Class <span class='n'>Symbolic</span></h1><div class='re'></div><div class='ds'><p>Symbolic types are types that have no physical counter part but play a role in the type system. This is for instance the case with Any or Nil.</p></div></div><div id='d_tz' class='de'><h1>Method <span class='n'>__call__</span></h1><div class='re'><code>__call__( self )</code></div><div class='ds'><p>A type instance can be used as a class to construct a new type, which will be cloned from the current type.</p></div></div><div id='d_uz' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self, name=None )</code></div><div class='ds'><p>Creates a new anonymous type</p></div></div><div id='d_vz' class='de'><h1>Method <span class='n'>__str__</span></h1><div class='re'><code>__str__( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_wz' class='de'><h1>Method <span class='n'>asString</span></h1><div class='re'><code>asString( self, fromTypes=None )</code></div><div class='ds'><p>Returns a string representation of this type.</p></div></div><div id='d_xz' class='de'><h1>Method <span class='n'>clone</span></h1><div class='re'><code>clone( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_yz' class='de'><h1>Method <span class='n'>concreteType</span></h1><div class='re'><code>concreteType( self )</code></div><div class='ds'><p>Returns the <span class='term'>concrete type</span> for this abstract type.</p></div></div><div id='d_zz' class='de'><h1>Method <span class='n'>definedBy</span></h1><div class='re'><code>definedBy( self, definition=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Az' class='de'><h1>Method <span class='n'>isLike</span></h1><div class='re'><code>isLike( self, otherType )</code></div><div class='ds'><p>Generic implementation of isLike. You should always call this method in subclasses, as it implements basic type systems rules such as isLike(Any).</p></div></div><div id='d_Bz' class='de'><h1>Method <span class='n'>isSameAs</span></h1><div class='re'><code>isSameAs( self, otherType )</code></div><div class='ds'><p>Generic implementation of isSameAs. You should always call this method in subclasses.</p></div></div><div id='d_Cz' class='de'><h1>Method <span class='n'>isSubtypeOf</span></h1><div class='re'><code>isSubtypeOf( self, otherType )</code></div><div class='ds'><p>Generic implementation of isSubtypeOf. You should always call this method in subclasses, as it implements basic type systems rules such as isSubtypeOf(Any).</p></div></div><div id='d_Dz' class='de'><h1>Method <span class='n'>name</span></h1><div class='re'><code>name( self, name=None )</code></div><div class='ds'><p>Returns/sets the name for this type. By defaults, types are unnamed.</p></div></div><div id='d_Ez' class='de'><h1>Method <span class='n'>result</span></h1><div class='re'><code>result( self )</code></div><div class='ds'><p>Returns the result for this type. This is usually just the type itself, except for processes types.</p></div></div><div id='d_Fz' class='de'><h1>Method <span class='n'>setConcreteType</span></h1><div class='re'><code>setConcreteType( self, value )</code></div><div class='ds'><p>Sets the <span class='term'>concrete type</span> for this abstract type. The concrete type is a value which represents the type. For instance, if this type represents a class, then the concrete type would be the class instance.</p></div></div><div id='d_Gz' class='de'><h1>Method <span class='n'>setName</span></h1><div class='re'><code>setName( self, name )</code></div><div class='ds'><p>Sets the name of this type</p></div></div><div id='d_Hz' class='de'><h1>Method <span class='n'>subtype</span></h1><div class='re'><code>subtype( self, name )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_sz' class='de'><h1>Class <span class='n'>Type</span></h1><div class='re'></div><div class='ds'><p>Abstract class for all types.</p></div></div><div id='d_Jz' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.typecast.Symbolic at 0x1132810&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Kz' class='de'><h1>Method <span class='n'>__call__</span></h1><div class='re'><code>__call__( self )</code></div><div class='ds'><p>A type instance can be used as a class to construct a new type, which will be cloned from the current type.</p></div></div><div id='d_Lz' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self, name )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Mz' class='de'><h1>Method <span class='n'>__str__</span></h1><div class='re'><code>__str__( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Nz' class='de'><h1>Method <span class='n'>asString</span></h1><div class='re'><code>asString( self, fromType=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Oz' class='de'><h1>Method <span class='n'>clone</span></h1><div class='re'><code>clone( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Pz' class='de'><h1>Method <span class='n'>concreteType</span></h1><div class='re'><code>concreteType( self )</code></div><div class='ds'><p>Returns the <span class='term'>concrete type</span> for this abstract type.</p></div></div><div id='d_Qz' class='de'><h1>Method <span class='n'>definedBy</span></h1><div class='re'><code>definedBy( self, definition=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Rz' class='de'><h1>Method <span class='n'>isLike</span></h1><div class='re'><code>isLike( self, otherType )</code></div><div class='ds'><p>Generic implementation of isLike. You should always call this method in subclasses, as it implements basic type systems rules such as isLike(Any).</p></div></div><div id='d_Sz' class='de'><h1>Method <span class='n'>isSameAs</span></h1><div class='re'><code>isSameAs( self, otherType )</code></div><div class='ds'><p>Generic implementation of isSameAs. You should always call this method in subclasses.</p></div></div><div id='d_Tz' class='de'><h1>Method <span class='n'>isSubtypeOf</span></h1><div class='re'><code>isSubtypeOf( self, otherType )</code></div><div class='ds'><p>Generic implementation of isSubtypeOf. You should always call this method in subclasses, as it implements basic type systems rules such as isSubtypeOf(Any).</p></div></div><div id='d_Uz' class='de'><h1>Method <span class='n'>name</span></h1><div class='re'><code>name( self, name=None )</code></div><div class='ds'><p>Returns/sets the name for this type. By defaults, types are unnamed.</p></div></div><div id='d_Vz' class='de'><h1>Method <span class='n'>result</span></h1><div class='re'><code>result( self )</code></div><div class='ds'><p>Returns the result for this type. This is usually just the type itself, except for processes types.</p></div></div><div id='d_Wz' class='de'><h1>Method <span class='n'>setConcreteType</span></h1><div class='re'><code>setConcreteType( self, value )</code></div><div class='ds'><p>Sets the <span class='term'>concrete type</span> for this abstract type. The concrete type is a value which represents the type. For instance, if this type represents a class, then the concrete type would be the class instance.</p></div></div><div id='d_Xz' class='de'><h1>Method <span class='n'>setName</span></h1><div class='re'><code>setName( self, name )</code></div><div class='ds'><p>Sets the name of this type</p></div></div><div id='d_Yz' class='de'><h1>Method <span class='n'>subtype</span></h1><div class='re'><code>subtype( self, name )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Iz' class='de'><h1>Class <span class='n'>Unresolved</span></h1><div class='re'></div><div class='ds'><p>Unresolved types are temporary types that can be resolved later when necessary.</p></div></div><div id='d_Zz' class='de'><h1>Function <span class='n'>Class</span></h1><div class='re'><code>Class( Context )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_aA' class='de'><h1>Function <span class='n'>Interface</span></h1><div class='re'><code>Interface( Context )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_bA' class='de'><h1>Function <span class='n'>Sequence_combine</span></h1><div class='re'><code>Sequence_combine( a, b, sequenceclass=<class lambdafactory.typecast.Sequence at 0x11328d0> )</code></div><div class='ds'><p>Combines the given arguments into a sequence. This follows the following rules: Nothing, Nothing -&gt; Nothing Nothing, A -&gt; A A, B -&gt; (A, B) (A, B), C -&gt; (A, B, C) ( type = type(a) ) (A, B), (C, D) -&gt; (A, B, C, D) ( type = type(a) ) A , (C, D) -&gt; (A, B, C) ( type = sequenceclass)</p></div></div><div id='d_cA' class='de'><h1>Function <span class='n'>Sequence_make</span></h1><div class='re'><code>Sequence_make( args, sequenceclass=<class lambdafactory.typecast.Sequence at 0x11328d0> )</code></div><div class='ds'><p>Tries to make a sequence from the given argumnents. This follows the following rules:</p><blockquote><div class='content'><p>len(args) == 0 -&gt; Nothing len(args) == 1 -&gt; args[1] otherwise -&gt; (args&hellip;.)</p></div></blockquote></div></div><div id='d_dA' class='de'><h1>Function <span class='n'>bits</span></h1><div class='re'><code>bits( size )</code></div><div class='ds'><p>Converts the given number of bits into bytes. This is simply for readibility purprose.</p></div></div><div id='d_eA' class='de'><h1>Function <span class='n'>isLike</span></h1><div class='re'><code>isLike( a, b )</code></div><div class='ds'><p>Type (b) is like type (a) if (b) can be used where (a) can be used. When two types are alike but not the same, this usually means that one type is composed at some level of <code>Any</code> or <code>Rest</code> types.</p><p>Not that isLike(a,b) does not imply isLike(b,a), as (a) may be a "broad" type (such as <code>Any</code>), and (b) a particular type (say <code>String</code>).</p></div></div><div id='d_fA' class='de'><h1>Function <span class='n'>isSame</span></h1><div class='re'><code>isSame( a, b )</code></div><div class='ds'><p>Type (b) is the same as (a) if (a) and (b) are identicial, that means that you can use b where you use a, and this also means that isSame(a,b) == isSame(b,a). Basically, when (b) is same as (a), (b) can be considered as an alias for (a).</p></div></div><div id='d_gA' class='de'><h1>Function <span class='n'>isSubtype</span></h1><div class='re'><code>isSubtype( a, b )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_hA' class='de'><h1>Function <span class='n'>isType</span></h1><div class='re'><code>isType( a )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_iA' class='de'><h1>instance</h1><div class='re'></div><div class='ds'><p>Symbolic types are types that have no physical counter part but play a role in the type system. This is for instance the case with Any or Nil.</p></div></div><div id='d_jA' class='de'><h1>instance</h1><div class='re'></div><div class='ds'><p>Symbolic types are types that have no physical counter part but play a role in the type system. This is for instance the case with Any or Nil.</p></div></div><div id='d_kA' class='de'><h1>instance</h1><div class='re'></div><div class='ds'><p>Symbolic types are types that have no physical counter part but play a role in the type system. This is for instance the case with Any or Nil.</p></div></div><div id='d_lA' class='de'><h1>instance</h1><div class='re'></div><div class='ds'><p>Symbolic types are types that have no physical counter part but play a role in the type system. This is for instance the case with Any or Nil.</p></div></div><div id='d_Zv' class='de'><h1>Module <span class='n'>lambdafactory.typecast</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_oA' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.passes.Pass at 0x1147b70&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_pA' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_qA' class='de'><h1>Method <span class='n'>onModule</span></h1><div class='re'><code>onModule( self, context, module )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_rA' class='de'><h1>Method <span class='n'>getHandle</span></h1><div class='re'><code>getHandle( self, element )</code></div><div class='ds'><p>Tells if the pass handles the given element. This basically iterates on the <code>handles</code> property values (which are interfaces), when one interface matches the given <code>element</code>, then the corresponding <code>onXXX</code> method is invoked, where <code>XXX</code> is the interface name (without the leading <code>I</code>).</p></div></div><div id='d_sA' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.IModule at 0x5bf810&gt;]</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='d_tA' class='de'><h1>str</h1><div class='re'><code>'Importation'</code></div><div class='ds'><p>str(object) -&gt; string</p><p>Return a nice string representation of the object. If the argument is a string, the return value is the same object.</p></div></div><div id='d_nA' class='de'><h1>Class <span class='n'>ImportationPass</span></h1><div class='re'></div><div class='ds'><p>The importation pass will look for importation operations (<code>IImportation</code>), will try to resolve the importations (according to the current environment) and will trigger the loading and parsing of each module into the current program.</p></div></div><div id='d_vA' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_wA' class='de'><h1>Method <span class='n'>getHandle</span></h1><div class='re'><code>getHandle( self, element )</code></div><div class='ds'><p>Tells if the pass handles the given element. This basically iterates on the <code>handles</code> property values (which are interfaces), when one interface matches the given <code>element</code>, then the corresponding <code>onXXX</code> method is invoked, where <code>XXX</code> is the interface name (without the leading <code>I</code>).</p></div></div><div id='d_xA' class='de'><h1>list</h1><div class='re'><code>[]</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='d_yA' class='de'><h1>str</h1><div class='re'><code>''</code></div><div class='ds'><p>str(object) -&gt; string</p><p>Return a nice string representation of the object. If the argument is a string, the return value is the same object.</p></div></div><div id='d_uA' class='de'><h1>Class <span class='n'>Pass</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_AA' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self, environment )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_BA' class='de'><h1>Method <span class='n'>filter</span></h1><div class='re'><code>filter( self, list, interface )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_CA' class='de'><h1>Method <span class='n'>filterContext</span></h1><div class='re'><code>filterContext( self, interface )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_DA' class='de'><h1>Method <span class='n'>findInContext</span></h1><div class='re'><code>findInContext( self, interface )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_EA' class='de'><h1>Method <span class='n'>getCurrentClass</span></h1><div class='re'><code>getCurrentClass( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_FA' class='de'><h1>Method <span class='n'>getCurrentClassParents</span></h1><div class='re'><code>getCurrentClassParents( self, theClass )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_GA' class='de'><h1>Method <span class='n'>getCurrentClosure</span></h1><div class='re'><code>getCurrentClosure( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_HA' class='de'><h1>Method <span class='n'>getCurrentFunction</span></h1><div class='re'><code>getCurrentFunction( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_IA' class='de'><h1>Method <span class='n'>getCurrentMethod</span></h1><div class='re'><code>getCurrentMethod( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_JA' class='de'><h1>Method <span class='n'>getCurrentProcess</span></h1><div class='re'><code>getCurrentProcess( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_KA' class='de'><h1>Method <span class='n'>isIn</span></h1><div class='re'><code>isIn( self, interface )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_LA' class='de'><h1>Method <span class='n'>resolve</span></h1><div class='re'><code>resolve( self, referenceOrName, contextOrDataFlow=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_MA' class='de'><h1>Method <span class='n'>run</span></h1><div class='re'><code>run( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_NA' class='de'><h1>Method <span class='n'>walk</span></h1><div class='re'><code>walk( self, element )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_zA' class='de'><h1>Class <span class='n'>PassContext</span></h1><div class='re'></div><div class='ds'><p>The <code>PassContext</code> represents the current state of one or more passes when walking the program. It offers access to the <code>environment</code> (gives access to the program and various passes).</p><p>A single context can be shared among various passes.</p></div></div><div id='d_PA' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.passes.Pass at 0x1147b70&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_QA' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_RA' class='de'><h1>Method <span class='n'>getHandle</span></h1><div class='re'><code>getHandle( self, element )</code></div><div class='ds'><p>Tells if the pass handles the given element. This basically iterates on the <code>handles</code> property values (which are interfaces), when one interface matches the given <code>element</code>, then the corresponding <code>onXXX</code> method is invoked, where <code>XXX</code> is the interface name (without the leading <code>I</code>).</p></div></div><div id='d_SA' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.IClosure at 0x5bf900&gt;]</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='d_TA' class='de'><h1>str</h1><div class='re'><code>'AsynchronousInvocationsExpansion'</code></div><div class='ds'><p>str(object) -&gt; string</p><p>Return a nice string representation of the object. If the argument is a string, the return value is the same object.</p></div></div><div id='d_OA' class='de'><h1>Class <span class='n'>TransformAsynchronousInvocations</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_mA' class='de'><h1>Module <span class='n'>lambdafactory.passes</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_WA' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_XA' class='de'><h1>Method <span class='n'>dedent</span></h1><div class='re'><code>dedent( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_YA' class='de'><h1>Method <span class='n'>echoError</span></h1><div class='re'><code>echoError( self, message, element )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_ZA' class='de'><h1>Method <span class='n'>echoWarning</span></h1><div class='re'><code>echoWarning( self, message, element )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_aB' class='de'><h1>Method <span class='n'>error</span></h1><div class='re'><code>error( self, message, element=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_bB' class='de'><h1>Method <span class='n'>indent</span></h1><div class='re'><code>indent( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_cB' class='de'><h1>Method <span class='n'>info</span></h1><div class='re'><code>info( self, *message )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_dB' class='de'><h1>Method <span class='n'>isDone</span></h1><div class='re'><code>isDone( self, message, element, update=True )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_eB' class='de'><h1>Method <span class='n'>onError</span></h1><div class='re'><code>onError( self, callback )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_fB' class='de'><h1>Method <span class='n'>onWarning</span></h1><div class='re'><code>onWarning( self, callback )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_gB' class='de'><h1>Method <span class='n'>warning</span></h1><div class='re'><code>warning( self, message, element=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_VA' class='de'><h1>Class <span class='n'>Reporter</span></h1><div class='re'></div><div class='ds'><p>The reporter aggregates error reports that may happen during model construction and the different phases (dataflowing, typing, writing, etc).</p></div></div><div id='d_hB' class='de'><h1>instance</h1><div class='re'></div><div class='ds'><p>The reporter aggregates error reports that may happen during model construction and the different phases (dataflowing, typing, writing, etc).</p></div></div><div id='d_UA' class='de'><h1>Module <span class='n'>lambdafactory.reporter</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div>
	<!-- descriptions-snip -->
</div>
<div id='hidden'>
	<!-- hidden-snip -->
	<div id='d_Wn' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_Wo' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_Wl' class='de'><h1>Class <span class='n'>IInvocation</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Wm' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IMatchOperation at 0x5bfd50&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Wj' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_Wk' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><p>Adds an argument to this operation. This should do checking of arguments (by expected internal type and number).</p></div></div><div id='d_Wh' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><p>Returns the arguments to this operation.</p></div></div><div id='d_Wi' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><p>Adds an argument to this operation. This should do checking of arguments (by expected internal type and number).</p></div></div><div id='d_Wf' class='de'><h1>Method <span class='n'>isAbstract</span></h1><div class='re'><code>isAbstract( self )</code></div><div class='ds'><p>Tells wether the given abstractable is abstract or not.</p></div></div><div id='d_Wg' class='de'><h1>Method <span class='n'>getLanguage</span></h1><div class='re'><code>getLanguage( self )</code></div><div class='ds'><p>Returns the language in which the emebedded code is written.</p></div></div><div id='d_Wd' class='de'><h1>Method <span class='n'>getSlots</span></h1><div class='re'><code>getSlots( self )</code></div><div class='ds'><p>Returns (key, evaluable) pairs representing the slots within this context.</p></div></div><div id='d_We' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, context )</code></div><div class='ds'><p>Sets the parent context for this context.</p></div></div><div id='d_Wb' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IOperation at 0x5bfa50&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Wc' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_Wz' class='de'><h1>Method <span class='n'>setConcreteType</span></h1><div class='re'><code>setConcreteType( self, value )</code></div><div class='ds'><p>Sets the <span class='term'>concrete type</span> for this abstract type. The concrete type is a value which represents the type. For instance, if this type represents a class, then the concrete type would be the class instance.</p></div></div><div id='d_Wx' class='de'><h1>Method <span class='n'>isLike</span></h1><div class='re'><code>isLike( self, otherType )</code></div><div class='ds'><p>The other type is like this one if the other is a sequence with the same length and that all elements are like the corresponding elements of this sequence.</p></div></div><div id='d_Wy' class='de'><h1>Method <span class='n'>name</span></h1><div class='re'><code>name( self, name=None )</code></div><div class='ds'><p>Returns/sets the name for this type. By defaults, types are unnamed.</p></div></div><div id='d_Wv' class='de'><h1>Function <span class='n'>typeForValue</span></h1><div class='re'><code>typeForValue( value, noneIs=<lambdafactory.typecast.Symbolic instance at 0x7bc238> )</code></div><div class='ds'><p>Associates a type with the given value. This basically creates a typecast instance/subtype, using the types defined in this module, using the given value which is a program element (implements interfaces defined in LF <code>interfaces</code> module).</p></div></div><div id='d_Ww' class='de'><h1>Method <span class='n'>length</span></h1><div class='re'><code>length( self )</code></div><div class='ds'><p>Returns the length (in bytes) for this cell.</p></div></div><div id='d_Wt' class='de'><h1>Method <span class='n'>getCurrentMethod</span></h1><div class='re'><code>getCurrentMethod( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Wu' class='de'><h1>Method <span class='n'>writeSelection</span></h1><div class='re'><code>writeSelection( self, selection )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Wr' class='de'><h1>Method <span class='n'>getLine</span></h1><div class='re'><code>getLine( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Ws' class='de'><h1>Method <span class='n'>createDestructor</span></h1><div class='re'><code>createDestructor( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Wp' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><p>Returns the local name for this referencable element</p></div></div><div id='d_Wq' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><p>Returns the arguments to this operation.</p></div></div><div id='d_WA' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_EA' class='de'><h1>Method <span class='n'>getCurrentClass</span></h1><div class='re'><code>getCurrentClass( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Ep' class='de'><h1>Method <span class='n'>getFactory</span></h1><div class='re'><code>getFactory( self )</code></div><div class='ds'><p>Gets the factory that was used to create this program. It can be used to create more elements in the program.</p></div></div><div id='d_Eq' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_Er' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_Es' class='de'><h1>Method <span class='n'>_moduleattr</span></h1><div class='re'><code>_moduleattr( self, name, typeinfo=None, value=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Et' class='de'><h1>Class <span class='n'>ModelException</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Eu' class='de'><h1>Method <span class='n'>writeDict</span></h1><div class='re'><code>writeDict( self, element )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Ev' class='de'><h1>Module <span class='n'>lambdafactory.modeltypes</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Ew' class='de'><h1>Method <span class='n'>__call__</span></h1><div class='re'><code>__call__( self )</code></div><div class='ds'><p>A type instance can be used as a class to construct a new type, which will be cloned from the current type.</p></div></div><div id='d_Ex' class='de'><h1>Method <span class='n'>setConcreteType</span></h1><div class='re'><code>setConcreteType( self, value )</code></div><div class='ds'><p>Sets the <span class='term'>concrete type</span> for this abstract type. The concrete type is a value which represents the type. For instance, if this type represents a class, then the concrete type would be the class instance.</p></div></div><div id='d_Ey' class='de'><h1>Method <span class='n'>subtype</span></h1><div class='re'><code>subtype( self, name )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Ez' class='de'><h1>Method <span class='n'>result</span></h1><div class='re'><code>result( self )</code></div><div class='ds'><p>Returns the result for this type. This is usually just the type itself, except for processes types.</p></div></div><div id='Gy' class='cr'><div class='n'><a href='javascript:dS("Gy");'>Sequence</a></div><div class='t'>Bases</div class='t'><div class='g'><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("Gy","Hy");'><span class='special __bases__'>Type</span></a></span><br /></div><div class='t'>Methods</div class='t'><div class='g'><span class='u'><span class='prefix'>&equiv;</span><a href='javascript:dO("Gy","Iy");'><span class='special __init__'>constructor</span></a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("Gy","Jy");'>add</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("Gy","Ky");'>asString</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("Gy","Ly");'>elements</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("Gy","My");'>extend</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Gy","Ny");'>isLike</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("Gy","Oy");'>isSameAs</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("Gy","Py");'>isSubtypeOf</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("Gy","Qy");'>length</a></span><br /></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("Gy","Ry");'><span class='special __call__'>when invoked</span></a></span><br /><span class='u'><span class='prefix'>&equiv;</span><a href='javascript:dO("Gy","Sy");'><span class='special __str__'>string conversion</span></a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("Gy","Ty");'>clone</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Gy","Uy");'>concreteType</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("Gy","Vy");'>definedBy</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Gy","Wy");'>name</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Gy","Xy");'>result</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Gy","Yy");'>setConcreteType</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Gy","Zy");'>setName</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("Gy","az");'>subtype</a></span><br /></div></div><div id='Gf' class='cr'><div class='n'><a href='javascript:dS("Gf");'>IDestructor</a></div><div class='t'>Bases</div class='t'><div class='g'><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("Gf","Hf");'><span class='special __bases__'>IMethod</span></a></span><br /></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Gf","If");'>addOperation</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Gf","Jf");'>endsWithTermination</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Gf","Kf");'>getAbsoluteName</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Gf","Lf");'>getAbstractType</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Gf","Mf");'>getAnnotation</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("Gf","Nf");'>getArguments</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Gf","Of");'>getDataFlow</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Gf","Pf");'>getName</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Gf","Qf");'>getOperations</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Gf","Rf");'>getParent</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Gf","Sf");'>getSlot</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Gf","Tf");'>getSlots</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Gf","Uf");'>hasExplicitTermination</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Gf","Vf");'>hasSlot</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Gf","Wf");'>isAbstract</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Gf","Xf");'>setAbstract</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Gf","Yf");'>setAbstractType</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Gf","Zf");'>setAnnotation</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("Gf","ag");'>setArguments</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Gf","bg");'>setParent</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Gf","cg");'>setSlot</a></span><br /></div></div><div id='d_Eb' class='de'><h1>Class <span class='n'>IAnnotation</span></h1><div class='re'></div><div class='ds'><p>An annotation is some information that is not used for the actual program, but annotates/gives meta-information about is elements.</p></div></div><div id='d_Ec' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_Ed' class='de'><h1>Method <span class='n'>isAbstract</span></h1><div class='re'><code>isAbstract( self )</code></div><div class='ds'><p>Tells wether the given abstractable is abstract or not.</p></div></div><div id='d_Ee' class='de'><h1>Method <span class='n'>endsWithTermination</span></h1><div class='re'><code>endsWithTermination( self )</code></div><div class='ds'><p>Returns true if this function ends with a termination operation. This is especially useful for back-ends which want to know if they have to insert an explicit <code>return</code> at the end (like Java).</p></div></div><div id='d_Ef' class='de'><h1>Method <span class='n'>getOrigin</span></h1><div class='re'><code>getOrigin( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Eg' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><p>Adds an argument to this operation. This should do checking of arguments (by expected internal type and number).</p></div></div><div id='d_Eh' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_Ei' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IImportOperation at 0x5bfa80&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Ej' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><p>Returns the arguments to this operation.</p></div></div><div id='d_Ek' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_El' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_Em' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_En' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><p>Adds an argument to this operation. This should do checking of arguments (by expected internal type and number).</p></div></div><div id='d_Eo' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_YA' class='de'><h1>Method <span class='n'>echoError</span></h1><div class='re'><code>echoError( self, message, element )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Yd' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_Ye' class='de'><h1>Class <span class='n'>IContext</span></h1><div class='re'></div><div class='ds'><p>A context is an element that has slots, which bind evaluable elements (aka values) to names.</p></div></div><div id='d_Yf' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_Yg' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><p>Returns the arguments to this operation.</p></div></div><div id='d_Yb' class='de'><h1>Method <span class='n'>getTarget</span></h1><div class='re'><code>getTarget( self )</code></div><div class='ds'><p>Returns this assignation target reference, which can be an evaluable (in case you assign to self.something, or a reference)</p></div></div><div id='d_Yc' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_Yl' class='de'><h1>Method <span class='n'>getArguments</span></h1><div class='re'><code>getArguments( self )</code></div><div class='ds'><p>Returns evaluable arguments.</p></div></div><div id='d_Ym' class='de'><h1>Method <span class='n'>setExpression</span></h1><div class='re'><code>setExpression( self, v )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Yn' class='de'><h1>Method <span class='n'>getArguments</span></h1><div class='re'><code>getArguments( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Yo' class='de'><h1>Class <span class='n'>IOperation</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Yh' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_Yi' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_Yj' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><p>Sets the given argument of this operation, by argument index.</p></div></div><div id='d_Yk' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_Yt' class='de'><h1>Method <span class='n'>isIn</span></h1><div class='re'><code>isIn( self, interface )</code></div><div class='ds'><p>Tells wether the current element is in a context where at least one of the parent elements define the given interface. It returns <code>-1</code> when no element implements the interface, and otherwise returns the offset of the element, starting from the most recent context.</p><p>To know if you're currently in an assignation: <pre>self.isIn(interfaces.IAssignation)
</pre></p></div></div><div id='d_Yu' class='de'><h1>Method <span class='n'>writeString</span></h1><div class='re'><code>writeString( self, element )</code></div><div class='ds'><p>Writes a string element.</p></div></div><div id='d_Yv' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.modeltypes.Data at 0x11325a0&gt;, &lt;class lambdafactory.modeltypes.Operations at 0x11329f0&gt;, &lt;class lambdafactory.modeltypes.Structure at 0x1132a20&gt;, &lt;class lambdafactory.modeltypes.Behaviour at 0x1132a50&gt;, &lt;class lambdafactory.modeltypes.Runtime at 0x1132a80&gt;)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Yw' class='de'><h1>Method <span class='n'>__str__</span></h1><div class='re'><code>__str__( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Yp' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IValue at 0x5bf4b0&gt;, &lt;class lambdafactory.interfaces.IReferencable at 0x5bf3c0&gt;)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Yq' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_Yr' class='de'><h1>Class <span class='n'>ITermination</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Ys' class='de'><h1>Method <span class='n'>createInterface</span></h1><div class='re'><code>createInterface( self, name, inherited=() )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Yx' class='de'><h1>Method <span class='n'>isSubtypeOf</span></h1><div class='re'><code>isSubtypeOf( self, otherType )</code></div><div class='ds'><p>The other type is a subtype of this one if for each element of this type, we find that the other type has a subtype.</p></div></div><div id='d_Yy' class='de'><h1>Method <span class='n'>setConcreteType</span></h1><div class='re'><code>setConcreteType( self, value )</code></div><div class='ds'><p>Sets the <span class='term'>concrete type</span> for this abstract type. The concrete type is a value which represents the type. For instance, if this type represents a class, then the concrete type would be the class instance.</p></div></div><div id='d_Yz' class='de'><h1>Method <span class='n'>subtype</span></h1><div class='re'><code>subtype( self, name )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='k' class='cr'><div class='n'><a href='javascript:dS("k");'>IAbsoluteReference</a></div><div class='t'>Bases</div class='t'><div class='g'><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("k","l");'><span class='special __bases__'>IReference</span></a></span><br /></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("k","m");'>getAbsoluteName</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("k","n");'>getAbstractType</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("k","o");'>getAnnotation</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("k","p");'>getDataFlow</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("k","q");'>getName</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("k","r");'>getReferenceName</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("k","s");'>getResultAbstractType</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("k","t");'>setAbstractType</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("k","u");'>setAnnotation</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("k","v");'>setResultAbstractType</a></span><br /></div></div><div id='Zv' class='ro'><div class='n'><a href='javascript:dS("Zv");'>lambdafactory.typecast</a></div><div class='t'>Classes</div class='t'><div class='g'><span class='u'><span class='prefix'>&Tau;</span><a href='javascript:dO("Zv","aw");'>Arguments</a></span><br /><span class='d'><span class='prefix'>&Tau;</span><a href='javascript:dO("Zv","vw");'>Array</a></span><br /><span class='d'><span class='prefix'>&Tau;</span><a href='javascript:dO("Zv","Ow");'>Cell</a></span><br /><span class='d'><span class='prefix'>&Tau;</span><a href='javascript:dO("Zv","gx");'>Context</a></span><br /><span class='d'><span class='prefix'>&Tau;</span><a href='javascript:dO("Zv","Hx");'>Environment</a></span><br /><span class='u'><span class='prefix'>&Tau;</span><a href='javascript:dO("Zv","Lx");'>InvalidArgument</a></span><br /><span class='d'><span class='prefix'>&Tau;</span><a href='javascript:dO("Zv","Mx");'>Map</a></span><br /><span class='d'><span class='prefix'>&Tau;</span><a href='javascript:dO("Zv","jy");'>Process</a></span><br /><span class='u'><span class='prefix'>&Tau;</span><a href='javascript:dO("Zv","Fy");'>SemanticError</a></span><br /><span class='d'><span class='prefix'>&Tau;</span><a href='javascript:dO("Zv","Gy");'>Sequence</a></span><br /><span class='d'><span class='prefix'>&Tau;</span><a href='javascript:dO("Zv","bz");'>Symbolic</a></span><br /><span class='d'><span class='prefix'>&Tau;</span><a href='javascript:dO("Zv","sz");'>Type</a></span><br /><span class='d'><span class='prefix'>&Tau;</span><a href='javascript:dO("Zv","Iz");'>Unresolved</a></span><br /></div><div class='t'>Functions</div class='t'><div class='g'><span class='u'><span class='prefix'>&lambda;</span><a href='javascript:dO("Zv","Zz");'>Class</a></span><br /><span class='u'><span class='prefix'>&lambda;</span><a href='javascript:dO("Zv","aA");'>Interface</a></span><br /><span class='d'><span class='prefix'>&lambda;</span><a href='javascript:dO("Zv","bA");'>Sequence_combine</a></span><br /><span class='d'><span class='prefix'>&lambda;</span><a href='javascript:dO("Zv","cA");'>Sequence_make</a></span><br /><span class='d'><span class='prefix'>&lambda;</span><a href='javascript:dO("Zv","dA");'>bits</a></span><br /><span class='d'><span class='prefix'>&lambda;</span><a href='javascript:dO("Zv","eA");'>isLike</a></span><br /><span class='d'><span class='prefix'>&lambda;</span><a href='javascript:dO("Zv","fA");'>isSame</a></span><br /><span class='u'><span class='prefix'>&lambda;</span><a href='javascript:dO("Zv","gA");'>isSubtype</a></span><br /><span class='u'><span class='prefix'>&lambda;</span><a href='javascript:dO("Zv","hA");'>isType</a></span><br /></div><div class='t'>Values</div class='t'><div class='g'><span class='d'><span class='prefix'>&sdot;</span><a href='javascript:dO("Zv","iA");'>Any</a></span><br /><span class='d'><span class='prefix'>&sdot;</span><a href='javascript:dO("Zv","jA");'>Nil</a></span><br /><span class='d'><span class='prefix'>&sdot;</span><a href='javascript:dO("Zv","kA");'>Nothing</a></span><br /><span class='d'><span class='prefix'>&sdot;</span><a href='javascript:dO("Zv","lA");'>Rest</a></span><br /></div></div><div id='mA' class='ro'><div class='n'><a href='javascript:dS("mA");'>lambdafactory.passes</a></div><div class='t'>Classes</div class='t'><div class='g'><span class='d'><span class='prefix'>&Tau;</span><a href='javascript:dO("mA","nA");'>ImportationPass</a></span><br /><span class='u'><span class='prefix'>&Tau;</span><a href='javascript:dO("mA","uA");'>Pass</a></span><br /><span class='d'><span class='prefix'>&Tau;</span><a href='javascript:dO("mA","zA");'>PassContext</a></span><br /><span class='u'><span class='prefix'>&Tau;</span><a href='javascript:dO("mA","OA");'>TransformAsynchronousInvocations</a></span><br /></div></div><div id='mn' class='cr'><div class='n'><a href='javascript:dS("mn");'>IMatchOperation</a></div><div class='t'>Bases</div class='t'><div class='g'><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("mn","nn");'><span class='special __bases__'>IOperation</span></a></span><br /></div><div class='t'>Methods</div class='t'><div class='g'><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("mn","on");'>getPredicate</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("mn","pn");'>setPredicate</a></span><br /></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("mn","qn");'>addOpArgument</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("mn","rn");'>getAbstractType</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("mn","sn");'>getAnnotation</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("mn","tn");'>getDataFlow</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("mn","un");'>getOpArgument</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("mn","vn");'>getOpArguments</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("mn","wn");'>getOpArgumentsInternalTypes</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("mn","xn");'>setAbstractType</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("mn","yn");'>setAnnotation</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("mn","zn");'>setOpArgument</a></span><br /></div></div><div id='ms' class='cr'><div class='n'><a href='javascript:dS("ms");'>IValue</a></div><div class='t'>Bases</div class='t'><div class='g'><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("ms","ns");'><span class='special __bases__'>IElement, IEvaluable</span></a></span><br /></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("ms","os");'>getAbstractType</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("ms","ps");'>getAnnotation</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("ms","qs");'>getDataFlow</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("ms","rs");'>getResultAbstractType</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("ms","ss");'>setAbstractType</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("ms","ts");'>setAnnotation</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("ms","us");'>setResultAbstractType</a></span><br /></div></div><div id='Ld' class='cr'><div class='n'><a href='javascript:dS("Ld");'>IClosure</a></div><div class='t'>Bases</div class='t'><div class='g'><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("Ld","Md");'><span class='special __bases__'>IProcess, IContext</span></a></span><br /></div><div class='t'>Methods</div class='t'><div class='g'><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("Ld","Nd");'>getArguments</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("Ld","Od");'>setArguments</a></span><br /></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Ld","Pd");'>addOperation</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Ld","Qd");'>getAbstractType</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Ld","Rd");'>getAnnotation</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Ld","Sd");'>getDataFlow</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Ld","Td");'>getOperations</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Ld","Ud");'>getParent</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Ld","Vd");'>getSlot</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Ld","Wd");'>getSlots</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Ld","Xd");'>hasSlot</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Ld","Yd");'>setAbstractType</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Ld","Zd");'>setAnnotation</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Ld","ae");'>setParent</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Ld","be");'>setSlot</a></span><br /></div></div><div id='Lm' class='cr'><div class='n'><a href='javascript:dS("Lm");'>ILiteral</a></div><div class='t'>Bases</div class='t'><div class='g'><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("Lm","Mm");'><span class='special __bases__'>IValue</span></a></span><br /></div><div class='t'>Methods</div class='t'><div class='g'><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Lm","Nm");'>getActualValue</a></span><br /></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Lm","Om");'>getAbstractType</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Lm","Pm");'>getAnnotation</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Lm","Qm");'>getDataFlow</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Lm","Rm");'>getResultAbstractType</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Lm","Sm");'>setAbstractType</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Lm","Tm");'>setAnnotation</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Lm","Um");'>setResultAbstractType</a></span><br /></div></div><div id='Lj' class='cr'><div class='n'><a href='javascript:dS("Lj");'>IImportSymbolsOperation</a></div><div class='t'>Bases</div class='t'><div class='g'><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("Lj","Mj");'><span class='special __bases__'>IImportOperation</span></a></span><br /></div><div class='t'>Methods</div class='t'><div class='g'><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("Lj","Nj");'>getImportOrigin</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Lj","Oj");'>getImportedElements</a></span><br /></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Lj","Pj");'>addOpArgument</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Lj","Qj");'>getAbstractType</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Lj","Rj");'>getAnnotation</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Lj","Sj");'>getDataFlow</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Lj","Tj");'>getOpArgument</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Lj","Uj");'>getOpArguments</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Lj","Vj");'>getOpArgumentsInternalTypes</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Lj","Wj");'>setAbstractType</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Lj","Xj");'>setAnnotation</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Lj","Yj");'>setOpArgument</a></span><br /></div><div class='t'>Values</div class='t'><div class='g'><span class='d'><span class='prefix'>&bull;</span><a href='javascript:dO("Lj","Zj");'>ARGS</a></span><br /><span class='d'><span class='prefix'>&bull;</span><a href='javascript:dO("Lj","ak");'>ARG_NAMES</a></span><br /></div></div><div id='d_Ly' class='de'><h1>Method <span class='n'>elements</span></h1><div class='re'><code>elements( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='Lv' class='cr'><div class='n'><a href='javascript:dS("Lv");'>Operations</a></div><div class='t'>Bases</div class='t'><div class='g'><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("Lv","Mv");'><span class='special __bases__'>TypeCollection</span></a></span><br /></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Lv","Nv");'>getType</a></span><br /></div></div><div id='d_Lx' class='de'><h1>Class <span class='n'>InvalidArgument</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='Lx' class='cr'><div class='n'><a href='javascript:dS("Lx");'>InvalidArgument</a></div><div class='t'>Inhertied Values</div class='t'><div class='g'><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("Lx","zt");'><span class='special __getitem__'>get item</span></a></span><br /><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("Lx","Ft");'><span class='special __init__'>constructor</span></a></span><br /><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("Lx","At");'><span class='special __repr__'>string repr</span></a></span><br /><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("Lx","Bt");'><span class='special __str__'>string conversion</span></a></span><br /><span class='u'><span class='prefix'>&sdot;</span><a href='javascript:dO("Lx","Ct");'>args</a></span><br /><span class='d'><span class='prefix'>&sdot;</span><a href='javascript:dO("Lx","Dt");'>message</a></span><br /></div></div><div id='d_Ls' class='de'><h1>Method <span class='n'>allocate</span></h1><div class='re'><code>allocate( self, slot, value=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Lr' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_Lq' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><p>Sets the given argument of this operation, by argument index.</p></div></div><div id='d_Lp' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns the parent context for this context (if any)</p></div></div><div id='d_Lw' class='de'><h1>Method <span class='n'>setConcreteType</span></h1><div class='re'><code>setConcreteType( self, value )</code></div><div class='ds'><p>Sets the <span class='term'>concrete type</span> for this abstract type. The concrete type is a value which represents the type. For instance, if this type represents a class, then the concrete type would be the class instance.</p></div></div><div id='d_Lv' class='de'><h1>Class <span class='n'>Operations</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Lu' class='de'><h1>Method <span class='n'>writeImportSymbolsOperation</span></h1><div class='re'><code>writeImportSymbolsOperation( self, element )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Lt' class='de'><h1>Method <span class='n'>_filterContext</span></h1><div class='re'><code>_filterContext( self, interface )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Lk' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_Lj' class='de'><h1>Class <span class='n'>IImportSymbolsOperation</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Li' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><p>Returns the ith arguments to this operation.</p></div></div><div id='d_Lh' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><p>Sets the given argument of this operation, by argument index.</p></div></div><div id='d_Lo' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><p>Returns the local name for this referencable element</p></div></div><div id='d_Ln' class='de'><h1>Method <span class='n'>getPredicate</span></h1><div class='re'><code>getPredicate( self )</code></div><div class='ds'><p>Returns the evaluable that acts as a predicate for this operation.</p></div></div><div id='d_Lm' class='de'><h1>Class <span class='n'>ILiteral</span></h1><div class='re'></div><div class='ds'><p>A literal is a value that does not need a context to be evaluated. The evaluation is direct.</p></div></div><div id='d_Ll' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_B' class='de'><h1>Method <span class='n'>getAttributes</span></h1><div class='re'><code>getAttributes( self )</code></div><div class='ds'><p>Returns the (non-class) attributes defined within this class.</p></div></div><div id='d_DA' class='de'><h1>Method <span class='n'>findInContext</span></h1><div class='re'><code>findInContext( self, interface )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Lb' class='de'><h1>Method <span class='n'>isOptional</span></h1><div class='re'><code>isOptional( self )</code></div><div class='ds'><p>Tells if the argument is optional or not.</p></div></div><div id='d_Ds' class='de'><h1>Method <span class='n'>_list</span></h1><div class='re'><code>_list( self, *args )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Dr' class='de'><h1>Method <span class='n'>getResultAbstractType</span></h1><div class='re'><code>getResultAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type of the result of the evaluation of this evaluable</p></div></div><div id='d_Dq' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_Dp' class='de'><h1>Method <span class='n'>addModule</span></h1><div class='re'><code>addModule( self, module )</code></div><div class='ds'><p>Adds a module to this program. The module will be registered in the global module catalogue.</p></div></div><div id='d_Dw' class='de'><h1>Method <span class='n'>setContentType</span></h1><div class='re'><code>setContentType( self, theType )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Dv' class='de'><h1>str</h1><div class='re'><code>'8&lt; ---['</code></div><div class='ds'><p>str(object) -&gt; string</p><p>Return a nice string representation of the object. If the argument is a string, the return value is the same object.</p></div></div><div id='d_Du' class='de'><h1>Method <span class='n'>writeDestructor</span></h1><div class='re'><code>writeDestructor( self, element )</code></div><div class='ds'><p>Writes a method element.</p></div></div><div id='d_Dt' class='de'><h1>member_descriptor</h1><div class='re'></div><div class='ds'><p>exception message</p></div></div><div id='d_Lg' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_Dy' class='de'><h1>Method <span class='n'>setName</span></h1><div class='re'><code>setName( self, name )</code></div><div class='ds'><p>Sets the name of this type</p></div></div><div id='d_Dx' class='de'><h1>Method <span class='n'>set</span></h1><div class='re'><code>set( self, name, theType )</code></div><div class='ds'><p>Sets the slot with the given <code>name</code> to have a value of the given type (<code>theType</code>).</p></div></div><div id='d_G' class='de'><h1>Method <span class='n'>getDestructors</span></h1><div class='re'><code>getDestructors( self )</code></div><div class='ds'><p>Returns the destructors for this class</p></div></div><div id='d_Dc' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><p>Returns the <em>internal types</em> for this operations arguments. This is typically the list of interfaces or @protocols that the arguments must comply to.</p></div></div><div id='d_Db' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.ISlot at 0x5bf660&gt;, &lt;class lambdafactory.interfaces.IEvaluable at 0x5bf3f0&gt;]</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='d_Dg' class='de'><h1>Method <span class='n'>setLanguage</span></h1><div class='re'><code>setLanguage( self, language )</code></div><div class='ds'><p>Sets the language in which the emebedded code is written.</p></div></div><div id='d_Df' class='de'><h1>Method <span class='n'>getOperations</span></h1><div class='re'><code>getOperations( self )</code></div><div class='ds'><p>Returns the (ordered) list of operations that affected the slot. Operations usually constrain the dataflow abstract type, and exception/warnings/errors may be raised by the type system when a type constraint fails.</p></div></div><div id='d_De' class='de'><h1>Method <span class='n'>addOperation</span></h1><div class='re'><code>addOperation( self, operation )</code></div><div class='ds'><p>Adds the given operation as a child of this process.</p></div></div><div id='d_Dd' class='de'><h1>Method <span class='n'>hasSlot</span></h1><div class='re'><code>hasSlot( self, name )</code></div><div class='ds'><p>Tells if the context has a slot with the given name.</p></div></div><div id='d_Dk' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><p>Adds an argument to this operation. This should do checking of arguments (by expected internal type and number).</p></div></div><div id='d_Dj' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><p>Returns the ith arguments to this operation.</p></div></div><div id='d_Di' class='de'><h1>Class <span class='n'>IImportModuleOperation</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Ld' class='de'><h1>Class <span class='n'>IClosure</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Do' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_Dn' class='de'><h1>Method <span class='n'>setProcess</span></h1><div class='re'><code>setProcess( self, v )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Dm' class='de'><h1>Method <span class='n'>getValues</span></h1><div class='re'><code>getValues( self )</code></div><div class='ds'><p>Returns the values within this list.</p></div></div><div id='d_Dl' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_rA' class='de'><h1>Method <span class='n'>getHandle</span></h1><div class='re'><code>getHandle( self, element )</code></div><div class='ds'><p>Tells if the pass handles the given element. This basically iterates on the <code>handles</code> property values (which are interfaces), when one interface matches the given <code>element</code>, then the corresponding <code>onXXX</code> method is invoked, where <code>XXX</code> is the interface name (without the leading <code>I</code>).</p></div></div><div id='d_re' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_rd' class='de'><h1>Method <span class='n'>endsWithTermination</span></h1><div class='re'><code>endsWithTermination( self )</code></div><div class='ds'><p>Returns true if this function ends with a termination operation. This is especially useful for back-ends which want to know if they have to insert an explicit <code>return</code> at the end (like Java).</p></div></div><div id='d_rg' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><p>Returns the name of this annotation.</p></div></div><div id='d_rf' class='de'><h1>Method <span class='n'>defines</span></h1><div class='re'><code>defines( self, name )</code></div><div class='ds'><p>Tells if this dataflow, or any of its child dataflows defines the given name (symbol)</p></div></div><div id='d_rc' class='de'><h1>Class <span class='n'>IBlock</span></h1><div class='re'></div><div class='ds'><p>A block is a specific type of (sub) process.</p></div></div><div id='d_rb' class='de'><h1>Method <span class='n'>getDefaultValue</span></h1><div class='re'><code>getDefaultValue( self )</code></div><div class='ds'><p>Returns the expression that assigns the @methodault value.</p></div></div><div id='d_rm' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_rl' class='de'><h1>Method <span class='n'>getDestructors</span></h1><div class='re'><code>getDestructors( self )</code></div><div class='ds'><p>Returns the destructors for this class</p></div></div><div id='d_ro' class='de'><h1>Method <span class='n'>getClasses</span></h1><div class='re'><code>getClasses( self )</code></div><div class='ds'><p>Returns the list of classes defined in this module. This is mainly a convenience function.</p></div></div><div id='d_rn' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_ri' class='de'><h1>Method <span class='n'>hasSlot</span></h1><div class='re'><code>hasSlot( self, name )</code></div><div class='ds'><p>Tells if the context has a slot with the given name.</p></div></div><div id='d_rh' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><p>Returns the <em>internal types</em> for this operations arguments. This is typically the list of interfaces or @protocols that the arguments must comply to.</p></div></div><div id='d_rk' class='de'><h1>Method <span class='n'>isAbstract</span></h1><div class='re'><code>isAbstract( self )</code></div><div class='ds'><p>Tells wether the given abstractable is abstract or not.</p></div></div><div id='d_rj' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_ru' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.modelwriter.AbstractWriter at 0x1147870&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_rt' class='de'><h1>Method <span class='n'>matchProcess</span></h1><div class='re'><code>matchProcess( self, evaluable, process )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_rw' class='de'><h1>Method <span class='n'>result</span></h1><div class='re'><code>result( self )</code></div><div class='ds'><p>Returns the result for this type. This is usually just the type itself, except for processes types.</p></div></div><div id='d_rv' class='de'><h1>Method <span class='n'>isInInstanceMethod</span></h1><div class='re'><code>isInInstanceMethod( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_rq' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><p>Returns the ith arguments to this operation.</p></div></div><div id='d_rp' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_rs' class='de'><h1>Method <span class='n'>getResultAbstractType</span></h1><div class='re'><code>getResultAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type of the result of the evaluation of this evaluable</p></div></div><div id='d_rr' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.IEvaluable at 0x5bf3f0&gt;, &lt;class lambdafactory.interfaces.IEvaluable at 0x5bf3f0&gt;, &lt;class lambdafactory.interfaces.IEvaluable at 0x5bf3f0&gt;]</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='d_ry' class='de'><h1>Method <span class='n'>elements</span></h1><div class='re'><code>elements( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_rx' class='de'><h1>Method <span class='n'>__str__</span></h1><div class='re'><code>__str__( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_rz' class='de'><h1>Method <span class='n'>subtype</span></h1><div class='re'><code>subtype( self, name )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_xy' class='de'><h1>Method <span class='n'>__call__</span></h1><div class='re'><code>__call__( self )</code></div><div class='ds'><p>A type instance can be used as a class to construct a new type, which will be cloned from the current type.</p></div></div><div id='rc' class='cr'><div class='n'><a href='javascript:dS("rc");'>IBlock</a></div><div class='t'>Bases</div class='t'><div class='g'><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("rc","sc");'><span class='special __bases__'>IGroup</span></a></span><br /></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("rc","tc");'>addOperation</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("rc","uc");'>getOperations</a></span><br /></div></div><div id='d_Vi' class='de'><h1>Method <span class='n'>getImportedModuleNames</span></h1><div class='re'><code>getImportedModuleNames( self )</code></div><div class='ds'><p>Returns the list of names representing the modules to load</p></div></div><div id='d_Vh' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><p>Returns the ith arguments to this operation.</p></div></div><div id='d_Vk' class='de'><h1>Method <span class='n'>setProcess</span></h1><div class='re'><code>setProcess( self, process )</code></div><div class='ds'><p>Sets the process from which interruptions will be intercepted.</p></div></div><div id='d_Vj' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><p>Returns the <em>internal types</em> for this operations arguments. This is typically the list of interfaces or @protocols that the arguments must comply to.</p></div></div><div id='d_Vm' class='de'><h1>Class <span class='n'>IMatchExpressionOperation</span></h1><div class='re'></div><div class='ds'><p>A match expression is a predicate that is associated to an expression. This is typically used in conditional expressions like in C:</p><pre>int a = ( b==2 ? 1 : 2 )</pre></div></div><div id='d_Vl' class='de'><h1>Method <span class='n'>getArguments</span></h1><div class='re'><code>getArguments( self )</code></div><div class='ds'><p>Returns a list of arguments (which are names associated with optional type information.</p></div></div><div id='d_Vo' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_Vn' class='de'><h1>Method <span class='n'>getAbsoluteName</span></h1><div class='re'><code>getAbsoluteName( self )</code></div><div class='ds'><p>Returns the absolute name for this element</p></div></div><div id='d_Vc' class='de'><h1>Method <span class='n'>getAbsoluteName</span></h1><div class='re'><code>getAbsoluteName( self )</code></div><div class='ds'><p>Returns the absolute name for this element</p></div></div><div id='d_Vb' class='de'><h1>Class <span class='n'>IAssignation</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Ve' class='de'><h1>Method <span class='n'>setArguments</span></h1><div class='re'><code>setArguments( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Vd' class='de'><h1>Method <span class='n'>getSlot</span></h1><div class='re'><code>getSlot( self, name )</code></div><div class='ds'><p>Returns the given evaluable bound to named slot.</p></div></div><div id='d_Vg' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_Vf' class='de'><h1>Method <span class='n'>hasSlot</span></h1><div class='re'><code>hasSlot( self, name )</code></div><div class='ds'><p>Tells if the context has a slot with the given name.</p></div></div><div id='d_Vy' class='de'><h1>Method <span class='n'>definedBy</span></h1><div class='re'><code>definedBy( self, definition=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Vx' class='de'><h1>Method <span class='n'>get</span></h1><div class='re'><code>get( self, name )</code></div><div class='ds'><p>Returns the type for the slot with the given name.</p></div></div><div id='d_Vz' class='de'><h1>Method <span class='n'>result</span></h1><div class='re'><code>result( self )</code></div><div class='ds'><p>Returns the result for this type. This is usually just the type itself, except for processes types.</p></div></div><div id='d_Vq' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><p>Returns the ith arguments to this operation.</p></div></div><div id='d_Vp' class='de'><h1>Method <span class='n'>getAbsoluteName</span></h1><div class='re'><code>getAbsoluteName( self )</code></div><div class='ds'><p>Returns the absolute name for this element</p></div></div><div id='d_Vs' class='de'><h1>Method <span class='n'>createConstructor</span></h1><div class='re'><code>createConstructor( self, arguments=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Vr' class='de'><h1>Method <span class='n'>getColumn</span></h1><div class='re'><code>getColumn( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Vu' class='de'><h1>Method <span class='n'>writeResolution</span></h1><div class='re'><code>writeResolution( self, resolution )</code></div><div class='ds'><p>Writes a resolution operation.</p></div></div><div id='d_Vt' class='de'><h1>Method <span class='n'>getCurrentFunction</span></h1><div class='re'><code>getCurrentFunction( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Vw' class='de'><h1>Method <span class='n'>isSubtypeOf</span></h1><div class='re'><code>isSubtypeOf( self, otherType )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Vv' class='de'><h1>Method <span class='n'>getType</span></h1><div class='re'><code>getType( self, name )</code></div><div class='ds'><p>Returns the type with the given name, or None if it does not exist.</p></div></div><div id='d_VA' class='de'><h1>Class <span class='n'>Reporter</span></h1><div class='re'></div><div class='ds'><p>The reporter aggregates error reports that may happen during model construction and the different phases (dataflowing, typing, writing, etc).</p></div></div><div id='d_XA' class='de'><h1>Method <span class='n'>dedent</span></h1><div class='re'><code>dedent( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Xg' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><p>Returns the ith arguments to this operation.</p></div></div><div id='d_Xf' class='de'><h1>Method <span class='n'>setAbstract</span></h1><div class='re'><code>setAbstract( self, isAbstract )</code></div><div class='ds'><p>Sets wether the given abstractable is abstract or not.</p></div></div><div id='d_Xe' class='de'><h1>Method <span class='n'>setSlot</span></h1><div class='re'><code>setSlot( self, name, evaluable )</code></div><div class='ds'><p>Binds the given evaluable to the named slot.</p></div></div><div id='d_Xd' class='de'><h1>Method <span class='n'>hasSlot</span></h1><div class='re'><code>hasSlot( self, name )</code></div><div class='ds'><p>Tells if the context has a slot with the given name.</p></div></div><div id='d_Xc' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_Xb' class='de'><h1>Method <span class='n'>getAssignedValue</span></h1><div class='re'><code>getAssignedValue( self )</code></div><div class='ds'><p>Returns this assigned evaluable.</p></div></div><div id='d_Xo' class='de'><h1>Method <span class='n'>setResultAbstractType</span></h1><div class='re'><code>setResultAbstractType( self, abstractType )</code></div><div class='ds'><p>Sets the abstract type for this operation result. This is usually invoked in the typing phase.</p></div></div><div id='d_Xn' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_Xm' class='de'><h1>Method <span class='n'>getExpression</span></h1><div class='re'><code>getExpression( self )</code></div><div class='ds'><p>Returns the process that will be executed if the rule matches.</p></div></div><div id='d_Xl' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IOperation at 0x5bfa50&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Xk' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_Xj' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_Xi' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_Xh' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><p>Returns the <em>internal types</em> for this operations arguments. This is typically the list of interfaces or @protocols that the arguments must comply to.</p></div></div><div id='d_Xw' class='de'><h1>Method <span class='n'>__call__</span></h1><div class='re'><code>__call__( self )</code></div><div class='ds'><p>A type instance can be used as a class to construct a new type, which will be cloned from the current type.</p></div></div><div id='d_Xv' class='de'><h1>NoneType</h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Xu' class='de'><h1>Method <span class='n'>writeSliceOperation</span></h1><div class='re'><code>writeSliceOperation( self, operation )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Xt' class='de'><h1>Method <span class='n'>getCurrentModule</span></h1><div class='re'><code>getCurrentModule( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Xs' class='de'><h1>Method <span class='n'>createFunction</span></h1><div class='re'><code>createFunction( self, name, arguments )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Xr' class='de'><h1>Method <span class='n'>getOffset</span></h1><div class='re'><code>getOffset( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Xq' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><p>Returns the <em>internal types</em> for this operations arguments. This is typically the list of interfaces or @protocols that the arguments must comply to.</p></div></div><div id='d_Xp' class='de'><h1>Class <span class='n'>IReference</span></h1><div class='re'></div><div class='ds'><p>A reference is a name that can be converted into a value using a resolution operation (for instance).</p></div></div><div id='d_Xz' class='de'><h1>Method <span class='n'>setName</span></h1><div class='re'><code>setName( self, name )</code></div><div class='ds'><p>Sets the name of this type</p></div></div><div id='d_Xy' class='de'><h1>Method <span class='n'>result</span></h1><div class='re'><code>result( self )</code></div><div class='ds'><p>Returns the result for this type. This is usually just the type itself, except for processes types.</p></div></div><div id='d_Xx' class='de'><h1>Method <span class='n'>isSameAs</span></h1><div class='re'><code>isSameAs( self, otherType )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_cj' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><p>Returns the <em>internal types</em> for this operations arguments. This is typically the list of interfaces or @protocols that the arguments must comply to.</p></div></div><div id='d_ck' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IMethod at 0x5bf960&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_ch' class='de'><h1>Method <span class='n'>setCode</span></h1><div class='re'><code>setCode( self, code )</code></div><div class='ds'><p>Sets the code of this embed operation.</p></div></div><div id='d_ci' class='de'><h1>Class <span class='n'>IFunction</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_cn' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_co' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns the parent context for this context (if any)</p></div></div><div id='d_cl' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><p>Returns the <em>internal types</em> for this operations arguments. This is typically the list of interfaces or @protocols that the arguments must comply to.</p></div></div><div id='d_cm' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_cb' class='de'><h1>Method <span class='n'>getIndex</span></h1><div class='re'><code>getIndex( self )</code></div><div class='ds'><p>Returns evaluable that will return the access index</p></div></div><div id='d_cc' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_cf' class='de'><h1>Method <span class='n'>getSlots</span></h1><div class='re'><code>getSlots( self )</code></div><div class='ds'><p>Returns (key, evaluable) pairs representing the slots within this context.</p></div></div><div id='d_cg' class='de'><h1>Method <span class='n'>setSlot</span></h1><div class='re'><code>setSlot( self, name, evaluable )</code></div><div class='ds'><p>Binds the given evaluable to the named slot.</p></div></div><div id='d_cd' class='de'><h1>Method <span class='n'>hasSlot</span></h1><div class='re'><code>hasSlot( self, name )</code></div><div class='ds'><p>Tells if the context has a slot with the given name.</p></div></div><div id='d_ce' class='de'><h1>Class <span class='n'>IComment</span></h1><div class='re'></div><div class='ds'><p>A comment is an annotation that can occur anywhere in a source file.</p></div></div><div id='d_cz' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.typecast.Type at 0x11327e0&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_cx' class='de'><h1>Method <span class='n'>result</span></h1><div class='re'><code>result( self )</code></div><div class='ds'><p>Returns the result for this type. This is usually just the type itself, except for processes types.</p></div></div><div id='d_cy' class='de'><h1>Method <span class='n'>concreteType</span></h1><div class='re'><code>concreteType( self )</code></div><div class='ds'><p>Returns the <span class='term'>concrete type</span> for this abstract type.</p></div></div><div id='d_cr' class='de'><h1>Class <span class='n'>ISliceOperation</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_cs' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_cp' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><p>Returns the arguments to this operation.</p></div></div><div id='d_cq' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_cv' class='de'><h1>Method <span class='n'>_filterContext</span></h1><div class='re'><code>_filterContext( self, interface )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_cw' class='de'><h1>Method <span class='n'>__call__</span></h1><div class='re'><code>__call__( self )</code></div><div class='ds'><p>A type instance can be used as a class to construct a new type, which will be cloned from the current type.</p></div></div><div id='d_ct' class='de'><h1>Method <span class='n'>doc</span></h1><div class='re'><code>doc( self, content )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_cu' class='de'><h1>Method <span class='n'>resolveAbsoluteOrLocal</span></h1><div class='re'><code>resolveAbsoluteOrLocal( self, name, dataflow=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_cB' class='de'><h1>Method <span class='n'>info</span></h1><div class='re'><code>info( self, *message )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_cA' class='de'><h1>Function <span class='n'>Sequence_make</span></h1><div class='re'><code>Sequence_make( args, sequenceclass=<class lambdafactory.typecast.Sequence at 0x11328d0> )</code></div><div class='ds'><p>Tries to make a sequence from the given argumnents. This follows the following rules:</p><blockquote><div class='content'><p>len(args) == 0 -&gt; Nothing len(args) == 1 -&gt; args[1] otherwise -&gt; (args&hellip;.)</p></div></blockquote></div></div><div id='d_uA' class='de'><h1>Class <span class='n'>Pass</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_ub' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_uc' class='de'><h1>Method <span class='n'>getOperations</span></h1><div class='re'><code>getOperations( self )</code></div><div class='ds'><p>Returns the list of operations in this process.</p></div></div><div id='d_ud' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_ue' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><p>Returns the ith arguments to this operation.</p></div></div><div id='d_uf' class='de'><h1>Method <span class='n'>getSlot</span></h1><div class='re'><code>getSlot( self, name )</code></div><div class='ds'><p>Returns the slot with the given name, if any.</p></div></div><div id='d_ug' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_uh' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><p>Sets the given argument of this operation, by argument index.</p></div></div><div id='d_ui' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_uj' class='de'><h1>Class <span class='n'>IImportSymbolOperation</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_uk' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_ul' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><p>Returns this class name. It can be <code>None</code> if the class is anonymous.</p></div></div><div id='d_um' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><p>Returns the arguments to this operation.</p></div></div><div id='d_un' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><p>Returns the ith arguments to this operation.</p></div></div><div id='d_uo' class='de'><h1>Method <span class='n'>isImported</span></h1><div class='re'><code>isImported( self )</code></div><div class='ds'><p>A stub module is a module that does not have any bound implementation. Stub modules are typically used by Programs when adding a module such as <code>a.b.c</code> where <code>a</code> and <code>a.b</code> will be stub modules unless they were or will be imported.</p></div></div><div id='d_up' class='de'><h1>Method <span class='n'>getResultAbstractType</span></h1><div class='re'><code>getResultAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type of the result of the evaluation of this evaluable</p></div></div><div id='d_uq' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_ur' class='de'><h1>Method <span class='n'>getTypeDescription</span></h1><div class='re'><code>getTypeDescription( self )</code></div><div class='ds'><p>Returns type information (constraints) that are associated to this argument.</p></div></div><div id='d_us' class='de'><h1>Method <span class='n'>setResultAbstractType</span></h1><div class='re'><code>setResultAbstractType( self, abstractType )</code></div><div class='ds'><p>Sets the abstract type for this operation result. This is usually invoked in the typing phase.</p></div></div><div id='d_ut' class='de'><h1>Method <span class='n'>returns</span></h1><div class='re'><code>returns( self, evaluable )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_uu' class='de'><h1>Method <span class='n'>writeAssignation</span></h1><div class='re'><code>writeAssignation( self, assignation )</code></div><div class='ds'><p>Writes an assignation operation.</p></div></div><div id='d_uv' class='de'><h1>Method <span class='n'>write</span></h1><div class='re'><code>write( self, element )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_uw' class='de'><h1>Method <span class='n'>subtype</span></h1><div class='re'><code>subtype( self, name )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_ux' class='de'><h1>Method <span class='n'>concreteType</span></h1><div class='re'><code>concreteType( self )</code></div><div class='ds'><p>Returns the <span class='term'>concrete type</span> for this abstract type.</p></div></div><div id='d_uy' class='de'><h1>Method <span class='n'>isSubtypeOf</span></h1><div class='re'><code>isSubtypeOf( self, otherType )</code></div><div class='ds'><p>The other type is like this one if the other is a sequence with the same length and that all elements are like the corresponding elements of this sequence.</p></div></div><div id='d_uz' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self, name=None )</code></div><div class='ds'><p>Creates a new anonymous type</p></div></div><div id='dg' class='cr'><div class='n'><a href='javascript:dS("dg");'>IDict</a></div><div class='t'>Bases</div class='t'><div class='g'><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("dg","eg");'><span class='special __bases__'>IValue</span></a></span><br /></div><div class='t'>Methods</div class='t'><div class='g'><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("dg","fg");'>getItems</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("dg","gg");'>setValue</a></span><br /></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("dg","hg");'>getAbstractType</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("dg","ig");'>getAnnotation</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("dg","jg");'>getDataFlow</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("dg","kg");'>getResultAbstractType</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("dg","lg");'>setAbstractType</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("dg","mg");'>setAnnotation</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("dg","ng");'>setResultAbstractType</a></span><br /></div></div><div id='X' class='cr'><div class='n'><a href='javascript:dS("X");'>IAbstractable</a></div><div class='t'>Bases</div class='t'><div class='g'><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("X","c");'><span class='special __bases__'><i>Base class</i></span></a></span><br /></div><div class='t'>Methods</div class='t'><div class='g'><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("X","Y");'>isAbstract</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("X","Z");'>setAbstract</a></span><br /></div></div><div id='d_It' class='de'><h1>Class <span class='n'>AbstractWriter</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Iu' class='de'><h1>Method <span class='n'>writeImportModuleOperation</span></h1><div class='re'><code>writeImportModuleOperation( self, element )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Iv' class='de'><h1>Class <span class='n'>Data</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Iw' class='de'><h1>Method <span class='n'>definedBy</span></h1><div class='re'><code>definedBy( self, definition=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Ip' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_Iq' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><p>Returns the <em>internal types</em> for this operations arguments. This is typically the list of interfaces or @protocols that the arguments must comply to.</p></div></div><div id='d_Ir' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IOperation at 0x5bfa50&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Is' class='de'><h1>Method <span class='n'>_slot</span></h1><div class='re'><code>_slot( self, name, typeinfo=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Ix' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Iy' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self, *args )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Iz' class='de'><h1>Class <span class='n'>Unresolved</span></h1><div class='re'></div><div class='ds'><p>Unresolved types are temporary types that can be resolved later when necessary.</p></div></div><div id='d_Id' class='de'><h1>Method <span class='n'>setArguments</span></h1><div class='re'><code>setArguments( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Ie' class='de'><h1>Method <span class='n'>getArguments</span></h1><div class='re'><code>getArguments( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_If' class='de'><h1>Method <span class='n'>addOperation</span></h1><div class='re'><code>addOperation( self, operation )</code></div><div class='ds'><p>Adds the given operation as a child of this process.</p></div></div><div id='d_Ig' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><p>Returns the ith arguments to this operation.</p></div></div><div id='d_Ib' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.ISlot at 0x5bf660&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Ic' class='de'><h1>Class <span class='n'>IClass</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Il' class='de'><h1>Class <span class='n'>IInterruption</span></h1><div class='re'></div><div class='ds'><p>An interruption can be be used to halt the process.</p></div></div><div id='d_Im' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_In' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><p>Returns the ith arguments to this operation.</p></div></div><div id='d_Io' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IAttribute at 0x5bf6c0&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Ih' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><p>Returns the <em>internal types</em> for this operations arguments. This is typically the list of interfaces or @protocols that the arguments must comply to.</p></div></div><div id='d_Ii' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_Ij' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><p>Sets the given argument of this operation, by argument index.</p></div></div><div id='d_Ik' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><p>Returns the arguments to this operation.</p></div></div><div id='d_IA' class='de'><h1>Method <span class='n'>getCurrentMethod</span></h1><div class='re'><code>getCurrentMethod( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='wh' class='cr'><div class='n'><a href='javascript:dS("wh");'>IEvaluable</a></div><div class='t'>Bases</div class='t'><div class='g'><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("wh","c");'><span class='special __bases__'><i>Base class</i></span></a></span><br /></div><div class='t'>Methods</div class='t'><div class='g'><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("wh","xh");'>getResultAbstractType</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("wh","yh");'>setResultAbstractType</a></span><br /></div></div><div id='ws' class='cr'><div class='n'><a href='javascript:dS("ws");'>Factory</a></div><div class='t'>Bases</div class='t'><div class='g'><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("ws","c");'><span class='special __bases__'><i>Base class</i></span></a></span><br /></div><div class='t'>Methods</div class='t'><div class='g'><span class='u'><span class='prefix'>&equiv;</span><a href='javascript:dO("ws","xs");'><span class='special __init__'>constructor</span></a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("ws","ys");'>_arg</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("ws","zs");'>_attr</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("ws","As");'>_classattr</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("ws","Bs");'>_dict</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("ws","Cs");'>_getImplementation</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("ws","Ds");'>_list</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("ws","Es");'>_moduleattr</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("ws","Fs");'>_number</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("ws","Gs");'>_op</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("ws","Hs");'>_ref</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("ws","Is");'>_slot</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("ws","Js");'>_string</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("ws","Ks");'>access</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("ws","Ls");'>allocate</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("ws","Ms");'>annotation</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("ws","Ns");'>assign</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("ws","Os");'>breaks</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("ws","Ps");'>comment</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("ws","Qs");'>compute</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("ws","Rs");'>createBlock</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("ws","Ss");'>createClass</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("ws","Ts");'>createClassMethod</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("ws","Us");'>createClosure</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("ws","Vs");'>createConstructor</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("ws","Ws");'>createDestructor</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("ws","Xs");'>createFunction</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("ws","Ys");'>createInterface</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("ws","Zs");'>createMethod</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("ws","at");'>createModule</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("ws","bt");'>createProgram</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("ws","ct");'>doc</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("ws","dt");'>embed</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("ws","et");'>embedTemplate</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("ws","ft");'>enumerate</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("ws","gt");'>evaluate</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("ws","ht");'>exception</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("ws","it");'>importModule</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("ws","jt");'>importModules</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("ws","kt");'>importSymbol</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("ws","lt");'>importSymbols</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("ws","mt");'>instanciate</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("ws","nt");'>intercept</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("ws","ot");'>invoke</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("ws","pt");'>iterate</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("ws","qt");'>matchExpression</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("ws","rt");'>matchProcess</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("ws","st");'>repeat</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("ws","tt");'>resolve</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("ws","ut");'>returns</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("ws","vt");'>select</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("ws","wt");'>slice</a></span><br /></div></div><div id='d_GA' class='de'><h1>Method <span class='n'>getCurrentClosure</span></h1><div class='re'><code>getCurrentClosure( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Gz' class='de'><h1>Method <span class='n'>setName</span></h1><div class='re'><code>setName( self, name )</code></div><div class='ds'><p>Sets the name of this type</p></div></div><div id='d_Gx' class='de'><h1>Method <span class='n'>subtype</span></h1><div class='re'><code>subtype( self, name )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Gy' class='de'><h1>Class <span class='n'>Sequence</span></h1><div class='re'></div><div class='ds'><p>A sequence is simply an ordered set of types.</p></div></div><div id='d_Gv' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.modeltypes.TypeCollection at 0x1127f90&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Gw' class='de'><h1>Method <span class='n'>clone</span></h1><div class='re'><code>clone( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Gt' class='de'><h1>Function <span class='n'>assertImplements</span></h1><div class='re'><code>assertImplements( v, i )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Gu' class='de'><h1>Method <span class='n'>writeEvaluation</span></h1><div class='re'><code>writeEvaluation( self, operation )</code></div><div class='ds'><p>Writes an evaluation operation.</p></div></div><div id='d_Gr' class='de'><h1>Method <span class='n'>setResultAbstractType</span></h1><div class='re'><code>setResultAbstractType( self, abstractType )</code></div><div class='ds'><p>Sets the abstract type for this operation result. This is usually invoked in the typing phase.</p></div></div><div id='d_Gs' class='de'><h1>Method <span class='n'>_op</span></h1><div class='re'><code>_op( self, symbol, priority=0 )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Gp' class='de'><h1>Method <span class='n'>getModules</span></h1><div class='re'><code>getModules( self )</code></div><div class='ds'><p>Returns the list of modules declared/imported in this program</p></div></div><div id='d_Gq' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><p>Returns the ith arguments to this operation.</p></div></div><div id='d_Gn' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_Go' class='de'><h1>Method <span class='n'>setSlot</span></h1><div class='re'><code>setSlot( self, name, evaluable )</code></div><div class='ds'><p>Binds the given evaluable to the named slot.</p></div></div><div id='d_Gl' class='de'><h1>Method <span class='n'>setParentClasses</span></h1><div class='re'><code>setParentClasses( self )</code></div><div class='ds'><p>gives the list of parent classes that will</p></div></div><div id='d_Gm' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_Gj' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_Gk' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_Gh' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><p>Returns the ith arguments to this operation.</p></div></div><div id='d_Gi' class='de'><h1>Method <span class='n'>getImportedModuleName</span></h1><div class='re'><code>getImportedModuleName( self )</code></div><div class='ds'><p>Returns the list of names representing the modules to load</p></div></div><div id='d_Gf' class='de'><h1>Class <span class='n'>IDestructor</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Gg' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_Gd' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_Ge' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_Gb' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><p>Returns the name of this annotation.</p></div></div><div id='d_Gc' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><p>Sets the given argument of this operation, by argument index.</p></div></div><div id='ij' class='cr'><div class='n'><a href='javascript:dS("ij");'>IImportOperation</a></div><div class='t'>Bases</div class='t'><div class='g'><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("ij","jj");'><span class='special __bases__'>IOperation</span></a></span><br /></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("ij","kj");'>addOpArgument</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("ij","lj");'>getAbstractType</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("ij","mj");'>getAnnotation</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("ij","nj");'>getDataFlow</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("ij","oj");'>getOpArgument</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("ij","pj");'>getOpArguments</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("ij","qj");'>getOpArgumentsInternalTypes</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("ij","rj");'>setAbstractType</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("ij","sj");'>setAnnotation</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("ij","tj");'>setOpArgument</a></span><br /></div></div><div id='VA' class='cr'><div class='n'><a href='javascript:dS("VA");'>Reporter</a></div><div class='t'>Bases</div class='t'><div class='g'><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("VA","c");'><span class='special __bases__'><i>Base class</i></span></a></span><br /></div><div class='t'>Methods</div class='t'><div class='g'><span class='u'><span class='prefix'>&equiv;</span><a href='javascript:dO("VA","WA");'><span class='special __init__'>constructor</span></a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("VA","XA");'>dedent</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("VA","YA");'>echoError</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("VA","ZA");'>echoWarning</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("VA","aB");'>error</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("VA","bB");'>indent</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("VA","cB");'>info</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("VA","dB");'>isDone</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("VA","eB");'>onError</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("VA","fB");'>onWarning</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("VA","gB");'>warning</a></span><br /></div></div><div id='Vb' class='cr'><div class='n'><a href='javascript:dS("Vb");'>IAssignation</a></div><div class='t'>Bases</div class='t'><div class='g'><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("Vb","Wb");'><span class='special __bases__'>IOperation</span></a></span><br /></div><div class='t'>Methods</div class='t'><div class='g'><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Vb","Xb");'>getAssignedValue</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Vb","Yb");'>getTarget</a></span><br /></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Vb","Zb");'>addOpArgument</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Vb","ac");'>getAbstractType</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Vb","bc");'>getAnnotation</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Vb","cc");'>getDataFlow</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Vb","dc");'>getOpArgument</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Vb","ec");'>getOpArguments</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Vb","fc");'>getOpArgumentsInternalTypes</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Vb","gc");'>setAbstractType</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Vb","hc");'>setAnnotation</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Vb","ic");'>setOpArgument</a></span><br /></div><div class='t'>Values</div class='t'><div class='g'><span class='d'><span class='prefix'>&bull;</span><a href='javascript:dO("Vb","jc");'>ARGS</a></span><br /></div></div><div id='Vm' class='cr'><div class='n'><a href='javascript:dS("Vm");'>IMatchExpressionOperation</a></div><div class='t'>Bases</div class='t'><div class='g'><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("Vm","Wm");'><span class='special __bases__'>IMatchOperation</span></a></span><br /></div><div class='t'>Methods</div class='t'><div class='g'><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Vm","Xm");'>getExpression</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("Vm","Ym");'>setExpression</a></span><br /></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Vm","Zm");'>addOpArgument</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Vm","an");'>getAbstractType</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Vm","bn");'>getAnnotation</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Vm","cn");'>getDataFlow</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Vm","dn");'>getOpArgument</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Vm","en");'>getOpArguments</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Vm","fn");'>getOpArgumentsInternalTypes</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Vm","gn");'>getPredicate</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Vm","hn");'>setAbstractType</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Vm","in");'>setAnnotation</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Vm","jn");'>setOpArgument</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("Vm","kn");'>setPredicate</a></span><br /></div><div class='t'>Values</div class='t'><div class='g'><span class='d'><span class='prefix'>&bull;</span><a href='javascript:dO("Vm","ln");'>ARGS</a></span><br /></div></div><div id='d_bu' class='de'><h1>Method <span class='n'>resolve</span></h1><div class='re'><code>resolve( self, name, dataflow=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_bt' class='de'><h1>Method <span class='n'>createProgram</span></h1><div class='re'><code>createProgram( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_bw' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.typecast.Sequence at 0x11328d0&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_bv' class='de'><h1>Method <span class='n'>_document</span></h1><div class='re'><code>_document( self, element )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_bq' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_bp' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><p>Returns the ith arguments to this operation.</p></div></div><div id='d_bs' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><p>Adds an argument to this operation. This should do checking of arguments (by expected internal type and number).</p></div></div><div id='d_br' class='de'><h1>list</h1><div class='re'><code>[[&lt;class lambdafactory.interfaces.IMatchOperation at 0x5bfd50&gt;]]</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='d_by' class='de'><h1>Method <span class='n'>__str__</span></h1><div class='re'><code>__str__( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_bx' class='de'><h1>Method <span class='n'>name</span></h1><div class='re'><code>name( self, name=None )</code></div><div class='ds'><p>Returns/sets the name for this type. By defaults, types are unnamed.</p></div></div><div id='d_bz' class='de'><h1>Class <span class='n'>Symbolic</span></h1><div class='re'></div><div class='ds'><p>Symbolic types are types that have no physical counter part but play a role in the type system. This is for instance the case with Any or Nil.</p></div></div><div id='d_be' class='de'><h1>Method <span class='n'>setSlot</span></h1><div class='re'><code>setSlot( self, name, evaluable )</code></div><div class='ds'><p>Binds the given evaluable to the named slot.</p></div></div><div id='d_bd' class='de'><h1>Method <span class='n'>getSlots</span></h1><div class='re'><code>getSlots( self )</code></div><div class='ds'><p>Returns (key, evaluable) pairs representing the slots within this context.</p></div></div><div id='d_bg' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, context )</code></div><div class='ds'><p>Sets the parent context for this context.</p></div></div><div id='d_bf' class='de'><h1>Method <span class='n'>getSlot</span></h1><div class='re'><code>getSlot( self, name )</code></div><div class='ds'><p>Returns the given evaluable bound to named slot.</p></div></div><div id='d_bc' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_bb' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.ISubsetOperation at 0x5bfcc0&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_bm' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_bl' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><p>Returns the arguments to this operation.</p></div></div><div id='d_bo' class='de'><h1>Method <span class='n'>getOperations</span></h1><div class='re'><code>getOperations( self )</code></div><div class='ds'><p>Returns the list of operations in this process.</p></div></div><div id='d_bn' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_bi' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.IEvaluable at 0x5bf3f0&gt;]</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='d_bh' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_bk' class='de'><h1>Class <span class='n'>IInstanceMethod</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_bj' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><p>Returns the arguments to this operation.</p></div></div><div id='d_bA' class='de'><h1>Function <span class='n'>Sequence_combine</span></h1><div class='re'><code>Sequence_combine( a, b, sequenceclass=<class lambdafactory.typecast.Sequence at 0x11328d0> )</code></div><div class='ds'><p>Combines the given arguments into a sequence. This follows the following rules: Nothing, Nothing -&gt; Nothing Nothing, A -&gt; A A, B -&gt; (A, B) (A, B), C -&gt; (A, B, C) ( type = type(a) ) (A, B), (C, D) -&gt; (A, B, C, D) ( type = type(a) ) A , (C, D) -&gt; (A, B, C) ( type = sequenceclass)</p></div></div><div id='d_bB' class='de'><h1>Method <span class='n'>indent</span></h1><div class='re'><code>indent( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_FA' class='de'><h1>Method <span class='n'>getCurrentClassParents</span></h1><div class='re'><code>getCurrentClassParents( self, theClass )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Fy' class='de'><h1>Class <span class='n'>SemanticError</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Fx' class='de'><h1>Method <span class='n'>setName</span></h1><div class='re'><code>setName( self, name )</code></div><div class='ds'><p>Sets the name of this type</p></div></div><div id='Hx' class='cr'><div class='n'><a href='javascript:dS("Hx");'>Environment</a></div><div class='t'>Bases</div class='t'><div class='g'><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("Hx","c");'><span class='special __bases__'><i>Base class</i></span></a></span><br /></div><div class='t'>Methods</div class='t'><div class='g'><span class='u'><span class='prefix'>&equiv;</span><a href='javascript:dO("Hx","Ix");'><span class='special __init__'>constructor</span></a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("Hx","Jx");'>register</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("Hx","Kx");'>resolve</a></span><br /></div></div><div id='d_Fz' class='de'><h1>Method <span class='n'>setConcreteType</span></h1><div class='re'><code>setConcreteType( self, value )</code></div><div class='ds'><p>Sets the <span class='term'>concrete type</span> for this abstract type. The concrete type is a value which represents the type. For instance, if this type represents a class, then the concrete type would be the class instance.</p></div></div><div id='d_Fq' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_Fp' class='de'><h1>Method <span class='n'>getModule</span></h1><div class='re'><code>getModule( self, moduleAbsoluteName )</code></div><div class='ds'><p>Returns the module (if any) with the given absolute name</p></div></div><div id='d_Fs' class='de'><h1>Method <span class='n'>_number</span></h1><div class='re'><code>_number( self, number )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Fr' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_Fu' class='de'><h1>Method <span class='n'>writeEnumeration</span></h1><div class='re'><code>writeEnumeration( self, operation )</code></div><div class='ds'><p>Writes an enumeration operation.</p></div></div><div id='d_Ft' class='de'><h1>wrapper_descriptor</h1><div class='re'></div><div class='ds'><div class="section"><h1 class="heading"><span class="number"><span class="level0">1<span class="lastDot dot">.</span></span></span><span class='term'>init</span><span class='term'>(...) initializes x; see x.</span><span class='term'>class</span><span class='term'>.</span><span class='term'>doc</span>_ for signature</h1><div class="level1"></div></div></div></div><div id='Ht' class='ro'><div class='n'><a href='javascript:dS("Ht");'>lambdafactory.modelwriter</a></div><div class='t'>Classes</div class='t'><div class='g'><span class='u'><span class='prefix'>&Tau;</span><a href='javascript:dO("Ht","It");'>AbstractWriter</a></span><br /><span class='d'><span class='prefix'>&Tau;</span><a href='javascript:dO("Ht","hu");'>FileSplitter</a></span><br /><span class='d'><span class='prefix'>&Tau;</span><a href='javascript:dO("Ht","qu");'>Writer</a></span><br /></div><div class='t'>Functions</div class='t'><div class='g'><span class='d'><span class='prefix'>&lambda;</span><a href='javascript:dO("Ht","wv");'>_flatten</a></span><br /><span class='d'><span class='prefix'>&lambda;</span><a href='javascript:dO("Ht","xv");'>_format</a></span><br /><span class='d'><span class='prefix'>&lambda;</span><a href='javascript:dO("Ht","yv");'>flatten</a></span><br /><span class='d'><span class='prefix'>&lambda;</span><a href='javascript:dO("Ht","zv");'>format</a></span><br /><span class='d'><span class='prefix'>&lambda;</span><a href='javascript:dO("Ht","Av");'>notEmpty</a></span><br /></div><div class='t'>Values</div class='t'><div class='g'><span class='d'><span class='prefix'>&bull;</span><a href='javascript:dO("Ht","Bv");'>PREFIX</a></span><br /><span class='d'><span class='prefix'>&bull;</span><a href='javascript:dO("Ht","gu");'>SNIP</a></span><br /><span class='d'><span class='prefix'>&bull;</span><a href='javascript:dO("Ht","Cv");'>SNIP_END</a></span><br /><span class='d'><span class='prefix'>&bull;</span><a href='javascript:dO("Ht","Dv");'>SNIP_START</a></span><br /></div></div><div id='d_Fv' class='de'><h1>Class <span class='n'>Behaviour</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Fi' class='de'><h1>Method <span class='n'>getAlias</span></h1><div class='re'><code>getAlias( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Fh' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_Fk' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_Fj' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><p>Returns the <em>internal types</em> for this operations arguments. This is typically the list of interfaces or @protocols that the arguments must comply to.</p></div></div><div id='d_Fm' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='Ho' class='cr'><div class='n'><a href='javascript:dS("Ho");'>IModuleAttribute</a></div><div class='t'>Bases</div class='t'><div class='g'><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("Ho","Io");'><span class='special __bases__'>IAttribute</span></a></span><br /></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Ho","Jo");'>getAbsoluteName</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Ho","Ko");'>getDefaultValue</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Ho","Lo");'>getName</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Ho","Mo");'>getTypeDescription</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Ho","No");'>setDefaultValue</a></span><br /></div></div><div id='d_Fo' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, context )</code></div><div class='ds'><p>Sets the parent context for this context.</p></div></div><div id='d_Fn' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='Hb' class='cr'><div class='n'><a href='javascript:dS("Hb");'>IArgument</a></div><div class='t'>Bases</div class='t'><div class='g'><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("Hb","Ib");'><span class='special __bases__'>ISlot</span></a></span><br /></div><div class='t'>Methods</div class='t'><div class='g'><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Hb","Jb");'>getDefaultValue</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Hb","Kb");'>isKeywords</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Hb","Lb");'>isOptional</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Hb","Mb");'>isRest</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Hb","Nb");'>setDefaultValue</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Hb","Ob");'>setKeywords</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Hb","Pb");'>setOptional</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Hb","Qb");'>setRest</a></span><br /></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Hb","Rb");'>getAbsoluteName</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Hb","Sb");'>getName</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Hb","Tb");'>getTypeDescription</a></span><br /></div></div><div id='d_Fc' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_Fb' class='de'><h1>Method <span class='n'>getContent</span></h1><div class='re'><code>getContent( self )</code></div><div class='ds'><p>Returns the content of this annotation.</p></div></div><div id='d_Fe' class='de'><h1>Method <span class='n'>getAbsoluteName</span></h1><div class='re'><code>getAbsoluteName( self )</code></div><div class='ds'><p>Returns the absolute name for this element</p></div></div><div id='d_Fd' class='de'><h1>Method <span class='n'>setAbstract</span></h1><div class='re'><code>setAbstract( self, isAbstract )</code></div><div class='ds'><p>Sets wether the given abstractable is abstract or not.</p></div></div><div id='d_Fg' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_Ff' class='de'><h1>Method <span class='n'>getOriginalValue</span></h1><div class='re'><code>getOriginalValue( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_tA' class='de'><h1>str</h1><div class='re'><code>'Importation'</code></div><div class='ds'><p>str(object) -&gt; string</p><p>Return a nice string representation of the object. If the argument is a string, the return value is the same object.</p></div></div><div id='d_tc' class='de'><h1>Method <span class='n'>addOperation</span></h1><div class='re'><code>addOperation( self, operation )</code></div><div class='ds'><p>Adds the given operation as a child of this process.</p></div></div><div id='d_tb' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><p>Adds an argument to this operation. This should do checking of arguments (by expected internal type and number).</p></div></div><div id='d_tg' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_tf' class='de'><h1>Method <span class='n'>getParents</span></h1><div class='re'><code>getParents( self )</code></div><div class='ds'><p>Returns the list of parent dataflows for this dataflow.</p></div></div><div id='d_te' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_td' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_tk' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_tj' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><p>Sets the given argument of this operation, by argument index.</p></div></div><div id='d_ti' class='de'><h1>Method <span class='n'>setAbstract</span></h1><div class='re'><code>setAbstract( self, isAbstract )</code></div><div class='ds'><p>Sets wether the given abstractable is abstract or not.</p></div></div><div id='d_th' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_to' class='de'><h1>Method <span class='n'>getParentName</span></h1><div class='re'><code>getParentName( self )</code></div><div class='ds'><p>Returns the parent name of this module (if any)</p></div></div><div id='d_tn' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_tm' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><p>Returns the ith arguments to this operation.</p></div></div><div id='d_tl' class='de'><h1>Method <span class='n'>getMethods</span></h1><div class='re'><code>getMethods( self )</code></div><div class='ds'><p>Returns the methods defined within this class.</p></div></div><div id='d_ts' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_tr' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IReferencable at 0x5bf3c0&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_tq' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><p>Returns the <em>internal types</em> for this operations arguments. This is typically the list of interfaces or @protocols that the arguments must comply to.</p></div></div><div id='d_tp' class='de'><h1>Method <span class='n'>getReferenceName</span></h1><div class='re'><code>getReferenceName( self )</code></div><div class='ds'><p>Returns the name which this reference contains. The name is used by the resolution operation to actually resolve a value from the name.</p></div></div><div id='d_tw' class='de'><h1>Method <span class='n'>setName</span></h1><div class='re'><code>setName( self, name )</code></div><div class='ds'><p>Sets the name of this type</p></div></div><div id='d_tv' class='de'><h1>Method <span class='n'>resolveAbsoluteOrLocal</span></h1><div class='re'><code>resolveAbsoluteOrLocal( self, name, dataflow=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_tu' class='de'><h1>Method <span class='n'>writeArgument</span></h1><div class='re'><code>writeArgument( self, argElement )</code></div><div class='ds'><p>Writes an argument element.</p></div></div><div id='d_tt' class='de'><h1>Method <span class='n'>resolve</span></h1><div class='re'><code>resolve( self, reference, context=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_tz' class='de'><h1>Method <span class='n'>__call__</span></h1><div class='re'><code>__call__( self )</code></div><div class='ds'><p>A type instance can be used as a class to construct a new type, which will be cloned from the current type.</p></div></div><div id='d_ty' class='de'><h1>Method <span class='n'>isSameAs</span></h1><div class='re'><code>isSameAs( self, otherType )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_tx' class='de'><h1>Method <span class='n'>asString</span></h1><div class='re'><code>asString( self, fromTypes=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Hw' class='de'><h1>Method <span class='n'>concreteType</span></h1><div class='re'><code>concreteType( self )</code></div><div class='ds'><p>Returns the <span class='term'>concrete type</span> for this abstract type.</p></div></div><div id='d_Hv' class='de'><h1>Method <span class='n'>getType</span></h1><div class='re'><code>getType( self, name )</code></div><div class='ds'><p>Returns the type with the given name, or None if it does not exist.</p></div></div><div id='d_Hu' class='de'><h1>Method <span class='n'>writeFunction</span></h1><div class='re'><code>writeFunction( self, function )</code></div><div class='ds'><p>Writes a function element.</p></div></div><div id='d_Ht' class='de'><h1>Module <span class='n'>lambdafactory.modelwriter</span></h1><div class='re'></div><div class='ds'><p>The <em>model writer</em> modules define a default program model to text conversion class and a set of useful functions to help writing program model to text translators.</p><p>Model writers can be used to convert a program model to source code in a specific language. As writer are stateful, you can add many checkings and transformations while writing a program, or parts of it.</p></div></div><div id='d_Hs' class='de'><h1>Method <span class='n'>_ref</span></h1><div class='re'><code>_ref( self, name )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Hr' class='de'><h1>Class <span class='n'>ISubsetOperation</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Hq' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><p>Returns the arguments to this operation.</p></div></div><div id='d_Hp' class='de'><h1>Method <span class='n'>setFactory</span></h1><div class='re'><code>setFactory( self, factory )</code></div><div class='ds'><p>Sets the factory that was used to create this program</p></div></div><div id='d_Hz' class='de'><h1>Method <span class='n'>subtype</span></h1><div class='re'><code>subtype( self, name )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Hy' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.typecast.Type at 0x11327e0&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Hx' class='de'><h1>Class <span class='n'>Environment</span></h1><div class='re'></div><div class='ds'><p>The environment stores types and names them. This allows to easily retrieve types from a given name.</p></div></div><div id='d_Hg' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_Hf' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IMethod at 0x5bf960&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_He' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_Hd' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_Hc' class='de'><h1>list</h1><div class='re'><code>[]</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='d_Hb' class='de'><h1>Class <span class='n'>IArgument</span></h1><div class='re'></div><div class='ds'><p>Arguments are slots which can be interpreted in different ways.</p><p>When an argument is <span class='term'>optional</span>, it does not need to be defined in the invocation. When an argument is <span class='term'>variable</span>, it means it references the rest of the arguments lists. When an argument is <span class='term'>keywords</span>, it will reference the named arguments of the rest of the arguments list.</p></div></div><div id='d_Ho' class='de'><h1>Class <span class='n'>IModuleAttribute</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Hn' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_Hm' class='de'><h1>Method <span class='n'>getResultAbstractType</span></h1><div class='re'><code>getResultAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type of the result of the evaluation of this evaluable</p></div></div><div id='d_Hl' class='de'><h1>Method <span class='n'>setSlot</span></h1><div class='re'><code>setSlot( self, name, evaluable )</code></div><div class='ds'><p>Binds the given evaluable to the named slot.</p></div></div><div id='d_Hk' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><p>Returns the ith arguments to this operation.</p></div></div><div id='d_Hj' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_Hi' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><p>Adds an argument to this operation. This should do checking of arguments (by expected internal type and number).</p></div></div><div id='d_Hh' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><p>Returns the arguments to this operation.</p></div></div><div id='d_HA' class='de'><h1>Method <span class='n'>getCurrentFunction</span></h1><div class='re'><code>getCurrentFunction( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='nA' class='cr'><div class='n'><a href='javascript:dS("nA");'>ImportationPass</a></div><div class='t'>Bases</div class='t'><div class='g'><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("nA","oA");'><span class='special __bases__'>Pass</span></a></span><br /></div><div class='t'>Methods</div class='t'><div class='g'><span class='u'><span class='prefix'>&equiv;</span><a href='javascript:dO("nA","pA");'><span class='special __init__'>constructor</span></a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("nA","qA");'>onModule</a></span><br /></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("nA","rA");'>getHandle</a></span><br /></div><div class='t'>Values</div class='t'><div class='g'><span class='d'><span class='prefix'>&bull;</span><a href='javascript:dO("nA","sA");'>HANDLES</a></span><br /><span class='d'><span class='prefix'>&bull;</span><a href='javascript:dO("nA","tA");'>NAME</a></span><br /></div></div><div id='d_ZA' class='de'><h1>Method <span class='n'>echoWarning</span></h1><div class='re'><code>echoWarning( self, message, element )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Zm' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><p>Adds an argument to this operation. This should do checking of arguments (by expected internal type and number).</p></div></div><div id='d_Zl' class='de'><h1>Method <span class='n'>getTarget</span></h1><div class='re'><code>getTarget( self )</code></div><div class='ds'><p>Returns the invocation target reference.</p></div></div><div id='d_Zo' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IElement at 0x5bf360&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Zn' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_Zi' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_Zh' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_Zk' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_Zj' class='de'><h1>list</h1><div class='re'><code>[[&lt;class lambdafactory.interfaces.IEvaluable at 0x5bf3f0&gt;], &lt;class lambdafactory.interfaces.IEvaluable at 0x5bf3f0&gt;]</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='d_Ze' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IElement at 0x5bf360&gt;, &lt;class lambdafactory.interfaces.IDataFlowOwner at 0x5bf330&gt;)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Zd' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_Zg' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><p>Returns the <em>internal types</em> for this operations arguments. This is typically the list of interfaces or @protocols that the arguments must comply to.</p></div></div><div id='d_Zf' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_Zc' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns the parent context for this context (if any)</p></div></div><div id='d_Zb' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><p>Adds an argument to this operation. This should do checking of arguments (by expected internal type and number).</p></div></div><div id='Hr' class='cr'><div class='n'><a href='javascript:dS("Hr");'>ISubsetOperation</a></div><div class='t'>Bases</div class='t'><div class='g'><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("Hr","Ir");'><span class='special __bases__'>IOperation</span></a></span><br /></div><div class='t'>Methods</div class='t'><div class='g'><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Hr","Jr");'>getTarget</a></span><br /></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Hr","Kr");'>addOpArgument</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Hr","Lr");'>getAbstractType</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Hr","Mr");'>getAnnotation</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Hr","Nr");'>getDataFlow</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Hr","Or");'>getOpArgument</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Hr","Pr");'>getOpArguments</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Hr","Qr");'>getOpArgumentsInternalTypes</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Hr","Rr");'>setAbstractType</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Hr","Sr");'>setAnnotation</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Hr","Tr");'>setOpArgument</a></span><br /></div></div><div id='d_Zy' class='de'><h1>Method <span class='n'>setName</span></h1><div class='re'><code>setName( self, name )</code></div><div class='ds'><p>Sets the name of this type</p></div></div><div id='d_Zx' class='de'><h1>Method <span class='n'>set</span></h1><div class='re'><code>set( self, name, theType )</code></div><div class='ds'><p>Sets the slot with the given <code>name</code> to have a value of the given type (<code>theType</code>).</p></div></div><div id='d_Zz' class='de'><h1>Function <span class='n'>Class</span></h1><div class='re'><code>Class( Context )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Zu' class='de'><h1>Method <span class='n'>writeTermination</span></h1><div class='re'><code>writeTermination( self, termination )</code></div><div class='ds'><p>Writes a termination operation.</p></div></div><div id='d_Zt' class='de'><h1>Method <span class='n'>isInClassMethod</span></h1><div class='re'><code>isInClassMethod( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Zw' class='de'><h1>Method <span class='n'>concreteType</span></h1><div class='re'><code>concreteType( self )</code></div><div class='ds'><p>Returns the <span class='term'>concrete type</span> for this abstract type.</p></div></div><div id='d_Zv' class='de'><h1>Module <span class='n'>lambdafactory.typecast</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Zq' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_Zp' class='de'><h1>Method <span class='n'>getReferenceName</span></h1><div class='re'><code>getReferenceName( self )</code></div><div class='ds'><p>Returns the name which this reference contains. The name is used by the resolution operation to actually resolve a value from the name.</p></div></div><div id='d_Zs' class='de'><h1>Method <span class='n'>createMethod</span></h1><div class='re'><code>createMethod( self, name, arguments=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Zr' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IOperation at 0x5bfa50&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_ep' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><p>Sets the given argument of this operation, by argument index.</p></div></div><div id='d_eq' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><p>Returns the local name for this referencable element</p></div></div><div id='d_er' class='de'><h1>Method <span class='n'>getSliceEnd</span></h1><div class='re'><code>getSliceEnd( self )</code></div><div class='ds'><p>Returns evaluable that will return the slice end</p></div></div><div id='d_es' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_et' class='de'><h1>Method <span class='n'>embedTemplate</span></h1><div class='re'><code>embedTemplate( self, lang, code )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_eu' class='de'><h1>Method <span class='n'>writeProgram</span></h1><div class='re'><code>writeProgram( self, programElement )</code></div><div class='ds'><p>Writes a Program element.</p></div></div><div id='d_ev' class='de'><h1>Method <span class='n'>_getContextsAsString</span></h1><div class='re'><code>_getContextsAsString( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_ew' class='de'><h1>Method <span class='n'>__str__</span></h1><div class='re'><code>__str__( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_ex' class='de'><h1>Method <span class='n'>setName</span></h1><div class='re'><code>setName( self, name )</code></div><div class='ds'><p>Sets the name of this type</p></div></div><div id='d_ey' class='de'><h1>Method <span class='n'>name</span></h1><div class='re'><code>name( self, name=None )</code></div><div class='ds'><p>Returns/sets the name for this type. By defaults, types are unnamed.</p></div></div><div id='d_ez' class='de'><h1>Method <span class='n'>asString</span></h1><div class='re'><code>asString( self, fromType=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_eb' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_ec' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><p>Returns the arguments to this operation.</p></div></div><div id='d_ed' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_ee' class='de'><h1>Method <span class='n'>getContent</span></h1><div class='re'><code>getContent( self )</code></div><div class='ds'><p>Returns the content of this annotation.</p></div></div><div id='d_ef' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, context )</code></div><div class='ds'><p>Sets the parent context for this context.</p></div></div><div id='d_eg' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IValue at 0x5bf4b0&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_eh' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><p>Sets the given argument of this operation, by argument index.</p></div></div><div id='d_ei' class='de'><h1>Method <span class='n'>endsWithTermination</span></h1><div class='re'><code>endsWithTermination( self )</code></div><div class='ds'><p>Returns true if this function ends with a termination operation. This is especially useful for back-ends which want to know if they have to insert an explicit <code>return</code> at the end (like Java).</p></div></div><div id='d_ej' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_ek' class='de'><h1>Method <span class='n'>endsWithTermination</span></h1><div class='re'><code>endsWithTermination( self )</code></div><div class='ds'><p>Returns true if this function ends with a termination operation. This is especially useful for back-ends which want to know if they have to insert an explicit <code>return</code> at the end (like Java).</p></div></div><div id='d_el' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_em' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><p>Returns the ith arguments to this operation.</p></div></div><div id='d_en' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><p>Returns the arguments to this operation.</p></div></div><div id='d_eo' class='de'><h1>Method <span class='n'>getSlots</span></h1><div class='re'><code>getSlots( self )</code></div><div class='ds'><p>Returns (key, evaluable) pairs representing the slots within this context.</p></div></div><div id='d_eA' class='de'><h1>Function <span class='n'>isLike</span></h1><div class='re'><code>isLike( a, b )</code></div><div class='ds'><p>Type (b) is like type (a) if (b) can be used where (a) can be used. When two types are alike but not the same, this usually means that one type is composed at some level of <code>Any</code> or <code>Rest</code> types.</p><p>Not that isLike(a,b) does not imply isLike(b,a), as (a) may be a "broad" type (such as <code>Any</code>), and (b) a particular type (say <code>String</code>).</p></div></div><div id='d_eB' class='de'><h1>Method <span class='n'>onError</span></h1><div class='re'><code>onError( self, callback )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Fl' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, context )</code></div><div class='ds'><p>Sets the parent context for this context.</p></div></div><div id='d_wA' class='de'><h1>Method <span class='n'>getHandle</span></h1><div class='re'><code>getHandle( self, element )</code></div><div class='ds'><p>Tells if the pass handles the given element. This basically iterates on the <code>handles</code> property values (which are interfaces), when one interface matches the given <code>element</code>, then the corresponding <code>onXXX</code> method is invoked, where <code>XXX</code> is the interface name (without the leading <code>I</code>).</p></div></div><div id='d_wn' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><p>Returns the <em>internal types</em> for this operations arguments. This is typically the list of interfaces or @protocols that the arguments must comply to.</p></div></div><div id='d_wo' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_wl' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns the parent context for this context (if any)</p></div></div><div id='d_wm' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_wj' class='de'><h1>Method <span class='n'>getAlias</span></h1><div class='re'><code>getAlias( self )</code></div><div class='ds'><p>Returns the (optional) alias which will allow to reference the element.</p></div></div><div id='d_wk' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, context )</code></div><div class='ds'><p>Sets the parent context for this context.</p></div></div><div id='d_wh' class='de'><h1>Class <span class='n'>IEvaluable</span></h1><div class='re'></div><div class='ds'><p>An evaluable is an element that can produce a value. Evaluable elements then have associated type information.</p></div></div><div id='d_wi' class='de'><h1>Method <span class='n'>setArguments</span></h1><div class='re'><code>setArguments( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_wf' class='de'><h1>Method <span class='n'>hasSlot</span></h1><div class='re'><code>hasSlot( self, name )</code></div><div class='ds'><p>Tells if this dataflow @methodines a slot with the given name.</p></div></div><div id='d_wg' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_wd' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_we' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><p>Returns the <em>internal types</em> for this operations arguments. This is typically the list of interfaces or @protocols that the arguments must comply to.</p></div></div><div id='d_wb' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_wc' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IInterruption at 0x5bfed0&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_wz' class='de'><h1>Method <span class='n'>asString</span></h1><div class='re'><code>asString( self, fromTypes=None )</code></div><div class='ds'><p>Returns a string representation of this type.</p></div></div><div id='d_wx' class='de'><h1>Method <span class='n'>elementNames</span></h1><div class='re'><code>elementNames( self )</code></div><div class='ds'><p>Returns the list of slots/elements defined in this map.</p></div></div><div id='d_wy' class='de'><h1>Method <span class='n'>result</span></h1><div class='re'><code>result( self, result=None )</code></div><div class='ds'><p>If there is not at least 2 addded types, the result is Nothing.</p></div></div><div id='d_wv' class='de'><h1>Function <span class='n'>_flatten</span></h1><div class='re'><code>_flatten( value, res )</code></div><div class='ds'><p>Flatten helper operation. See @flatten.</p></div></div><div id='d_ww' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.typecast.Type at 0x11327e0&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_wt' class='de'><h1>Method <span class='n'>slice</span></h1><div class='re'><code>slice( self, target, _start, _end=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_wu' class='de'><h1>Method <span class='n'>writeBlock</span></h1><div class='re'><code>writeBlock( self, block )</code></div><div class='ds'><p>Writes a block element.</p></div></div><div id='d_wr' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><p>Returns the local name for this referencable element</p></div></div><div id='d_ws' class='de'><h1>Class <span class='n'>Factory</span></h1><div class='re'></div><div class='ds'><p>This class takes a module and look for classes with the same name as the <code>createXXX</code> methods and instanciates them.</p><p>For instance, if you define a module with classes like <code>Value</code>, <code>Literal</code>, <code>Invocation</code>, <code>Function</code>, etc. you just have to give this module to the factory constructor and it will be used to generate the given element.</p></div></div><div id='d_wp' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_wq' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><p>Sets the given argument of this operation, by argument index.</p></div></div><div id='Mx' class='cr'><div class='n'><a href='javascript:dS("Mx");'>Map</a></div><div class='t'>Bases</div class='t'><div class='g'><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("Mx","Nx");'><span class='special __bases__'>Type</span></a></span><br /></div><div class='t'>Methods</div class='t'><div class='g'><span class='u'><span class='prefix'>&equiv;</span><a href='javascript:dO("Mx","Ox");'><span class='special __init__'>constructor</span></a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Mx","Px");'>add</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("Mx","Qx");'>asString</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("Mx","Rx");'>clone</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Mx","Sx");'>element</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Mx","Tx");'>elementNames</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Mx","Ux");'>elements</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Mx","Vx");'>get</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Mx","Wx");'>isLike</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("Mx","Xx");'>isSameAs</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Mx","Yx");'>isSubtypeOf</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Mx","Zx");'>set</a></span><br /></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("Mx","ay");'><span class='special __call__'>when invoked</span></a></span><br /><span class='u'><span class='prefix'>&equiv;</span><a href='javascript:dO("Mx","by");'><span class='special __str__'>string conversion</span></a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Mx","cy");'>concreteType</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("Mx","dy");'>definedBy</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Mx","ey");'>name</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Mx","fy");'>result</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Mx","gy");'>setConcreteType</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Mx","hy");'>setName</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("Mx","iy");'>subtype</a></span><br /></div></div><div id='d_Kr' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><p>Adds an argument to this operation. This should do checking of arguments (by expected internal type and number).</p></div></div><div id='d_Ks' class='de'><h1>Method <span class='n'>access</span></h1><div class='re'><code>access( self, target, _index )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Kp' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_Kq' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_Kv' class='de'><h1>Method <span class='n'>getType</span></h1><div class='re'><code>getType( self, name )</code></div><div class='ds'><p>Returns the type with the given name, or None if it does not exist.</p></div></div><div id='d_Kw' class='de'><h1>Method <span class='n'>result</span></h1><div class='re'><code>result( self )</code></div><div class='ds'><p>Returns the result for this type. This is usually just the type itself, except for processes types.</p></div></div><div id='d_Kt' class='de'><h1>Method <span class='n'>_document</span></h1><div class='re'><code>_document( self, element )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Ku' class='de'><h1>Method <span class='n'>writeImportSymbolOperation</span></h1><div class='re'><code>writeImportSymbolOperation( self, element )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Kz' class='de'><h1>Method <span class='n'>__call__</span></h1><div class='re'><code>__call__( self )</code></div><div class='ds'><p>A type instance can be used as a class to construct a new type, which will be cloned from the current type.</p></div></div><div id='d_Kx' class='de'><h1>Method <span class='n'>resolve</span></h1><div class='re'><code>resolve( self, typeName )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Ky' class='de'><h1>Method <span class='n'>asString</span></h1><div class='re'><code>asString( self, fromTypes=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Kb' class='de'><h1>Method <span class='n'>isKeywords</span></h1><div class='re'><code>isKeywords( self )</code></div><div class='ds'><p>Tells if the argument is keywords list or not.</p></div></div><div id='d_Kc' class='de'><h1>Method <span class='n'>getAttributes</span></h1><div class='re'><code>getAttributes( self )</code></div><div class='ds'><p>Returns the (non-class) attributes defined within this class.</p></div></div><div id='d_Kf' class='de'><h1>Method <span class='n'>getAbsoluteName</span></h1><div class='re'><code>getAbsoluteName( self )</code></div><div class='ds'><p>Returns the absolute name for this element</p></div></div><div id='d_Kg' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><p>Returns the <em>internal types</em> for this operations arguments. This is typically the list of interfaces or @protocols that the arguments must comply to.</p></div></div><div id='d_Kd' class='de'><h1>Method <span class='n'>setSlot</span></h1><div class='re'><code>setSlot( self, name, evaluable )</code></div><div class='ds'><p>Binds the given evaluable to the named slot.</p></div></div><div id='d_Ke' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><p>Returns this @protocol name. It can be <code>None</code> if the @protocol is anonymous.</p></div></div><div id='d_Kj' class='de'><h1>list</h1><div class='re'><code>['ImportedElement', 'ImportOrigin', 'Alias']</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='d_Kk' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_Kh' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_Ki' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_Kn' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><p>Returns the <em>internal types</em> for this operations arguments. This is typically the list of interfaces or @protocols that the arguments must comply to.</p></div></div><div id='d_Ko' class='de'><h1>Method <span class='n'>getDefaultValue</span></h1><div class='re'><code>getDefaultValue( self )</code></div><div class='ds'><p>Gets the @methodault value for this attribute</p></div></div><div id='d_Kl' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><p>Adds an argument to this operation. This should do checking of arguments (by expected internal type and number).</p></div></div><div id='d_Km' class='de'><h1>Method <span class='n'>setResultAbstractType</span></h1><div class='re'><code>setResultAbstractType( self, abstractType )</code></div><div class='ds'><p>Sets the abstract type for this operation result. This is usually invoked in the typing phase.</p></div></div><div id='d_KA' class='de'><h1>Method <span class='n'>isIn</span></h1><div class='re'><code>isIn( self, interface )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_yd' class='de'><h1>Method <span class='n'>getOperations</span></h1><div class='re'><code>getOperations( self )</code></div><div class='ds'><p>Returns the list of operations in this process.</p></div></div><div id='d_ye' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_yf' class='de'><h1>Class <span class='n'>IDataFlowOwner</span></h1><div class='re'></div><div class='ds'><p>DataFlow owners are elements that have their own dataflow. IContext are typical examples of elements that are dataflow owners</p></div></div><div id='d_yg' class='de'><h1>Class <span class='n'>IEmbed</span></h1><div class='re'></div><div class='ds'><p>An embedded operation represents a bit of verbatim code written in a different language. This allows for embedding code written specifically in a target language (which may happen for optimizing stuff, for instance).</p></div></div><div id='d_yb' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><p>Returns the arguments to this operation.</p></div></div><div id='d_yc' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_yl' class='de'><h1>Method <span class='n'>getSlot</span></h1><div class='re'><code>getSlot( self, name )</code></div><div class='ds'><p>Returns the given evaluable bound to named slot.</p></div></div><div id='d_ym' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><p>Sets the given argument of this operation, by argument index.</p></div></div><div id='d_yn' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_yo' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_yh' class='de'><h1>Method <span class='n'>setResultAbstractType</span></h1><div class='re'><code>setResultAbstractType( self, abstractType )</code></div><div class='ds'><p>Sets the abstract type for this operation result. This is usually invoked in the typing phase.</p></div></div><div id='d_yi' class='de'><h1>Method <span class='n'>setSlot</span></h1><div class='re'><code>setSlot( self, name, evaluable )</code></div><div class='ds'><p>Binds the given evaluable to the named slot.</p></div></div><div id='d_yj' class='de'><h1>Method <span class='n'>getImportedElement</span></h1><div class='re'><code>getImportedElement( self )</code></div><div class='ds'><p>Returns a reference or a resolution that will allow to get the imported element.</p></div></div><div id='d_yk' class='de'><h1>Class <span class='n'>IInstanciable</span></h1><div class='re'></div><div class='ds'><p>Instanciable is a property of some elements that allows them to be instanciated. Conceptually, an instanciation could be considered as a specific kind of invocation.</p></div></div><div id='d_yt' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self, someClass, expectedClass, argument )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_yu' class='de'><h1>Method <span class='n'>writeClassAttribute</span></h1><div class='re'><code>writeClassAttribute( self, element )</code></div><div class='ds'><p>Writes an argument element.</p></div></div><div id='d_yv' class='de'><h1>Function <span class='n'>flatten</span></h1><div class='re'><code>flatten( *lists )</code></div><div class='ds'><p>Flattens the given lists in a single list.</p></div></div><div id='d_yw' class='de'><h1>Method <span class='n'>asString</span></h1><div class='re'><code>asString( self, fromTypes=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_yp' class='de'><h1>Class <span class='n'>IProcess</span></h1><div class='re'></div><div class='ds'><p>A process is a sequence of operations.</p></div></div><div id='d_yq' class='de'><h1>Class <span class='n'>IResolution</span></h1><div class='re'></div><div class='ds'><p>A resolution resolves a reference into a value.</p></div></div><div id='d_yr' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.ILiteral at 0x5bf4e0&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_ys' class='de'><h1>Method <span class='n'>_arg</span></h1><div class='re'><code>_arg( self, name, typeinfo=None, optional=False )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_yx' class='de'><h1>Method <span class='n'>isLike</span></h1><div class='re'><code>isLike( self, otherType )</code></div><div class='ds'><p>The other type is like this one if the other is a sequence with the same length and that all elements are like the corresponding elements of this sequence.</p></div></div><div id='d_yy' class='de'><h1>Method <span class='n'>__str__</span></h1><div class='re'><code>__str__( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_yz' class='de'><h1>Method <span class='n'>concreteType</span></h1><div class='re'><code>concreteType( self )</code></div><div class='ds'><p>Returns the <span class='term'>concrete type</span> for this abstract type.</p></div></div><div id='d_yA' class='de'><h1>str</h1><div class='re'><code>''</code></div><div class='ds'><p>str(object) -&gt; string</p><p>Return a nice string representation of the object. If the argument is a string, the return value is the same object.</p></div></div><div id='sz' class='cr'><div class='n'><a href='javascript:dS("sz");'>Type</a></div><div class='t'>Bases</div class='t'><div class='g'><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("sz","c");'><span class='special __bases__'><i>Base class</i></span></a></span><br /></div><div class='t'>Methods</div class='t'><div class='g'><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("sz","tz");'><span class='special __call__'>when invoked</span></a></span><br /><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("sz","uz");'><span class='special __init__'>constructor</span></a></span><br /><span class='u'><span class='prefix'>&equiv;</span><a href='javascript:dO("sz","vz");'><span class='special __str__'>string conversion</span></a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("sz","wz");'>asString</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("sz","xz");'>clone</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("sz","yz");'>concreteType</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("sz","zz");'>definedBy</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("sz","Az");'>isLike</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("sz","Bz");'>isSameAs</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("sz","Cz");'>isSubtypeOf</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("sz","Dz");'>name</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("sz","Ez");'>result</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("sz","Fz");'>setConcreteType</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("sz","Gz");'>setName</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("sz","Hz");'>subtype</a></span><br /></div></div><div id='sr' class='cr'><div class='n'><a href='javascript:dS("sr");'>ISlot</a></div><div class='t'>Bases</div class='t'><div class='g'><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("sr","tr");'><span class='special __bases__'>IReferencable</span></a></span><br /></div><div class='t'>Methods</div class='t'><div class='g'><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("sr","ur");'>getTypeDescription</a></span><br /></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("sr","vr");'>getAbsoluteName</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("sr","wr");'>getName</a></span><br /></div></div><div id='sg' class='cr'><div class='n'><a href='javascript:dS("sg");'>IElement</a></div><div class='t'>Bases</div class='t'><div class='g'><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("sg","c");'><span class='special __bases__'><i>Base class</i></span></a></span><br /></div><div class='t'>Methods</div class='t'><div class='g'><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("sg","tg");'>getAbstractType</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("sg","ug");'>getAnnotation</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("sg","vg");'>getDataFlow</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("sg","wg");'>setAbstractType</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("sg","xg");'>setAnnotation</a></span><br /></div></div><div id='Rv' class='cr'><div class='n'><a href='javascript:dS("Rv");'>Structure</a></div><div class='t'>Bases</div class='t'><div class='g'><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("Rv","Sv");'><span class='special __bases__'>TypeCollection</span></a></span><br /></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Rv","Tv");'>getType</a></span><br /></div></div><div id='Rn' class='cr'><div class='n'><a href='javascript:dS("Rn");'>IMethod</a></div><div class='t'>Bases</div class='t'><div class='g'><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("Rn","Sn");'><span class='special __bases__'>IFunction</span></a></span><br /></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Rn","Tn");'>addOperation</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Rn","Un");'>endsWithTermination</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Rn","Vn");'>getAbsoluteName</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Rn","Wn");'>getAbstractType</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Rn","Xn");'>getAnnotation</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("Rn","Yn");'>getArguments</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Rn","Zn");'>getDataFlow</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Rn","ao");'>getName</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Rn","bo");'>getOperations</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Rn","co");'>getParent</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Rn","do");'>getSlot</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Rn","eo");'>getSlots</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Rn","fo");'>hasExplicitTermination</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Rn","go");'>hasSlot</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Rn","ho");'>isAbstract</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Rn","io");'>setAbstract</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Rn","jo");'>setAbstractType</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Rn","ko");'>setAnnotation</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("Rn","lo");'>setArguments</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Rn","mo");'>setParent</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Rn","no");'>setSlot</a></span><br /></div></div><div id='d_ds' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_dr' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.ISubsetOperation at 0x5bfcc0&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_dq' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_dp' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><p>Returns the <em>internal types</em> for this operations arguments. This is typically the list of interfaces or @protocols that the arguments must comply to.</p></div></div><div id='d_dw' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self, *args )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_dv' class='de'><h1>Method <span class='n'>_format</span></h1><div class='re'><code>_format( self, *values )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_du' class='de'><h1>Method <span class='n'>write</span></h1><div class='re'><code>write( self, element )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_dt' class='de'><h1>Method <span class='n'>embed</span></h1><div class='re'><code>embed( self, lang, code )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_dz' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self, name )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_dy' class='de'><h1>Method <span class='n'>definedBy</span></h1><div class='re'><code>definedBy( self, definition=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_dx' class='de'><h1>Method <span class='n'>setConcreteType</span></h1><div class='re'><code>setConcreteType( self, value )</code></div><div class='ds'><p>Sets the <span class='term'>concrete type</span> for this abstract type. The concrete type is a value which represents the type. For instance, if this type represents a class, then the concrete type would be the class instance.</p></div></div><div id='d_dc' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><p>Returns the ith arguments to this operation.</p></div></div><div id='d_db' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><p>Adds an argument to this operation. This should do checking of arguments (by expected internal type and number).</p></div></div><div id='d_dg' class='de'><h1>Class <span class='n'>IDict</span></h1><div class='re'></div><div class='ds'><p>A dictionary is a binding of key to values. It may or may not be ordered, depending on the implementation/model semantics.</p></div></div><div id='d_df' class='de'><h1>Method <span class='n'>hasSlot</span></h1><div class='re'><code>hasSlot( self, name )</code></div><div class='ds'><p>Tells if the context has a slot with the given name.</p></div></div><div id='d_de' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IAnnotation at 0x5bf210&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_dd' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_dk' class='de'><h1>Method <span class='n'>addOperation</span></h1><div class='re'><code>addOperation( self, operation )</code></div><div class='ds'><p>Adds the given operation as a child of this process.</p></div></div><div id='d_dj' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_di' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IClosure at 0x5bf900&gt;, &lt;class lambdafactory.interfaces.IReferencable at 0x5bf3c0&gt;, &lt;class lambdafactory.interfaces.IAbstractable at 0x5bf480&gt;)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_dh' class='de'><h1>Method <span class='n'>setLanguage</span></h1><div class='re'><code>setLanguage( self, language )</code></div><div class='ds'><p>Sets the language in which the emebedded code is written.</p></div></div><div id='d_do' class='de'><h1>Method <span class='n'>getSlot</span></h1><div class='re'><code>getSlot( self, name )</code></div><div class='ds'><p>Returns the given evaluable bound to named slot.</p></div></div><div id='d_dn' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><p>Returns the ith arguments to this operation.</p></div></div><div id='d_dm' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_dl' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_dB' class='de'><h1>Method <span class='n'>isDone</span></h1><div class='re'><code>isDone( self, message, element, update=True )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_dA' class='de'><h1>Function <span class='n'>bits</span></h1><div class='re'><code>bits( size )</code></div><div class='ds'><p>Converts the given number of bits into bytes. This is simply for readibility purprose.</p></div></div><div id='d_xg' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_xf' class='de'><h1>Method <span class='n'>resolve</span></h1><div class='re'><code>resolve( self, name )</code></div><div class='ds'><p>Returns a couple <code>(DataFlow slot, IElement)</code> or <code>(None,None)</code> corresponding to the resolution of the given <code>name</code> in this dataflow.</p></div></div><div id='d_xe' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_xd' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><p>Returns this @protocol name. It can be <code>None</code> if the @protocol is anonymous.</p></div></div><div id='d_xc' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><p>Adds an argument to this operation. This should do checking of arguments (by expected internal type and number).</p></div></div><div id='d_xb' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><p>Returns the ith arguments to this operation.</p></div></div><div id='d_xo' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_xn' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_xm' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_xl' class='de'><h1>Method <span class='n'>getParentClasses</span></h1><div class='re'><code>getParentClasses( self )</code></div><div class='ds'><p>Returns the list of inherited classes references.</p></div></div><div id='d_xk' class='de'><h1>Method <span class='n'>setSlot</span></h1><div class='re'><code>setSlot( self, name, evaluable )</code></div><div class='ds'><p>Binds the given evaluable to the named slot.</p></div></div><div id='d_xj' class='de'><h1>Method <span class='n'>getImportOrigin</span></h1><div class='re'><code>getImportOrigin( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_xi' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, context )</code></div><div class='ds'><p>Sets the parent context for this context.</p></div></div><div id='d_xh' class='de'><h1>Method <span class='n'>getResultAbstractType</span></h1><div class='re'><code>getResultAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type of the result of the evaluation of this evaluable</p></div></div><div id='d_xw' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self, contentType, name=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_xv' class='de'><h1>Function <span class='n'>_format</span></h1><div class='re'><code>_format( value, level=-1 )</code></div><div class='ds'><p>Format helper operation. See @format.</p></div></div><div id='d_xu' class='de'><h1>Method <span class='n'>writeClass</span></h1><div class='re'><code>writeClass( self, classElement )</code></div><div class='ds'><p>Writes a class element.</p></div></div><div id='d_xt' class='de'><h1>Class <span class='n'>ModelBadArgument</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_xs' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self, module=<module 'lambdafactory.model' from '/Users/sebastien/Local/Python/lambdafactory/model.pyc'> )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_xr' class='de'><h1>Class <span class='n'>IString</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_xq' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.IEvaluable at 0x5bf3f0&gt;, &lt;class lambdafactory.interfaces.IProcess at 0x5bf870&gt;]</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='d_xp' class='de'><h1>Method <span class='n'>setResultAbstractType</span></h1><div class='re'><code>setResultAbstractType( self, abstractType )</code></div><div class='ds'><p>Sets the abstract type for this operation result. This is usually invoked in the typing phase.</p></div></div><div id='xr' class='cr'><div class='n'><a href='javascript:dS("xr");'>IString</a></div><div class='t'>Bases</div class='t'><div class='g'><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("xr","yr");'><span class='special __bases__'>ILiteral</span></a></span><br /></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("xr","zr");'>getAbstractType</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("xr","Ar");'>getActualValue</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("xr","Br");'>getAnnotation</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("xr","Cr");'>getDataFlow</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("xr","Dr");'>getResultAbstractType</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("xr","Er");'>setAbstractType</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("xr","Fr");'>setAnnotation</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("xr","Gr");'>setResultAbstractType</a></span><br /></div></div><div id='d_xz' class='de'><h1>Method <span class='n'>clone</span></h1><div class='re'><code>clone( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='xt' class='cr'><div class='n'><a href='javascript:dS("xt");'>ModelBadArgument</a></div><div class='t'>Methods</div class='t'><div class='g'><span class='u'><span class='prefix'>&equiv;</span><a href='javascript:dO("xt","yt");'><span class='special __init__'>constructor</span></a></span><br /></div><div class='t'>Inhertied Values</div class='t'><div class='g'><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("xt","zt");'><span class='special __getitem__'>get item</span></a></span><br /><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("xt","At");'><span class='special __repr__'>string repr</span></a></span><br /><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("xt","Bt");'><span class='special __str__'>string conversion</span></a></span><br /><span class='u'><span class='prefix'>&sdot;</span><a href='javascript:dO("xt","Ct");'>args</a></span><br /><span class='d'><span class='prefix'>&sdot;</span><a href='javascript:dO("xt","Dt");'>message</a></span><br /></div></div><div id='d_xx' class='de'><h1>Method <span class='n'>get</span></h1><div class='re'><code>get( self, name )</code></div><div class='ds'><p>Returns the type for the slot with the given name.</p></div></div><div id='d_xA' class='de'><h1>list</h1><div class='re'><code>[]</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='d_vA' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_vi' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_vh' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.IEvaluable at 0x5bf3f0&gt;, &lt;class lambdafactory.interfaces.IEvaluable at 0x5bf3f0&gt;, &lt;class lambdafactory.interfaces.IEvaluable at 0x5bf3f0&gt;]</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='d_vk' class='de'><h1>Method <span class='n'>setArguments</span></h1><div class='re'><code>setArguments( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_vj' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IImportOperation at 0x5bfa80&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_vm' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><p>Returns the <em>internal types</em> for this operations arguments. This is typically the list of interfaces or @protocols that the arguments must comply to.</p></div></div><div id='d_vl' class='de'><h1>Method <span class='n'>getOperations</span></h1><div class='re'><code>getOperations( self )</code></div><div class='ds'><p>Returns the operations (methods and class methods) defined within this class.</p></div></div><div id='d_vo' class='de'><h1>Method <span class='n'>setImported</span></h1><div class='re'><code>setImported( self, value=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_vn' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><p>Returns the arguments to this operation.</p></div></div><div id='d_vc' class='de'><h1>Class <span class='n'>IBreaking</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_vb' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_ve' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><p>Returns the arguments to this operation.</p></div></div><div id='d_vd' class='de'><h1>Method <span class='n'>getArguments</span></h1><div class='re'><code>getArguments( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_vg' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_vf' class='de'><h1>Method <span class='n'>getSlots</span></h1><div class='re'><code>getSlots( self )</code></div><div class='ds'><p>Returns the lsit of slots @methodiend for this dataflow.</p></div></div><div id='d_vy' class='de'><h1>Method <span class='n'>peel</span></h1><div class='re'><code>peel( self )</code></div><div class='ds'><p>If this process is (A, B)-&gt;C, will return (B)-&gt;C. You cannot peel a process that is (B)-&gt;C.</p></div></div><div id='d_vx' class='de'><h1>Method <span class='n'>definedBy</span></h1><div class='re'><code>definedBy( self, definition=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_vz' class='de'><h1>Method <span class='n'>__str__</span></h1><div class='re'><code>__str__( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_vq' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_vp' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_vs' class='de'><h1>Module <span class='n'>lambdafactory.modelbase</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_vr' class='de'><h1>Method <span class='n'>getAbsoluteName</span></h1><div class='re'><code>getAbsoluteName( self )</code></div><div class='ds'><p>Returns the absolute name for this element</p></div></div><div id='d_vu' class='de'><h1>Method <span class='n'>writeAttribute</span></h1><div class='re'><code>writeAttribute( self, element )</code></div><div class='ds'><p>Writes an argument element.</p></div></div><div id='d_vt' class='de'><h1>Method <span class='n'>select</span></h1><div class='re'><code>select( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_vw' class='de'><h1>Class <span class='n'>Array</span></h1><div class='re'></div><div class='ds'><p>A sequence is simply an ordered set of types.</p></div></div><div id='d_vv' class='de'><h1>Method <span class='n'>writeProgram</span></h1><div class='re'><code>writeProgram( self, programElement )</code></div><div class='ds'><p>Writes a Program element.</p></div></div><div id='d_Le' class='de'><h1>Method <span class='n'>getOperations</span></h1><div class='re'><code>getOperations( self )</code></div><div class='ds'><p>Returns the list of operations in this process.</p></div></div><div id='Di' class='cr'><div class='n'><a href='javascript:dS("Di");'>IImportModuleOperation</a></div><div class='t'>Bases</div class='t'><div class='g'><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("Di","Ei");'><span class='special __bases__'>IImportOperation</span></a></span><br /></div><div class='t'>Methods</div class='t'><div class='g'><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("Di","Fi");'>getAlias</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Di","Gi");'>getImportedModuleName</a></span><br /></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Di","Hi");'>addOpArgument</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Di","Ii");'>getAbstractType</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Di","Ji");'>getAnnotation</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Di","Ki");'>getDataFlow</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Di","Li");'>getOpArgument</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Di","Mi");'>getOpArguments</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Di","Ni");'>getOpArgumentsInternalTypes</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Di","Oi");'>setAbstractType</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Di","Pi");'>setAnnotation</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Di","Qi");'>setOpArgument</a></span><br /></div><div class='t'>Values</div class='t'><div class='g'><span class='d'><span class='prefix'>&bull;</span><a href='javascript:dO("Di","Ri");'>ARGS</a></span><br /><span class='d'><span class='prefix'>&bull;</span><a href='javascript:dO("Di","Si");'>ARG_NAMES</a></span><br /></div></div><div id='d_Jy' class='de'><h1>Method <span class='n'>add</span></h1><div class='re'><code>add( self, theType )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Jx' class='de'><h1>Method <span class='n'>register</span></h1><div class='re'><code>register( self, name, _type )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Jz' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.typecast.Symbolic at 0x1132810&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Ju' class='de'><h1>Method <span class='n'>writeImportModulesOperation</span></h1><div class='re'><code>writeImportModulesOperation( self, element )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Jt' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self, reporter=<lambdafactory.reporter.Reporter instance at 0x11aa058> )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Jw' class='de'><h1>Method <span class='n'>name</span></h1><div class='re'><code>name( self, name=None )</code></div><div class='ds'><p>Returns/sets the name for this type. By defaults, types are unnamed.</p></div></div><div id='d_Jv' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.modeltypes.TypeCollection at 0x1127f90&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Jq' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_Jp' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_Js' class='de'><h1>Method <span class='n'>_string</span></h1><div class='re'><code>_string( self, value )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Jr' class='de'><h1>Method <span class='n'>getTarget</span></h1><div class='re'><code>getTarget( self )</code></div><div class='ds'><p>Returns the operation target.</p></div></div><div id='d_Jm' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_Jl' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IOperation at 0x5bfa50&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Jo' class='de'><h1>Method <span class='n'>getAbsoluteName</span></h1><div class='re'><code>getAbsoluteName( self )</code></div><div class='ds'><p>Returns the absolute name for this element</p></div></div><div id='d_Jn' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><p>Returns the arguments to this operation.</p></div></div><div id='d_Ji' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_Jh' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_Jk' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><p>Returns the <em>internal types</em> for this operations arguments. This is typically the list of interfaces or @protocols that the arguments must comply to.</p></div></div><div id='d_Jj' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.IEvaluable at 0x5bf3f0&gt;, &lt;class lambdafactory.interfaces.IEvaluable at 0x5bf3f0&gt;, &lt;class lambdafactory.interfaces.IEvaluable at 0x5bf3f0&gt;]</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='d_Je' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_Jd' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, context )</code></div><div class='ds'><p>Sets the parent context for this context.</p></div></div><div id='d_Jg' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><p>Returns the arguments to this operation.</p></div></div><div id='d_Jf' class='de'><h1>Method <span class='n'>endsWithTermination</span></h1><div class='re'><code>endsWithTermination( self )</code></div><div class='ds'><p>Returns true if this function ends with a termination operation. This is especially useful for back-ends which want to know if they have to insert an explicit <code>return</code> at the end (like Java).</p></div></div><div id='d_Jc' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IContext at 0x5bf750&gt;, &lt;class lambdafactory.interfaces.IReferencable at 0x5bf3c0&gt;)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Jb' class='de'><h1>Method <span class='n'>getDefaultValue</span></h1><div class='re'><code>getDefaultValue( self )</code></div><div class='ds'><p>Returns the @methodault value for this slot.</p></div></div><div id='d_JA' class='de'><h1>Method <span class='n'>getCurrentProcess</span></h1><div class='re'><code>getCurrentProcess( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='Wl' class='cr'><div class='n'><a href='javascript:dS("Wl");'>IInvocation</a></div><div class='t'>Bases</div class='t'><div class='g'><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("Wl","Xl");'><span class='special __bases__'>IOperation</span></a></span><br /></div><div class='t'>Methods</div class='t'><div class='g'><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Wl","Yl");'>getArguments</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Wl","Zl");'>getTarget</a></span><br /></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Wl","am");'>addOpArgument</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Wl","bm");'>getAbstractType</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Wl","cm");'>getAnnotation</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Wl","dm");'>getDataFlow</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Wl","em");'>getOpArgument</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Wl","fm");'>getOpArguments</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Wl","gm");'>getOpArgumentsInternalTypes</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Wl","hm");'>setAbstractType</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Wl","im");'>setAnnotation</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Wl","jm");'>setOpArgument</a></span><br /></div><div class='t'>Values</div class='t'><div class='g'><span class='d'><span class='prefix'>&bull;</span><a href='javascript:dO("Wl","km");'>ARGS</a></span><br /></div></div><div id='d_gz' class='de'><h1>Method <span class='n'>__call__</span></h1><div class='re'><code>__call__( self )</code></div><div class='ds'><p>A type instance can be used as a class to construct a new type, which will be cloned from the current type.</p></div></div><div id='d_gx' class='de'><h1>Class <span class='n'>Context</span></h1><div class='re'></div><div class='ds'><p>The Context type is the type that will probably be the most used in OO languages. A context can inherit from other contexts, in which case there is an explicit subtyping relationship.</p></div></div><div id='d_gy' class='de'><h1>Method <span class='n'>setConcreteType</span></h1><div class='re'><code>setConcreteType( self, value )</code></div><div class='ds'><p>Sets the <span class='term'>concrete type</span> for this abstract type. The concrete type is a value which represents the type. For instance, if this type represents a class, then the concrete type would be the class instance.</p></div></div><div id='d_gv' class='de'><h1>Method <span class='n'>getCurrentClass</span></h1><div class='re'><code>getCurrentClass( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_gw' class='de'><h1>Method <span class='n'>asString</span></h1><div class='re'><code>asString( self, fromTypes=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_gt' class='de'><h1>Method <span class='n'>evaluate</span></h1><div class='re'><code>evaluate( self, evaluable )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_gu' class='de'><h1>str</h1><div class='re'><code>'8&lt; ---[%s]---'</code></div><div class='ds'><p>str(object) -&gt; string</p><p>Return a nice string representation of the object. If the argument is a string, the return value is the same object.</p></div></div><div id='d_gr' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><p>Adds an argument to this operation. This should do checking of arguments (by expected internal type and number).</p></div></div><div id='d_gs' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><p>Returns the arguments to this operation.</p></div></div><div id='d_gp' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_gq' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_gn' class='de'><h1>Method <span class='n'>getPredicate</span></h1><div class='re'><code>getPredicate( self )</code></div><div class='ds'><p>Returns the evaluable that acts as a predicate for this operation.</p></div></div><div id='d_go' class='de'><h1>Method <span class='n'>hasSlot</span></h1><div class='re'><code>hasSlot( self, name )</code></div><div class='ds'><p>Tells if the context has a slot with the given name.</p></div></div><div id='d_gl' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.IProcess at 0x5bf870&gt;, &lt;class lambdafactory.interfaces.IProcess at 0x5bf870&gt;, &lt;class lambdafactory.interfaces.IProcess at 0x5bf870&gt;]</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='d_gm' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><p>Returns the <em>internal types</em> for this operations arguments. This is typically the list of interfaces or @protocols that the arguments must comply to.</p></div></div><div id='d_gj' class='de'><h1>list</h1><div class='re'><code>[[&lt;class lambdafactory.interfaces.IEvaluable at 0x5bf3f0&gt;]]</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='d_gk' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_gh' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IOperation at 0x5bfa50&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_gi' class='de'><h1>Method <span class='n'>hasExplicitTermination</span></h1><div class='re'><code>hasExplicitTermination( self )</code></div><div class='ds'><p>Returns true if this function has an operation with a termination, otherwise return false.</p></div></div><div id='d_gf' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_gg' class='de'><h1>Method <span class='n'>setValue</span></h1><div class='re'><code>setValue( self, key, value )</code></div><div class='ds'><p>Sets the value to be associated to the given key (which must be an evaluable).</p></div></div><div id='d_gd' class='de'><h1>Method <span class='n'>setSlot</span></h1><div class='re'><code>setSlot( self, name, evaluable )</code></div><div class='ds'><p>Binds the given evaluable to the named slot.</p></div></div><div id='d_ge' class='de'><h1>Class <span class='n'>IComputation</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_gb' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_gc' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_gB' class='de'><h1>Method <span class='n'>warning</span></h1><div class='re'><code>warning( self, message, element=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_gA' class='de'><h1>Function <span class='n'>isSubtype</span></h1><div class='re'><code>isSubtype( a, b )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='jy' class='cr'><div class='n'><a href='javascript:dS("jy");'>Process</a></div><div class='t'>Bases</div class='t'><div class='g'><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("jy","ky");'><span class='special __bases__'>Type</span></a></span><br /></div><div class='t'>Methods</div class='t'><div class='g'><span class='u'><span class='prefix'>&equiv;</span><a href='javascript:dO("jy","ly");'><span class='special __init__'>constructor</span></a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("jy","my");'>_ensureIntegrity</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("jy","ny");'>add</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("jy","oy");'>arguments</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("jy","py");'>asString</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("jy","qy");'>clone</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("jy","ry");'>elements</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("jy","sy");'>isLike</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("jy","ty");'>isSameAs</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("jy","uy");'>isSubtypeOf</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("jy","vy");'>peel</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("jy","wy");'>result</a></span><br /></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("jy","xy");'><span class='special __call__'>when invoked</span></a></span><br /><span class='u'><span class='prefix'>&equiv;</span><a href='javascript:dO("jy","yy");'><span class='special __str__'>string conversion</span></a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("jy","zy");'>concreteType</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("jy","Ay");'>definedBy</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("jy","By");'>name</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("jy","Cy");'>setConcreteType</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("jy","Dy");'>setName</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("jy","Ey");'>subtype</a></span><br /></div></div><div id='jq' class='cr'><div class='n'><a href='javascript:dS("jq");'>IRepetition</a></div><div class='t'>Bases</div class='t'><div class='g'><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("jq","kq");'><span class='special __bases__'>IOperation</span></a></span><br /></div><div class='t'>Methods</div class='t'><div class='g'><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("jq","lq");'>getCondition</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("jq","mq");'>getProcess</a></span><br /></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("jq","nq");'>addOpArgument</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("jq","oq");'>getAbstractType</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("jq","pq");'>getAnnotation</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("jq","qq");'>getDataFlow</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("jq","rq");'>getOpArgument</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("jq","sq");'>getOpArguments</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("jq","tq");'>getOpArgumentsInternalTypes</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("jq","uq");'>setAbstractType</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("jq","vq");'>setAnnotation</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("jq","wq");'>setOpArgument</a></span><br /></div><div class='t'>Values</div class='t'><div class='g'><span class='d'><span class='prefix'>&bull;</span><a href='javascript:dO("jq","xq");'>ARGS</a></span><br /></div></div><div id='d_Dz' class='de'><h1>Method <span class='n'>name</span></h1><div class='re'><code>name( self, name=None )</code></div><div class='ds'><p>Returns/sets the name for this type. By defaults, types are unnamed.</p></div></div><div id='d_iA' class='de'><h1>instance</h1><div class='re'></div><div class='ds'><p>Symbolic types are types that have no physical counter part but play a role in the type system. This is for instance the case with Any or Nil.</p></div></div><div id='d_it' class='de'><h1>Method <span class='n'>importModule</span></h1><div class='re'><code>importModule( self, name, alias )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_iu' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self, outputDir )</code></div><div class='ds'><p>Initializes the file splitter with the given output directory.</p></div></div><div id='d_iv' class='de'><h1>Method <span class='n'>getCurrentClassParents</span></h1><div class='re'><code>getCurrentClassParents( self, theClass=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_iw' class='de'><h1>Method <span class='n'>concreteType</span></h1><div class='re'><code>concreteType( self )</code></div><div class='ds'><p>Returns the <span class='term'>concrete type</span> for this abstract type.</p></div></div><div id='d_ip' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_iq' class='de'><h1>Method <span class='n'>setResultAbstractType</span></h1><div class='re'><code>setResultAbstractType( self, abstractType )</code></div><div class='ds'><p>Sets the abstract type for this operation result. This is usually invoked in the typing phase.</p></div></div><div id='d_ir' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_is' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_ix' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self, *args, **kwargs )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_iy' class='de'><h1>Method <span class='n'>subtype</span></h1><div class='re'><code>subtype( self, name )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_iz' class='de'><h1>Method <span class='n'>concreteType</span></h1><div class='re'><code>concreteType( self )</code></div><div class='ds'><p>Returns the <span class='term'>concrete type</span> for this abstract type.</p></div></div><div id='d_id' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IAttribute at 0x5bf6c0&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_ie' class='de'><h1>Method <span class='n'>getLeftOperand</span></h1><div class='re'><code>getLeftOperand( self )</code></div><div class='ds'><p>Returns the left operand of this computation.</p></div></div><div id='d_if' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_ig' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_ib' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><p>Returns the arguments to this operation.</p></div></div><div id='d_ic' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><p>Sets the given argument of this operation, by argument index.</p></div></div><div id='d_il' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IAbstractClass at 0x5bf7b0&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_im' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_in' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_io' class='de'><h1>Method <span class='n'>setAbstract</span></h1><div class='re'><code>setAbstract( self, isAbstract )</code></div><div class='ds'><p>Sets wether the given abstractable is abstract or not.</p></div></div><div id='d_ih' class='de'><h1>Method <span class='n'>getStart</span></h1><div class='re'><code>getStart( self )</code></div><div class='ds'><p>Returns this enumeration start.</p></div></div><div id='d_ii' class='de'><h1>Method <span class='n'>getAbsoluteName</span></h1><div class='re'><code>getAbsoluteName( self )</code></div><div class='ds'><p>Returns the absolute name for this element</p></div></div><div id='d_ij' class='de'><h1>Class <span class='n'>IImportOperation</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_ik' class='de'><h1>Method <span class='n'>getArguments</span></h1><div class='re'><code>getArguments( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Dh' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_Mx' class='de'><h1>Class <span class='n'>Map</span></h1><div class='re'></div><div class='ds'><p>A map is simply an unordered set of types, mapped to names.</p></div></div><div id='d_My' class='de'><h1>Method <span class='n'>extend</span></h1><div class='re'><code>extend( self, othertype )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Mz' class='de'><h1>Method <span class='n'>__str__</span></h1><div class='re'><code>__str__( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Mp' class='de'><h1>Method <span class='n'>getSlot</span></h1><div class='re'><code>getSlot( self, name )</code></div><div class='ds'><p>Returns the given evaluable bound to named slot.</p></div></div><div id='d_Mq' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.IReferencable at 0x5bf3c0&gt;, &lt;class lambdafactory.interfaces.IEvaluable at 0x5bf3f0&gt;]</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='d_Mr' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_Ms' class='de'><h1>Method <span class='n'>annotation</span></h1><div class='re'><code>annotation( self, name, content )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Mt' class='de'><h1>Method <span class='n'>_format</span></h1><div class='re'><code>_format( self, *values )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Mu' class='de'><h1>Method <span class='n'>writeInvocation</span></h1><div class='re'><code>writeInvocation( self, invocation )</code></div><div class='ds'><p>Writes an invocation operation.</p></div></div><div id='d_Mv' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.modeltypes.TypeCollection at 0x1127f90&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Mw' class='de'><h1>Method <span class='n'>setName</span></h1><div class='re'><code>setName( self, name )</code></div><div class='ds'><p>Sets the name of this type</p></div></div><div id='d_Mh' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.IEvaluable at 0x5bf3f0&gt;, &lt;class lambdafactory.interfaces.IEvaluable at 0x5bf3f0&gt;]</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='d_Mi' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><p>Returns the arguments to this operation.</p></div></div><div id='d_Mj' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IImportOperation at 0x5bfa80&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Mk' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><p>Sets the given argument of this operation, by argument index.</p></div></div><div id='d_Ml' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_Mm' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IValue at 0x5bf4b0&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Mn' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_Mo' class='de'><h1>Method <span class='n'>getTypeDescription</span></h1><div class='re'><code>getTypeDescription( self )</code></div><div class='ds'><p>Returns type information (constraints) that are associated to this argument.</p></div></div><div id='d_Mb' class='de'><h1>Method <span class='n'>isRest</span></h1><div class='re'><code>isRest( self )</code></div><div class='ds'><p>Tells if the argument is variable or not.</p></div></div><div id='d_Mc' class='de'><h1>Method <span class='n'>getClassMethods</span></h1><div class='re'><code>getClassMethods( self )</code></div><div class='ds'><p>Returns the class method defined within this class.</p></div></div><div id='d_Md' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IProcess at 0x5bf870&gt;, &lt;class lambdafactory.interfaces.IContext at 0x5bf750&gt;)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Me' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns the parent context for this context (if any)</p></div></div><div id='d_Mf' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_Fw' class='de'><h1>Method <span class='n'>__str__</span></h1><div class='re'><code>__str__( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_MA' class='de'><h1>Method <span class='n'>run</span></h1><div class='re'><code>run( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='Iz' class='cr'><div class='n'><a href='javascript:dS("Iz");'>Unresolved</a></div><div class='t'>Bases</div class='t'><div class='g'><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("Iz","Jz");'><span class='special __bases__'>Symbolic</span></a></span><br /></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("Iz","Kz");'><span class='special __call__'>when invoked</span></a></span><br /><span class='u'><span class='prefix'>&equiv;</span><a href='javascript:dO("Iz","Lz");'><span class='special __init__'>constructor</span></a></span><br /><span class='u'><span class='prefix'>&equiv;</span><a href='javascript:dO("Iz","Mz");'><span class='special __str__'>string conversion</span></a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("Iz","Nz");'>asString</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("Iz","Oz");'>clone</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Iz","Pz");'>concreteType</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("Iz","Qz");'>definedBy</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Iz","Rz");'>isLike</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Iz","Sz");'>isSameAs</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Iz","Tz");'>isSubtypeOf</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Iz","Uz");'>name</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Iz","Vz");'>result</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Iz","Wz");'>setConcreteType</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Iz","Xz");'>setName</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("Iz","Yz");'>subtype</a></span><br /></div></div><div id='It' class='cr'><div class='n'><a href='javascript:dS("It");'>AbstractWriter</a></div><div class='t'>Bases</div class='t'><div class='g'><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("It","c");'><span class='special __bases__'><i>Base class</i></span></a></span><br /></div><div class='t'>Methods</div class='t'><div class='g'><span class='u'><span class='prefix'>&equiv;</span><a href='javascript:dO("It","Jt");'><span class='special __init__'>constructor</span></a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("It","Kt");'>_document</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("It","Lt");'>_filterContext</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("It","Mt");'>_format</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("It","Nt");'>_getContextsAsString</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("It","Ot");'>_unique</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("It","Pt");'>getCurrentClass</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("It","Qt");'>getCurrentClassAncestors</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("It","Rt");'>getCurrentClassParents</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("It","St");'>getCurrentClosure</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("It","Tt");'>getCurrentContext</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("It","Ut");'>getCurrentDataFlow</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("It","Vt");'>getCurrentFunction</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("It","Wt");'>getCurrentMethod</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("It","Xt");'>getCurrentModule</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("It","Yt");'>isIn</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("It","Zt");'>isInClassMethod</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("It","au");'>isInInstanceMethod</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("It","bu");'>resolve</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("It","cu");'>resolveAbsoluteOrLocal</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("It","du");'>write</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("It","eu");'>writeProgram</a></span><br /></div><div class='t'>Values</div class='t'><div class='g'><span class='d'><span class='prefix'>&bull;</span><a href='javascript:dO("It","fu");'>INTERFACES</a></span><br /><span class='d'><span class='prefix'>&bull;</span><a href='javascript:dO("It","gu");'>SNIP</a></span><br /></div></div><div id='Iv' class='cr'><div class='n'><a href='javascript:dS("Iv");'>Data</a></div><div class='t'>Bases</div class='t'><div class='g'><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("Iv","Jv");'><span class='special __bases__'>TypeCollection</span></a></span><br /></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Iv","Kv");'>getType</a></span><br /></div></div><div id='Il' class='cr'><div class='n'><a href='javascript:dS("Il");'>IInterruption</a></div><div class='t'>Bases</div class='t'><div class='g'><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("Il","Jl");'><span class='special __bases__'>IOperation</span></a></span><br /></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Il","Kl");'>addOpArgument</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Il","Ll");'>getAbstractType</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Il","Ml");'>getAnnotation</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Il","Nl");'>getDataFlow</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Il","Ol");'>getOpArgument</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Il","Pl");'>getOpArguments</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Il","Ql");'>getOpArgumentsInternalTypes</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Il","Rl");'>setAbstractType</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Il","Sl");'>setAnnotation</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Il","Tl");'>setOpArgument</a></span><br /></div></div><div id='Ic' class='cr'><div class='n'><a href='javascript:dS("Ic");'>IClass</a></div><div class='t'>Bases</div class='t'><div class='g'><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("Ic","Jc");'><span class='special __bases__'>IContext, IReferencable</span></a></span><br /></div><div class='t'>Methods</div class='t'><div class='g'><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Ic","Kc");'>getAttributes</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Ic","Lc");'>getClassAttributes</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Ic","Mc");'>getClassMethods</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Ic","Nc");'>getConstructors</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Ic","Oc");'>getDestructors</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Ic","Pc");'>getInstanceMethods</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Ic","Qc");'>getMethods</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Ic","Rc");'>getName</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Ic","Sc");'>getOperations</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Ic","Tc");'>getParentClasses</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Ic","Uc");'>setParentClasses</a></span><br /></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Ic","Vc");'>getAbsoluteName</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Ic","Wc");'>getAbstractType</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Ic","Xc");'>getAnnotation</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Ic","Yc");'>getDataFlow</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Ic","Zc");'>getParent</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Ic","ad");'>getSlot</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Ic","bd");'>getSlots</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Ic","cd");'>hasSlot</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Ic","dd");'>setAbstractType</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Ic","ed");'>setAnnotation</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Ic","fd");'>setParent</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Ic","gd");'>setSlot</a></span><br /></div></div><div id='d_pq' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='cr' class='cr'><div class='n'><a href='javascript:dS("cr");'>ISliceOperation</a></div><div class='t'>Bases</div class='t'><div class='g'><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("cr","dr");'><span class='special __bases__'>ISubsetOperation</span></a></span><br /></div><div class='t'>Methods</div class='t'><div class='g'><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("cr","er");'>getSliceEnd</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("cr","fr");'>getSliceStart</a></span><br /></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("cr","gr");'>addOpArgument</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("cr","hr");'>getAbstractType</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("cr","ir");'>getAnnotation</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("cr","jr");'>getDataFlow</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("cr","kr");'>getOpArgument</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("cr","lr");'>getOpArguments</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("cr","mr");'>getOpArgumentsInternalTypes</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("cr","nr");'>getTarget</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("cr","or");'>setAbstractType</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("cr","pr");'>setAnnotation</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("cr","qr");'>setOpArgument</a></span><br /></div><div class='t'>Values</div class='t'><div class='g'><span class='d'><span class='prefix'>&bull;</span><a href='javascript:dO("cr","rr");'>ARGS</a></span><br /></div></div><div id='oo' class='cr'><div class='n'><a href='javascript:dS("oo");'>IModule</a></div><div class='t'>Bases</div class='t'><div class='g'><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("oo","po");'><span class='special __bases__'>IContext</span></a></span><br /></div><div class='t'>Methods</div class='t'><div class='g'><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("oo","qo");'>addImportOperation</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("oo","ro");'>getClasses</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("oo","so");'>getImportOperations</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("oo","to");'>getParentName</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("oo","uo");'>isImported</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("oo","vo");'>setImported</a></span><br /></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("oo","wo");'>getAbstractType</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("oo","xo");'>getAnnotation</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("oo","yo");'>getDataFlow</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("oo","zo");'>getParent</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("oo","Ao");'>getSlot</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("oo","Bo");'>getSlots</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("oo","Co");'>hasSlot</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("oo","Do");'>setAbstractType</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("oo","Eo");'>setAnnotation</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("oo","Fo");'>setParent</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("oo","Go");'>setSlot</a></span><br /></div></div><div id='og' class='cr'><div class='n'><a href='javascript:dS("og");'>IDocumentation</a></div><div class='t'>Bases</div class='t'><div class='g'><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("og","pg");'><span class='special __bases__'>IAnnotation</span></a></span><br /></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("og","qg");'>getContent</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("og","rg");'>getName</a></span><br /></div></div><div id='od' class='cr'><div class='n'><a href='javascript:dS("od");'>IClassMethod</a></div><div class='t'>Bases</div class='t'><div class='g'><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("od","pd");'><span class='special __bases__'>IMethod</span></a></span><br /></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("od","qd");'>addOperation</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("od","rd");'>endsWithTermination</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("od","sd");'>getAbsoluteName</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("od","td");'>getAbstractType</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("od","ud");'>getAnnotation</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("od","vd");'>getArguments</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("od","wd");'>getDataFlow</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("od","xd");'>getName</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("od","yd");'>getOperations</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("od","zd");'>getParent</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("od","Ad");'>getSlot</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("od","Bd");'>getSlots</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("od","Cd");'>hasExplicitTermination</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("od","Dd");'>hasSlot</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("od","Ed");'>isAbstract</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("od","Fd");'>setAbstract</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("od","Gd");'>setAbstractType</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("od","Hd");'>setAnnotation</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("od","Id");'>setArguments</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("od","Jd");'>setParent</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("od","Kd");'>setSlot</a></span><br /></div></div><div id='Nq' class='cr'><div class='n'><a href='javascript:dS("Nq");'>ISelection</a></div><div class='t'>Bases</div class='t'><div class='g'><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("Nq","Oq");'><span class='special __bases__'>IOperation</span></a></span><br /></div><div class='t'>Methods</div class='t'><div class='g'><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Nq","Pq");'>addRule</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Nq","Qq");'>getRules</a></span><br /></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Nq","Rq");'>addOpArgument</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Nq","Sq");'>getAbstractType</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Nq","Tq");'>getAnnotation</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Nq","Uq");'>getDataFlow</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Nq","Vq");'>getOpArgument</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Nq","Wq");'>getOpArguments</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Nq","Xq");'>getOpArgumentsInternalTypes</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Nq","Yq");'>setAbstractType</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Nq","Zq");'>setAnnotation</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Nq","ar");'>setOpArgument</a></span><br /></div><div class='t'>Values</div class='t'><div class='g'><span class='d'><span class='prefix'>&bull;</span><a href='javascript:dO("Nq","br");'>ARGS</a></span><br /></div></div><div id='d_fy' class='de'><h1>Method <span class='n'>result</span></h1><div class='re'><code>result( self )</code></div><div class='ds'><p>Returns the result for this type. This is usually just the type itself, except for processes types.</p></div></div><div id='d_fx' class='de'><h1>Method <span class='n'>subtype</span></h1><div class='re'><code>subtype( self, name )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_fz' class='de'><h1>Method <span class='n'>clone</span></h1><div class='re'><code>clone( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_fq' class='de'><h1>Method <span class='n'>getResultAbstractType</span></h1><div class='re'><code>getResultAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type of the result of the evaluation of this evaluable</p></div></div><div id='d_fp' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_fs' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><p>Returns the ith arguments to this operation.</p></div></div><div id='d_fr' class='de'><h1>Method <span class='n'>getSliceStart</span></h1><div class='re'><code>getSliceStart( self )</code></div><div class='ds'><p>Returns evaluable that will return the slice start</p></div></div><div id='d_fu' class='de'><h1>tuple</h1><div class='re'><code>('Program', 'Module', 'Class', 'Destructor', 'Constructor', 'ClassMethod', 'Method', 'Function', 'Closure', 'Block', 'ModuleAttribute', 'ClassAttribute', 'Attribute', 'Argument', 'Operator', 'Reference', 'Number', 'String', 'List', 'Dict', 'Enumeration', 'Allocation', 'Assignation', 'Computation', 'Invocation', 'Instanciation', 'Resolution', 'Selection', 'Repetition', 'Iteration', 'AccessOperation', 'SliceOperation', 'Evaluation', 'Termination', 'Breaking', 'Except', 'Interception', 'ImportSymbolOperation', 'ImportSymbolsOperation', 'ImportModuleOperation', 'ImportModulesOperation', 'Embed')</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_ft' class='de'><h1>Method <span class='n'>enumerate</span></h1><div class='re'><code>enumerate( self, start, end, step=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_fw' class='de'><h1>Method <span class='n'>add</span></h1><div class='re'><code>add( self, theType )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_fv' class='de'><h1>Method <span class='n'>_unique</span></h1><div class='re'><code>_unique( self, name )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_fi' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><p>Returns this @protocol name. It can be <code>None</code> if the @protocol is anonymous.</p></div></div><div id='d_fh' class='de'><h1>Class <span class='n'>IEnumeration</span></h1><div class='re'></div><div class='ds'><p>An enumeration produces values between a start and an end value, with the given step.</p></div></div><div id='d_fk' class='de'><h1>Method <span class='n'>getAbsoluteName</span></h1><div class='re'><code>getAbsoluteName( self )</code></div><div class='ds'><p>Returns the absolute name for this element</p></div></div><div id='d_fj' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><p>Sets the given argument of this operation, by argument index.</p></div></div><div id='d_fm' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><p>Returns the arguments to this operation.</p></div></div><div id='d_fl' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><p>Sets the given argument of this operation, by argument index.</p></div></div><div id='d_fo' class='de'><h1>Method <span class='n'>hasExplicitTermination</span></h1><div class='re'><code>hasExplicitTermination( self )</code></div><div class='ds'><p>Returns true if this function has an operation with a termination, otherwise return false.</p></div></div><div id='d_fn' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><p>Returns the <em>internal types</em> for this operations arguments. This is typically the list of interfaces or @protocols that the arguments must comply to.</p></div></div><div id='d_fc' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><p>Returns the <em>internal types</em> for this operations arguments. This is typically the list of interfaces or @protocols that the arguments must comply to.</p></div></div><div id='d_fb' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_fe' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><p>Returns the name of this annotation.</p></div></div><div id='d_fd' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, context )</code></div><div class='ds'><p>Sets the parent context for this context.</p></div></div><div id='d_fg' class='de'><h1>Method <span class='n'>getItems</span></h1><div class='re'><code>getItems( self )</code></div><div class='ds'><p>Returns the items contained in this dict</p></div></div><div id='d_ff' class='de'><h1>Method <span class='n'>setSlot</span></h1><div class='re'><code>setSlot( self, name, evaluable )</code></div><div class='ds'><p>Binds the given evaluable to the named slot.</p></div></div><div id='d_fA' class='de'><h1>Function <span class='n'>isSame</span></h1><div class='re'><code>isSame( a, b )</code></div><div class='ds'><p>Type (b) is the same as (a) if (a) and (b) are identicial, that means that you can use b where you use a, and this also means that isSame(a,b) == isSame(b,a). Basically, when (b) is same as (a), (b) can be considered as an alias for (a).</p></div></div><div id='d_fB' class='de'><h1>Method <span class='n'>onWarning</span></h1><div class='re'><code>onWarning( self, callback )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_zm' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.IEvaluable at 0x5bf3f0&gt;, &lt;class lambdafactory.interfaces.IEvaluable at 0x5bf3f0&gt;]</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='d_zl' class='de'><h1>Method <span class='n'>getSlots</span></h1><div class='re'><code>getSlots( self )</code></div><div class='ds'><p>Returns (key, evaluable) pairs representing the slots within this context.</p></div></div><div id='d_zo' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns the parent context for this context (if any)</p></div></div><div id='d_zn' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><p>Sets the given argument of this operation, by argument index.</p></div></div><div id='d_zi' class='de'><h1>Class <span class='n'>IGroup</span></h1><div class='re'></div><div class='ds'><p>A block is a group of operations that share a common aspect. Groups are more likely to be used by program passes to further structure the program.</p><p>Groups should generally not have their own context, as opposed to blocks which generally have a context of their own.</p></div></div><div id='d_zh' class='de'><h1>Class <span class='n'>IEvaluation</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_zk' class='de'><h1>Class <span class='n'>IInstanciation</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_zj' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><p>Adds an argument to this operation. This should do checking of arguments (by expected internal type and number).</p></div></div><div id='d_ze' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><p>Sets the given argument of this operation, by argument index.</p></div></div><div id='d_zd' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns the parent context for this context (if any)</p></div></div><div id='d_zg' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IOperation at 0x5bfa50&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_zf' class='de'><h1>Class <span class='n'>IDataFlowSlot</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_zc' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_zb' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><p>Returns the <em>internal types</em> for this operations arguments. This is typically the list of interfaces or @protocols that the arguments must comply to.</p></div></div><div id='d_zy' class='de'><h1>Method <span class='n'>concreteType</span></h1><div class='re'><code>concreteType( self )</code></div><div class='ds'><p>Returns the <span class='term'>concrete type</span> for this abstract type.</p></div></div><div id='d_zx' class='de'><h1>Method <span class='n'>isSameAs</span></h1><div class='re'><code>isSameAs( self, otherType )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='aw' class='cr'><div class='n'><a href='javascript:dS("aw");'>Arguments</a></div><div class='t'>Bases</div class='t'><div class='g'><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("aw","bw");'><span class='special __bases__'>Sequence</span></a></span><br /></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("aw","cw");'><span class='special __call__'>when invoked</span></a></span><br /><span class='u'><span class='prefix'>&equiv;</span><a href='javascript:dO("aw","dw");'><span class='special __init__'>constructor</span></a></span><br /><span class='u'><span class='prefix'>&equiv;</span><a href='javascript:dO("aw","ew");'><span class='special __str__'>string conversion</span></a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("aw","fw");'>add</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("aw","gw");'>asString</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("aw","hw");'>clone</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("aw","iw");'>concreteType</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("aw","jw");'>definedBy</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("aw","kw");'>elements</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("aw","lw");'>extend</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("aw","mw");'>isLike</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("aw","nw");'>isSameAs</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("aw","ow");'>isSubtypeOf</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("aw","pw");'>length</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("aw","qw");'>name</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("aw","rw");'>result</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("aw","sw");'>setConcreteType</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("aw","tw");'>setName</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("aw","uw");'>subtype</a></span><br /></div></div><div id='d_zz' class='de'><h1>Method <span class='n'>definedBy</span></h1><div class='re'><code>definedBy( self, definition=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_zu' class='de'><h1>Method <span class='n'>writeClassMethod</span></h1><div class='re'><code>writeClassMethod( self, methodElement )</code></div><div class='ds'><p>Writes a class method element.</p></div></div><div id='d_zt' class='de'><h1>wrapper_descriptor</h1><div class='re'></div><div class='ds'><div class="section"><h1 class="heading"><span class="number"><span class="level0">1<span class="lastDot dot">.</span></span></span><span class='term'>getitem</span>_(y) &lt;==&gt; x[y]</h1><div class="level1"></div></div></div></div><div id='d_zw' class='de'><h1>Method <span class='n'>content</span></h1><div class='re'><code>content( self )</code></div><div class='ds'><p>Returns the type for the content of this array.</p></div></div><div id='d_zv' class='de'><h1>Function <span class='n'>format</span></h1><div class='re'><code>format( *values )</code></div><div class='ds'><p>Formats a combination of string ang tuples. Strings are joined by newlines, and the content of the inner tuples gets indented</p></div></div><div id='d_zq' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IOperation at 0x5bfa50&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_zp' class='de'><h1>Method <span class='n'>addOperation</span></h1><div class='re'><code>addOperation( self, operation )</code></div><div class='ds'><p>Adds the given operation as a child of this process.</p></div></div><div id='d_zs' class='de'><h1>Method <span class='n'>_attr</span></h1><div class='re'><code>_attr( self, name, typeinfo=None, value=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_zr' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_zA' class='de'><h1>Class <span class='n'>PassContext</span></h1><div class='re'></div><div class='ds'><p>The <code>PassContext</code> represents the current state of one or more passes when walking the program. It offers access to the <code>environment</code> (gives access to the program and various passes).</p><p>A single context can be shared among various passes.</p></div></div><div id='d_hB' class='de'><h1>instance</h1><div class='re'></div><div class='ds'><p>The reporter aggregates error reports that may happen during model construction and the different phases (dataflowing, typing, writing, etc).</p></div></div><div id='d_hA' class='de'><h1>Function <span class='n'>isType</span></h1><div class='re'><code>isType( a )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_hw' class='de'><h1>Method <span class='n'>clone</span></h1><div class='re'><code>clone( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_hv' class='de'><h1>Method <span class='n'>getCurrentClassAncestors</span></h1><div class='re'><code>getCurrentClassAncestors( self, theClass=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_hu' class='de'><h1>Class <span class='n'>FileSplitter</span></h1><div class='re'></div><div class='ds'><p>Some languages (like Java or ActionScript) may generate multiple files for one single module. The FileSplitter makes it easy for front-end to produce multiple file from a single file or text generated by the LambdaFactory back-end writers.</p></div></div><div id='d_ht' class='de'><h1>Method <span class='n'>exception</span></h1><div class='re'><code>exception( self, exception )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_hs' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><p>Returns the <em>internal types</em> for this operations arguments. This is typically the list of interfaces or @protocols that the arguments must comply to.</p></div></div><div id='d_hr' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_hq' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_hp' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_hz' class='de'><h1>Method <span class='n'>__str__</span></h1><div class='re'><code>__str__( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_hy' class='de'><h1>Method <span class='n'>setName</span></h1><div class='re'><code>setName( self, name )</code></div><div class='ds'><p>Sets the name of this type</p></div></div><div id='d_hx' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.typecast.Map at 0x1132960&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_hg' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_hf' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_he' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IOperation at 0x5bfa50&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_hd' class='de'><h1>Class <span class='n'>IClassAttribute</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_hc' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_hb' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><p>Returns the ith arguments to this operation.</p></div></div><div id='d_ho' class='de'><h1>Method <span class='n'>isAbstract</span></h1><div class='re'><code>isAbstract( self )</code></div><div class='ds'><p>Tells wether the given abstractable is abstract or not.</p></div></div><div id='d_hn' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_hm' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_hl' class='de'><h1>Class <span class='n'>IInterface</span></h1><div class='re'></div><div class='ds'><p>An interface is an abstract @protocol that only has abstract elements.</p></div></div><div id='d_hk' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_hj' class='de'><h1>list</h1><div class='re'><code>['ImportedModuleNames']</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='d_hi' class='de'><h1>Method <span class='n'>addOperation</span></h1><div class='re'><code>addOperation( self, operation )</code></div><div class='ds'><p>Adds the given operation as a child of this process.</p></div></div><div id='d_hh' class='de'><h1>Method <span class='n'>getEnd</span></h1><div class='re'><code>getEnd( self )</code></div><div class='ds'><p>Returns this enumeration end.</p></div></div><div id='d_Z' class='de'><h1>Method <span class='n'>setAbstract</span></h1><div class='re'><code>setAbstract( self, isAbstract )</code></div><div class='ds'><p>Sets wether the given abstractable is abstract or not.</p></div></div><div id='d_Lz' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self, name )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_X' class='de'><h1>Class <span class='n'>IAbstractable</span></h1><div class='re'></div><div class='ds'><p>An abstractable element is an element that is allow to have no underlying implementation. Abstract element are typically interfaces, methods, functions, operations, and sometimes modules and @protocoles.</p></div></div><div id='d_Y' class='de'><h1>Method <span class='n'>isAbstract</span></h1><div class='re'><code>isAbstract( self )</code></div><div class='ds'><p>Tells wether the given abstractable is abstract or not.</p></div></div><div id='d_R' class='de'><h1>Method <span class='n'>setAbstract</span></h1><div class='re'><code>setAbstract( self, isAbstract )</code></div><div class='ds'><p>Sets wether the given abstractable is abstract or not.</p></div></div><div id='d_S' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_P' class='de'><h1>Method <span class='n'>hasSlot</span></h1><div class='re'><code>hasSlot( self, name )</code></div><div class='ds'><p>Tells if the context has a slot with the given name.</p></div></div><div id='d_Q' class='de'><h1>Method <span class='n'>isAbstract</span></h1><div class='re'><code>isAbstract( self )</code></div><div class='ds'><p>Tells wether the given abstractable is abstract or not.</p></div></div><div id='d_V' class='de'><h1>Method <span class='n'>setParentClasses</span></h1><div class='re'><code>setParentClasses( self )</code></div><div class='ds'><p>gives the list of parent classes that will</p></div></div><div id='d_W' class='de'><h1>Method <span class='n'>setSlot</span></h1><div class='re'><code>setSlot( self, name, evaluable )</code></div><div class='ds'><p>Binds the given evaluable to the named slot.</p></div></div><div id='d_T' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_U' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, context )</code></div><div class='ds'><p>Sets the parent context for this context.</p></div></div><div id='d_J' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><p>Returns this class name. It can be <code>None</code> if the class is anonymous.</p></div></div><div id='d_K' class='de'><h1>Method <span class='n'>getOperations</span></h1><div class='re'><code>getOperations( self )</code></div><div class='ds'><p>Returns the operations (methods and class methods) defined within this class.</p></div></div><div id='d_H' class='de'><h1>Method <span class='n'>getInstanceMethods</span></h1><div class='re'><code>getInstanceMethods( self )</code></div><div class='ds'><p>Returns the instance methods defined within this class.</p></div></div><div id='d_I' class='de'><h1>Method <span class='n'>getMethods</span></h1><div class='re'><code>getMethods( self )</code></div><div class='ds'><p>Returns the methods defined within this class.</p></div></div><div id='d_N' class='de'><h1>Method <span class='n'>getSlot</span></h1><div class='re'><code>getSlot( self, name )</code></div><div class='ds'><p>Returns the given evaluable bound to named slot.</p></div></div><div id='d_O' class='de'><h1>Method <span class='n'>getSlots</span></h1><div class='re'><code>getSlots( self )</code></div><div class='ds'><p>Returns (key, evaluable) pairs representing the slots within this context.</p></div></div><div id='d_L' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns the parent context for this context (if any)</p></div></div><div id='d_M' class='de'><h1>Method <span class='n'>getParentClasses</span></h1><div class='re'><code>getParentClasses( self )</code></div><div class='ds'><p>Returns the list of inherited classes references.</p></div></div><div id='d_Lc' class='de'><h1>Method <span class='n'>getClassAttributes</span></h1><div class='re'><code>getClassAttributes( self )</code></div><div class='ds'><p>Returns the class attributes defined within this class.</p></div></div><div id='d_C' class='de'><h1>Method <span class='n'>getClassAttributes</span></h1><div class='re'><code>getClassAttributes( self )</code></div><div class='ds'><p>Returns the class attributes defined within this class.</p></div></div><div id='d_A' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_F' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_Lf' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_D' class='de'><h1>Method <span class='n'>getClassMethods</span></h1><div class='re'><code>getClassMethods( self )</code></div><div class='ds'><p>Returns the class method defined within this class.</p></div></div><div id='d_E' class='de'><h1>Method <span class='n'>getConstructors</span></h1><div class='re'><code>getConstructors( self )</code></div><div class='ds'><p>Returns the constructors for this class</p></div></div><div id='d_z' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_x' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IClass at 0x5bf780&gt;, &lt;class lambdafactory.interfaces.IAbstractable at 0x5bf480&gt;)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_y' class='de'><h1>Method <span class='n'>getAbsoluteName</span></h1><div class='re'><code>getAbsoluteName( self )</code></div><div class='ds'><p>Returns the absolute name for this element</p></div></div><div id='d_r' class='de'><h1>Method <span class='n'>getReferenceName</span></h1><div class='re'><code>getReferenceName( self )</code></div><div class='ds'><p>Returns the name which this reference contains. The name is used by the resolution operation to actually resolve a value from the name.</p></div></div><div id='d_s' class='de'><h1>Method <span class='n'>getResultAbstractType</span></h1><div class='re'><code>getResultAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type of the result of the evaluation of this evaluable</p></div></div><div id='d_p' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_q' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><p>Returns the local name for this referencable element</p></div></div><div id='d_v' class='de'><h1>Method <span class='n'>setResultAbstractType</span></h1><div class='re'><code>setResultAbstractType( self, abstractType )</code></div><div class='ds'><p>Sets the abstract type for this operation result. This is usually invoked in the typing phase.</p></div></div><div id='d_w' class='de'><h1>Class <span class='n'>IAbstractClass</span></h1><div class='re'></div><div class='ds'><p>An abstract @protocol is a @protocol that has at least one abstract element.</p></div></div><div id='d_t' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_u' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_j' class='de'><h1>int</h1><div class='re'></div><div class='ds'><p>int(x[, base]) -&gt; integer</p><p>Convert a string or number to an integer, if possible. A floating point argument will be truncated towards zero (this does not include a string representation of a floating point number!) When converting a string, use the optional base. It is an error to supply a base when converting a non-string. If the argument is outside the integer range a long object will be returned instead.</p></div></div><div id='d_k' class='de'><h1>Class <span class='n'>IAbsoluteReference</span></h1><div class='re'></div><div class='ds'><p>An absolute reference is a specific kind of reference that does not necessarily resolve in the current context, but will rather use the program root context as a starting point.</p></div></div><div id='d_h' class='de'><h1>str</h1><div class='re'><code>'__main__'</code></div><div class='ds'><p>str(object) -&gt; string</p><p>Return a nice string representation of the object. If the argument is a string, the return value is the same object.</p></div></div><div id='d_i' class='de'><h1>str</h1><div class='re'><code>'__moduleinit__'</code></div><div class='ds'><p>str(object) -&gt; string</p><p>Return a nice string representation of the object. If the argument is a string, the return value is the same object.</p></div></div><div id='d_n' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_o' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_l' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IReference at 0x5bf5d0&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_m' class='de'><h1>Method <span class='n'>getAbsoluteName</span></h1><div class='re'><code>getAbsoluteName( self )</code></div><div class='ds'><p>Returns the absolute name for this element</p></div></div><div id='d_b' class='de'><h1>Class <span class='n'>Constants</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_c' class='de'><h1>tuple</h1><div class='re'><code>()</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_LA' class='de'><h1>Method <span class='n'>resolve</span></h1><div class='re'><code>resolve( self, referenceOrName, contextOrDataFlow=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_a' class='de'><h1>Module <span class='n'>lambdafactory.interfaces</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_f' class='de'><h1>str</h1><div class='re'><code>'__currentvalue__'</code></div><div class='ds'><p>str(object) -&gt; string</p><p>Return a nice string representation of the object. If the argument is a string, the return value is the same object.</p></div></div><div id='d_g' class='de'><h1>str</h1><div class='re'><code>'__destroy__'</code></div><div class='ds'><p>str(object) -&gt; string</p><p>Return a nice string representation of the object. If the argument is a string, the return value is the same object.</p></div></div><div id='d_d' class='de'><h1>str</h1><div class='re'><code>'__init__'</code></div><div class='ds'><p>str(object) -&gt; string</p><p>Return a nice string representation of the object. If the argument is a string, the return value is the same object.</p></div></div><div id='d_e' class='de'><h1>str</h1><div class='re'><code>'__current__'</code></div><div class='ds'><p>str(object) -&gt; string</p><p>Return a nice string representation of the object. If the argument is a string, the return value is the same object.</p></div></div><div id='d_kA' class='de'><h1>instance</h1><div class='re'></div><div class='ds'><p>Symbolic types are types that have no physical counter part but play a role in the type system. This is for instance the case with Any or Nil.</p></div></div><div id='Eb' class='cr'><div class='n'><a href='javascript:dS("Eb");'>IAnnotation</a></div><div class='t'>Bases</div class='t'><div class='g'><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("Eb","c");'><span class='special __bases__'><i>Base class</i></span></a></span><br /></div><div class='t'>Methods</div class='t'><div class='g'><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Eb","Fb");'>getContent</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Eb","Gb");'>getName</a></span><br /></div></div><div id='d_kr' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><p>Returns the ith arguments to this operation.</p></div></div><div id='d_ks' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><p>Sets the given argument of this operation, by argument index.</p></div></div><div id='d_kp' class='de'><h1>Class <span class='n'>IOperator</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_kq' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IOperation at 0x5bfa50&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_kv' class='de'><h1>Method <span class='n'>getCurrentContext</span></h1><div class='re'><code>getCurrentContext( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_kw' class='de'><h1>Method <span class='n'>elements</span></h1><div class='re'><code>elements( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_kt' class='de'><h1>Method <span class='n'>importSymbol</span></h1><div class='re'><code>importSymbol( self, name, origin, alias )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_ku' class='de'><h1>Method <span class='n'>fromLines</span></h1><div class='re'><code>fromLines( self, lines, addEOL=False )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_kz' class='de'><h1>Method <span class='n'>isLike</span></h1><div class='re'><code>isLike( self, otherType )</code></div><div class='ds'><p>Generic implementation of isLike. You should always call this method in subclasses, as it implements basic type systems rules such as isLike(Any).</p></div></div><div id='d_kx' class='de'><h1>Method <span class='n'>element</span></h1><div class='re'><code>element( self, key )</code></div><div class='ds'><p>Returns the element associated with the given key, or <code>None</code> if it does not exist.</p></div></div><div id='d_ky' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.typecast.Type at 0x11327e0&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_kb' class='de'><h1>Method <span class='n'>getTarget</span></h1><div class='re'><code>getTarget( self )</code></div><div class='ds'><p>Returns the operation target.</p></div></div><div id='d_kc' class='de'><h1>Class <span class='n'>IAttribute</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_kf' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_kg' class='de'><h1>Method <span class='n'>getResultAbstractType</span></h1><div class='re'><code>getResultAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type of the result of the evaluation of this evaluable</p></div></div><div id='d_kd' class='de'><h1>Method <span class='n'>getDefaultValue</span></h1><div class='re'><code>getDefaultValue( self )</code></div><div class='ds'><p>Gets the @methodault value for this attribute</p></div></div><div id='d_ke' class='de'><h1>Method <span class='n'>getOperands</span></h1><div class='re'><code>getOperands( self )</code></div><div class='ds'><p>Returns the left (and right, if any) operands of this computation.</p></div></div><div id='d_kj' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><p>Adds an argument to this operation. This should do checking of arguments (by expected internal type and number).</p></div></div><div id='d_kk' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><p>Returns this @protocol name. It can be <code>None</code> if the @protocol is anonymous.</p></div></div><div id='d_kh' class='de'><h1>Method <span class='n'>setStep</span></h1><div class='re'><code>setStep( self, value )</code></div><div class='ds'><p>Sets this enumeration step</p></div></div><div id='d_ki' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_kn' class='de'><h1>Method <span class='n'>setPredicate</span></h1><div class='re'><code>setPredicate( self, v )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_ko' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_kl' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_km' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.IEvaluable at 0x5bf3f0&gt;, [&lt;class lambdafactory.interfaces.IEvaluable at 0x5bf3f0&gt;]]</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='w' class='cr'><div class='n'><a href='javascript:dS("w");'>IAbstractClass</a></div><div class='t'>Bases</div class='t'><div class='g'><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("w","x");'><span class='special __bases__'>IClass, IAbstractable</span></a></span><br /></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("w","y");'>getAbsoluteName</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("w","z");'>getAbstractType</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("w","A");'>getAnnotation</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("w","B");'>getAttributes</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("w","C");'>getClassAttributes</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("w","D");'>getClassMethods</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("w","E");'>getConstructors</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("w","F");'>getDataFlow</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("w","G");'>getDestructors</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("w","H");'>getInstanceMethods</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("w","I");'>getMethods</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("w","J");'>getName</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("w","K");'>getOperations</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("w","L");'>getParent</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("w","M");'>getParentClasses</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("w","N");'>getSlot</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("w","O");'>getSlots</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("w","P");'>hasSlot</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("w","Q");'>isAbstract</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("w","R");'>setAbstract</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("w","S");'>setAbstractType</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("w","T");'>setAnnotation</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("w","U");'>setParent</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("w","V");'>setParentClasses</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("w","W");'>setSlot</a></span><br /></div></div><div id='fh' class='cr'><div class='n'><a href='javascript:dS("fh");'>IEnumeration</a></div><div class='t'>Bases</div class='t'><div class='g'><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("fh","gh");'><span class='special __bases__'>IOperation</span></a></span><br /></div><div class='t'>Methods</div class='t'><div class='g'><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("fh","hh");'>getEnd</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("fh","ih");'>getStart</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("fh","jh");'>getStep</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("fh","kh");'>setStep</a></span><br /></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("fh","lh");'>addOpArgument</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("fh","mh");'>getAbstractType</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("fh","nh");'>getAnnotation</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("fh","oh");'>getDataFlow</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("fh","ph");'>getOpArgument</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("fh","qh");'>getOpArguments</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("fh","rh");'>getOpArgumentsInternalTypes</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("fh","sh");'>setAbstractType</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("fh","th");'>setAnnotation</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("fh","uh");'>setOpArgument</a></span><br /></div><div class='t'>Values</div class='t'><div class='g'><span class='d'><span class='prefix'>&bull;</span><a href='javascript:dO("fh","vh");'>ARGS</a></span><br /></div></div><div id='a' class='ro'><div class='n'><a href='javascript:dS("a");'>lambdafactory.interfaces</a></div><div class='t'>Classes</div class='t'><div class='g'><span class='u'><span class='prefix'>&Tau;</span><a href='javascript:dO("a","b");'>Constants</a></span><br /><span class='d'><span class='prefix'>&Tau;</span><a href='javascript:dO("a","k");'>IAbsoluteReference</a></span><br /><span class='d'><span class='prefix'>&Tau;</span><a href='javascript:dO("a","w");'>IAbstractClass</a></span><br /><span class='d'><span class='prefix'>&Tau;</span><a href='javascript:dO("a","X");'>IAbstractable</a></span><br /><span class='u'><span class='prefix'>&Tau;</span><a href='javascript:dO("a","ab");'>IAccessOperation</a></span><br /><span class='u'><span class='prefix'>&Tau;</span><a href='javascript:dO("a","pb");'>IAllocation</a></span><br /><span class='d'><span class='prefix'>&Tau;</span><a href='javascript:dO("a","Eb");'>IAnnotation</a></span><br /><span class='d'><span class='prefix'>&Tau;</span><a href='javascript:dO("a","Hb");'>IArgument</a></span><br /><span class='d'><span class='prefix'>&Tau;</span><a href='javascript:dO("a","Ub");'>IAssignable</a></span><br /><span class='u'><span class='prefix'>&Tau;</span><a href='javascript:dO("a","Vb");'>IAssignation</a></span><br /><span class='u'><span class='prefix'>&Tau;</span><a href='javascript:dO("a","kc");'>IAttribute</a></span><br /><span class='d'><span class='prefix'>&Tau;</span><a href='javascript:dO("a","rc");'>IBlock</a></span><br /><span class='u'><span class='prefix'>&Tau;</span><a href='javascript:dO("a","vc");'>IBreaking</a></span><br /><span class='u'><span class='prefix'>&Tau;</span><a href='javascript:dO("a","Ic");'>IClass</a></span><br /><span class='u'><span class='prefix'>&Tau;</span><a href='javascript:dO("a","hd");'>IClassAttribute</a></span><br /><span class='u'><span class='prefix'>&Tau;</span><a href='javascript:dO("a","od");'>IClassMethod</a></span><br /><span class='u'><span class='prefix'>&Tau;</span><a href='javascript:dO("a","Ld");'>IClosure</a></span><br /><span class='d'><span class='prefix'>&Tau;</span><a href='javascript:dO("a","ce");'>IComment</a></span><br /><span class='u'><span class='prefix'>&Tau;</span><a href='javascript:dO("a","ge");'>IComputation</a></span><br /><span class='u'><span class='prefix'>&Tau;</span><a href='javascript:dO("a","Be");'>IConstructor</a></span><br /><span class='d'><span class='prefix'>&Tau;</span><a href='javascript:dO("a","Ye");'>IContext</a></span><br /><span class='d'><span class='prefix'>&Tau;</span><a href='javascript:dO("a","lf");'>IDataFlow</a></span><br /><span class='d'><span class='prefix'>&Tau;</span><a href='javascript:dO("a","yf");'>IDataFlowOwner</a></span><br /><span class='u'><span class='prefix'>&Tau;</span><a href='javascript:dO("a","zf");'>IDataFlowSlot</a></span><br /><span class='u'><span class='prefix'>&Tau;</span><a href='javascript:dO("a","Gf");'>IDestructor</a></span><br /><span class='d'><span class='prefix'>&Tau;</span><a href='javascript:dO("a","dg");'>IDict</a></span><br /><span class='d'><span class='prefix'>&Tau;</span><a href='javascript:dO("a","og");'>IDocumentation</a></span><br /><span class='d'><span class='prefix'>&Tau;</span><a href='javascript:dO("a","sg");'>IElement</a></span><br /><span class='d'><span class='prefix'>&Tau;</span><a href='javascript:dO("a","yg");'>IEmbed</a></span><br /><span class='d'><span class='prefix'>&Tau;</span><a href='javascript:dO("a","Pg");'>IEmbedTemplate</a></span><br /><span class='d'><span class='prefix'>&Tau;</span><a href='javascript:dO("a","fh");'>IEnumeration</a></span><br /><span class='d'><span class='prefix'>&Tau;</span><a href='javascript:dO("a","wh");'>IEvaluable</a></span><br /><span class='u'><span class='prefix'>&Tau;</span><a href='javascript:dO("a","zh");'>IEvaluation</a></span><br /><span class='d'><span class='prefix'>&Tau;</span><a href='javascript:dO("a","Oh");'>IExcept</a></span><br /><span class='u'><span class='prefix'>&Tau;</span><a href='javascript:dO("a","ci");'>IFunction</a></span><br /><span class='d'><span class='prefix'>&Tau;</span><a href='javascript:dO("a","zi");'>IGroup</a></span><br /><span class='u'><span class='prefix'>&Tau;</span><a href='javascript:dO("a","Di");'>IImportModuleOperation</a></span><br /><span class='u'><span class='prefix'>&Tau;</span><a href='javascript:dO("a","Ti");'>IImportModulesOperation</a></span><br /><span class='u'><span class='prefix'>&Tau;</span><a href='javascript:dO("a","ij");'>IImportOperation</a></span><br /><span class='u'><span class='prefix'>&Tau;</span><a href='javascript:dO("a","uj");'>IImportSymbolOperation</a></span><br /><span class='u'><span class='prefix'>&Tau;</span><a href='javascript:dO("a","Lj");'>IImportSymbolsOperation</a></span><br /><span class='u'><span class='prefix'>&Tau;</span><a href='javascript:dO("a","bk");'>IInstanceMethod</a></span><br /><span class='d'><span class='prefix'>&Tau;</span><a href='javascript:dO("a","yk");'>IInstanciable</a></span><br /><span class='u'><span class='prefix'>&Tau;</span><a href='javascript:dO("a","zk");'>IInstanciation</a></span><br /><span class='d'><span class='prefix'>&Tau;</span><a href='javascript:dO("a","Ok");'>IInterception</a></span><br /><span class='d'><span class='prefix'>&Tau;</span><a href='javascript:dO("a","hl");'>IInterface</a></span><br /><span class='d'><span class='prefix'>&Tau;</span><a href='javascript:dO("a","Il");'>IInterruption</a></span><br /><span class='d'><span class='prefix'>&Tau;</span><a href='javascript:dO("a","Ul");'>IInvocable</a></span><br /><span class='u'><span class='prefix'>&Tau;</span><a href='javascript:dO("a","Wl");'>IInvocation</a></span><br /><span class='d'><span class='prefix'>&Tau;</span><a href='javascript:dO("a","lm");'>IIteration</a></span><br /><span class='u'><span class='prefix'>&Tau;</span><a href='javascript:dO("a","Am");'>IList</a></span><br /><span class='d'><span class='prefix'>&Tau;</span><a href='javascript:dO("a","Lm");'>ILiteral</a></span><br /><span class='d'><span class='prefix'>&Tau;</span><a href='javascript:dO("a","Vm");'>IMatchExpressionOperation</a></span><br /><span class='d'><span class='prefix'>&Tau;</span><a href='javascript:dO("a","mn");'>IMatchOperation</a></span><br /><span class='d'><span class='prefix'>&Tau;</span><a href='javascript:dO("a","An");'>IMatchProcessOperation</a></span><br /><span class='u'><span class='prefix'>&Tau;</span><a href='javascript:dO("a","Rn");'>IMethod</a></span><br /><span class='u'><span class='prefix'>&Tau;</span><a href='javascript:dO("a","oo");'>IModule</a></span><br /><span class='u'><span class='prefix'>&Tau;</span><a href='javascript:dO("a","Ho");'>IModuleAttribute</a></span><br /><span class='u'><span class='prefix'>&Tau;</span><a href='javascript:dO("a","Oo");'>INumber</a></span><br /><span class='u'><span class='prefix'>&Tau;</span><a href='javascript:dO("a","Yo");'>IOperation</a></span><br /><span class='u'><span class='prefix'>&Tau;</span><a href='javascript:dO("a","kp");'>IOperator</a></span><br /><span class='d'><span class='prefix'>&Tau;</span><a href='javascript:dO("a","yp");'>IProcess</a></span><br /><span class='d'><span class='prefix'>&Tau;</span><a href='javascript:dO("a","Bp");'>IProgram</a></span><br /><span class='d'><span class='prefix'>&Tau;</span><a href='javascript:dO("a","Tp");'>IReferencable</a></span><br /><span class='d'><span class='prefix'>&Tau;</span><a href='javascript:dO("a","Xp");'>IReference</a></span><br /><span class='d'><span class='prefix'>&Tau;</span><a href='javascript:dO("a","jq");'>IRepetition</a></span><br /><span class='d'><span class='prefix'>&Tau;</span><a href='javascript:dO("a","yq");'>IResolution</a></span><br /><span class='d'><span class='prefix'>&Tau;</span><a href='javascript:dO("a","Nq");'>ISelection</a></span><br /><span class='u'><span class='prefix'>&Tau;</span><a href='javascript:dO("a","cr");'>ISliceOperation</a></span><br /><span class='d'><span class='prefix'>&Tau;</span><a href='javascript:dO("a","sr");'>ISlot</a></span><br /><span class='u'><span class='prefix'>&Tau;</span><a href='javascript:dO("a","xr");'>IString</a></span><br /><span class='u'><span class='prefix'>&Tau;</span><a href='javascript:dO("a","Hr");'>ISubsetOperation</a></span><br /><span class='u'><span class='prefix'>&Tau;</span><a href='javascript:dO("a","Ur");'>ISyntactic</a></span><br /><span class='u'><span class='prefix'>&Tau;</span><a href='javascript:dO("a","Yr");'>ITermination</a></span><br /><span class='d'><span class='prefix'>&Tau;</span><a href='javascript:dO("a","ms");'>IValue</a></span><br /></div></div><div id='yk' class='cr'><div class='n'><a href='javascript:dS("yk");'>IInstanciable</a></div><div class='t'>Bases</div class='t'><div class='g'><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("yk","c");'><span class='special __bases__'><i>Base class</i></span></a></span><br /></div></div><div id='yg' class='cr'><div class='n'><a href='javascript:dS("yg");'>IEmbed</a></div><div class='t'>Bases</div class='t'><div class='g'><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("yg","zg");'><span class='special __bases__'>IOperation</span></a></span><br /></div><div class='t'>Methods</div class='t'><div class='g'><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("yg","Ag");'>getCode</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("yg","Bg");'>getLanguage</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("yg","Cg");'>setCode</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("yg","Dg");'>setLanguage</a></span><br /></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("yg","Eg");'>addOpArgument</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("yg","Fg");'>getAbstractType</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("yg","Gg");'>getAnnotation</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("yg","Hg");'>getDataFlow</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("yg","Ig");'>getOpArgument</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("yg","Jg");'>getOpArguments</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("yg","Kg");'>getOpArgumentsInternalTypes</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("yg","Lg");'>setAbstractType</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("yg","Mg");'>setAnnotation</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("yg","Ng");'>setOpArgument</a></span><br /></div><div class='t'>Values</div class='t'><div class='g'><span class='d'><span class='prefix'>&bull;</span><a href='javascript:dO("yg","Og");'>ARGS</a></span><br /></div></div><div id='yf' class='cr'><div class='n'><a href='javascript:dS("yf");'>IDataFlowOwner</a></div><div class='t'>Bases</div class='t'><div class='g'><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("yf","c");'><span class='special __bases__'><i>Base class</i></span></a></span><br /></div></div><div id='yq' class='cr'><div class='n'><a href='javascript:dS("yq");'>IResolution</a></div><div class='t'>Bases</div class='t'><div class='g'><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("yq","zq");'><span class='special __bases__'>IOperation</span></a></span><br /></div><div class='t'>Methods</div class='t'><div class='g'><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("yq","Aq");'>getContext</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("yq","Bq");'>getReference</a></span><br /></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("yq","Cq");'>addOpArgument</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("yq","Dq");'>getAbstractType</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("yq","Eq");'>getAnnotation</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("yq","Fq");'>getDataFlow</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("yq","Gq");'>getOpArgument</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("yq","Hq");'>getOpArguments</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("yq","Iq");'>getOpArgumentsInternalTypes</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("yq","Jq");'>setAbstractType</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("yq","Kq");'>setAnnotation</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("yq","Lq");'>setOpArgument</a></span><br /></div><div class='t'>Values</div class='t'><div class='g'><span class='d'><span class='prefix'>&bull;</span><a href='javascript:dO("yq","Mq");'>ARGS</a></span><br /></div></div><div id='yp' class='cr'><div class='n'><a href='javascript:dS("yp");'>IProcess</a></div><div class='t'>Bases</div class='t'><div class='g'><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("yp","c");'><span class='special __bases__'><i>Base class</i></span></a></span><br /></div><div class='t'>Methods</div class='t'><div class='g'><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("yp","zp");'>addOperation</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("yp","Ap");'>getOperations</a></span><br /></div></div><div id='d_QA' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Qx' class='de'><h1>Method <span class='n'>asString</span></h1><div class='re'><code>asString( self, fromTypes=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Qy' class='de'><h1>Method <span class='n'>length</span></h1><div class='re'><code>length( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Qz' class='de'><h1>Method <span class='n'>definedBy</span></h1><div class='re'><code>definedBy( self, definition=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Qt' class='de'><h1>Method <span class='n'>getCurrentClassAncestors</span></h1><div class='re'><code>getCurrentClassAncestors( self, theClass=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Qu' class='de'><h1>Method <span class='n'>writeModule</span></h1><div class='re'><code>writeModule( self, moduleElement )</code></div><div class='ds'><p>Writes a Module element.</p></div></div><div id='d_Qv' class='de'><h1>Method <span class='n'>getType</span></h1><div class='re'><code>getType( self, name )</code></div><div class='ds'><p>Returns the type with the given name, or None if it does not exist.</p></div></div><div id='d_Qw' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self, length, name=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Qp' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_Qq' class='de'><h1>Method <span class='n'>getRules</span></h1><div class='re'><code>getRules( self )</code></div><div class='ds'><p>Returns the ordered set of rule for this selection.</p></div></div><div id='d_Qr' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><p>Returns the <em>internal types</em> for this operations arguments. This is typically the list of interfaces or @protocols that the arguments must comply to.</p></div></div><div id='d_Qs' class='de'><h1>Method <span class='n'>compute</span></h1><div class='re'><code>compute( self, operatorName, leftOperand, rightOperand=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Ql' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><p>Returns the <em>internal types</em> for this operations arguments. This is typically the list of interfaces or @protocols that the arguments must comply to.</p></div></div><div id='d_Qm' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_Qn' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.IEvaluable at 0x5bf3f0&gt;, &lt;class lambdafactory.interfaces.IProcess at 0x5bf870&gt;]</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='d_Qo' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_Qh' class='de'><h1>Method <span class='n'>getValue</span></h1><div class='re'><code>getValue( self )</code></div><div class='ds'><p>Returns the termination return evaluable.</p></div></div><div id='d_Qi' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><p>Sets the given argument of this operation, by argument index.</p></div></div><div id='d_Qj' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_Qk' class='de'><h1>Method <span class='n'>getConclusion</span></h1><div class='re'><code>getConclusion( self )</code></div><div class='ds'><p>Returns the process that will conclude the interception (finally)</p></div></div><div id='d_Qd' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_Qe' class='de'><h1>Method <span class='n'>hasSlot</span></h1><div class='re'><code>hasSlot( self, name )</code></div><div class='ds'><p>Tells if the context has a slot with the given name.</p></div></div><div id='d_Qf' class='de'><h1>Method <span class='n'>getOperations</span></h1><div class='re'><code>getOperations( self )</code></div><div class='ds'><p>Returns the list of operations in this process.</p></div></div><div id='d_Qg' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IEmbed at 0x5bff90&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Qb' class='de'><h1>Method <span class='n'>setRest</span></h1><div class='re'><code>setRest( self, value )</code></div><div class='ds'><p>Sets this argument as variable or not.</p></div></div><div id='d_Qc' class='de'><h1>Method <span class='n'>getMethods</span></h1><div class='re'><code>getMethods( self )</code></div><div class='ds'><p>Returns the methods defined within this class.</p></div></div><div id='d_OA' class='de'><h1>Class <span class='n'>TransformAsynchronousInvocations</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Of' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_Og' class='de'><h1>list</h1><div class='re'><code>[]</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='d_Od' class='de'><h1>Method <span class='n'>setArguments</span></h1><div class='re'><code>setArguments( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Oe' class='de'><h1>Method <span class='n'>getSlots</span></h1><div class='re'><code>getSlots( self )</code></div><div class='ds'><p>Returns (key, evaluable) pairs representing the slots within this context.</p></div></div><div id='d_Ob' class='de'><h1>Method <span class='n'>setKeywords</span></h1><div class='re'><code>setKeywords( self, value )</code></div><div class='ds'><p>Sets this argument as keywords list or not.</p></div></div><div id='d_Oc' class='de'><h1>Method <span class='n'>getDestructors</span></h1><div class='re'><code>getDestructors( self )</code></div><div class='ds'><p>Returns the destructors for this class</p></div></div><div id='d_On' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><p>Sets the given argument of this operation, by argument index.</p></div></div><div id='d_Oo' class='de'><h1>Class <span class='n'>INumber</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Ol' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><p>Returns the ith arguments to this operation.</p></div></div><div id='d_Om' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_Oj' class='de'><h1>Method <span class='n'>getImportedElements</span></h1><div class='re'><code>getImportedElements( self )</code></div><div class='ds'><p>Returns a reference or a resolution that will allow to get the imported element.</p></div></div><div id='d_Ok' class='de'><h1>Class <span class='n'>IInterception</span></h1><div class='re'></div><div class='ds'><p>An interception allows to intercept interruptions that propagage from an enclosed process to parent contexts.</p></div></div><div id='d_Oh' class='de'><h1>Class <span class='n'>IExcept</span></h1><div class='re'></div><div class='ds'><p>An interruption that raises some value</p></div></div><div id='d_Oi' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_Ov' class='de'><h1>Class <span class='n'>Runtime</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Ow' class='de'><h1>Class <span class='n'>Cell</span></h1><div class='re'></div><div class='ds'><p>A cell type represents a memory unit. It has a size (in bytes) the represents the length in memory.</p></div></div><div id='d_Ot' class='de'><h1>Method <span class='n'>_unique</span></h1><div class='re'><code>_unique( self, name )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Ou' class='de'><h1>Method <span class='n'>writeList</span></h1><div class='re'><code>writeList( self, element )</code></div><div class='ds'><p>Writes a list element.</p></div></div><div id='d_Or' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><p>Returns the ith arguments to this operation.</p></div></div><div id='d_Os' class='de'><h1>Method <span class='n'>breaks</span></h1><div class='re'><code>breaks( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Op' class='de'><h1>Method <span class='n'>hasSlot</span></h1><div class='re'><code>hasSlot( self, name )</code></div><div class='ds'><p>Tells if the context has a slot with the given name.</p></div></div><div id='d_Oq' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IOperation at 0x5bfa50&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='Et' class='cr'><div class='n'><a href='javascript:dS("Et");'>ModelException</a></div><div class='t'>Inhertied Values</div class='t'><div class='g'><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("Et","zt");'><span class='special __getitem__'>get item</span></a></span><br /><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("Et","Ft");'><span class='special __init__'>constructor</span></a></span><br /><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("Et","At");'><span class='special __repr__'>string repr</span></a></span><br /><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("Et","Bt");'><span class='special __str__'>string conversion</span></a></span><br /><span class='u'><span class='prefix'>&sdot;</span><a href='javascript:dO("Et","Ct");'>args</a></span><br /><span class='d'><span class='prefix'>&sdot;</span><a href='javascript:dO("Et","Dt");'>message</a></span><br /></div></div><div id='Ev' class='ro'><div class='n'><a href='javascript:dS("Ev");'>lambdafactory.modeltypes</a></div><div class='t'>Classes</div class='t'><div class='g'><span class='u'><span class='prefix'>&Tau;</span><a href='javascript:dO("Ev","Fv");'>Behaviour</a></span><br /><span class='u'><span class='prefix'>&Tau;</span><a href='javascript:dO("Ev","Iv");'>Data</a></span><br /><span class='u'><span class='prefix'>&Tau;</span><a href='javascript:dO("Ev","Lv");'>Operations</a></span><br /><span class='u'><span class='prefix'>&Tau;</span><a href='javascript:dO("Ev","Ov");'>Runtime</a></span><br /><span class='u'><span class='prefix'>&Tau;</span><a href='javascript:dO("Ev","Rv");'>Structure</a></span><br /><span class='d'><span class='prefix'>&Tau;</span><a href='javascript:dO("Ev","Uv");'>TypeCollection</a></span><br /></div><div class='t'>Functions</div class='t'><div class='g'><span class='d'><span class='prefix'>&lambda;</span><a href='javascript:dO("Ev","Wv");'>typeForValue</a></span><br /></div><div class='t'>Values</div class='t'><div class='g'><span class='u'><span class='prefix'>&bull;</span><a href='javascript:dO("Ev","Xv");'>CATALOG</a></span><br /><span class='d'><span class='prefix'>&bull;</span><a href='javascript:dO("Ev","Yv");'>COLLECTIONS</a></span><br /></div></div><div id='d_Oz' class='de'><h1>Method <span class='n'>clone</span></h1><div class='re'><code>clone( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Ox' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self, **kwargs )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Oy' class='de'><h1>Method <span class='n'>isSameAs</span></h1><div class='re'><code>isSameAs( self, otherType )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='b' class='cr'><div class='n'><a href='javascript:dS("b");'>Constants</a></div><div class='t'>Bases</div class='t'><div class='g'><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("b","c");'><span class='special __bases__'><i>Base class</i></span></a></span><br /></div><div class='t'>Values</div class='t'><div class='g'><span class='d'><span class='prefix'>&sdot;</span><a href='javascript:dO("b","d");'>Constructor</a></span><br /><span class='d'><span class='prefix'>&sdot;</span><a href='javascript:dO("b","e");'>CurrentModule</a></span><br /><span class='d'><span class='prefix'>&sdot;</span><a href='javascript:dO("b","f");'>CurrentValue</a></span><br /><span class='d'><span class='prefix'>&sdot;</span><a href='javascript:dO("b","g");'>Destructor</a></span><br /><span class='d'><span class='prefix'>&sdot;</span><a href='javascript:dO("b","h");'>MainFunction</a></span><br /><span class='d'><span class='prefix'>&sdot;</span><a href='javascript:dO("b","i");'>ModuleInit</a></span><br /><span class='d'><span class='prefix'>&bull;</span><a href='javascript:dO("b","j");'>PARENS_PRIORITY</a></span><br /></div></div><div id='Xp' class='cr'><div class='n'><a href='javascript:dS("Xp");'>IReference</a></div><div class='t'>Bases</div class='t'><div class='g'><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("Xp","Yp");'><span class='special __bases__'>IValue, IReferencable</span></a></span><br /></div><div class='t'>Methods</div class='t'><div class='g'><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Xp","Zp");'>getReferenceName</a></span><br /></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Xp","aq");'>getAbsoluteName</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Xp","bq");'>getAbstractType</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Xp","cq");'>getAnnotation</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Xp","dq");'>getDataFlow</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Xp","eq");'>getName</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Xp","fq");'>getResultAbstractType</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Xp","gq");'>setAbstractType</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Xp","hq");'>setAnnotation</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Xp","iq");'>setResultAbstractType</a></span><br /></div></div><div id='kc' class='cr'><div class='n'><a href='javascript:dS("kc");'>IAttribute</a></div><div class='t'>Bases</div class='t'><div class='g'><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("kc","lc");'><span class='special __bases__'>ISlot</span></a></span><br /></div><div class='t'>Methods</div class='t'><div class='g'><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("kc","mc");'>getDefaultValue</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("kc","nc");'>setDefaultValue</a></span><br /></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("kc","oc");'>getAbsoluteName</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("kc","pc");'>getName</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("kc","qc");'>getTypeDescription</a></span><br /></div></div><div id='kp' class='cr'><div class='n'><a href='javascript:dS("kp");'>IOperator</a></div><div class='t'>Bases</div class='t'><div class='g'><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("kp","lp");'><span class='special __bases__'>IReference</span></a></span><br /></div><div class='t'>Methods</div class='t'><div class='g'><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("kp","mp");'>getPriority</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("kp","np");'>setPriority</a></span><br /></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("kp","op");'>getAbsoluteName</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("kp","pp");'>getAbstractType</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("kp","qp");'>getAnnotation</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("kp","rp");'>getDataFlow</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("kp","sp");'>getName</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("kp","tp");'>getReferenceName</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("kp","up");'>getResultAbstractType</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("kp","vp");'>setAbstractType</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("kp","wp");'>setAnnotation</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("kp","xp");'>setResultAbstractType</a></span><br /></div></div><div id='d_jA' class='de'><h1>instance</h1><div class='re'></div><div class='ds'><p>Symbolic types are types that have no physical counter part but play a role in the type system. This is for instance the case with Any or Nil.</p></div></div><div id='d_jy' class='de'><h1>Class <span class='n'>Process</span></h1><div class='re'></div><div class='ds'><p>A process generates values by processing (optional) arguments.</p></div></div><div id='d_jx' class='de'><h1>Method <span class='n'>clone</span></h1><div class='re'><code>clone( self, clone=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_jz' class='de'><h1>Method <span class='n'>definedBy</span></h1><div class='re'><code>definedBy( self, definition=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_ju' class='de'><h1>Method <span class='n'>end</span></h1><div class='re'><code>end( self )</code></div><div class='ds'><p>Callback invoked after a <code>fromXXX</code> method was invoked.</p></div></div><div id='d_jt' class='de'><h1>Method <span class='n'>importModules</span></h1><div class='re'><code>importModules( self, names )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_jw' class='de'><h1>Method <span class='n'>definedBy</span></h1><div class='re'><code>definedBy( self, definition=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_jv' class='de'><h1>Method <span class='n'>getCurrentClosure</span></h1><div class='re'><code>getCurrentClosure( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_jq' class='de'><h1>Class <span class='n'>IRepetition</span></h1><div class='re'></div><div class='ds'><p>A repetition is the repetitive execution of a process according to a predicate expression which can be modified by the process.</p></div></div><div id='d_jp' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_js' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_jr' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_jm' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><p>Sets the given argument of this operation, by argument index.</p></div></div><div id='d_jl' class='de'><h1>Method <span class='n'>getAbsoluteName</span></h1><div class='re'><code>getAbsoluteName( self )</code></div><div class='ds'><p>Returns the absolute name for this element</p></div></div><div id='d_jo' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_jn' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><p>Sets the given argument of this operation, by argument index.</p></div></div><div id='d_ji' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_jh' class='de'><h1>Method <span class='n'>getStep</span></h1><div class='re'><code>getStep( self )</code></div><div class='ds'><p>Returns this enumeration step.</p></div></div><div id='d_jk' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_jj' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IOperation at 0x5bfa50&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_je' class='de'><h1>Method <span class='n'>getOperand</span></h1><div class='re'><code>getOperand( self )</code></div><div class='ds'><p>Returns the left operand of this computation.</p></div></div><div id='d_jd' class='de'><h1>Method <span class='n'>getAbsoluteName</span></h1><div class='re'><code>getAbsoluteName( self )</code></div><div class='ds'><p>Returns the absolute name for this element</p></div></div><div id='d_jg' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_jf' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_jc' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.IEvaluable at 0x5bf3f0&gt;, &lt;class lambdafactory.interfaces.IEvaluable at 0x5bf3f0&gt;]</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='d_jb' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><p>Returns the <em>internal types</em> for this operations arguments. This is typically the list of interfaces or @protocols that the arguments must comply to.</p></div></div><div id='d_NA' class='de'><h1>Method <span class='n'>walk</span></h1><div class='re'><code>walk( self, element )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Nc' class='de'><h1>Method <span class='n'>getConstructors</span></h1><div class='re'><code>getConstructors( self )</code></div><div class='ds'><p>Returns the constructors for this class</p></div></div><div id='d_Nb' class='de'><h1>Method <span class='n'>setDefaultValue</span></h1><div class='re'><code>setDefaultValue( self, value )</code></div><div class='ds'><p>Sets the @methodault value for this argument.</p></div></div><div id='d_Ne' class='de'><h1>Method <span class='n'>getSlot</span></h1><div class='re'><code>getSlot( self, name )</code></div><div class='ds'><p>Returns the given evaluable bound to named slot.</p></div></div><div id='d_Nd' class='de'><h1>Method <span class='n'>getArguments</span></h1><div class='re'><code>getArguments( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Ng' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><p>Sets the given argument of this operation, by argument index.</p></div></div><div id='d_Nf' class='de'><h1>Method <span class='n'>getArguments</span></h1><div class='re'><code>getArguments( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Ni' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><p>Returns the <em>internal types</em> for this operations arguments. This is typically the list of interfaces or @protocols that the arguments must comply to.</p></div></div><div id='d_Nh' class='de'><h1>list</h1><div class='re'><code>['Evaluable']</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='d_Nk' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.IEvaluable at 0x5bf3f0&gt;, [&lt;class lambdafactory.interfaces.IEvaluable at 0x5bf3f0&gt;]]</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='d_Nj' class='de'><h1>Method <span class='n'>getImportOrigin</span></h1><div class='re'><code>getImportOrigin( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Nm' class='de'><h1>Method <span class='n'>getActualValue</span></h1><div class='re'><code>getActualValue( self )</code></div><div class='ds'><p>Returns the (implementation language) value for this literal</p></div></div><div id='d_Nl' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_No' class='de'><h1>Method <span class='n'>setDefaultValue</span></h1><div class='re'><code>setDefaultValue( self )</code></div><div class='ds'><p>Sets the @methodault value for this attribute</p></div></div><div id='d_Nn' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_Nq' class='de'><h1>Class <span class='n'>ISelection</span></h1><div class='re'></div><div class='ds'><p>Selections are the abstract objects behind <code>if</code>, <code>select</code> or pattern-matching operations. Each selection has match operations as arguments, which bind a subprocess to a predicate expression.</p></div></div><div id='d_Np' class='de'><h1>Method <span class='n'>getSlots</span></h1><div class='re'><code>getSlots( self )</code></div><div class='ds'><p>Returns (key, evaluable) pairs representing the slots within this context.</p></div></div><div id='d_Ns' class='de'><h1>Method <span class='n'>assign</span></h1><div class='re'><code>assign( self, name, evaluable )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Nr' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_Nu' class='de'><h1>Method <span class='n'>writeIteration</span></h1><div class='re'><code>writeIteration( self, iteration )</code></div><div class='ds'><p>Writes a iteration operation.</p></div></div><div id='d_Nt' class='de'><h1>Method <span class='n'>_getContextsAsString</span></h1><div class='re'><code>_getContextsAsString( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Nw' class='de'><h1>Method <span class='n'>subtype</span></h1><div class='re'><code>subtype( self, name )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Nv' class='de'><h1>Method <span class='n'>getType</span></h1><div class='re'><code>getType( self, name )</code></div><div class='ds'><p>Returns the type with the given name, or None if it does not exist.</p></div></div><div id='d_Ny' class='de'><h1>Method <span class='n'>isLike</span></h1><div class='re'><code>isLike( self, otherType )</code></div><div class='ds'><p>The other type is like this one if the other is a sequence with the same length and that all elements are like the corresponding elements of this sequence.</p></div></div><div id='d_Nx' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.typecast.Type at 0x11327e0&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Nz' class='de'><h1>Method <span class='n'>asString</span></h1><div class='re'><code>asString( self, fromType=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='pb' class='cr'><div class='n'><a href='javascript:dS("pb");'>IAllocation</a></div><div class='t'>Bases</div class='t'><div class='g'><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("pb","qb");'><span class='special __bases__'>IOperation</span></a></span><br /></div><div class='t'>Methods</div class='t'><div class='g'><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("pb","rb");'>getDefaultValue</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("pb","sb");'>getSlotToAllocate</a></span><br /></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("pb","tb");'>addOpArgument</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("pb","ub");'>getAbstractType</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("pb","vb");'>getAnnotation</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("pb","wb");'>getDataFlow</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("pb","xb");'>getOpArgument</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("pb","yb");'>getOpArguments</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("pb","zb");'>getOpArgumentsInternalTypes</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("pb","Ab");'>setAbstractType</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("pb","Bb");'>setAnnotation</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("pb","Cb");'>setOpArgument</a></span><br /></div><div class='t'>Values</div class='t'><div class='g'><span class='d'><span class='prefix'>&bull;</span><a href='javascript:dO("pb","Db");'>ARGS</a></span><br /></div></div><div id='d_PA' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.passes.Pass at 0x1147b70&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Pz' class='de'><h1>Method <span class='n'>concreteType</span></h1><div class='re'><code>concreteType( self )</code></div><div class='ds'><p>Returns the <span class='term'>concrete type</span> for this abstract type.</p></div></div><div id='d_Py' class='de'><h1>Method <span class='n'>isSubtypeOf</span></h1><div class='re'><code>isSubtypeOf( self, otherType )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Px' class='de'><h1>Method <span class='n'>add</span></h1><div class='re'><code>add( self, name, theType )</code></div><div class='ds'><p>This is a <em>deprecated</em> methods that is simply an alias for <code>Map.set</code>.</p></div></div><div id='d_Pw' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.typecast.Type at 0x11327e0&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Pv' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.modeltypes.TypeCollection at 0x1127f90&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Pu' class='de'><h1>Method <span class='n'>writeMethod</span></h1><div class='re'><code>writeMethod( self, methodElement )</code></div><div class='ds'><p>Writes a method element.</p></div></div><div id='d_Pt' class='de'><h1>Method <span class='n'>getCurrentClass</span></h1><div class='re'><code>getCurrentClass( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Ps' class='de'><h1>Method <span class='n'>comment</span></h1><div class='re'><code>comment( self, content )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Pr' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><p>Returns the arguments to this operation.</p></div></div><div id='d_Pq' class='de'><h1>Method <span class='n'>addRule</span></h1><div class='re'><code>addRule( self, evaluable )</code></div><div class='ds'><p>Adds a rule to this operation.</p></div></div><div id='d_Pp' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_Po' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.ILiteral at 0x5bf4e0&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Pn' class='de'><h1>Method <span class='n'>setPredicate</span></h1><div class='re'><code>setPredicate( self, v )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Pm' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_Pl' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><p>Returns the arguments to this operation.</p></div></div><div id='d_Pk' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IOperation at 0x5bfa50&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Pj' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><p>Adds an argument to this operation. This should do checking of arguments (by expected internal type and number).</p></div></div><div id='d_Pi' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_Ph' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IInterruption at 0x5bfed0&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Pg' class='de'><h1>Class <span class='n'>IEmbedTemplate</span></h1><div class='re'></div><div class='ds'><p>The <code>EmbedTemplate</code> is embedded (<code>Embed</code>) that contains template expressions. It's up to the model writer to know how to expand the template to convert it to the target language.</p></div></div><div id='d_Pf' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><p>Returns this @protocol name. It can be <code>None</code> if the @protocol is anonymous.</p></div></div><div id='d_Pe' class='de'><h1>Method <span class='n'>hasExplicitTermination</span></h1><div class='re'><code>hasExplicitTermination( self )</code></div><div class='ds'><p>Returns true if this function has an operation with a termination, otherwise return false.</p></div></div><div id='d_Pd' class='de'><h1>Method <span class='n'>addOperation</span></h1><div class='re'><code>addOperation( self, operation )</code></div><div class='ds'><p>Adds the given operation as a child of this process.</p></div></div><div id='d_Pc' class='de'><h1>Method <span class='n'>getInstanceMethods</span></h1><div class='re'><code>getInstanceMethods( self )</code></div><div class='ds'><p>Returns the instance methods defined within this class.</p></div></div><div id='d_Pb' class='de'><h1>Method <span class='n'>setOptional</span></h1><div class='re'><code>setOptional( self, value )</code></div><div class='ds'><p>Sets this argument as optional or not.</p></div></div><div id='ab' class='cr'><div class='n'><a href='javascript:dS("ab");'>IAccessOperation</a></div><div class='t'>Bases</div class='t'><div class='g'><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("ab","bb");'><span class='special __bases__'>ISubsetOperation</span></a></span><br /></div><div class='t'>Methods</div class='t'><div class='g'><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("ab","cb");'>getIndex</a></span><br /></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("ab","db");'>addOpArgument</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("ab","eb");'>getAbstractType</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("ab","fb");'>getAnnotation</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("ab","gb");'>getDataFlow</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("ab","hb");'>getOpArgument</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("ab","ib");'>getOpArguments</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("ab","jb");'>getOpArgumentsInternalTypes</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("ab","kb");'>getTarget</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("ab","lb");'>setAbstractType</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("ab","mb");'>setAnnotation</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("ab","nb");'>setOpArgument</a></span><br /></div><div class='t'>Values</div class='t'><div class='g'><span class='d'><span class='prefix'>&bull;</span><a href='javascript:dO("ab","ob");'>ARGS</a></span><br /></div></div><div id='d_mA' class='de'><h1>Module <span class='n'>lambdafactory.passes</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_mx' class='de'><h1>Method <span class='n'>extends</span></h1><div class='re'><code>extends( self, parent )</code></div><div class='ds'><p>Add a new parent from which this Context inherits.</p></div></div><div id='d_my' class='de'><h1>Method <span class='n'>_ensureIntegrity</span></h1><div class='re'><code>_ensureIntegrity( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_mz' class='de'><h1>Method <span class='n'>isSubtypeOf</span></h1><div class='re'><code>isSubtypeOf( self, otherType )</code></div><div class='ds'><p>Generic implementation of isSubtypeOf. You should always call this method in subclasses, as it implements basic type systems rules such as isSubtypeOf(Any).</p></div></div><div id='d_mp' class='de'><h1>Method <span class='n'>getPriority</span></h1><div class='re'><code>getPriority( self )</code></div><div class='ds'><p>Gets the priority for this operator</p></div></div><div id='d_mq' class='de'><h1>Method <span class='n'>getProcess</span></h1><div class='re'><code>getProcess( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_mr' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><p>Returns the <em>internal types</em> for this operations arguments. This is typically the list of interfaces or @protocols that the arguments must comply to.</p></div></div><div id='d_ms' class='de'><h1>Class <span class='n'>IValue</span></h1><div class='re'></div><div class='ds'><p>A value represents an atomic element of the language, like a number, a string, or a name (that can resolved by the language, acts as key for data structures, etc.).</p></div></div><div id='d_mt' class='de'><h1>Method <span class='n'>instanciate</span></h1><div class='re'><code>instanciate( self, evaluable, *arguments )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_mu' class='de'><h1>Method <span class='n'>fromString</span></h1><div class='re'><code>fromString( self, text )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_mv' class='de'><h1>Method <span class='n'>getCurrentFunction</span></h1><div class='re'><code>getCurrentFunction( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_mw' class='de'><h1>Method <span class='n'>isLike</span></h1><div class='re'><code>isLike( self, otherType )</code></div><div class='ds'><p>The other type is like this one if the other is a sequence with the same length and that all elements are like the corresponding elements of this sequence.</p></div></div><div id='d_mh' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_mi' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_mj' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_mk' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns the parent context for this context (if any)</p></div></div><div id='d_ml' class='de'><h1>Method <span class='n'>getAttributes</span></h1><div class='re'><code>getAttributes( self )</code></div><div class='ds'><p>Returns the (non-class) attributes defined within this class.</p></div></div><div id='d_mm' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IOperation at 0x5bfa50&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_mn' class='de'><h1>Class <span class='n'>IMatchOperation</span></h1><div class='re'></div><div class='ds'><p>A match operation is the binding of an expression and a process.</p></div></div><div id='d_mo' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, context )</code></div><div class='ds'><p>Sets the parent context for this context.</p></div></div><div id='d_mb' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_mc' class='de'><h1>Method <span class='n'>getDefaultValue</span></h1><div class='re'><code>getDefaultValue( self )</code></div><div class='ds'><p>Gets the @methodault value for this attribute</p></div></div><div id='d_md' class='de'><h1>Method <span class='n'>getTypeDescription</span></h1><div class='re'><code>getTypeDescription( self )</code></div><div class='ds'><p>Returns type information (constraints) that are associated to this argument.</p></div></div><div id='d_me' class='de'><h1>Method <span class='n'>getRightOperand</span></h1><div class='re'><code>getRightOperand( self )</code></div><div class='ds'><p>Returns the right operand of this computation (if any)</p></div></div><div id='d_mf' class='de'><h1>Method <span class='n'>addChild</span></h1><div class='re'><code>addChild( self, child )</code></div><div class='ds'><p>Adds the given dataflow as a child of this dataflow.</p></div></div><div id='d_mg' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='Oo' class='cr'><div class='n'><a href='javascript:dS("Oo");'>INumber</a></div><div class='t'>Bases</div class='t'><div class='g'><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("Oo","Po");'><span class='special __bases__'>ILiteral</span></a></span><br /></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Oo","Qo");'>getAbstractType</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Oo","Ro");'>getActualValue</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Oo","So");'>getAnnotation</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Oo","To");'>getDataFlow</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Oo","Uo");'>getResultAbstractType</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Oo","Vo");'>setAbstractType</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Oo","Wo");'>setAnnotation</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Oo","Xo");'>setResultAbstractType</a></span><br /></div></div><div id='Ok' class='cr'><div class='n'><a href='javascript:dS("Ok");'>IInterception</a></div><div class='t'>Bases</div class='t'><div class='g'><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("Ok","Pk");'><span class='special __bases__'>IOperation</span></a></span><br /></div><div class='t'>Methods</div class='t'><div class='g'><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Ok","Qk");'>getConclusion</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Ok","Rk");'>getIntercept</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Ok","Sk");'>getProcess</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Ok","Tk");'>setConclusion</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Ok","Uk");'>setIntercept</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Ok","Vk");'>setProcess</a></span><br /></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Ok","Wk");'>addOpArgument</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Ok","Xk");'>getAbstractType</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Ok","Yk");'>getAnnotation</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Ok","Zk");'>getDataFlow</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Ok","al");'>getOpArgument</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Ok","bl");'>getOpArguments</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Ok","cl");'>getOpArgumentsInternalTypes</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Ok","dl");'>setAbstractType</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Ok","el");'>setAnnotation</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Ok","fl");'>setOpArgument</a></span><br /></div><div class='t'>Values</div class='t'><div class='g'><span class='d'><span class='prefix'>&bull;</span><a href='javascript:dO("Ok","gl");'>ARGS</a></span><br /></div></div><div id='Oh' class='cr'><div class='n'><a href='javascript:dS("Oh");'>IExcept</a></div><div class='t'>Bases</div class='t'><div class='g'><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("Oh","Ph");'><span class='special __bases__'>IInterruption</span></a></span><br /></div><div class='t'>Methods</div class='t'><div class='g'><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Oh","Qh");'>getValue</a></span><br /></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Oh","Rh");'>addOpArgument</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Oh","Sh");'>getAbstractType</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Oh","Th");'>getAnnotation</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Oh","Uh");'>getDataFlow</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Oh","Vh");'>getOpArgument</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Oh","Wh");'>getOpArguments</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Oh","Xh");'>getOpArgumentsInternalTypes</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Oh","Yh");'>setAbstractType</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Oh","Zh");'>setAnnotation</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Oh","ai");'>setOpArgument</a></span><br /></div><div class='t'>Values</div class='t'><div class='g'><span class='d'><span class='prefix'>&bull;</span><a href='javascript:dO("Oh","bi");'>ARGS</a></span><br /></div></div><div id='Ow' class='cr'><div class='n'><a href='javascript:dS("Ow");'>Cell</a></div><div class='t'>Bases</div class='t'><div class='g'><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("Ow","Pw");'><span class='special __bases__'>Type</span></a></span><br /></div><div class='t'>Methods</div class='t'><div class='g'><span class='u'><span class='prefix'>&equiv;</span><a href='javascript:dO("Ow","Qw");'><span class='special __init__'>constructor</span></a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("Ow","Rw");'>asString</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("Ow","Sw");'>clone</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Ow","Tw");'>isLike</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("Ow","Uw");'>isSameAs</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("Ow","Vw");'>isSubtypeOf</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Ow","Ww");'>length</a></span><br /></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("Ow","Xw");'><span class='special __call__'>when invoked</span></a></span><br /><span class='u'><span class='prefix'>&equiv;</span><a href='javascript:dO("Ow","Yw");'><span class='special __str__'>string conversion</span></a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Ow","Zw");'>concreteType</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("Ow","ax");'>definedBy</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Ow","bx");'>name</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Ow","cx");'>result</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Ow","dx");'>setConcreteType</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Ow","ex");'>setName</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("Ow","fx");'>subtype</a></span><br /></div></div><div id='Ov' class='cr'><div class='n'><a href='javascript:dS("Ov");'>Runtime</a></div><div class='t'>Bases</div class='t'><div class='g'><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("Ov","Pv");'><span class='special __bases__'>TypeCollection</span></a></span><br /></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Ov","Qv");'>getType</a></span><br /></div></div><div id='OA' class='cr'><div class='n'><a href='javascript:dS("OA");'>TransformAsynchronousInvocations</a></div><div class='t'>Bases</div class='t'><div class='g'><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("OA","PA");'><span class='special __bases__'>Pass</span></a></span><br /></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><span class='u'><span class='prefix'>&equiv;</span><a href='javascript:dO("OA","QA");'><span class='special __init__'>constructor</span></a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("OA","RA");'>getHandle</a></span><br /></div><div class='t'>Values</div class='t'><div class='g'><span class='d'><span class='prefix'>&bull;</span><a href='javascript:dO("OA","SA");'>HANDLES</a></span><br /><span class='d'><span class='prefix'>&bull;</span><a href='javascript:dO("OA","TA");'>NAME</a></span><br /></div></div><div id='bk' class='cr'><div class='n'><a href='javascript:dS("bk");'>IInstanceMethod</a></div><div class='t'>Bases</div class='t'><div class='g'><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("bk","ck");'><span class='special __bases__'>IMethod</span></a></span><br /></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("bk","dk");'>addOperation</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("bk","ek");'>endsWithTermination</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("bk","fk");'>getAbsoluteName</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("bk","gk");'>getAbstractType</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("bk","hk");'>getAnnotation</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("bk","ik");'>getArguments</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("bk","jk");'>getDataFlow</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("bk","kk");'>getName</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("bk","lk");'>getOperations</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("bk","mk");'>getParent</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("bk","nk");'>getSlot</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("bk","ok");'>getSlots</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("bk","pk");'>hasExplicitTermination</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("bk","qk");'>hasSlot</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("bk","rk");'>isAbstract</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("bk","sk");'>setAbstract</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("bk","tk");'>setAbstractType</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("bk","uk");'>setAnnotation</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("bk","vk");'>setArguments</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("bk","wk");'>setParent</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("bk","xk");'>setSlot</a></span><br /></div></div><div id='bz' class='cr'><div class='n'><a href='javascript:dS("bz");'>Symbolic</a></div><div class='t'>Bases</div class='t'><div class='g'><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("bz","cz");'><span class='special __bases__'>Type</span></a></span><br /></div><div class='t'>Methods</div class='t'><div class='g'><span class='u'><span class='prefix'>&equiv;</span><a href='javascript:dO("bz","dz");'><span class='special __init__'>constructor</span></a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("bz","ez");'>asString</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("bz","fz");'>clone</a></span><br /></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("bz","gz");'><span class='special __call__'>when invoked</span></a></span><br /><span class='u'><span class='prefix'>&equiv;</span><a href='javascript:dO("bz","hz");'><span class='special __str__'>string conversion</span></a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("bz","iz");'>concreteType</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("bz","jz");'>definedBy</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("bz","kz");'>isLike</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("bz","lz");'>isSameAs</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("bz","mz");'>isSubtypeOf</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("bz","nz");'>name</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("bz","oz");'>result</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("bz","pz");'>setConcreteType</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("bz","qz");'>setName</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("bz","rz");'>subtype</a></span><br /></div></div><div id='d_SA' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.IClosure at 0x5bf900&gt;]</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='d_Sz' class='de'><h1>Method <span class='n'>isSameAs</span></h1><div class='re'><code>isSameAs( self, otherType )</code></div><div class='ds'><p>Generic implementation of isSameAs. You should always call this method in subclasses.</p></div></div><div id='d_Sx' class='de'><h1>Method <span class='n'>element</span></h1><div class='re'><code>element( self, key )</code></div><div class='ds'><p>Returns the element associated to the given key.</p></div></div><div id='d_Sy' class='de'><h1>Method <span class='n'>__str__</span></h1><div class='re'><code>__str__( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Sr' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_Ss' class='de'><h1>Method <span class='n'>createClass</span></h1><div class='re'><code>createClass( self, name, inherited=() )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Sp' class='de'><h1>Method <span class='n'>setSlot</span></h1><div class='re'><code>setSlot( self, name, evaluable )</code></div><div class='ds'><p>Binds the given evaluable to the named slot.</p></div></div><div id='d_Sq' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_Sv' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.modeltypes.TypeCollection at 0x1127f90&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Sw' class='de'><h1>Method <span class='n'>clone</span></h1><div class='re'><code>clone( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_St' class='de'><h1>Method <span class='n'>getCurrentClosure</span></h1><div class='re'><code>getCurrentClosure( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Su' class='de'><h1>Method <span class='n'>writeOperator</span></h1><div class='re'><code>writeOperator( self, operator )</code></div><div class='ds'><p>Writes an operator element.</p></div></div><div id='d_Sj' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_Sk' class='de'><h1>Method <span class='n'>getProcess</span></h1><div class='re'><code>getProcess( self )</code></div><div class='ds'><p>Returns the process that we will intercept interruptions from.</p></div></div><div id='d_Sh' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_Si' class='de'><h1>list</h1><div class='re'><code>['ImportedModuleName', 'Alias']</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='d_Sn' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IFunction at 0x5bf930&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_So' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_Sl' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_Sm' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_Sb' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><p>Returns the local name for this referencable element</p></div></div><div id='d_Sc' class='de'><h1>Method <span class='n'>getOperations</span></h1><div class='re'><code>getOperations( self )</code></div><div class='ds'><p>Returns the operations (methods and class methods) defined within this class.</p></div></div><div id='d_Sf' class='de'><h1>Method <span class='n'>getSlot</span></h1><div class='re'><code>getSlot( self, name )</code></div><div class='ds'><p>Returns the given evaluable bound to named slot.</p></div></div><div id='d_Sg' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_Sd' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_Se' class='de'><h1>Method <span class='n'>setAbstract</span></h1><div class='re'><code>setAbstract( self, isAbstract )</code></div><div class='ds'><p>Sets wether the given abstractable is abstract or not.</p></div></div><div id='d_AA' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self, environment )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='uA' class='cr'><div class='n'><a href='javascript:dS("uA");'>Pass</a></div><div class='t'>Bases</div class='t'><div class='g'><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("uA","c");'><span class='special __bases__'><i>Base class</i></span></a></span><br /></div><div class='t'>Methods</div class='t'><div class='g'><span class='u'><span class='prefix'>&equiv;</span><a href='javascript:dO("uA","vA");'><span class='special __init__'>constructor</span></a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("uA","wA");'>getHandle</a></span><br /></div><div class='t'>Values</div class='t'><div class='g'><span class='d'><span class='prefix'>&bull;</span><a href='javascript:dO("uA","xA");'>HANDLES</a></span><br /><span class='d'><span class='prefix'>&bull;</span><a href='javascript:dO("uA","yA");'>NAME</a></span><br /></div></div><div id='d_Al' class='de'><h1>Method <span class='n'>hasSlot</span></h1><div class='re'><code>hasSlot( self, name )</code></div><div class='ds'><p>Tells if the context has a slot with the given name.</p></div></div><div id='d_Am' class='de'><h1>Class <span class='n'>IList</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_An' class='de'><h1>Class <span class='n'>IMatchProcessOperation</span></h1><div class='re'></div><div class='ds'><p>A match process is a predicate associate to a process, which is typically used for implementing <code>if</code>, <code>else</code>, etc.</p></div></div><div id='d_Ao' class='de'><h1>Method <span class='n'>getSlot</span></h1><div class='re'><code>getSlot( self, name )</code></div><div class='ds'><p>Returns the given evaluable bound to named slot.</p></div></div><div id='d_Ah' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IOperation at 0x5bfa50&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Ai' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IProcess at 0x5bf870&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Aj' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_Ak' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IOperation at 0x5bfa50&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Ad' class='de'><h1>Method <span class='n'>getSlot</span></h1><div class='re'><code>getSlot( self, name )</code></div><div class='ds'><p>Returns the given evaluable bound to named slot.</p></div></div><div id='d_Ae' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.IOperator at 0x5bf630&gt;, &lt;class lambdafactory.interfaces.IEvaluable at 0x5bf3f0&gt;, &lt;class lambdafactory.interfaces.IEvaluable at 0x5bf3f0&gt;]</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='d_Af' class='de'><h1>Method <span class='n'>addOperation</span></h1><div class='re'><code>addOperation( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Ag' class='de'><h1>Method <span class='n'>getCode</span></h1><div class='re'><code>getCode( self )</code></div><div class='ds'><p>Returns the embedded code string.</p></div></div><div id='d_Ab' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_Ac' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_Ax' class='de'><h1>Method <span class='n'>isSubtypeOf</span></h1><div class='re'><code>isSubtypeOf( self, otherType )</code></div><div class='ds'><p>The other type is a subtype of this one if for each element of this type, we find that the other type has a subtype.</p></div></div><div id='d_Ay' class='de'><h1>Method <span class='n'>definedBy</span></h1><div class='re'><code>definedBy( self, definition=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Az' class='de'><h1>Method <span class='n'>isLike</span></h1><div class='re'><code>isLike( self, otherType )</code></div><div class='ds'><p>Generic implementation of isLike. You should always call this method in subclasses, as it implements basic type systems rules such as isLike(Any).</p></div></div><div id='uj' class='cr'><div class='n'><a href='javascript:dS("uj");'>IImportSymbolOperation</a></div><div class='t'>Bases</div class='t'><div class='g'><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("uj","vj");'><span class='special __bases__'>IImportOperation</span></a></span><br /></div><div class='t'>Methods</div class='t'><div class='g'><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("uj","wj");'>getAlias</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("uj","xj");'>getImportOrigin</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("uj","yj");'>getImportedElement</a></span><br /></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("uj","zj");'>addOpArgument</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("uj","Aj");'>getAbstractType</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("uj","Bj");'>getAnnotation</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("uj","Cj");'>getDataFlow</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("uj","Dj");'>getOpArgument</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("uj","Ej");'>getOpArguments</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("uj","Fj");'>getOpArgumentsInternalTypes</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("uj","Gj");'>setAbstractType</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("uj","Hj");'>setAnnotation</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("uj","Ij");'>setOpArgument</a></span><br /></div><div class='t'>Values</div class='t'><div class='g'><span class='d'><span class='prefix'>&bull;</span><a href='javascript:dO("uj","Jj");'>ARGS</a></span><br /><span class='d'><span class='prefix'>&bull;</span><a href='javascript:dO("uj","Kj");'>ARG_NAMES</a></span><br /></div></div><div id='d_At' class='de'><h1>wrapper_descriptor</h1><div class='re'></div><div class='ds'><div class="section"><h1 class="heading"><span class="number"><span class="level0">1<span class="lastDot dot">.</span></span></span><span class='term'>repr</span>_() &lt;==&gt; repr(x)</h1><div class="level1"></div></div></div></div><div id='d_Au' class='de'><h1>Method <span class='n'>writeClosure</span></h1><div class='re'><code>writeClosure( self, closure )</code></div><div class='ds'><p>Writes a closure element.</p></div></div><div id='d_Av' class='de'><h1>Function <span class='n'>notEmpty</span></h1><div class='re'><code>notEmpty( p )</code></div><div class='ds'><p>Returns None if the given parameter is empty.</p></div></div><div id='d_Aw' class='de'><h1>Method <span class='n'>isLike</span></h1><div class='re'><code>isLike( self, otherType )</code></div><div class='ds'><p>Othertype must be an Array with a content type that is the same type as the content type.</p></div></div><div id='d_Ap' class='de'><h1>Method <span class='n'>getOperations</span></h1><div class='re'><code>getOperations( self )</code></div><div class='ds'><p>Returns the list of operations in this process.</p></div></div><div id='d_Aq' class='de'><h1>Method <span class='n'>getContext</span></h1><div class='re'><code>getContext( self )</code></div><div class='ds'><p>Returns the (optional) context in which the resolution should occur.</p></div></div><div id='d_Ar' class='de'><h1>Method <span class='n'>getActualValue</span></h1><div class='re'><code>getActualValue( self )</code></div><div class='ds'><p>Returns the (implementation language) value for this literal</p></div></div><div id='d_As' class='de'><h1>Method <span class='n'>_classattr</span></h1><div class='re'><code>_classattr( self, name, typeinfo=None, value=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='Tp' class='cr'><div class='n'><a href='javascript:dS("Tp");'>IReferencable</a></div><div class='t'>Bases</div class='t'><div class='g'><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("Tp","Up");'><span class='special __bases__'>IAssignable</span></a></span><br /></div><div class='t'>Methods</div class='t'><div class='g'><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Tp","Vp");'>getAbsoluteName</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Tp","Wp");'>getName</a></span><br /></div></div><div id='Ti' class='cr'><div class='n'><a href='javascript:dS("Ti");'>IImportModulesOperation</a></div><div class='t'>Bases</div class='t'><div class='g'><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("Ti","Ui");'><span class='special __bases__'>IImportOperation</span></a></span><br /></div><div class='t'>Methods</div class='t'><div class='g'><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Ti","Vi");'>getImportedModuleNames</a></span><br /></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Ti","Wi");'>addOpArgument</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Ti","Xi");'>getAbstractType</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Ti","Yi");'>getAnnotation</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Ti","Zi");'>getDataFlow</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Ti","aj");'>getOpArgument</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Ti","bj");'>getOpArguments</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Ti","cj");'>getOpArgumentsInternalTypes</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Ti","dj");'>setAbstractType</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Ti","ej");'>setAnnotation</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Ti","fj");'>setOpArgument</a></span><br /></div><div class='t'>Values</div class='t'><div class='g'><span class='d'><span class='prefix'>&bull;</span><a href='javascript:dO("Ti","gj");'>ARGS</a></span><br /><span class='d'><span class='prefix'>&bull;</span><a href='javascript:dO("Ti","hj");'>ARG_NAMES</a></span><br /></div></div><div id='Am' class='cr'><div class='n'><a href='javascript:dS("Am");'>IList</a></div><div class='t'>Bases</div class='t'><div class='g'><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("Am","Bm");'><span class='special __bases__'>IValue</span></a></span><br /></div><div class='t'>Methods</div class='t'><div class='g'><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Am","Cm");'>addValue</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Am","Dm");'>getValues</a></span><br /></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Am","Em");'>getAbstractType</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Am","Fm");'>getAnnotation</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Am","Gm");'>getDataFlow</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Am","Hm");'>getResultAbstractType</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Am","Im");'>setAbstractType</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Am","Jm");'>setAnnotation</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Am","Km");'>setResultAbstractType</a></span><br /></div></div><div id='An' class='cr'><div class='n'><a href='javascript:dS("An");'>IMatchProcessOperation</a></div><div class='t'>Bases</div class='t'><div class='g'><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("An","Bn");'><span class='special __bases__'>IMatchOperation</span></a></span><br /></div><div class='t'>Methods</div class='t'><div class='g'><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("An","Cn");'>getProcess</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("An","Dn");'>setProcess</a></span><br /></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("An","En");'>addOpArgument</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("An","Fn");'>getAbstractType</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("An","Gn");'>getAnnotation</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("An","Hn");'>getDataFlow</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("An","In");'>getOpArgument</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("An","Jn");'>getOpArguments</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("An","Kn");'>getOpArgumentsInternalTypes</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("An","Ln");'>getPredicate</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("An","Mn");'>setAbstractType</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("An","Nn");'>setAnnotation</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("An","On");'>setOpArgument</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("An","Pn");'>setPredicate</a></span><br /></div><div class='t'>Values</div class='t'><div class='g'><span class='d'><span class='prefix'>&bull;</span><a href='javascript:dO("An","Qn");'>ARGS</a></span><br /></div></div><div id='gx' class='cr'><div class='n'><a href='javascript:dS("gx");'>Context</a></div><div class='t'>Bases</div class='t'><div class='g'><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("gx","hx");'><span class='special __bases__'>Map</span></a></span><br /></div><div class='t'>Methods</div class='t'><div class='g'><span class='u'><span class='prefix'>&equiv;</span><a href='javascript:dO("gx","ix");'><span class='special __init__'>constructor</span></a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("gx","jx");'>clone</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("gx","kx");'>element</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("gx","lx");'>elements</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("gx","mx");'>extends</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("gx","nx");'>fullName</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("gx","ox");'>parent</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("gx","px");'>parents</a></span><br /></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("gx","qx");'><span class='special __call__'>when invoked</span></a></span><br /><span class='u'><span class='prefix'>&equiv;</span><a href='javascript:dO("gx","rx");'><span class='special __str__'>string conversion</span></a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("gx","sx");'>add</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("gx","tx");'>asString</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("gx","ux");'>concreteType</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("gx","vx");'>definedBy</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("gx","wx");'>elementNames</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("gx","xx");'>get</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("gx","yx");'>isLike</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("gx","zx");'>isSameAs</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("gx","Ax");'>isSubtypeOf</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("gx","Bx");'>name</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("gx","Cx");'>result</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("gx","Dx");'>set</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("gx","Ex");'>setConcreteType</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("gx","Fx");'>setName</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("gx","Gx");'>subtype</a></span><br /></div></div><div id='ge' class='cr'><div class='n'><a href='javascript:dS("ge");'>IComputation</a></div><div class='t'>Bases</div class='t'><div class='g'><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("ge","he");'><span class='special __bases__'>IOperation</span></a></span><br /></div><div class='t'>Methods</div class='t'><div class='g'><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("ge","ie");'>getLeftOperand</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("ge","je");'>getOperand</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("ge","ke");'>getOperands</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("ge","le");'>getOperator</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("ge","me");'>getRightOperand</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("ge","ne");'>setLeftOperand</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("ge","oe");'>setOperator</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("ge","pe");'>setRightOperand</a></span><br /></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("ge","qe");'>addOpArgument</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("ge","re");'>getAbstractType</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("ge","se");'>getAnnotation</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("ge","te");'>getDataFlow</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("ge","ue");'>getOpArgument</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("ge","ve");'>getOpArguments</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("ge","we");'>getOpArgumentsInternalTypes</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("ge","xe");'>setAbstractType</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("ge","ye");'>setAnnotation</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("ge","ze");'>setOpArgument</a></span><br /></div><div class='t'>Values</div class='t'><div class='g'><span class='d'><span class='prefix'>&bull;</span><a href='javascript:dO("ge","Ae");'>ARGS</a></span><br /></div></div><div id='zh' class='cr'><div class='n'><a href='javascript:dS("zh");'>IEvaluation</a></div><div class='t'>Bases</div class='t'><div class='g'><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("zh","Ah");'><span class='special __bases__'>IOperation</span></a></span><br /></div><div class='t'>Methods</div class='t'><div class='g'><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("zh","Bh");'>getEvaluable</a></span><br /></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("zh","Ch");'>addOpArgument</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("zh","Dh");'>getAbstractType</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("zh","Eh");'>getAnnotation</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("zh","Fh");'>getDataFlow</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("zh","Gh");'>getOpArgument</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("zh","Hh");'>getOpArguments</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("zh","Ih");'>getOpArgumentsInternalTypes</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("zh","Jh");'>setAbstractType</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("zh","Kh");'>setAnnotation</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("zh","Lh");'>setOpArgument</a></span><br /></div><div class='t'>Values</div class='t'><div class='g'><span class='d'><span class='prefix'>&bull;</span><a href='javascript:dO("zh","Mh");'>ARGS</a></span><br /><span class='d'><span class='prefix'>&bull;</span><a href='javascript:dO("zh","Nh");'>ARG_NAMES</a></span><br /></div></div><div id='zi' class='cr'><div class='n'><a href='javascript:dS("zi");'>IGroup</a></div><div class='t'>Bases</div class='t'><div class='g'><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("zi","Ai");'><span class='special __bases__'>IProcess</span></a></span><br /></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("zi","Bi");'>addOperation</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("zi","Ci");'>getOperations</a></span><br /></div></div><div id='zk' class='cr'><div class='n'><a href='javascript:dS("zk");'>IInstanciation</a></div><div class='t'>Bases</div class='t'><div class='g'><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("zk","Ak");'><span class='special __bases__'>IOperation</span></a></span><br /></div><div class='t'>Methods</div class='t'><div class='g'><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("zk","Bk");'>getArguments</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("zk","Ck");'>getInstanciable</a></span><br /></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("zk","Dk");'>addOpArgument</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("zk","Ek");'>getAbstractType</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("zk","Fk");'>getAnnotation</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("zk","Gk");'>getDataFlow</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("zk","Hk");'>getOpArgument</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("zk","Ik");'>getOpArguments</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("zk","Jk");'>getOpArgumentsInternalTypes</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("zk","Kk");'>setAbstractType</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("zk","Lk");'>setAnnotation</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("zk","Mk");'>setOpArgument</a></span><br /></div><div class='t'>Values</div class='t'><div class='g'><span class='d'><span class='prefix'>&bull;</span><a href='javascript:dO("zk","Nk");'>ARGS</a></span><br /></div></div><div id='zf' class='cr'><div class='n'><a href='javascript:dS("zf");'>IDataFlowSlot</a></div><div class='t'>Bases</div class='t'><div class='g'><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("zf","c");'><span class='special __bases__'><i>Base class</i></span></a></span><br /></div><div class='t'>Methods</div class='t'><div class='g'><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("zf","Af");'>addOperation</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("zf","Bf");'>getAbstractType</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("zf","Cf");'>getName</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("zf","Df");'>getOperations</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("zf","Ef");'>getOrigin</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("zf","Ff");'>getOriginalValue</a></span><br /></div></div><div id='zA' class='cr'><div class='n'><a href='javascript:dS("zA");'>PassContext</a></div><div class='t'>Bases</div class='t'><div class='g'><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("zA","c");'><span class='special __bases__'><i>Base class</i></span></a></span><br /></div><div class='t'>Methods</div class='t'><div class='g'><span class='u'><span class='prefix'>&equiv;</span><a href='javascript:dO("zA","AA");'><span class='special __init__'>constructor</span></a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("zA","BA");'>filter</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("zA","CA");'>filterContext</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("zA","DA");'>findInContext</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("zA","EA");'>getCurrentClass</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("zA","FA");'>getCurrentClassParents</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("zA","GA");'>getCurrentClosure</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("zA","HA");'>getCurrentFunction</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("zA","IA");'>getCurrentMethod</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("zA","JA");'>getCurrentProcess</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("zA","KA");'>isIn</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("zA","LA");'>resolve</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("zA","MA");'>run</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("zA","NA");'>walk</a></span><br /></div></div><div id='d_lA' class='de'><h1>instance</h1><div class='re'></div><div class='ds'><p>Symbolic types are types that have no physical counter part but play a role in the type system. This is for instance the case with Any or Nil.</p></div></div><div id='d_lz' class='de'><h1>Method <span class='n'>isSameAs</span></h1><div class='re'><code>isSameAs( self, otherType )</code></div><div class='ds'><p>Generic implementation of isSameAs. You should always call this method in subclasses.</p></div></div><div id='d_ly' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self, *args )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_lx' class='de'><h1>Method <span class='n'>elements</span></h1><div class='re'><code>elements( self )</code></div><div class='ds'><p>Returns a dict of the elements in this map.</p></div></div><div id='d_ls' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.IEvaluable at 0x5bf3f0&gt;]</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='d_lr' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><p>Returns the arguments to this operation.</p></div></div><div id='d_lq' class='de'><h1>Method <span class='n'>getCondition</span></h1><div class='re'><code>getCondition( self )</code></div><div class='ds'><p>Gets the expression that is the condition for this repetition.</p></div></div><div id='d_lp' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IReference at 0x5bf5d0&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_lw' class='de'><h1>Method <span class='n'>extend</span></h1><div class='re'><code>extend( self, othertype )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_lv' class='de'><h1>Method <span class='n'>getCurrentDataFlow</span></h1><div class='re'><code>getCurrentDataFlow( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_lu' class='de'><h1>Method <span class='n'>fromStream</span></h1><div class='re'><code>fromStream( self, stream, addEOL=False )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_lt' class='de'><h1>Method <span class='n'>importSymbols</span></h1><div class='re'><code>importSymbols( self, names, origin )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_lk' class='de'><h1>Method <span class='n'>getOperations</span></h1><div class='re'><code>getOperations( self )</code></div><div class='ds'><p>Returns the list of operations in this process.</p></div></div><div id='d_lj' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_li' class='de'><h1>Method <span class='n'>getArguments</span></h1><div class='re'><code>getArguments( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_lh' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><p>Adds an argument to this operation. This should do checking of arguments (by expected internal type and number).</p></div></div><div id='d_lo' class='de'><h1>Method <span class='n'>setArguments</span></h1><div class='re'><code>setArguments( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_ln' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.IEvaluable at 0x5bf3f0&gt;, &lt;class lambdafactory.interfaces.IEvaluable at 0x5bf3f0&gt;]</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='d_lm' class='de'><h1>Class <span class='n'>IIteration</span></h1><div class='re'></div><div class='ds'><p>An iteration is the multiple application of a process given a set of values produced by an iterator.</p></div></div><div id='d_ll' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_lc' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.ISlot at 0x5bf660&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_lb' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_lg' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_lf' class='de'><h1>Class <span class='n'>IDataFlow</span></h1><div class='re'></div><div class='ds'><p>The DataFlow are &ldquo;<span class='quote'>dynamic contexts</span>&rdquo; bound to the various program model elements. DataFlows are typically owned by elements which implement <code>IContext</code>, and are linked together by rules defined in the <code>Resolver</code> @protocol.</p><p>The dataflow bound to most expressions is the one of the enclosing closure (whether it is a function, or method. The dataflow of a method is bound to its parent @protocol, which dataflow is also bound to the parent @protocol dataflow.</p><p>While <code>DataFlow</code> and <code>Context</code> may appear very similar, they are not the same: contexts are elements that keep track of declared slots, while the dataflow make use of the context to weave the elements togeher.</p></div></div><div id='d_le' class='de'><h1>Method <span class='n'>getOperator</span></h1><div class='re'><code>getOperator( self )</code></div><div class='ds'><p>Gets the operator for this computation</p></div></div><div id='d_ld' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><p>Returns the local name for this referencable element</p></div></div><div id='Fv' class='cr'><div class='n'><a href='javascript:dS("Fv");'>Behaviour</a></div><div class='t'>Bases</div class='t'><div class='g'><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("Fv","Gv");'><span class='special __bases__'>TypeCollection</span></a></span><br /></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Fv","Hv");'>getType</a></span><br /></div></div><div id='Fy' class='cr'><div class='n'><a href='javascript:dS("Fy");'>SemanticError</a></div><div class='t'>Inhertied Values</div class='t'><div class='g'><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("Fy","zt");'><span class='special __getitem__'>get item</span></a></span><br /><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("Fy","Ft");'><span class='special __init__'>constructor</span></a></span><br /><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("Fy","At");'><span class='special __repr__'>string repr</span></a></span><br /><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("Fy","Bt");'><span class='special __str__'>string conversion</span></a></span><br /><span class='u'><span class='prefix'>&sdot;</span><a href='javascript:dO("Fy","Ct");'>args</a></span><br /><span class='d'><span class='prefix'>&sdot;</span><a href='javascript:dO("Fy","Dt");'>message</a></span><br /></div></div><div id='Yo' class='cr'><div class='n'><a href='javascript:dS("Yo");'>IOperation</a></div><div class='t'>Bases</div class='t'><div class='g'><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("Yo","Zo");'><span class='special __bases__'>IElement</span></a></span><br /></div><div class='t'>Methods</div class='t'><div class='g'><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Yo","ap");'>addOpArgument</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Yo","bp");'>getOpArgument</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Yo","cp");'>getOpArguments</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Yo","dp");'>getOpArgumentsInternalTypes</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Yo","ep");'>setOpArgument</a></span><br /></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Yo","fp");'>getAbstractType</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Yo","gp");'>getAnnotation</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Yo","hp");'>getDataFlow</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Yo","ip");'>setAbstractType</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Yo","jp");'>setAnnotation</a></span><br /></div></div><div id='Ye' class='cr'><div class='n'><a href='javascript:dS("Ye");'>IContext</a></div><div class='t'>Bases</div class='t'><div class='g'><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("Ye","Ze");'><span class='special __bases__'>IElement, IDataFlowOwner</span></a></span><br /></div><div class='t'>Methods</div class='t'><div class='g'><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Ye","af");'>getParent</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Ye","bf");'>getSlot</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Ye","cf");'>getSlots</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Ye","df");'>hasSlot</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Ye","ef");'>setParent</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Ye","ff");'>setSlot</a></span><br /></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Ye","gf");'>getAbstractType</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Ye","hf");'>getAnnotation</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Ye","if");'>getDataFlow</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Ye","jf");'>setAbstractType</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Ye","kf");'>setAnnotation</a></span><br /></div></div><div id='Yr' class='cr'><div class='n'><a href='javascript:dS("Yr");'>ITermination</a></div><div class='t'>Bases</div class='t'><div class='g'><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("Yr","Zr");'><span class='special __bases__'>IOperation</span></a></span><br /></div><div class='t'>Methods</div class='t'><div class='g'><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Yr","as");'>getReturnedEvaluable</a></span><br /></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Yr","bs");'>addOpArgument</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Yr","cs");'>getAbstractType</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Yr","ds");'>getAnnotation</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Yr","es");'>getDataFlow</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Yr","fs");'>getOpArgument</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Yr","gs");'>getOpArguments</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Yr","hs");'>getOpArgumentsInternalTypes</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Yr","is");'>setAbstractType</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Yr","js");'>setAnnotation</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Yr","ks");'>setOpArgument</a></span><br /></div><div class='t'>Values</div class='t'><div class='g'><span class='d'><span class='prefix'>&bull;</span><a href='javascript:dO("Yr","ls");'>ARGS</a></span><br /></div></div><div id='d_Re' class='de'><h1>Method <span class='n'>isAbstract</span></h1><div class='re'><code>isAbstract( self )</code></div><div class='ds'><p>Tells wether the given abstractable is abstract or not.</p></div></div><div id='d_Rd' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_Rg' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><p>Adds an argument to this operation. This should do checking of arguments (by expected internal type and number).</p></div></div><div id='d_Rf' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns the parent context for this context (if any)</p></div></div><div id='d_Rc' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><p>Returns this class name. It can be <code>None</code> if the class is anonymous.</p></div></div><div id='d_Rb' class='de'><h1>Method <span class='n'>getAbsoluteName</span></h1><div class='re'><code>getAbsoluteName( self )</code></div><div class='ds'><p>Returns the absolute name for this element</p></div></div><div id='d_Rm' class='de'><h1>Method <span class='n'>getResultAbstractType</span></h1><div class='re'><code>getResultAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type of the result of the evaluation of this evaluable</p></div></div><div id='d_Rl' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_Ro' class='de'><h1>Method <span class='n'>getActualValue</span></h1><div class='re'><code>getActualValue( self )</code></div><div class='ds'><p>Returns the (implementation language) value for this literal</p></div></div><div id='d_Rn' class='de'><h1>Class <span class='n'>IMethod</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Ri' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.IEvaluable at 0x5bf3f0&gt;, &lt;class lambdafactory.interfaces.IEvaluable at 0x5bf3f0&gt;]</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='d_Rh' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><p>Adds an argument to this operation. This should do checking of arguments (by expected internal type and number).</p></div></div><div id='d_Rk' class='de'><h1>Method <span class='n'>getIntercept</span></h1><div class='re'><code>getIntercept( self )</code></div><div class='ds'><p>Returns the process that will do the interception</p></div></div><div id='d_Rj' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_Ru' class='de'><h1>Method <span class='n'>writeNumber</span></h1><div class='re'><code>writeNumber( self, number )</code></div><div class='ds'><p>Writes a number element.</p></div></div><div id='d_Rt' class='de'><h1>Method <span class='n'>getCurrentClassParents</span></h1><div class='re'><code>getCurrentClassParents( self, theClass=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Rw' class='de'><h1>Method <span class='n'>asString</span></h1><div class='re'><code>asString( self, fromType=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Rv' class='de'><h1>Class <span class='n'>Structure</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Rq' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><p>Adds an argument to this operation. This should do checking of arguments (by expected internal type and number).</p></div></div><div id='d_Rp' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, context )</code></div><div class='ds'><p>Sets the parent context for this context.</p></div></div><div id='d_Rs' class='de'><h1>Method <span class='n'>createBlock</span></h1><div class='re'><code>createBlock( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Rr' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_Ry' class='de'><h1>Method <span class='n'>__call__</span></h1><div class='re'><code>__call__( self )</code></div><div class='ds'><p>A type instance can be used as a class to construct a new type, which will be cloned from the current type.</p></div></div><div id='d_Rx' class='de'><h1>Method <span class='n'>clone</span></h1><div class='re'><code>clone( self, clone=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Rz' class='de'><h1>Method <span class='n'>isLike</span></h1><div class='re'><code>isLike( self, otherType )</code></div><div class='ds'><p>Generic implementation of isLike. You should always call this method in subclasses, as it implements basic type systems rules such as isLike(Any).</p></div></div><div id='d_RA' class='de'><h1>Method <span class='n'>getHandle</span></h1><div class='re'><code>getHandle( self, element )</code></div><div class='ds'><p>Tells if the pass handles the given element. This basically iterates on the <code>handles</code> property values (which are interfaces), when one interface matches the given <code>element</code>, then the corresponding <code>onXXX</code> method is invoked, where <code>XXX</code> is the interface name (without the leading <code>I</code>).</p></div></div><div id='lf' class='cr'><div class='n'><a href='javascript:dS("lf");'>IDataFlow</a></div><div class='t'>Bases</div class='t'><div class='g'><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("lf","c");'><span class='special __bases__'><i>Base class</i></span></a></span><br /></div><div class='t'>Methods</div class='t'><div class='g'><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("lf","mf");'>addChild</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("lf","nf");'>addParent</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("lf","of");'>declareArgument</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("lf","pf");'>declareEnvironment</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("lf","qf");'>declareVariable</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("lf","rf");'>defines</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("lf","sf");'>getChildren</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("lf","tf");'>getParents</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("lf","uf");'>getSlot</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("lf","vf");'>getSlots</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("lf","wf");'>hasSlot</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("lf","xf");'>resolve</a></span><br /></div></div><div id='lm' class='cr'><div class='n'><a href='javascript:dS("lm");'>IIteration</a></div><div class='t'>Bases</div class='t'><div class='g'><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("lm","mm");'><span class='special __bases__'>IOperation</span></a></span><br /></div><div class='t'>Methods</div class='t'><div class='g'><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("lm","nm");'>getClosure</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("lm","om");'>getIterator</a></span><br /></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("lm","pm");'>addOpArgument</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("lm","qm");'>getAbstractType</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("lm","rm");'>getAnnotation</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("lm","sm");'>getDataFlow</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("lm","tm");'>getOpArgument</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("lm","um");'>getOpArguments</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("lm","vm");'>getOpArgumentsInternalTypes</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("lm","wm");'>setAbstractType</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("lm","xm");'>setAnnotation</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("lm","ym");'>setOpArgument</a></span><br /></div><div class='t'>Values</div class='t'><div class='g'><span class='d'><span class='prefix'>&bull;</span><a href='javascript:dO("lm","zm");'>ARGS</a></span><br /></div></div><div id='d_ax' class='de'><h1>Method <span class='n'>definedBy</span></h1><div class='re'><code>definedBy( self, definition=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_of' class='de'><h1>Method <span class='n'>declareArgument</span></h1><div class='re'><code>declareArgument( self, name, value )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_og' class='de'><h1>Class <span class='n'>IDocumentation</span></h1><div class='re'></div><div class='ds'><p>Documentation is often attached to various language elements. Documentation can be found in coments (as in Java), or be directly embedded as values (as in Python).</p></div></div><div id='d_od' class='de'><h1>Class <span class='n'>IClassMethod</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_oe' class='de'><h1>Method <span class='n'>setOperator</span></h1><div class='re'><code>setOperator( self, operator )</code></div><div class='ds'><p>Sets the operator for this computation</p></div></div><div id='d_ob' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.IEvaluable at 0x5bf3f0&gt;, &lt;class lambdafactory.interfaces.IEvaluable at 0x5bf3f0&gt;]</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='d_oc' class='de'><h1>Method <span class='n'>getAbsoluteName</span></h1><div class='re'><code>getAbsoluteName( self )</code></div><div class='ds'><p>Returns the absolute name for this element</p></div></div><div id='d_on' class='de'><h1>Method <span class='n'>getPredicate</span></h1><div class='re'><code>getPredicate( self )</code></div><div class='ds'><p>Returns the evaluable that acts as a predicate for this operation.</p></div></div><div id='d_oo' class='de'><h1>Class <span class='n'>IModule</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_ol' class='de'><h1>Method <span class='n'>getClassMethods</span></h1><div class='re'><code>getClassMethods( self )</code></div><div class='ds'><p>Returns the class method defined within this class.</p></div></div><div id='d_om' class='de'><h1>Method <span class='n'>getIterator</span></h1><div class='re'><code>getIterator( self )</code></div><div class='ds'><p>Returns this iteration iterator.</p></div></div><div id='d_oj' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><p>Returns the ith arguments to this operation.</p></div></div><div id='d_ok' class='de'><h1>Method <span class='n'>getSlots</span></h1><div class='re'><code>getSlots( self )</code></div><div class='ds'><p>Returns (key, evaluable) pairs representing the slots within this context.</p></div></div><div id='d_oh' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_oi' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns the parent context for this context (if any)</p></div></div><div id='d_ov' class='de'><h1>Method <span class='n'>getCurrentModule</span></h1><div class='re'><code>getCurrentModule( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_ow' class='de'><h1>Method <span class='n'>isSubtypeOf</span></h1><div class='re'><code>isSubtypeOf( self, otherType )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_ot' class='de'><h1>Method <span class='n'>invoke</span></h1><div class='re'><code>invoke( self, evaluable, *arguments )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_ou' class='de'><h1>Method <span class='n'>start</span></h1><div class='re'><code>start( self )</code></div><div class='ds'><p>Callback invoked when a <code>fromXXX</code> method is invoked.</p></div></div><div id='d_or' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_os' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_op' class='de'><h1>Method <span class='n'>getAbsoluteName</span></h1><div class='re'><code>getAbsoluteName( self )</code></div><div class='ds'><p>Returns the absolute name for this element</p></div></div><div id='d_oq' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_oz' class='de'><h1>Method <span class='n'>result</span></h1><div class='re'><code>result( self )</code></div><div class='ds'><p>Returns the result for this type. This is usually just the type itself, except for processes types.</p></div></div><div id='d_ox' class='de'><h1>Method <span class='n'>parent</span></h1><div class='re'><code>parent( self, parent=None )</code></div><div class='ds'><p>Returns the main parent for this context.</p></div></div><div id='d_oy' class='de'><h1>Method <span class='n'>arguments</span></h1><div class='re'><code>arguments( self, args=None )</code></div><div class='ds'><p>Returns the arguments of this process encapsulated in a sequence if there is more than one argument.</p></div></div><div id='d_oA' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.passes.Pass at 0x1147b70&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_qx' class='de'><h1>Method <span class='n'>__call__</span></h1><div class='re'><code>__call__( self )</code></div><div class='ds'><p>A type instance can be used as a class to construct a new type, which will be cloned from the current type.</p></div></div><div id='d_qy' class='de'><h1>Method <span class='n'>clone</span></h1><div class='re'><code>clone( self, clone=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_qz' class='de'><h1>Method <span class='n'>setName</span></h1><div class='re'><code>setName( self, name )</code></div><div class='ds'><p>Sets the name of this type</p></div></div><div id='d_qt' class='de'><h1>Method <span class='n'>matchExpression</span></h1><div class='re'><code>matchExpression( self, evaluable, expression )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_qu' class='de'><h1>Class <span class='n'>Writer</span></h1><div class='re'></div><div class='ds'><p>This is the default writer implementation that outputs a text-based program representation. You can call the main @write method to get the representatio of any model element.</p></div></div><div id='d_qv' class='de'><h1>Method <span class='n'>isInClassMethod</span></h1><div class='re'><code>isInClassMethod( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_qw' class='de'><h1>Method <span class='n'>name</span></h1><div class='re'><code>name( self, name=None )</code></div><div class='ds'><p>Returns/sets the name for this type. By defaults, types are unnamed.</p></div></div><div id='d_qp' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_qq' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_qr' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><p>Sets the given argument of this operation, by argument index.</p></div></div><div id='d_qs' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_ql' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_qm' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_qn' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><p>Adds an argument to this operation. This should do checking of arguments (by expected internal type and number).</p></div></div><div id='d_qo' class='de'><h1>Method <span class='n'>addImportOperation</span></h1><div class='re'><code>addImportOperation( self, operation )</code></div><div class='ds'><p>Returns the list of import operations declared in this module</p></div></div><div id='d_qh' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><p>Returns the arguments to this operation.</p></div></div><div id='d_qi' class='de'><h1>Method <span class='n'>getSlots</span></h1><div class='re'><code>getSlots( self )</code></div><div class='ds'><p>Returns (key, evaluable) pairs representing the slots within this context.</p></div></div><div id='d_qj' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><p>Returns the <em>internal types</em> for this operations arguments. This is typically the list of interfaces or @protocols that the arguments must comply to.</p></div></div><div id='d_qk' class='de'><h1>Method <span class='n'>hasSlot</span></h1><div class='re'><code>hasSlot( self, name )</code></div><div class='ds'><p>Tells if the context has a slot with the given name.</p></div></div><div id='d_qd' class='de'><h1>Method <span class='n'>addOperation</span></h1><div class='re'><code>addOperation( self, operation )</code></div><div class='ds'><p>Adds the given operation as a child of this process.</p></div></div><div id='d_qe' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><p>Adds an argument to this operation. This should do checking of arguments (by expected internal type and number).</p></div></div><div id='d_qf' class='de'><h1>Method <span class='n'>declareVariable</span></h1><div class='re'><code>declareVariable( self, name, value, origin=None )</code></div><div class='ds'><p>Declares a (local) variable with the given name, value and origin</p></div></div><div id='d_qg' class='de'><h1>Method <span class='n'>getContent</span></h1><div class='re'><code>getContent( self )</code></div><div class='ds'><p>Returns the content of this annotation.</p></div></div><div id='d_qb' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IOperation at 0x5bfa50&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_qc' class='de'><h1>Method <span class='n'>getTypeDescription</span></h1><div class='re'><code>getTypeDescription( self )</code></div><div class='ds'><p>Returns type information (constraints) that are associated to this argument.</p></div></div><div id='d_qA' class='de'><h1>Method <span class='n'>onModule</span></h1><div class='re'><code>onModule( self, context, module )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Ub' class='de'><h1>Class <span class='n'>IAssignable</span></h1><div class='re'></div><div class='ds'><p>Assignable elements are elements that can be bound to slots. In many languages, only a subset of elements can be assigned. For instance, in Java, you cannot assign a package to something:</p><pre>  Object my_package = java.lang.Object</pre><p>while in some other languages (like JavaScript), you could do that.</p></div></div><div id='d_Uc' class='de'><h1>Method <span class='n'>setParentClasses</span></h1><div class='re'><code>setParentClasses( self )</code></div><div class='ds'><p>gives the list of parent classes that will</p></div></div><div id='d_Ud' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns the parent context for this context (if any)</p></div></div><div id='d_Ue' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_Uf' class='de'><h1>Method <span class='n'>hasExplicitTermination</span></h1><div class='re'><code>hasExplicitTermination( self )</code></div><div class='ds'><p>Returns true if this function has an operation with a termination, otherwise return false.</p></div></div><div id='d_Ug' class='de'><h1>Method <span class='n'>getCode</span></h1><div class='re'><code>getCode( self )</code></div><div class='ds'><p>Returns the embedded code string.</p></div></div><div id='d_Uh' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_Ui' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IImportOperation at 0x5bfa80&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Uj' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><p>Returns the arguments to this operation.</p></div></div><div id='d_Uk' class='de'><h1>Method <span class='n'>setIntercept</span></h1><div class='re'><code>setIntercept( self, process )</code></div><div class='ds'><p>Sets the process that will do the interception</p></div></div><div id='d_Ul' class='de'><h1>Class <span class='n'>IInvocable</span></h1><div class='re'></div><div class='ds'><p>An invocable can be used in an invocation operation.</p></div></div><div id='d_Um' class='de'><h1>Method <span class='n'>setResultAbstractType</span></h1><div class='re'><code>setResultAbstractType( self, abstractType )</code></div><div class='ds'><p>Sets the abstract type for this operation result. This is usually invoked in the typing phase.</p></div></div><div id='d_Un' class='de'><h1>Method <span class='n'>endsWithTermination</span></h1><div class='re'><code>endsWithTermination( self )</code></div><div class='ds'><p>Returns true if this function ends with a termination operation. This is especially useful for back-ends which want to know if they have to insert an explicit <code>return</code> at the end (like Java).</p></div></div><div id='d_Uo' class='de'><h1>Method <span class='n'>getResultAbstractType</span></h1><div class='re'><code>getResultAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type of the result of the evaluation of this evaluable</p></div></div><div id='d_Up' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IAssignable at 0x5bf390&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Uq' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_Ur' class='de'><h1>Class <span class='n'>ISyntactic</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Us' class='de'><h1>Method <span class='n'>createClosure</span></h1><div class='re'><code>createClosure( self, arguments )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Ut' class='de'><h1>Method <span class='n'>getCurrentDataFlow</span></h1><div class='re'><code>getCurrentDataFlow( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Uu' class='de'><h1>Method <span class='n'>writeRepetition</span></h1><div class='re'><code>writeRepetition( self, repetition )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Uv' class='de'><h1>Class <span class='n'>TypeCollection</span></h1><div class='re'></div><div class='ds'><p>A type collection is a class that contains type definitions which can be easily retrieved using the @getType method.</p></div></div><div id='d_Uw' class='de'><h1>Method <span class='n'>isSameAs</span></h1><div class='re'><code>isSameAs( self, otherType )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Ux' class='de'><h1>Method <span class='n'>elements</span></h1><div class='re'><code>elements( self )</code></div><div class='ds'><p>Returns a dict of the elements in this map. Do not modify it.</p></div></div><div id='d_Uy' class='de'><h1>Method <span class='n'>concreteType</span></h1><div class='re'><code>concreteType( self )</code></div><div class='ds'><p>Returns the <span class='term'>concrete type</span> for this abstract type.</p></div></div><div id='d_Uz' class='de'><h1>Method <span class='n'>name</span></h1><div class='re'><code>name( self, name=None )</code></div><div class='ds'><p>Returns/sets the name for this type. By defaults, types are unnamed.</p></div></div><div id='d_UA' class='de'><h1>Module <span class='n'>lambdafactory.reporter</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_CA' class='de'><h1>Method <span class='n'>filterContext</span></h1><div class='re'><code>filterContext( self, interface )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Cj' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_Ck' class='de'><h1>Method <span class='n'>getInstanciable</span></h1><div class='re'><code>getInstanciable( self )</code></div><div class='ds'><p>Returns the instanciable used in this operation.</p></div></div><div id='d_Ch' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><p>Adds an argument to this operation. This should do checking of arguments (by expected internal type and number).</p></div></div><div id='d_Ci' class='de'><h1>Method <span class='n'>getOperations</span></h1><div class='re'><code>getOperations( self )</code></div><div class='ds'><p>Returns the list of operations in this process.</p></div></div><div id='d_Cn' class='de'><h1>Method <span class='n'>getProcess</span></h1><div class='re'><code>getProcess( self )</code></div><div class='ds'><p>Returns the process that will be executed if the rule matches.</p></div></div><div id='d_Co' class='de'><h1>Method <span class='n'>hasSlot</span></h1><div class='re'><code>hasSlot( self, name )</code></div><div class='ds'><p>Tells if the context has a slot with the given name.</p></div></div><div id='d_Cl' class='de'><h1>Method <span class='n'>setAbstract</span></h1><div class='re'><code>setAbstract( self, isAbstract )</code></div><div class='ds'><p>Sets wether the given abstractable is abstract or not.</p></div></div><div id='d_Cm' class='de'><h1>Method <span class='n'>addValue</span></h1><div class='re'><code>addValue( self, value )</code></div><div class='ds'><p>Adds a value to this list.</p></div></div><div id='d_Cb' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><p>Sets the given argument of this operation, by argument index.</p></div></div><div id='d_Cc' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><p>Returns the arguments to this operation.</p></div></div><div id='d_Cf' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Cg' class='de'><h1>Method <span class='n'>setCode</span></h1><div class='re'><code>setCode( self, code )</code></div><div class='ds'><p>Sets the code of this embed operation.</p></div></div><div id='d_Cd' class='de'><h1>Method <span class='n'>hasExplicitTermination</span></h1><div class='re'><code>hasExplicitTermination( self )</code></div><div class='ds'><p>Returns true if this function has an operation with a termination, otherwise return false.</p></div></div><div id='d_Ce' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IMethod at 0x5bf960&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Cz' class='de'><h1>Method <span class='n'>isSubtypeOf</span></h1><div class='re'><code>isSubtypeOf( self, otherType )</code></div><div class='ds'><p>Generic implementation of isSubtypeOf. You should always call this method in subclasses, as it implements basic type systems rules such as isSubtypeOf(Any).</p></div></div><div id='d_Cx' class='de'><h1>Method <span class='n'>result</span></h1><div class='re'><code>result( self )</code></div><div class='ds'><p>Returns the result for this type. This is usually just the type itself, except for processes types.</p></div></div><div id='d_Cy' class='de'><h1>Method <span class='n'>setConcreteType</span></h1><div class='re'><code>setConcreteType( self, value )</code></div><div class='ds'><p>Sets the <span class='term'>concrete type</span> for this abstract type. The concrete type is a value which represents the type. For instance, if this type represents a class, then the concrete type would be the class instance.</p></div></div><div id='d_Cr' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_Cs' class='de'><h1>Method <span class='n'>_getImplementation</span></h1><div class='re'><code>_getImplementation( self, name )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Cp' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IContext at 0x5bf750&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Cq' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><p>Adds an argument to this operation. This should do checking of arguments (by expected internal type and number).</p></div></div><div id='d_Cv' class='de'><h1>str</h1><div class='re'><code>']---'</code></div><div class='ds'><p>str(object) -&gt; string</p><p>Return a nice string representation of the object. If the argument is a string, the return value is the same object.</p></div></div><div id='d_Cw' class='de'><h1>Method <span class='n'>isSubtypeOf</span></h1><div class='re'><code>isSubtypeOf( self, otherType )</code></div><div class='ds'><p>Othertype must be an Array with a content type that is a subtype of this content type.</p></div></div><div id='d_Ct' class='de'><h1>getset_descriptor</h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Cu' class='de'><h1>Method <span class='n'>writeConstructor</span></h1><div class='re'><code>writeConstructor( self, element )</code></div><div class='ds'><p>Writes a method element.</p></div></div><div id='qu' class='cr'><div class='n'><a href='javascript:dS("qu");'>Writer</a></div><div class='t'>Bases</div class='t'><div class='g'><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("qu","ru");'><span class='special __bases__'>AbstractWriter</span></a></span><br /></div><div class='t'>Methods</div class='t'><div class='g'><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("qu","su");'>writeAllocation</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("qu","tu");'>writeArgument</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("qu","uu");'>writeAssignation</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("qu","vu");'>writeAttribute</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("qu","wu");'>writeBlock</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("qu","xu");'>writeClass</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("qu","yu");'>writeClassAttribute</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("qu","zu");'>writeClassMethod</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("qu","Au");'>writeClosure</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("qu","Bu");'>writeComputation</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("qu","Cu");'>writeConstructor</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("qu","Du");'>writeDestructor</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("qu","Eu");'>writeDict</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("qu","Fu");'>writeEnumeration</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("qu","Gu");'>writeEvaluation</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("qu","Hu");'>writeFunction</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("qu","Iu");'>writeImportModuleOperation</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("qu","Ju");'>writeImportModulesOperation</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("qu","Ku");'>writeImportSymbolOperation</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("qu","Lu");'>writeImportSymbolsOperation</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("qu","Mu");'>writeInvocation</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("qu","Nu");'>writeIteration</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("qu","Ou");'>writeList</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("qu","Pu");'>writeMethod</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("qu","Qu");'>writeModule</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("qu","Ru");'>writeNumber</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("qu","Su");'>writeOperator</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("qu","Tu");'>writeReference</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("qu","Uu");'>writeRepetition</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("qu","Vu");'>writeResolution</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("qu","Wu");'>writeSelection</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("qu","Xu");'>writeSliceOperation</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("qu","Yu");'>writeString</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("qu","Zu");'>writeTermination</a></span><br /></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><span class='u'><span class='prefix'>&equiv;</span><a href='javascript:dO("qu","av");'><span class='special __init__'>constructor</span></a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("qu","bv");'>_document</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("qu","cv");'>_filterContext</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("qu","dv");'>_format</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("qu","ev");'>_getContextsAsString</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("qu","fv");'>_unique</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("qu","gv");'>getCurrentClass</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("qu","hv");'>getCurrentClassAncestors</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("qu","iv");'>getCurrentClassParents</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("qu","jv");'>getCurrentClosure</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("qu","kv");'>getCurrentContext</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("qu","lv");'>getCurrentDataFlow</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("qu","mv");'>getCurrentFunction</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("qu","nv");'>getCurrentMethod</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("qu","ov");'>getCurrentModule</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("qu","pv");'>isIn</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("qu","qv");'>isInClassMethod</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("qu","rv");'>isInInstanceMethod</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("qu","sv");'>resolve</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("qu","tv");'>resolveAbsoluteOrLocal</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("qu","uv");'>write</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("qu","vv");'>writeProgram</a></span><br /></div><div class='t'>Inhertied Values</div class='t'><div class='g'><span class='d'><span class='prefix'>&bull;</span><a href='javascript:dO("qu","fu");'>INTERFACES</a></span><br /><span class='d'><span class='prefix'>&bull;</span><a href='javascript:dO("qu","gu");'>SNIP</a></span><br /></div></div><div id='Pg' class='cr'><div class='n'><a href='javascript:dS("Pg");'>IEmbedTemplate</a></div><div class='t'>Bases</div class='t'><div class='g'><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("Pg","Qg");'><span class='special __bases__'>IEmbed</span></a></span><br /></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Pg","Rg");'>addOpArgument</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Pg","Sg");'>getAbstractType</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Pg","Tg");'>getAnnotation</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Pg","Ug");'>getCode</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Pg","Vg");'>getDataFlow</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Pg","Wg");'>getLanguage</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Pg","Xg");'>getOpArgument</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Pg","Yg");'>getOpArguments</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Pg","Zg");'>getOpArgumentsInternalTypes</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Pg","ah");'>setAbstractType</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Pg","bh");'>setAnnotation</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Pg","ch");'>setCode</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Pg","dh");'>setLanguage</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Pg","eh");'>setOpArgument</a></span><br /></div><div class='t'>Inhertied Values</div class='t'><div class='g'><span class='d'><span class='prefix'>&bull;</span><a href='javascript:dO("Pg","Og");'>ARGS</a></span><br /></div></div><div id='ci' class='cr'><div class='n'><a href='javascript:dS("ci");'>IFunction</a></div><div class='t'>Bases</div class='t'><div class='g'><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("ci","di");'><span class='special __bases__'>IClosure, IReferencable, IAbstractable</span></a></span><br /></div><div class='t'>Methods</div class='t'><div class='g'><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("ci","ei");'>endsWithTermination</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("ci","fi");'>getName</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("ci","gi");'>hasExplicitTermination</a></span><br /></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("ci","hi");'>addOperation</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("ci","ii");'>getAbsoluteName</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("ci","ji");'>getAbstractType</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("ci","ki");'>getAnnotation</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("ci","li");'>getArguments</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("ci","mi");'>getDataFlow</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("ci","ni");'>getOperations</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("ci","oi");'>getParent</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("ci","pi");'>getSlot</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("ci","qi");'>getSlots</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("ci","ri");'>hasSlot</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("ci","si");'>isAbstract</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("ci","ti");'>setAbstract</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("ci","ui");'>setAbstractType</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("ci","vi");'>setAnnotation</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("ci","wi");'>setArguments</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("ci","xi");'>setParent</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("ci","yi");'>setSlot</a></span><br /></div></div><div id='d_pz' class='de'><h1>Method <span class='n'>setConcreteType</span></h1><div class='re'><code>setConcreteType( self, value )</code></div><div class='ds'><p>Sets the <span class='term'>concrete type</span> for this abstract type. The concrete type is a value which represents the type. For instance, if this type represents a class, then the concrete type would be the class instance.</p></div></div><div id='d_py' class='de'><h1>Method <span class='n'>asString</span></h1><div class='re'><code>asString( self, fromTypes=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_px' class='de'><h1>Method <span class='n'>parents</span></h1><div class='re'><code>parents( self )</code></div><div class='ds'><p>Returns a context parents, as a mutable list.</p></div></div><div id='d_pw' class='de'><h1>Method <span class='n'>length</span></h1><div class='re'><code>length( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_pv' class='de'><h1>Method <span class='n'>isIn</span></h1><div class='re'><code>isIn( self, interface )</code></div><div class='ds'><p>Tells wether the current element is in a context where at least one of the parent elements define the given interface. It returns <code>-1</code> when no element implements the interface, and otherwise returns the offset of the element, starting from the most recent context.</p><p>To know if you're currently in an assignation: <pre>self.isIn(interfaces.IAssignation)
</pre></p></div></div><div id='d_pu' class='de'><h1>Method <span class='n'>writeLine</span></h1><div class='re'><code>writeLine( self, line )</code></div><div class='ds'><p>Writes the given line to the current file.</p></div></div><div id='d_pt' class='de'><h1>Method <span class='n'>iterate</span></h1><div class='re'><code>iterate( self, evaluable, process )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_ps' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_pr' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='ce' class='cr'><div class='n'><a href='javascript:dS("ce");'>IComment</a></div><div class='t'>Bases</div class='t'><div class='g'><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("ce","de");'><span class='special __bases__'>IAnnotation</span></a></span><br /></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("ce","ee");'>getContent</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("ce","fe");'>getName</a></span><br /></div></div><div id='d_pp' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_po' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IContext at 0x5bf750&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_pn' class='de'><h1>Method <span class='n'>setPredicate</span></h1><div class='re'><code>setPredicate( self, v )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_pm' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><p>Adds an argument to this operation. This should do checking of arguments (by expected internal type and number).</p></div></div><div id='d_pl' class='de'><h1>Method <span class='n'>getConstructors</span></h1><div class='re'><code>getConstructors( self )</code></div><div class='ds'><p>Returns the constructors for this class</p></div></div><div id='d_pk' class='de'><h1>Method <span class='n'>hasExplicitTermination</span></h1><div class='re'><code>hasExplicitTermination( self )</code></div><div class='ds'><p>Returns true if this function has an operation with a termination, otherwise return false.</p></div></div><div id='d_pj' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><p>Returns the arguments to this operation.</p></div></div><div id='d_pi' class='de'><h1>Method <span class='n'>getSlot</span></h1><div class='re'><code>getSlot( self, name )</code></div><div class='ds'><p>Returns the given evaluable bound to named slot.</p></div></div><div id='d_ph' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><p>Returns the ith arguments to this operation.</p></div></div><div id='d_pg' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IAnnotation at 0x5bf210&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_pf' class='de'><h1>Method <span class='n'>declareEnvironment</span></h1><div class='re'><code>declareEnvironment( self, name, value )</code></div><div class='ds'><p>Declares an environment variable with the given name, value and origin.</p></div></div><div id='d_pe' class='de'><h1>Method <span class='n'>setRightOperand</span></h1><div class='re'><code>setRightOperand( self, operand )</code></div><div class='ds'><p>Sets the right operand of this computation</p></div></div><div id='d_pd' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IMethod at 0x5bf960&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_pc' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><p>Returns the local name for this referencable element</p></div></div><div id='d_pb' class='de'><h1>Class <span class='n'>IAllocation</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_pA' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_nc' class='de'><h1>Method <span class='n'>setDefaultValue</span></h1><div class='re'><code>setDefaultValue( self )</code></div><div class='ds'><p>Sets the @methodault value for this attribute</p></div></div><div id='d_nb' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><p>Sets the given argument of this operation, by argument index.</p></div></div><div id='d_ne' class='de'><h1>Method <span class='n'>setLeftOperand</span></h1><div class='re'><code>setLeftOperand( self, operand )</code></div><div class='ds'><p>Sets the left operand of this computation.</p></div></div><div id='d_nd' class='de'><h1>Method <span class='n'>setDefaultValue</span></h1><div class='re'><code>setDefaultValue( self )</code></div><div class='ds'><p>Sets the @methodault value for this attribute</p></div></div><div id='d_ng' class='de'><h1>Method <span class='n'>setResultAbstractType</span></h1><div class='re'><code>setResultAbstractType( self, abstractType )</code></div><div class='ds'><p>Sets the abstract type for this operation result. This is usually invoked in the typing phase.</p></div></div><div id='d_nf' class='de'><h1>Method <span class='n'>addParent</span></h1><div class='re'><code>addParent( self, parent )</code></div><div class='ds'><p>Add the given dataflow as a parent of this dataflow.</p></div></div><div id='d_ni' class='de'><h1>Method <span class='n'>getOperations</span></h1><div class='re'><code>getOperations( self )</code></div><div class='ds'><p>Returns the list of operations in this process.</p></div></div><div id='d_nh' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_nk' class='de'><h1>Method <span class='n'>getSlot</span></h1><div class='re'><code>getSlot( self, name )</code></div><div class='ds'><p>Returns the given evaluable bound to named slot.</p></div></div><div id='d_nj' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_nm' class='de'><h1>Method <span class='n'>getClosure</span></h1><div class='re'><code>getClosure( self )</code></div><div class='ds'><p>Returns the closure that will be applied to the iterator.</p></div></div><div id='d_nl' class='de'><h1>Method <span class='n'>getClassAttributes</span></h1><div class='re'><code>getClassAttributes( self )</code></div><div class='ds'><p>Returns the class attributes defined within this class.</p></div></div><div id='d_no' class='de'><h1>Method <span class='n'>setSlot</span></h1><div class='re'><code>setSlot( self, name, evaluable )</code></div><div class='ds'><p>Binds the given evaluable to the named slot.</p></div></div><div id='d_nn' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IOperation at 0x5bfa50&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_nq' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><p>Adds an argument to this operation. This should do checking of arguments (by expected internal type and number).</p></div></div><div id='d_np' class='de'><h1>Method <span class='n'>setPriority</span></h1><div class='re'><code>setPriority( self, priority )</code></div><div class='ds'><p>Sets the priority for this operator</p></div></div><div id='d_ns' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IElement at 0x5bf360&gt;, &lt;class lambdafactory.interfaces.IEvaluable at 0x5bf3f0&gt;)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_nr' class='de'><h1>Method <span class='n'>getTarget</span></h1><div class='re'><code>getTarget( self )</code></div><div class='ds'><p>Returns the operation target.</p></div></div><div id='d_nu' class='de'><h1>Method <span class='n'>newFile</span></h1><div class='re'><code>newFile( self, path )</code></div><div class='ds'><p>Callback invoked by a <code>fromXXX</code> method, indicating that the lines should be written to a file.</p></div></div><div id='d_nt' class='de'><h1>Method <span class='n'>intercept</span></h1><div class='re'><code>intercept( self, tryProcess, catchProcess=None, finallyProcess=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_nw' class='de'><h1>Method <span class='n'>isSameAs</span></h1><div class='re'><code>isSameAs( self, otherType )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_nv' class='de'><h1>Method <span class='n'>getCurrentMethod</span></h1><div class='re'><code>getCurrentMethod( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_ny' class='de'><h1>Method <span class='n'>add</span></h1><div class='re'><code>add( self, theType )</code></div><div class='ds'><p>Adds the given type as an element to this process. The last added type becomes the result if one type was already added, the argument otherwise.</p></div></div><div id='d_nx' class='de'><h1>Method <span class='n'>fullName</span></h1><div class='re'><code>fullName( self )</code></div><div class='ds'><p>Returns the fully qualified name for this context, by concateniating the chain of parents name with <code>.</code></p></div></div><div id='d_nz' class='de'><h1>Method <span class='n'>name</span></h1><div class='re'><code>name( self, name=None )</code></div><div class='ds'><p>Returns/sets the name for this type. By defaults, types are unnamed.</p></div></div><div id='d_nA' class='de'><h1>Class <span class='n'>ImportationPass</span></h1><div class='re'></div><div class='ds'><p>The importation pass will look for importation operations (<code>IImportation</code>), will try to resolve the importations (according to the current environment) and will trigger the loading and parsing of each module into the current program.</p></div></div><div id='vc' class='cr'><div class='n'><a href='javascript:dS("vc");'>IBreaking</a></div><div class='t'>Bases</div class='t'><div class='g'><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("vc","wc");'><span class='special __bases__'>IInterruption</span></a></span><br /></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("vc","xc");'>addOpArgument</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("vc","yc");'>getAbstractType</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("vc","zc");'>getAnnotation</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("vc","Ac");'>getDataFlow</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("vc","Bc");'>getOpArgument</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("vc","Cc");'>getOpArguments</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("vc","Dc");'>getOpArgumentsInternalTypes</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("vc","Ec");'>setAbstractType</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("vc","Fc");'>setAnnotation</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("vc","Gc");'>setOpArgument</a></span><br /></div><div class='t'>Values</div class='t'><div class='g'><span class='d'><span class='prefix'>&bull;</span><a href='javascript:dO("vc","Hc");'>ARGS</a></span><br /></div></div><div id='vs' class='ro'><div class='n'><a href='javascript:dS("vs");'>lambdafactory.modelbase</a></div><div class='t'>Classes</div class='t'><div class='g'><span class='d'><span class='prefix'>&Tau;</span><a href='javascript:dO("vs","ws");'>Factory</a></span><br /><span class='u'><span class='prefix'>&Tau;</span><a href='javascript:dO("vs","xt");'>ModelBadArgument</a></span><br /><span class='u'><span class='prefix'>&Tau;</span><a href='javascript:dO("vs","Et");'>ModelException</a></span><br /></div><div class='t'>Functions</div class='t'><div class='g'><span class='u'><span class='prefix'>&lambda;</span><a href='javascript:dO("vs","Gt");'>assertImplements</a></span><br /></div></div><div id='d_BA' class='de'><h1>Method <span class='n'>filter</span></h1><div class='re'><code>filter( self, list, interface )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='vw' class='cr'><div class='n'><a href='javascript:dS("vw");'>Array</a></div><div class='t'>Bases</div class='t'><div class='g'><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("vw","ww");'><span class='special __bases__'>Type</span></a></span><br /></div><div class='t'>Methods</div class='t'><div class='g'><span class='u'><span class='prefix'>&equiv;</span><a href='javascript:dO("vw","xw");'><span class='special __init__'>constructor</span></a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("vw","yw");'>asString</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("vw","zw");'>content</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("vw","Aw");'>isLike</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("vw","Bw");'>isSameAs</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("vw","Cw");'>isSubtypeOf</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("vw","Dw");'>setContentType</a></span><br /></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("vw","Ew");'><span class='special __call__'>when invoked</span></a></span><br /><span class='u'><span class='prefix'>&equiv;</span><a href='javascript:dO("vw","Fw");'><span class='special __str__'>string conversion</span></a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("vw","Gw");'>clone</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("vw","Hw");'>concreteType</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("vw","Iw");'>definedBy</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("vw","Jw");'>name</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("vw","Kw");'>result</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("vw","Lw");'>setConcreteType</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("vw","Mw");'>setName</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("vw","Nw");'>subtype</a></span><br /></div></div><div id='d_Bu' class='de'><h1>Method <span class='n'>writeComputation</span></h1><div class='re'><code>writeComputation( self, computation )</code></div><div class='ds'><p>Writes a computation operation.</p></div></div><div id='d_Bt' class='de'><h1>wrapper_descriptor</h1><div class='re'></div><div class='ds'><div class="section"><h1 class="heading"><span class="number"><span class="level0">1<span class="lastDot dot">.</span></span></span><span class='term'>str</span>_() &lt;==&gt; str(x)</h1><div class="level1"></div></div></div></div><div id='d_Bw' class='de'><h1>Method <span class='n'>isSameAs</span></h1><div class='re'><code>isSameAs( self, otherType )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Bv' class='de'><h1>str</h1><div class='re'><code>'\t'</code></div><div class='ds'><p>str(object) -&gt; string</p><p>Return a nice string representation of the object. If the argument is a string, the return value is the same object.</p></div></div><div id='d_Bq' class='de'><h1>Method <span class='n'>getReference</span></h1><div class='re'><code>getReference( self )</code></div><div class='ds'><p>Returns the reference to be resolved.</p></div></div><div id='d_Bp' class='de'><h1>Class <span class='n'>IProgram</span></h1><div class='re'></div><div class='ds'><p>The program is the core context and entry point for almost every operation offered by LambdaFactory.</p></div></div><div id='d_Bs' class='de'><h1>Method <span class='n'>_dict</span></h1><div class='re'><code>_dict( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Br' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_By' class='de'><h1>Method <span class='n'>name</span></h1><div class='re'><code>name( self, name=None )</code></div><div class='ds'><p>Returns/sets the name for this type. By defaults, types are unnamed.</p></div></div><div id='d_Bx' class='de'><h1>Method <span class='n'>name</span></h1><div class='re'><code>name( self, name=None )</code></div><div class='ds'><p>Returns/sets the name for this type. By defaults, types are unnamed.</p></div></div><div id='d_Bz' class='de'><h1>Method <span class='n'>isSameAs</span></h1><div class='re'><code>isSameAs( self, otherType )</code></div><div class='ds'><p>Generic implementation of isSameAs. You should always call this method in subclasses.</p></div></div><div id='d_Be' class='de'><h1>Class <span class='n'>IConstructor</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Bd' class='de'><h1>Method <span class='n'>getSlots</span></h1><div class='re'><code>getSlots( self )</code></div><div class='ds'><p>Returns (key, evaluable) pairs representing the slots within this context.</p></div></div><div id='d_Bg' class='de'><h1>Method <span class='n'>getLanguage</span></h1><div class='re'><code>getLanguage( self )</code></div><div class='ds'><p>Returns the language in which the emebedded code is written.</p></div></div><div id='d_Bf' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Bc' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><p>Returns the ith arguments to this operation.</p></div></div><div id='d_Bb' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_Bm' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IValue at 0x5bf4b0&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Bl' class='de'><h1>Method <span class='n'>isAbstract</span></h1><div class='re'><code>isAbstract( self )</code></div><div class='ds'><p>Tells wether the given abstractable is abstract or not.</p></div></div><div id='d_Bo' class='de'><h1>Method <span class='n'>getSlots</span></h1><div class='re'><code>getSlots( self )</code></div><div class='ds'><p>Returns (key, evaluable) pairs representing the slots within this context.</p></div></div><div id='d_Bn' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IMatchOperation at 0x5bfd50&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Bi' class='de'><h1>Method <span class='n'>addOperation</span></h1><div class='re'><code>addOperation( self, operation )</code></div><div class='ds'><p>Adds the given operation as a child of this process.</p></div></div><div id='d_Bh' class='de'><h1>Method <span class='n'>getEvaluable</span></h1><div class='re'><code>getEvaluable( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Bk' class='de'><h1>Method <span class='n'>getArguments</span></h1><div class='re'><code>getArguments( self )</code></div><div class='ds'><p>Returns evaluable arguments.</p></div></div><div id='d_Bj' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='Be' class='cr'><div class='n'><a href='javascript:dS("Be");'>IConstructor</a></div><div class='t'>Bases</div class='t'><div class='g'><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("Be","Ce");'><span class='special __bases__'>IMethod</span></a></span><br /></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Be","De");'>addOperation</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Be","Ee");'>endsWithTermination</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Be","Fe");'>getAbsoluteName</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Be","Ge");'>getAbstractType</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Be","He");'>getAnnotation</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("Be","Ie");'>getArguments</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Be","Je");'>getDataFlow</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Be","Ke");'>getName</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Be","Le");'>getOperations</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Be","Me");'>getParent</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Be","Ne");'>getSlot</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Be","Oe");'>getSlots</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Be","Pe");'>hasExplicitTermination</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Be","Qe");'>hasSlot</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Be","Re");'>isAbstract</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Be","Se");'>setAbstract</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Be","Te");'>setAbstractType</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Be","Ue");'>setAnnotation</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("Be","Ve");'>setArguments</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Be","We");'>setParent</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Be","Xe");'>setSlot</a></span><br /></div></div><div id='Bp' class='cr'><div class='n'><a href='javascript:dS("Bp");'>IProgram</a></div><div class='t'>Bases</div class='t'><div class='g'><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("Bp","Cp");'><span class='special __bases__'>IContext</span></a></span><br /></div><div class='t'>Methods</div class='t'><div class='g'><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Bp","Dp");'>addModule</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Bp","Ep");'>getFactory</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Bp","Fp");'>getModule</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Bp","Gp");'>getModules</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Bp","Hp");'>setFactory</a></span><br /></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Bp","Ip");'>getAbstractType</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Bp","Jp");'>getAnnotation</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Bp","Kp");'>getDataFlow</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Bp","Lp");'>getParent</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Bp","Mp");'>getSlot</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Bp","Np");'>getSlots</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Bp","Op");'>hasSlot</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Bp","Pp");'>setAbstractType</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Bp","Qp");'>setAnnotation</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Bp","Rp");'>setParent</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Bp","Sp");'>setSlot</a></span><br /></div></div><div id='d_Tc' class='de'><h1>Method <span class='n'>getParentClasses</span></h1><div class='re'><code>getParentClasses( self )</code></div><div class='ds'><p>Returns the list of inherited classes references.</p></div></div><div id='d_Tb' class='de'><h1>Method <span class='n'>getTypeDescription</span></h1><div class='re'><code>getTypeDescription( self )</code></div><div class='ds'><p>Returns type information (constraints) that are associated to this argument.</p></div></div><div id='d_Tg' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_Tf' class='de'><h1>Method <span class='n'>getSlots</span></h1><div class='re'><code>getSlots( self )</code></div><div class='ds'><p>Returns (key, evaluable) pairs representing the slots within this context.</p></div></div><div id='d_Te' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_Td' class='de'><h1>Method <span class='n'>getOperations</span></h1><div class='re'><code>getOperations( self )</code></div><div class='ds'><p>Returns the list of operations in this process.</p></div></div><div id='d_Tk' class='de'><h1>Method <span class='n'>setConclusion</span></h1><div class='re'><code>setConclusion( self, process )</code></div><div class='ds'><p>Sets the process that will conclude the interception (finally)</p></div></div><div id='d_Tj' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><p>Returns the ith arguments to this operation.</p></div></div><div id='d_Ti' class='de'><h1>Class <span class='n'>IImportModulesOperation</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Th' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_To' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_Tn' class='de'><h1>Method <span class='n'>addOperation</span></h1><div class='re'><code>addOperation( self, operation )</code></div><div class='ds'><p>Adds the given operation as a child of this process.</p></div></div><div id='d_Tm' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_Tl' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><p>Sets the given argument of this operation, by argument index.</p></div></div><div id='d_Ts' class='de'><h1>Method <span class='n'>createClassMethod</span></h1><div class='re'><code>createClassMethod( self, name, arguments=() )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Tr' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><p>Sets the given argument of this operation, by argument index.</p></div></div><div id='d_Tq' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_Tp' class='de'><h1>Class <span class='n'>IReferencable</span></h1><div class='re'></div><div class='ds'><p>A referencable is an element that can be referenced either by id (it is unique and stable), or by a name (which is also not supposed to change).</p><p>Types are good examples of referencables: they have an <em>absolute name</em> (like <code>Data.List</code>), but can also be bound to slots within contexts which give them "local names" (like <code>List := Data.List</code>)</p></div></div><div id='d_Tw' class='de'><h1>Method <span class='n'>isLike</span></h1><div class='re'><code>isLike( self, otherType )</code></div><div class='ds'><p>The other type is like this Cell if the other type is a cell of the same length as this one.</p></div></div><div id='d_Tv' class='de'><h1>Method <span class='n'>getType</span></h1><div class='re'><code>getType( self, name )</code></div><div class='ds'><p>Returns the type with the given name, or None if it does not exist.</p></div></div><div id='d_Tu' class='de'><h1>Method <span class='n'>writeReference</span></h1><div class='re'><code>writeReference( self, element )</code></div><div class='ds'><p>Writes an argument element.</p></div></div><div id='d_Tt' class='de'><h1>Method <span class='n'>getCurrentContext</span></h1><div class='re'><code>getCurrentContext( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Tz' class='de'><h1>Method <span class='n'>isSubtypeOf</span></h1><div class='re'><code>isSubtypeOf( self, otherType )</code></div><div class='ds'><p>Generic implementation of isSubtypeOf. You should always call this method in subclasses, as it implements basic type systems rules such as isSubtypeOf(Any).</p></div></div><div id='d_Ty' class='de'><h1>Method <span class='n'>clone</span></h1><div class='re'><code>clone( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Tx' class='de'><h1>Method <span class='n'>elementNames</span></h1><div class='re'><code>elementNames( self )</code></div><div class='ds'><p>Returns the list of slots/elements defined in this map.</p></div></div><div id='d_TA' class='de'><h1>str</h1><div class='re'><code>'AsynchronousInvocationsExpansion'</code></div><div class='ds'><p>str(object) -&gt; string</p><p>Return a nice string representation of the object. If the argument is a string, the return value is the same object.</p></div></div><div id='Uv' class='cr'><div class='n'><a href='javascript:dS("Uv");'>TypeCollection</a></div><div class='t'>Bases</div class='t'><div class='g'><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("Uv","c");'><span class='special __bases__'><i>Base class</i></span></a></span><br /></div><div class='t'>Methods</div class='t'><div class='g'><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Uv","Vv");'>getType</a></span><br /></div></div><div id='Ur' class='cr'><div class='n'><a href='javascript:dS("Ur");'>ISyntactic</a></div><div class='t'>Bases</div class='t'><div class='g'><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("Ur","c");'><span class='special __bases__'><i>Base class</i></span></a></span><br /></div><div class='t'>Methods</div class='t'><div class='g'><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("Ur","Vr");'>getColumn</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("Ur","Wr");'>getLine</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("Ur","Xr");'>getOffset</a></span><br /></div></div><div id='Ul' class='cr'><div class='n'><a href='javascript:dS("Ul");'>IInvocable</a></div><div class='t'>Bases</div class='t'><div class='g'><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("Ul","c");'><span class='special __bases__'><i>Base class</i></span></a></span><br /></div><div class='t'>Methods</div class='t'><div class='g'><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("Ul","Vl");'>getArguments</a></span><br /></div></div><div id='Ub' class='cr'><div class='n'><a href='javascript:dS("Ub");'>IAssignable</a></div><div class='t'>Bases</div class='t'><div class='g'><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("Ub","c");'><span class='special __bases__'><i>Base class</i></span></a></span><br /></div></div><div id='UA' class='ro'><div class='n'><a href='javascript:dS("UA");'>lambdafactory.reporter</a></div><div class='t'>Classes</div class='t'><div class='g'><span class='d'><span class='prefix'>&Tau;</span><a href='javascript:dO("UA","VA");'>Reporter</a></span><br /></div><div class='t'>Values</div class='t'><div class='g'><span class='d'><span class='prefix'>&sdot;</span><a href='javascript:dO("UA","hB");'>DefaultReporter</a></span><br /></div></div><div id='d_al' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><p>Returns the ith arguments to this operation.</p></div></div><div id='d_am' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><p>Adds an argument to this operation. This should do checking of arguments (by expected internal type and number).</p></div></div><div id='d_an' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_ao' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><p>Returns this @protocol name. It can be <code>None</code> if the @protocol is anonymous.</p></div></div><div id='d_ah' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_ai' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><p>Sets the given argument of this operation, by argument index.</p></div></div><div id='d_aj' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><p>Returns the ith arguments to this operation.</p></div></div><div id='d_ak' class='de'><h1>list</h1><div class='re'><code>['ImportedElements', 'ImportOrigin']</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='d_ad' class='de'><h1>Method <span class='n'>getSlot</span></h1><div class='re'><code>getSlot( self, name )</code></div><div class='ds'><p>Returns the given evaluable bound to named slot.</p></div></div><div id='d_ae' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, context )</code></div><div class='ds'><p>Sets the parent context for this context.</p></div></div><div id='d_af' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns the parent context for this context (if any)</p></div></div><div id='d_ag' class='de'><h1>Method <span class='n'>setArguments</span></h1><div class='re'><code>setArguments( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_ab' class='de'><h1>Class <span class='n'>IAccessOperation</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_ac' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_Mg' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_ay' class='de'><h1>Method <span class='n'>__call__</span></h1><div class='re'><code>__call__( self )</code></div><div class='ds'><p>A type instance can be used as a class to construct a new type, which will be cloned from the current type.</p></div></div><div id='d_az' class='de'><h1>Method <span class='n'>subtype</span></h1><div class='re'><code>subtype( self, name )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_at' class='de'><h1>Method <span class='n'>createModule</span></h1><div class='re'><code>createModule( self, name )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_au' class='de'><h1>Method <span class='n'>isInInstanceMethod</span></h1><div class='re'><code>isInInstanceMethod( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_av' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self, reporter=<lambdafactory.reporter.Reporter instance at 0x11aa058> )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_aw' class='de'><h1>Class <span class='n'>Arguments</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_ap' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><p>Adds an argument to this operation. This should do checking of arguments (by expected internal type and number).</p></div></div><div id='d_aq' class='de'><h1>Method <span class='n'>getAbsoluteName</span></h1><div class='re'><code>getAbsoluteName( self )</code></div><div class='ds'><p>Returns the absolute name for this element</p></div></div><div id='d_ar' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><p>Sets the given argument of this operation, by argument index.</p></div></div><div id='d_as' class='de'><h1>Method <span class='n'>getReturnedEvaluable</span></h1><div class='re'><code>getReturnedEvaluable( self )</code></div><div class='ds'><p>Returns the termination return evaluable.</p></div></div><div id='d_aA' class='de'><h1>Function <span class='n'>Interface</span></h1><div class='re'><code>Interface( Context )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_aB' class='de'><h1>Method <span class='n'>error</span></h1><div class='re'><code>error( self, message, element=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='hu' class='cr'><div class='n'><a href='javascript:dS("hu");'>FileSplitter</a></div><div class='t'>Bases</div class='t'><div class='g'><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("hu","c");'><span class='special __bases__'><i>Base class</i></span></a></span><br /></div><div class='t'>Methods</div class='t'><div class='g'><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("hu","iu");'><span class='special __init__'>constructor</span></a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("hu","ju");'>end</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("hu","ku");'>fromLines</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("hu","lu");'>fromStream</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("hu","mu");'>fromString</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("hu","nu");'>newFile</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("hu","ou");'>start</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("hu","pu");'>writeLine</a></span><br /></div></div><div id='hl' class='cr'><div class='n'><a href='javascript:dS("hl");'>IInterface</a></div><div class='t'>Bases</div class='t'><div class='g'><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("hl","il");'><span class='special __bases__'>IAbstractClass</span></a></span><br /></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("hl","jl");'>getAbsoluteName</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("hl","kl");'>getAbstractType</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("hl","ll");'>getAnnotation</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("hl","ml");'>getAttributes</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("hl","nl");'>getClassAttributes</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("hl","ol");'>getClassMethods</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("hl","pl");'>getConstructors</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("hl","ql");'>getDataFlow</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("hl","rl");'>getDestructors</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("hl","sl");'>getInstanceMethods</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("hl","tl");'>getMethods</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("hl","ul");'>getName</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("hl","vl");'>getOperations</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("hl","wl");'>getParent</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("hl","xl");'>getParentClasses</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("hl","yl");'>getSlot</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("hl","zl");'>getSlots</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("hl","Al");'>hasSlot</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("hl","Bl");'>isAbstract</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("hl","Cl");'>setAbstract</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("hl","Dl");'>setAbstractType</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("hl","El");'>setAnnotation</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("hl","Fl");'>setParent</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("hl","Gl");'>setParentClasses</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("hl","Hl");'>setSlot</a></span><br /></div></div><div id='hd' class='cr'><div class='n'><a href='javascript:dS("hd");'>IClassAttribute</a></div><div class='t'>Bases</div class='t'><div class='g'><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("hd","id");'><span class='special __bases__'>IAttribute</span></a></span><br /></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("hd","jd");'>getAbsoluteName</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("hd","kd");'>getDefaultValue</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("hd","ld");'>getName</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("hd","md");'>getTypeDescription</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("hd","nd");'>setDefaultValue</a></span><br /></div></div><div id='d_sz' class='de'><h1>Class <span class='n'>Type</span></h1><div class='re'></div><div class='ds'><p>Abstract class for all types.</p></div></div><div id='d_sx' class='de'><h1>Method <span class='n'>add</span></h1><div class='re'><code>add( self, name, theType )</code></div><div class='ds'><p>This is a <em>deprecated</em> methods that is simply an alias for <code>Map.set</code>.</p></div></div><div id='d_sy' class='de'><h1>Method <span class='n'>isLike</span></h1><div class='re'><code>isLike( self, otherType )</code></div><div class='ds'><p>The other type is like this one if the other is a sequence with the same length and that all elements are like the corresponding elements of this sequence.</p></div></div><div id='d_sr' class='de'><h1>Class <span class='n'>ISlot</span></h1><div class='re'></div><div class='ds'><p>An argument is a reference with additional type information.</p></div></div><div id='d_ss' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_sp' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><p>Returns the local name for this referencable element</p></div></div><div id='d_sq' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><p>Returns the arguments to this operation.</p></div></div><div id='d_sv' class='de'><h1>Method <span class='n'>resolve</span></h1><div class='re'><code>resolve( self, name, dataflow=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_sw' class='de'><h1>Method <span class='n'>setConcreteType</span></h1><div class='re'><code>setConcreteType( self, value )</code></div><div class='ds'><p>Sets the <span class='term'>concrete type</span> for this abstract type. The concrete type is a value which represents the type. For instance, if this type represents a class, then the concrete type would be the class instance.</p></div></div><div id='d_st' class='de'><h1>Method <span class='n'>repeat</span></h1><div class='re'><code>repeat( self, condition, process )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_su' class='de'><h1>Method <span class='n'>writeAllocation</span></h1><div class='re'><code>writeAllocation( self, allocation )</code></div><div class='ds'><p>Writes an allocation operation.</p></div></div><div id='d_sj' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_sk' class='de'><h1>Method <span class='n'>setAbstract</span></h1><div class='re'><code>setAbstract( self, isAbstract )</code></div><div class='ds'><p>Sets wether the given abstractable is abstract or not.</p></div></div><div id='d_sh' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_si' class='de'><h1>Method <span class='n'>isAbstract</span></h1><div class='re'><code>isAbstract( self )</code></div><div class='ds'><p>Tells wether the given abstractable is abstract or not.</p></div></div><div id='d_sn' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_so' class='de'><h1>Method <span class='n'>getImportOperations</span></h1><div class='re'><code>getImportOperations( self )</code></div><div class='ds'><p>Returns the list of import operations declared in this module</p></div></div><div id='d_sl' class='de'><h1>Method <span class='n'>getInstanceMethods</span></h1><div class='re'><code>getInstanceMethods( self )</code></div><div class='ds'><p>Returns the instance methods defined within this class.</p></div></div><div id='d_sm' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_sb' class='de'><h1>Method <span class='n'>getSlotToAllocate</span></h1><div class='re'><code>getSlotToAllocate( self )</code></div><div class='ds'><p>Returns slot to be allocated by this operation.</p></div></div><div id='d_sc' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IGroup at 0x5bf8a0&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_sf' class='de'><h1>Method <span class='n'>getChildren</span></h1><div class='re'><code>getChildren( self )</code></div><div class='ds'><p>Returns a list of the child dataflows for this dataflow.</p></div></div><div id='d_sg' class='de'><h1>Class <span class='n'>IElement</span></h1><div class='re'></div><div class='ds'><p>The core @protocol for every element.</p></div></div><div id='d_sd' class='de'><h1>Method <span class='n'>getAbsoluteName</span></h1><div class='re'><code>getAbsoluteName( self )</code></div><div class='ds'><p>Returns the absolute name for this element</p></div></div><div id='d_se' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_sA' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.IModule at 0x5bf810&gt;]</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div>
	<!-- hidden-snip -->
	<!-- hidden nodes will be moved here -->
</div>
</div>
<!-- body -->
</body>
</html>
