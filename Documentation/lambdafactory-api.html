<html>
<!-- Document generated by SDoc <http://www.ivy.fr/sdoc> -->
<head>
<title>Python API documentation (SDoc)</title>

<style type="text/css" media="screen">
/* css-main-snip */
html, body {
	background : #fcfcf6;
	color: #000000;
	font: 8pt/14pt "Lucida Grande", "Lucida", Helvetica, sans-serif;
	padding: 0;
	margin: 0;
}


a, a:active, a:link, a:visited, a:hover {
	color: #404040;
	text-decoration: none;
}

a:active, a:focus {
	background-color: #eae08c;
	color: white;
	border: 0;
	padding: 2px;
}

a:hover {
	color: #8fb216;
}

code {
	color: #8fb216;
}

pre {
	padding-top: 5pt;
	padding-bottom: 5pt;
	background: #f0f0f0;
	color: #8fb216;
}

/* css-main-snip */
/* css-classes-snip */
#descriptions {
	padding: 0;
	margin: 0;
	margin-left: 380px;
}

#options {
	display: none;
	text-align: right;
}

#options label {
	font-weight: bold;
	padding-left: 10px;
}

#modules,
#api {
	display: block;
	width: 200px;
	float: left;
	padding:0;
	padding-left: 5pt;
	padding-right: 10pt;
	background: white;
	border-right: 1px solid #f0f0f0;
	overflow: auto;
	height: 100%;
}

#api {
	margin-right: 10pt;
}

#modules ul {
	margin: 0;
	padding: 0;
}

#modules ul li {
	list-style-type: none;
	padding: 0;
}

#hidden {
	padding: 0;
	margin: 0;
	display: none;
}

#sdoc .de {
	display: none;
	padding: 5pt;
}

#sdoc .re {
	padding-bottom: 5pt;
}


#sdoc .t {
	padding-top: 10pt;
	font-weight: bold;
	border-bottom: 1px solid #f0f0f0;
	color: #505050;
}

#sdoc .prefix {
	color: #D0C0C0;
	font-style: italic;
	padding-right: 5px;
}

#sdoc .noattributes {
	color: #D0C0C0;
	font-style: italic;
}

#sdoc .n, #sdoc .n a {
	color: #cdb425;
}

#sdoc .term {
	font-weight:bold;
	color: #cdb425;
	background: #F9FFDE;
	padding-left: 2px;
	padding-right: 2px;
}

#sdoc .n {
	font-weight: bold;
	margin-top: 1em;
}

#sdoc .special {
	font-weight: bold;
}

#sdoc .special.__bases__ {
	font-weight: normal;
	color: #cdb425;
}

#sdoc .u, #sdoc .u a {
	color: #b0c0c0;
	font-style: italic;
}
#sdoc .ds {
	border-top: 1px solid #f0f0f0;
	border-bottom: 1px solid #f0f0f0;
	background: white;
	padding: 5pt;
	color: #808080;
}

#sdoc table caption {
	font: 8pt/14pt "Lucida Grande", "Lucida", Helvetica, sans-serif;
	font-weight: bold;
}

#sdoc table tr td {
	font: 8pt/14pt "Lucida Grande", "Lucida", Helvetica, sans-serif;
	color: #808080;
}

#sdoc .ro, #sdoc .cr {
	color: #404040;
}

#sdoc .cr {
	margin-left: 10pt;
}


/* css-classes-snip */
</style>

<script type="text/javascript" src="http://jqueryjs.googlecode.com/files/jquery-1.2.2.pack.js" > </script>
<script type="text/javascript">
/* <![CDATA[ */
// javascript-snip

var displays    = [];
var selected    = undefined;
var description = undefined;
var hidden      = undefined;
var content     = undefined;

function dO( from_id, to_id )
{
	if ( to_id == undefined ) { to_id = from_id ; from_id = undefined; }
	if ( hidden  == undefined ) hidden  = document.getElementById("hidden");
	if ( content == undefined ) content = document.getElementById("api");
	// We get the target element and the associated description element
	var element  = document.getElementById(to_id);
	var felement = document.getElementById(from_id);
	var level    = 0;
	if ( felement != undefined )
	{
		level        = felement.getAttribute("level");
		if ( !level ) { level = 0; }
		else { level = parseInt(level); }
	}
	else
	{
		level = 0;
	}
	// We show the element description
	dS(to_id);
	// We show the element
	if (element)
	{
		if ( element == selected ) return;
		// We re-order the content nodes anyway
		element.parentNode.removeChild(element);
		element.setAttribute("level", level + 1);
		content.appendChild(element);
		// Ensure that the node is visible
		element.style.display  = "block";
		// And its description
		// We hide the old ones
		while ( displays.length > 0 && displays.length > level )
		{
			var hiding_id = displays.pop()
			var hiding_el = document.getElementById(hiding_id);
			if ( hiding_el != element )
			{
				hiding_el.parentNode.removeChild(hiding_el);
				hidden.appendChild(hiding_el);
			}
		}
		// And update the state
		displays.push(to_id);
		selected = element;
	}
}

function dS( eid )
{
	var delement = document.getElementById("d_" + eid);
	if ( delement != undefined && delement != description )
	{
		delement.style.display = "block";
		if ( description != undefined ) description.style.display = "none";
		description = delement;
	}
	else if ( delement == undefined )
	{
		alert("ERROR: Description not found for id 'd_" + eid + "'");
	}
}

var J = jQuery

function updatePrivateVisibility () {
	/* FIXME: Use proper class instead */
	if ( J(".do-togglePrivate").attr("checked") ) {
		J(".private").parent().parent().fadeIn()
	} else {
		J(".private").parent().parent().fadeOut()
	}
}

function updateProtectedVisibility () {
	if ( J(".do-toggleProtected").attr("checked") ) {
		J(".protected").parent().parent().fadeIn()
	} else {
		J(".protected").parent().parent().fadeOut()
	}
}

jQuery(document).ready(function(){
	J(".do-togglePrivate").click(updatePrivateVisibility)
	J(".do-toggleProtected").click(updateProtectedVisibility)
	updatePrivateVisibility()
	updateProtectedVisibility()
})

// javascript-snip
/* ]]> */

</script>
</head>
<body onLoad="javascript:dO('a');">
<!-- body -->
<div id="sdoc">
<div id='modules'>
<!-- modules-snip -->
<div class='cr'><div class='n'>$TITLE</div><div class='t'>Modules</div><ul class='g'><li><span class='prefix'>M</span><a href='javascript:dO("a");'>lambdafactory.interfaces</a><li><li><span class='prefix'>M</span><a href='javascript:dO("SC");'>lambdafactory.modelbase</a><li><li><span class='prefix'>M</span><a href='javascript:dO("lE");'>lambdafactory.modelwriter</a><li><li><span class='prefix'>M</span><a href='javascript:dO("DE");'>lambdafactory.modeltypes</a><li><li><span class='prefix'>M</span><a href='javascript:dO("YE");'>lambdafactory.typecast</a><li><li><span class='prefix'>M</span><a href='javascript:dO("lJ");'>lambdafactory.passes</a><li><li><span class='prefix'>M</span><a href='javascript:dO("GN");'>lambdafactory.reporter</a><li></ul></div>
<div id='options'>
	<label>Show:</label>
	<input type="checkbox" class="do-togglePrivate"> private
	<input type="checkbox" class="do-toggleProtected"> protected
</div>
<!-- modules-snip -->
</div>
<div id='api'><!-- main element will be displayed here --></div>
<div id='descriptions'>
	<!-- descriptions-snip -->
	<div id='d_c' class='de'><h1>tuple</h1><div class='re'><code>()</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_d' class='de'><h1>str</h1><div class='re'><code>'__init__'</code></div><div class='ds'><pre>str(object) -&gt; string<br />Return a nice string representation of the object.
If the argument is a string, the return value is the same object.</pre></div></div><div id='d_e' class='de'><h1>str</h1><div class='re'><code>'__current__'</code></div><div class='ds'><pre>str(object) -&gt; string<br />Return a nice string representation of the object.
If the argument is a string, the return value is the same object.</pre></div></div><div id='d_f' class='de'><h1>str</h1><div class='re'><code>'__currentvalue__'</code></div><div class='ds'><pre>str(object) -&gt; string<br />Return a nice string representation of the object.
If the argument is a string, the return value is the same object.</pre></div></div><div id='d_g' class='de'><h1>str</h1><div class='re'><code>'__destroy__'</code></div><div class='ds'><pre>str(object) -&gt; string<br />Return a nice string representation of the object.
If the argument is a string, the return value is the same object.</pre></div></div><div id='d_h' class='de'><h1>str</h1><div class='re'><code>'__main__'</code></div><div class='ds'><pre>str(object) -&gt; string<br />Return a nice string representation of the object.
If the argument is a string, the return value is the same object.</pre></div></div><div id='d_i' class='de'><h1>str</h1><div class='re'><code>'__moduleinit__'</code></div><div class='ds'><pre>str(object) -&gt; string<br />Return a nice string representation of the object.
If the argument is a string, the return value is the same object.</pre></div></div><div id='d_j' class='de'><h1>int</h1><div class='re'></div><div class='ds'><pre>int(x[, base]) -&gt; integer<br />Convert a string or number to an integer, if possible.  A floating point
argument will be truncated towards zero (this does not include a string
representation of a floating point number!)  When converting a string, use
the optional base.  It is an error to supply a base when converting a
non-string. If the argument is outside the integer range a long object
will be returned instead.</pre></div></div><div id='d_b' class='de'><h1>Class <span class='n'>Constants</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_l' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IReference at 0x85d214c&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_m' class='de'><h1>Method <span class='n'>addAnnotation</span></h1><div class='re'><code>addAnnotation( self, annotation )</code></div><div class='ds'><pre>Adds an annotation to this element</pre></div></div><div id='d_n' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><pre>Performs a deep clone of this element. Any mutation to the original won't
		change the copy.</pre></div></div><div id='d_o' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><pre>Detaches the element from its parent (in case it was already attached).
		This should return this element, and set the parent to None.</pre></div></div><div id='d_p' class='de'><h1>Method <span class='n'>getAbsoluteName</span></h1><div class='re'><code>getAbsoluteName( self )</code></div><div class='ds'><pre>Returns the absolute name for this element</pre></div></div><div id='d_q' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type for this element</pre></div></div><div id='d_r' class='de'><h1>Method <span class='n'>getAnnotations</span></h1><div class='re'><code>getAnnotations( self, name=None )</code></div><div class='ds'><pre>Gets all the annotation with the given name associated to this element
		or all annotations if no name is specified.</pre></div></div><div id='d_s' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><pre>Returns the dataflow accessible/bound to this element</pre></div></div><div id='d_t' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><pre>Returns the local name for this referencable element</pre></div></div><div id='d_u' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><pre>Returns this element parent</pre></div></div><div id='d_v' class='de'><h1>Method <span class='n'>getReferenceName</span></h1><div class='re'><code>getReferenceName( self )</code></div><div class='ds'><pre>Returns the name which this reference contains. The name is used by
		the resolution operation to actually resolve a value from the name.</pre></div></div><div id='d_w' class='de'><h1>Method <span class='n'>getResultAbstractType</span></h1><div class='re'><code>getResultAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type of the result of the evaluation of this
		evaluable</pre></div></div><div id='d_x' class='de'><h1>Method <span class='n'>hasAnnotation</span></h1><div class='re'><code>hasAnnotation( self, name )</code></div><div class='ds'><pre>Tells if the given element has an annotation with the given name</pre></div></div><div id='d_y' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><pre>Tells if this element has a parent or not</pre></div></div><div id='d_z' class='de'><h1>Method <span class='n'>removeAnnotation</span></h1><div class='re'><code>removeAnnotation( self, name )</code></div><div class='ds'><pre>Removes the annotations with the given name</pre></div></div><div id='d_A' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><pre>Sets the abstract type for this element</pre></div></div><div id='d_B' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><pre>Sets this element parent</pre></div></div><div id='d_C' class='de'><h1>Method <span class='n'>setResultAbstractType</span></h1><div class='re'><code>setResultAbstractType( self, abstractType )</code></div><div class='ds'><pre>Sets the abstract type for this operation result. This is usually
		invoked in the typing phase.</pre></div></div><div id='d_k' class='de'><h1>Class <span class='n'>IAbsoluteReference</span></h1><div class='re'></div><div class='ds'><pre>An absolute reference is a specific kind of reference that does not
	necessarily resolve in the current context, but will rather use the program
	root context as a starting point.</pre></div></div><div id='d_E' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IClass at 0x85d232c&gt;, &lt;class lambdafactory.interfaces.IAbstractable at 0x85c4fbc&gt;)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_F' class='de'><h1>Method <span class='n'>addAnnotation</span></h1><div class='re'><code>addAnnotation( self, annotation )</code></div><div class='ds'><pre>Adds an annotation to this element</pre></div></div><div id='d_G' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><pre>Performs a deep clone of this element. Any mutation to the original won't
		change the copy.</pre></div></div><div id='d_H' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><pre>Detaches the element from its parent (in case it was already attached).
		This should return this element, and set the parent to None.</pre></div></div><div id='d_I' class='de'><h1>Method <span class='n'>getAbsoluteName</span></h1><div class='re'><code>getAbsoluteName( self )</code></div><div class='ds'><pre>Returns the absolute name for this element</pre></div></div><div id='d_J' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type for this element</pre></div></div><div id='d_K' class='de'><h1>Method <span class='n'>getAnnotations</span></h1><div class='re'><code>getAnnotations( self, name=None )</code></div><div class='ds'><pre>Gets all the annotation with the given name associated to this element
		or all annotations if no name is specified.</pre></div></div><div id='d_L' class='de'><h1>Method <span class='n'>getAttributes</span></h1><div class='re'><code>getAttributes( self )</code></div><div class='ds'><pre>Returns the (non-class) attributes defined within this class.</pre></div></div><div id='d_M' class='de'><h1>Method <span class='n'>getClassAttributes</span></h1><div class='re'><code>getClassAttributes( self )</code></div><div class='ds'><pre>Returns the class attributes defined within this class.</pre></div></div><div id='d_N' class='de'><h1>Method <span class='n'>getClassMethods</span></h1><div class='re'><code>getClassMethods( self )</code></div><div class='ds'><pre>Returns the class method defined within this class.</pre></div></div><div id='d_O' class='de'><h1>Method <span class='n'>getConstructors</span></h1><div class='re'><code>getConstructors( self )</code></div><div class='ds'><pre>Returns the constructors for this class</pre></div></div><div id='d_P' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><pre>Returns the dataflow accessible/bound to this element</pre></div></div><div id='d_Q' class='de'><h1>Method <span class='n'>getDestructors</span></h1><div class='re'><code>getDestructors( self )</code></div><div class='ds'><pre>Returns the destructors for this class</pre></div></div><div id='d_R' class='de'><h1>Method <span class='n'>getInheritedSlots</span></h1><div class='re'><code>getInheritedSlots( self )</code></div><div class='ds'><pre>gives the list of inherited slots</pre></div></div><div id='d_S' class='de'><h1>Method <span class='n'>getInstanceMethods</span></h1><div class='re'><code>getInstanceMethods( self )</code></div><div class='ds'><pre>Returns the instance methods defined within this class.</pre></div></div><div id='d_T' class='de'><h1>Method <span class='n'>getMethods</span></h1><div class='re'><code>getMethods( self )</code></div><div class='ds'><pre>Returns the methods defined within this class.</pre></div></div><div id='d_U' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><pre>Returns this class name. It can be `None` if the class is anonymous.</pre></div></div><div id='d_V' class='de'><h1>Method <span class='n'>getOperations</span></h1><div class='re'><code>getOperations( self )</code></div><div class='ds'><pre>Returns the operations (methods and class methods) defined within this class.</pre></div></div><div id='d_W' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><pre>Returns the parent context for this context (if any)</pre></div></div><div id='d_X' class='de'><h1>Method <span class='n'>getParentClassesRefs</span></h1><div class='re'><code>getParentClassesRefs( self )</code></div><div class='ds'><pre>Returns the list of inherited classes references. Note that they
		have to be interpreted in the class parent (a module)</pre></div></div><div id='d_Y' class='de'><h1>Method <span class='n'>getSlot</span></h1><div class='re'><code>getSlot( self, name )</code></div><div class='ds'><pre>Returns the given evaluable bound to named slot.</pre></div></div><div id='d_Z' class='de'><h1>Method <span class='n'>getSlotNames</span></h1><div class='re'><code>getSlotNames( self )</code></div><div class='ds'><pre>Returns the list of slot names (in order) for this context</pre></div></div><div id='d_ab' class='de'><h1>Method <span class='n'>getSlots</span></h1><div class='re'><code>getSlots( self )</code></div><div class='ds'><pre>Returns (key, evaluable) pairs representing the slots within this
		context. In the case of context that may inherits slots, this only
		returns the slots that are owned by the context (ie. it does not
		include inherited slots)</pre></div></div><div id='d_bb' class='de'><h1>Method <span class='n'>hasAnnotation</span></h1><div class='re'><code>hasAnnotation( self, name )</code></div><div class='ds'><pre>Tells if the given element has an annotation with the given name</pre></div></div><div id='d_cb' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><pre>Tells if this element has a parent or not</pre></div></div><div id='d_db' class='de'><h1>Method <span class='n'>hasSlot</span></h1><div class='re'><code>hasSlot( self, name )</code></div><div class='ds'><pre>Tells if the context has a slot with the given name.</pre></div></div><div id='d_eb' class='de'><h1>Method <span class='n'>isAbstract</span></h1><div class='re'><code>isAbstract( self )</code></div><div class='ds'><pre>Tells wether the given abstractable is abstract or not.</pre></div></div><div id='d_fb' class='de'><h1>Method <span class='n'>removeAnnotation</span></h1><div class='re'><code>removeAnnotation( self, name )</code></div><div class='ds'><pre>Removes the annotations with the given name</pre></div></div><div id='d_gb' class='de'><h1>Method <span class='n'>setAbstract</span></h1><div class='re'><code>setAbstract( self, isAbstract )</code></div><div class='ds'><pre>Sets wether the given abstractable is abstract or not.</pre></div></div><div id='d_hb' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><pre>Sets the abstract type for this element</pre></div></div><div id='d_ib' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, context )</code></div><div class='ds'><pre>Sets the parent context for this context.</pre></div></div><div id='d_jb' class='de'><h1>Method <span class='n'>setParentClasses</span></h1><div class='re'><code>setParentClasses( self )</code></div><div class='ds'><pre>gives the list of parent classes that will</pre></div></div><div id='d_kb' class='de'><h1>Method <span class='n'>setSlot</span></h1><div class='re'><code>setSlot( self, name, evaluable )</code></div><div class='ds'><pre>Binds the given evaluable to the named slot. If there is already a slot
		with the same name, then 'getSlot(name)' should return the evaluable
		given as parameter.<br />		In the default implementation, setSlot preserves the ''history'' of
		added slots, and will always return the latest one.</pre></div></div><div id='d_D' class='de'><h1>Class <span class='n'>IAbstractClass</span></h1><div class='re'></div><div class='ds'><pre>An abstract @protocol is a @protocol that has at least one abstract element.</pre></div></div><div id='d_mb' class='de'><h1>Method <span class='n'>isAbstract</span></h1><div class='re'><code>isAbstract( self )</code></div><div class='ds'><pre>Tells wether the given abstractable is abstract or not.</pre></div></div><div id='d_nb' class='de'><h1>Method <span class='n'>setAbstract</span></h1><div class='re'><code>setAbstract( self, isAbstract )</code></div><div class='ds'><pre>Sets wether the given abstractable is abstract or not.</pre></div></div><div id='d_lb' class='de'><h1>Class <span class='n'>IAbstractable</span></h1><div class='re'></div><div class='ds'><pre>An abstractable element is an element that is allow to have
	no underlying implementation.  Abstract element are typically interfaces,
	methods, functions, operations, and sometimes modules and @protocoles.</pre></div></div><div id='d_pb' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.ISubsetOperation at 0x85d28fc&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_qb' class='de'><h1>Method <span class='n'>getIndex</span></h1><div class='re'><code>getIndex( self )</code></div><div class='ds'><pre>Returns evaluable that will return the access index</pre></div></div><div id='d_rb' class='de'><h1>Method <span class='n'>addAnnotation</span></h1><div class='re'><code>addAnnotation( self, annotation )</code></div><div class='ds'><pre>Adds an annotation to this element</pre></div></div><div id='d_sb' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><pre>Adds an argument to this operation. This should do checking of
		arguments (by expected internal type and number).</pre></div></div><div id='d_tb' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><pre>Performs a deep clone of this element. Any mutation to the original won't
		change the copy.</pre></div></div><div id='d_ub' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><pre>Detaches the element from its parent (in case it was already attached).
		This should return this element, and set the parent to None.</pre></div></div><div id='d_vb' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type for this element</pre></div></div><div id='d_wb' class='de'><h1>Method <span class='n'>getAnnotations</span></h1><div class='re'><code>getAnnotations( self, name=None )</code></div><div class='ds'><pre>Gets all the annotation with the given name associated to this element
		or all annotations if no name is specified.</pre></div></div><div id='d_xb' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><pre>Returns the dataflow accessible/bound to this element</pre></div></div><div id='d_yb' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><pre>Returns the ith arguments to this operation.</pre></div></div><div id='d_zb' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><pre>Returns the arguments to this operation.</pre></div></div><div id='d_Ab' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><pre>Returns the *internal types* for this operations arguments. This is
		typically the list of interfaces or @protocols that the arguments must
		comply to.</pre></div></div><div id='d_Bb' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><pre>Returns this element parent</pre></div></div><div id='d_Cb' class='de'><h1>Method <span class='n'>getTarget</span></h1><div class='re'><code>getTarget( self )</code></div><div class='ds'><pre>Returns the operation target.</pre></div></div><div id='d_Db' class='de'><h1>Method <span class='n'>hasAnnotation</span></h1><div class='re'><code>hasAnnotation( self, name )</code></div><div class='ds'><pre>Tells if the given element has an annotation with the given name</pre></div></div><div id='d_Eb' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><pre>Tells if this element has a parent or not</pre></div></div><div id='d_Fb' class='de'><h1>Method <span class='n'>removeAnnotation</span></h1><div class='re'><code>removeAnnotation( self, name )</code></div><div class='ds'><pre>Removes the annotations with the given name</pre></div></div><div id='d_Gb' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><pre>Sets the abstract type for this element</pre></div></div><div id='d_Hb' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><pre>Sets the given argument of this operation, by argument index.</pre></div></div><div id='d_Ib' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><pre>Sets this element parent</pre></div></div><div id='d_Jb' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.IEvaluable at 0x85c4f2c&gt;, &lt;class lambdafactory.interfaces.IEvaluable at 0x85c4f2c&gt;]</code></div><div class='ds'><pre>list() -&gt; new list
list(sequence) -&gt; new list initialized from sequence's items</pre></div></div><div id='d_ob' class='de'><h1>Class <span class='n'>IAccessOperation</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Lb' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IAttributeMethod at 0x85d253c&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_Mb' class='de'><h1>Method <span class='n'>addAnnotation</span></h1><div class='re'><code>addAnnotation( self, annotation )</code></div><div class='ds'><pre>Adds an annotation to this element</pre></div></div><div id='d_Nb' class='de'><h1>Method <span class='n'>addOperation</span></h1><div class='re'><code>addOperation( self, operation )</code></div><div class='ds'><pre>Adds the given operation as a child of this process.</pre></div></div><div id='d_Ob' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><pre>Performs a deep clone of this element. Any mutation to the original won't
		change the copy.</pre></div></div><div id='d_Pb' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><pre>Detaches the element from its parent (in case it was already attached).
		This should return this element, and set the parent to None.</pre></div></div><div id='d_Qb' class='de'><h1>Method <span class='n'>endsWithTermination</span></h1><div class='re'><code>endsWithTermination( self )</code></div><div class='ds'><pre>Returns true if this function ends with a termination operation. This
		is especially useful for back-ends which want to know if they have to
		insert an explicit 'return' at the end (like Java).</pre></div></div><div id='d_Rb' class='de'><h1>Method <span class='n'>getAbsoluteName</span></h1><div class='re'><code>getAbsoluteName( self )</code></div><div class='ds'><pre>Returns the absolute name for this element</pre></div></div><div id='d_Sb' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type for this element</pre></div></div><div id='d_Tb' class='de'><h1>Method <span class='n'>getAnnotations</span></h1><div class='re'><code>getAnnotations( self, name=None )</code></div><div class='ds'><pre>Gets all the annotation with the given name associated to this element
		or all annotations if no name is specified.</pre></div></div><div id='d_Ub' class='de'><h1>Method <span class='n'>getArguments</span></h1><div class='re'><code>getArguments( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Vb' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><pre>Returns the dataflow accessible/bound to this element</pre></div></div><div id='d_Wb' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><pre>Returns this @protocol name. It can be `None` if the @protocol is anonymous.</pre></div></div><div id='d_Xb' class='de'><h1>Method <span class='n'>getOperations</span></h1><div class='re'><code>getOperations( self )</code></div><div class='ds'><pre>Returns the list of operations in this process.</pre></div></div><div id='d_Yb' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><pre>Returns this element parent</pre></div></div><div id='d_Zb' class='de'><h1>Method <span class='n'>getReturnTypeDescription</span></h1><div class='re'><code>getReturnTypeDescription( self )</code></div><div class='ds'><pre>Returns the return type description for this closure, if any</pre></div></div><div id='d_ac' class='de'><h1>Method <span class='n'>getSlot</span></h1><div class='re'><code>getSlot( self, name )</code></div><div class='ds'><pre>Returns the given evaluable bound to named slot.</pre></div></div><div id='d_bc' class='de'><h1>Method <span class='n'>getSlotNames</span></h1><div class='re'><code>getSlotNames( self )</code></div><div class='ds'><pre>Returns the list of slot names (in order) for this context</pre></div></div><div id='d_cc' class='de'><h1>Method <span class='n'>getSlots</span></h1><div class='re'><code>getSlots( self )</code></div><div class='ds'><pre>Returns (key, evaluable) pairs representing the slots within this
		context. In the case of context that may inherits slots, this only
		returns the slots that are owned by the context (ie. it does not
		include inherited slots)</pre></div></div><div id='d_dc' class='de'><h1>Method <span class='n'>hasAnnotation</span></h1><div class='re'><code>hasAnnotation( self, name )</code></div><div class='ds'><pre>Tells if the given element has an annotation with the given name</pre></div></div><div id='d_ec' class='de'><h1>Method <span class='n'>hasExplicitTermination</span></h1><div class='re'><code>hasExplicitTermination( self )</code></div><div class='ds'><pre>Returns true if this function has an operation with a termination,
		otherwise return false.</pre></div></div><div id='d_fc' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><pre>Tells if this element has a parent or not</pre></div></div><div id='d_gc' class='de'><h1>Method <span class='n'>hasSlot</span></h1><div class='re'><code>hasSlot( self, name )</code></div><div class='ds'><pre>Tells if the context has a slot with the given name.</pre></div></div><div id='d_hc' class='de'><h1>Method <span class='n'>isAbstract</span></h1><div class='re'><code>isAbstract( self )</code></div><div class='ds'><pre>Tells wether the given abstractable is abstract or not.</pre></div></div><div id='d_ic' class='de'><h1>Method <span class='n'>removeAnnotation</span></h1><div class='re'><code>removeAnnotation( self, name )</code></div><div class='ds'><pre>Removes the annotations with the given name</pre></div></div><div id='d_jc' class='de'><h1>Method <span class='n'>setAbstract</span></h1><div class='re'><code>setAbstract( self, isAbstract )</code></div><div class='ds'><pre>Sets wether the given abstractable is abstract or not.</pre></div></div><div id='d_kc' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><pre>Sets the abstract type for this element</pre></div></div><div id='d_lc' class='de'><h1>Method <span class='n'>setArguments</span></h1><div class='re'><code>setArguments( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_mc' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><pre>Sets this element parent</pre></div></div><div id='d_nc' class='de'><h1>Method <span class='n'>setReturnTypeDescription</span></h1><div class='re'><code>setReturnTypeDescription( self, description )</code></div><div class='ds'><pre>Sets the return type description for this closure, if any</pre></div></div><div id='d_oc' class='de'><h1>Method <span class='n'>setSlot</span></h1><div class='re'><code>setSlot( self, name, evaluable )</code></div><div class='ds'><pre>Binds the given evaluable to the named slot. If there is already a slot
		with the same name, then 'getSlot(name)' should return the evaluable
		given as parameter.<br />		In the default implementation, setSlot preserves the ''history'' of
		added slots, and will always return the latest one.</pre></div></div><div id='d_Kb' class='de'><h1>Class <span class='n'>IAccessor</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_qc' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IOperation at 0x85d268c&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_rc' class='de'><h1>Method <span class='n'>getDefaultValue</span></h1><div class='re'><code>getDefaultValue( self )</code></div><div class='ds'><pre>Returns the expression that assigns the @methodault value.</pre></div></div><div id='d_sc' class='de'><h1>Method <span class='n'>getSlotToAllocate</span></h1><div class='re'><code>getSlotToAllocate( self )</code></div><div class='ds'><pre>Returns slot to be allocated by this operation.</pre></div></div><div id='d_tc' class='de'><h1>Method <span class='n'>addAnnotation</span></h1><div class='re'><code>addAnnotation( self, annotation )</code></div><div class='ds'><pre>Adds an annotation to this element</pre></div></div><div id='d_uc' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><pre>Adds an argument to this operation. This should do checking of
		arguments (by expected internal type and number).</pre></div></div><div id='d_vc' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><pre>Performs a deep clone of this element. Any mutation to the original won't
		change the copy.</pre></div></div><div id='d_wc' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><pre>Detaches the element from its parent (in case it was already attached).
		This should return this element, and set the parent to None.</pre></div></div><div id='d_xc' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type for this element</pre></div></div><div id='d_yc' class='de'><h1>Method <span class='n'>getAnnotations</span></h1><div class='re'><code>getAnnotations( self, name=None )</code></div><div class='ds'><pre>Gets all the annotation with the given name associated to this element
		or all annotations if no name is specified.</pre></div></div><div id='d_zc' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><pre>Returns the dataflow accessible/bound to this element</pre></div></div><div id='d_Ac' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><pre>Returns the ith arguments to this operation.</pre></div></div><div id='d_Bc' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><pre>Returns the arguments to this operation.</pre></div></div><div id='d_Cc' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><pre>Returns the *internal types* for this operations arguments. This is
		typically the list of interfaces or @protocols that the arguments must
		comply to.</pre></div></div><div id='d_Dc' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><pre>Returns this element parent</pre></div></div><div id='d_Ec' class='de'><h1>Method <span class='n'>hasAnnotation</span></h1><div class='re'><code>hasAnnotation( self, name )</code></div><div class='ds'><pre>Tells if the given element has an annotation with the given name</pre></div></div><div id='d_Fc' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><pre>Tells if this element has a parent or not</pre></div></div><div id='d_Gc' class='de'><h1>Method <span class='n'>removeAnnotation</span></h1><div class='re'><code>removeAnnotation( self, name )</code></div><div class='ds'><pre>Removes the annotations with the given name</pre></div></div><div id='d_Hc' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><pre>Sets the abstract type for this element</pre></div></div><div id='d_Ic' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><pre>Sets the given argument of this operation, by argument index.</pre></div></div><div id='d_Jc' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><pre>Sets this element parent</pre></div></div><div id='d_Kc' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.ISlot at 0x85d21dc&gt;, &lt;class lambdafactory.interfaces.IEvaluable at 0x85c4f2c&gt;]</code></div><div class='ds'><pre>list() -&gt; new list
list(sequence) -&gt; new list initialized from sequence's items</pre></div></div><div id='d_pc' class='de'><h1>Class <span class='n'>IAllocation</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Mc' class='de'><h1>Method <span class='n'>getContent</span></h1><div class='re'><code>getContent( self )</code></div><div class='ds'><pre>Returns the content of this annotation.</pre></div></div><div id='d_Nc' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><pre>Returns the name of this annotation.</pre></div></div><div id='d_Oc' class='de'><h1>Method <span class='n'>setContent</span></h1><div class='re'><code>setContent( self, content )</code></div><div class='ds'><pre>Updates the content of this annotation.</pre></div></div><div id='d_Lc' class='de'><h1>Class <span class='n'>IAnnotation</span></h1><div class='re'></div><div class='ds'><pre>An annotation is some information that is not used for the actual
	program, but annotates/gives meta-information about is elements.</pre></div></div><div id='d_Qc' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.ISlot at 0x85d21dc&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_Rc' class='de'><h1>Method <span class='n'>getDefaultValue</span></h1><div class='re'><code>getDefaultValue( self )</code></div><div class='ds'><pre>Returns the @methodault value for this slot.</pre></div></div><div id='d_Sc' class='de'><h1>Method <span class='n'>isKeywordsRest</span></h1><div class='re'><code>isKeywordsRest( self )</code></div><div class='ds'><pre>Tells if this arguments represents ''the rest'' of the keyword argument in
		the invocation</pre></div></div><div id='d_Tc' class='de'><h1>Method <span class='n'>isOptional</span></h1><div class='re'><code>isOptional( self )</code></div><div class='ds'><pre>Tells if the argument is optional or not.</pre></div></div><div id='d_Uc' class='de'><h1>Method <span class='n'>isRest</span></h1><div class='re'><code>isRest( self )</code></div><div class='ds'><pre>Tells if this argument represents ''the rest'' of arguments in the
		invocation</pre></div></div><div id='d_Vc' class='de'><h1>Method <span class='n'>setDefaultValue</span></h1><div class='re'><code>setDefaultValue( self, value )</code></div><div class='ds'><pre>Sets the @methodault value for this argument.</pre></div></div><div id='d_Wc' class='de'><h1>Method <span class='n'>setKeywordsRest</span></h1><div class='re'><code>setKeywordsRest( self, value )</code></div><div class='ds'><pre>Tells this arguments represents ''the rest'' of the keyword argument in
		the invocation</pre></div></div><div id='d_Xc' class='de'><h1>Method <span class='n'>setOptional</span></h1><div class='re'><code>setOptional( self, value )</code></div><div class='ds'><pre>Sets this argument as optional or not.</pre></div></div><div id='d_Yc' class='de'><h1>Method <span class='n'>setRest</span></h1><div class='re'><code>setRest( self, value )</code></div><div class='ds'><pre>Tells this argument represents ''the rest'' of arguments in the
		invocation</pre></div></div><div id='d_Zc' class='de'><h1>Method <span class='n'>getAbsoluteName</span></h1><div class='re'><code>getAbsoluteName( self )</code></div><div class='ds'><pre>Returns the absolute name for this element</pre></div></div><div id='d_ad' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><pre>Returns the local name for this referencable element</pre></div></div><div id='d_bd' class='de'><h1>Method <span class='n'>getTypeDescription</span></h1><div class='re'><code>getTypeDescription( self )</code></div><div class='ds'><pre>Returns type information (constraints) that are associated to this
		argument.</pre></div></div><div id='d_Pc' class='de'><h1>Class <span class='n'>IArgument</span></h1><div class='re'></div><div class='ds'><pre>Arguments are slots which can be interpreted in different ways.<br />	When an argument is _optional_, it does not need to be defined in the
	invocation. When an argument is _variable_, it means it references the
	rest of the arguments lists. When an argument is _keywords_, it will reference
	the named arguments of the rest of the arguments list.</pre></div></div><div id='d_cd' class='de'><h1>Class <span class='n'>IAssignable</span></h1><div class='re'></div><div class='ds'><pre>Assignable elements are elements that can be bound to slots. In many
	languages, only a subset of elements can be assigned. For instance, in
	Java, you cannot assign a package to something:<br />	&gt;     Object my_package = java.lang.Object<br />	while in some other languages (like JavaScript), you could do that.</pre></div></div><div id='d_ed' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IOperation at 0x85d268c&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_fd' class='de'><h1>Method <span class='n'>getAssignedValue</span></h1><div class='re'><code>getAssignedValue( self )</code></div><div class='ds'><pre>Returns this assigned evaluable.</pre></div></div><div id='d_gd' class='de'><h1>Method <span class='n'>getTarget</span></h1><div class='re'><code>getTarget( self )</code></div><div class='ds'><pre>Returns this assignation target reference, which can be an evaluable
		(in case you assign to self.something, or a reference)</pre></div></div><div id='d_hd' class='de'><h1>Method <span class='n'>addAnnotation</span></h1><div class='re'><code>addAnnotation( self, annotation )</code></div><div class='ds'><pre>Adds an annotation to this element</pre></div></div><div id='d_id' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><pre>Adds an argument to this operation. This should do checking of
		arguments (by expected internal type and number).</pre></div></div><div id='d_jd' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><pre>Performs a deep clone of this element. Any mutation to the original won't
		change the copy.</pre></div></div><div id='d_kd' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><pre>Detaches the element from its parent (in case it was already attached).
		This should return this element, and set the parent to None.</pre></div></div><div id='d_ld' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type for this element</pre></div></div><div id='d_md' class='de'><h1>Method <span class='n'>getAnnotations</span></h1><div class='re'><code>getAnnotations( self, name=None )</code></div><div class='ds'><pre>Gets all the annotation with the given name associated to this element
		or all annotations if no name is specified.</pre></div></div><div id='d_nd' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><pre>Returns the dataflow accessible/bound to this element</pre></div></div><div id='d_od' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><pre>Returns the ith arguments to this operation.</pre></div></div><div id='d_pd' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><pre>Returns the arguments to this operation.</pre></div></div><div id='d_qd' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><pre>Returns the *internal types* for this operations arguments. This is
		typically the list of interfaces or @protocols that the arguments must
		comply to.</pre></div></div><div id='d_rd' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><pre>Returns this element parent</pre></div></div><div id='d_sd' class='de'><h1>Method <span class='n'>hasAnnotation</span></h1><div class='re'><code>hasAnnotation( self, name )</code></div><div class='ds'><pre>Tells if the given element has an annotation with the given name</pre></div></div><div id='d_td' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><pre>Tells if this element has a parent or not</pre></div></div><div id='d_ud' class='de'><h1>Method <span class='n'>removeAnnotation</span></h1><div class='re'><code>removeAnnotation( self, name )</code></div><div class='ds'><pre>Removes the annotations with the given name</pre></div></div><div id='d_vd' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><pre>Sets the abstract type for this element</pre></div></div><div id='d_wd' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><pre>Sets the given argument of this operation, by argument index.</pre></div></div><div id='d_xd' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><pre>Sets this element parent</pre></div></div><div id='d_yd' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.IEvaluable at 0x85c4f2c&gt;, &lt;class lambdafactory.interfaces.IEvaluable at 0x85c4f2c&gt;]</code></div><div class='ds'><pre>list() -&gt; new list
list(sequence) -&gt; new list initialized from sequence's items</pre></div></div><div id='d_dd' class='de'><h1>Class <span class='n'>IAssignation</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Ad' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.ISlot at 0x85d21dc&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_Bd' class='de'><h1>Method <span class='n'>getDefaultValue</span></h1><div class='re'><code>getDefaultValue( self )</code></div><div class='ds'><pre>Gets the @methodault value for this attribute</pre></div></div><div id='d_Cd' class='de'><h1>Method <span class='n'>setDefaultValue</span></h1><div class='re'><code>setDefaultValue( self )</code></div><div class='ds'><pre>Sets the @methodault value for this attribute</pre></div></div><div id='d_Dd' class='de'><h1>Method <span class='n'>getAbsoluteName</span></h1><div class='re'><code>getAbsoluteName( self )</code></div><div class='ds'><pre>Returns the absolute name for this element</pre></div></div><div id='d_Ed' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><pre>Returns the local name for this referencable element</pre></div></div><div id='d_Fd' class='de'><h1>Method <span class='n'>getTypeDescription</span></h1><div class='re'><code>getTypeDescription( self )</code></div><div class='ds'><pre>Returns type information (constraints) that are associated to this
		argument.</pre></div></div><div id='d_zd' class='de'><h1>Class <span class='n'>IAttribute</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Hd' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IMethod at 0x85d250c&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_Id' class='de'><h1>Method <span class='n'>addAnnotation</span></h1><div class='re'><code>addAnnotation( self, annotation )</code></div><div class='ds'><pre>Adds an annotation to this element</pre></div></div><div id='d_Jd' class='de'><h1>Method <span class='n'>addOperation</span></h1><div class='re'><code>addOperation( self, operation )</code></div><div class='ds'><pre>Adds the given operation as a child of this process.</pre></div></div><div id='d_Kd' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><pre>Performs a deep clone of this element. Any mutation to the original won't
		change the copy.</pre></div></div><div id='d_Ld' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><pre>Detaches the element from its parent (in case it was already attached).
		This should return this element, and set the parent to None.</pre></div></div><div id='d_Md' class='de'><h1>Method <span class='n'>endsWithTermination</span></h1><div class='re'><code>endsWithTermination( self )</code></div><div class='ds'><pre>Returns true if this function ends with a termination operation. This
		is especially useful for back-ends which want to know if they have to
		insert an explicit 'return' at the end (like Java).</pre></div></div><div id='d_Nd' class='de'><h1>Method <span class='n'>getAbsoluteName</span></h1><div class='re'><code>getAbsoluteName( self )</code></div><div class='ds'><pre>Returns the absolute name for this element</pre></div></div><div id='d_Od' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type for this element</pre></div></div><div id='d_Pd' class='de'><h1>Method <span class='n'>getAnnotations</span></h1><div class='re'><code>getAnnotations( self, name=None )</code></div><div class='ds'><pre>Gets all the annotation with the given name associated to this element
		or all annotations if no name is specified.</pre></div></div><div id='d_Qd' class='de'><h1>Method <span class='n'>getArguments</span></h1><div class='re'><code>getArguments( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Rd' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><pre>Returns the dataflow accessible/bound to this element</pre></div></div><div id='d_Sd' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><pre>Returns this @protocol name. It can be `None` if the @protocol is anonymous.</pre></div></div><div id='d_Td' class='de'><h1>Method <span class='n'>getOperations</span></h1><div class='re'><code>getOperations( self )</code></div><div class='ds'><pre>Returns the list of operations in this process.</pre></div></div><div id='d_Ud' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><pre>Returns this element parent</pre></div></div><div id='d_Vd' class='de'><h1>Method <span class='n'>getReturnTypeDescription</span></h1><div class='re'><code>getReturnTypeDescription( self )</code></div><div class='ds'><pre>Returns the return type description for this closure, if any</pre></div></div><div id='d_Wd' class='de'><h1>Method <span class='n'>getSlot</span></h1><div class='re'><code>getSlot( self, name )</code></div><div class='ds'><pre>Returns the given evaluable bound to named slot.</pre></div></div><div id='d_Xd' class='de'><h1>Method <span class='n'>getSlotNames</span></h1><div class='re'><code>getSlotNames( self )</code></div><div class='ds'><pre>Returns the list of slot names (in order) for this context</pre></div></div><div id='d_Yd' class='de'><h1>Method <span class='n'>getSlots</span></h1><div class='re'><code>getSlots( self )</code></div><div class='ds'><pre>Returns (key, evaluable) pairs representing the slots within this
		context. In the case of context that may inherits slots, this only
		returns the slots that are owned by the context (ie. it does not
		include inherited slots)</pre></div></div><div id='d_Zd' class='de'><h1>Method <span class='n'>hasAnnotation</span></h1><div class='re'><code>hasAnnotation( self, name )</code></div><div class='ds'><pre>Tells if the given element has an annotation with the given name</pre></div></div><div id='d_ae' class='de'><h1>Method <span class='n'>hasExplicitTermination</span></h1><div class='re'><code>hasExplicitTermination( self )</code></div><div class='ds'><pre>Returns true if this function has an operation with a termination,
		otherwise return false.</pre></div></div><div id='d_be' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><pre>Tells if this element has a parent or not</pre></div></div><div id='d_ce' class='de'><h1>Method <span class='n'>hasSlot</span></h1><div class='re'><code>hasSlot( self, name )</code></div><div class='ds'><pre>Tells if the context has a slot with the given name.</pre></div></div><div id='d_de' class='de'><h1>Method <span class='n'>isAbstract</span></h1><div class='re'><code>isAbstract( self )</code></div><div class='ds'><pre>Tells wether the given abstractable is abstract or not.</pre></div></div><div id='d_ee' class='de'><h1>Method <span class='n'>removeAnnotation</span></h1><div class='re'><code>removeAnnotation( self, name )</code></div><div class='ds'><pre>Removes the annotations with the given name</pre></div></div><div id='d_fe' class='de'><h1>Method <span class='n'>setAbstract</span></h1><div class='re'><code>setAbstract( self, isAbstract )</code></div><div class='ds'><pre>Sets wether the given abstractable is abstract or not.</pre></div></div><div id='d_ge' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><pre>Sets the abstract type for this element</pre></div></div><div id='d_he' class='de'><h1>Method <span class='n'>setArguments</span></h1><div class='re'><code>setArguments( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_ie' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><pre>Sets this element parent</pre></div></div><div id='d_je' class='de'><h1>Method <span class='n'>setReturnTypeDescription</span></h1><div class='re'><code>setReturnTypeDescription( self, description )</code></div><div class='ds'><pre>Sets the return type description for this closure, if any</pre></div></div><div id='d_ke' class='de'><h1>Method <span class='n'>setSlot</span></h1><div class='re'><code>setSlot( self, name, evaluable )</code></div><div class='ds'><pre>Binds the given evaluable to the named slot. If there is already a slot
		with the same name, then 'getSlot(name)' should return the evaluable
		given as parameter.<br />		In the default implementation, setSlot preserves the ''history'' of
		added slots, and will always return the latest one.</pre></div></div><div id='d_Gd' class='de'><h1>Class <span class='n'>IAttributeMethod</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_me' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IGroup at 0x85d244c&gt;, &lt;class lambdafactory.interfaces.IAssignable at 0x85c4ecc&gt;)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_ne' class='de'><h1>Method <span class='n'>addAnnotation</span></h1><div class='re'><code>addAnnotation( self, annotation )</code></div><div class='ds'><pre>Adds an annotation to this element</pre></div></div><div id='d_oe' class='de'><h1>Method <span class='n'>addOperation</span></h1><div class='re'><code>addOperation( self, operation )</code></div><div class='ds'><pre>Adds the given operation as a child of this process.</pre></div></div><div id='d_pe' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><pre>Performs a deep clone of this element. Any mutation to the original won't
		change the copy.</pre></div></div><div id='d_qe' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><pre>Detaches the element from its parent (in case it was already attached).
		This should return this element, and set the parent to None.</pre></div></div><div id='d_re' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type for this element</pre></div></div><div id='d_se' class='de'><h1>Method <span class='n'>getAnnotations</span></h1><div class='re'><code>getAnnotations( self, name=None )</code></div><div class='ds'><pre>Gets all the annotation with the given name associated to this element
		or all annotations if no name is specified.</pre></div></div><div id='d_te' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><pre>Returns the dataflow accessible/bound to this element</pre></div></div><div id='d_ue' class='de'><h1>Method <span class='n'>getOperations</span></h1><div class='re'><code>getOperations( self )</code></div><div class='ds'><pre>Returns the list of operations in this process.</pre></div></div><div id='d_ve' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><pre>Returns this element parent</pre></div></div><div id='d_we' class='de'><h1>Method <span class='n'>hasAnnotation</span></h1><div class='re'><code>hasAnnotation( self, name )</code></div><div class='ds'><pre>Tells if the given element has an annotation with the given name</pre></div></div><div id='d_xe' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><pre>Tells if this element has a parent or not</pre></div></div><div id='d_ye' class='de'><h1>Method <span class='n'>removeAnnotation</span></h1><div class='re'><code>removeAnnotation( self, name )</code></div><div class='ds'><pre>Removes the annotations with the given name</pre></div></div><div id='d_ze' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><pre>Sets the abstract type for this element</pre></div></div><div id='d_Ae' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><pre>Sets this element parent</pre></div></div><div id='d_le' class='de'><h1>Class <span class='n'>IBlock</span></h1><div class='re'></div><div class='ds'><pre>A block is a specific type of (sub) process.</pre></div></div><div id='d_Ce' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IInterruption at 0x85d2b0c&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_De' class='de'><h1>Method <span class='n'>addAnnotation</span></h1><div class='re'><code>addAnnotation( self, annotation )</code></div><div class='ds'><pre>Adds an annotation to this element</pre></div></div><div id='d_Ee' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><pre>Adds an argument to this operation. This should do checking of
		arguments (by expected internal type and number).</pre></div></div><div id='d_Fe' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><pre>Performs a deep clone of this element. Any mutation to the original won't
		change the copy.</pre></div></div><div id='d_Ge' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><pre>Detaches the element from its parent (in case it was already attached).
		This should return this element, and set the parent to None.</pre></div></div><div id='d_He' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type for this element</pre></div></div><div id='d_Ie' class='de'><h1>Method <span class='n'>getAnnotations</span></h1><div class='re'><code>getAnnotations( self, name=None )</code></div><div class='ds'><pre>Gets all the annotation with the given name associated to this element
		or all annotations if no name is specified.</pre></div></div><div id='d_Je' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><pre>Returns the dataflow accessible/bound to this element</pre></div></div><div id='d_Ke' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><pre>Returns the ith arguments to this operation.</pre></div></div><div id='d_Le' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><pre>Returns the arguments to this operation.</pre></div></div><div id='d_Me' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><pre>Returns the *internal types* for this operations arguments. This is
		typically the list of interfaces or @protocols that the arguments must
		comply to.</pre></div></div><div id='d_Ne' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><pre>Returns this element parent</pre></div></div><div id='d_Oe' class='de'><h1>Method <span class='n'>hasAnnotation</span></h1><div class='re'><code>hasAnnotation( self, name )</code></div><div class='ds'><pre>Tells if the given element has an annotation with the given name</pre></div></div><div id='d_Pe' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><pre>Tells if this element has a parent or not</pre></div></div><div id='d_Qe' class='de'><h1>Method <span class='n'>removeAnnotation</span></h1><div class='re'><code>removeAnnotation( self, name )</code></div><div class='ds'><pre>Removes the annotations with the given name</pre></div></div><div id='d_Re' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><pre>Sets the abstract type for this element</pre></div></div><div id='d_Se' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><pre>Sets the given argument of this operation, by argument index.</pre></div></div><div id='d_Te' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><pre>Sets this element parent</pre></div></div><div id='d_Ue' class='de'><h1>list</h1><div class='re'><code>[]</code></div><div class='ds'><pre>list() -&gt; new list
list(sequence) -&gt; new list initialized from sequence's items</pre></div></div><div id='d_Be' class='de'><h1>Class <span class='n'>IBreaking</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_We' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IContext at 0x85d22fc&gt;, &lt;class lambdafactory.interfaces.IReferencable at 0x85c4efc&gt;, &lt;class lambdafactory.interfaces.IConstruct at 0x85c4e9c&gt;)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_Xe' class='de'><h1>Method <span class='n'>getAttributes</span></h1><div class='re'><code>getAttributes( self )</code></div><div class='ds'><pre>Returns the (non-class) attributes defined within this class.</pre></div></div><div id='d_Ye' class='de'><h1>Method <span class='n'>getClassAttributes</span></h1><div class='re'><code>getClassAttributes( self )</code></div><div class='ds'><pre>Returns the class attributes defined within this class.</pre></div></div><div id='d_Ze' class='de'><h1>Method <span class='n'>getClassMethods</span></h1><div class='re'><code>getClassMethods( self )</code></div><div class='ds'><pre>Returns the class method defined within this class.</pre></div></div><div id='d_af' class='de'><h1>Method <span class='n'>getConstructors</span></h1><div class='re'><code>getConstructors( self )</code></div><div class='ds'><pre>Returns the constructors for this class</pre></div></div><div id='d_bf' class='de'><h1>Method <span class='n'>getDestructors</span></h1><div class='re'><code>getDestructors( self )</code></div><div class='ds'><pre>Returns the destructors for this class</pre></div></div><div id='d_cf' class='de'><h1>Method <span class='n'>getInheritedSlots</span></h1><div class='re'><code>getInheritedSlots( self )</code></div><div class='ds'><pre>gives the list of inherited slots</pre></div></div><div id='d_df' class='de'><h1>Method <span class='n'>getInstanceMethods</span></h1><div class='re'><code>getInstanceMethods( self )</code></div><div class='ds'><pre>Returns the instance methods defined within this class.</pre></div></div><div id='d_ef' class='de'><h1>Method <span class='n'>getMethods</span></h1><div class='re'><code>getMethods( self )</code></div><div class='ds'><pre>Returns the methods defined within this class.</pre></div></div><div id='d_ff' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><pre>Returns this class name. It can be `None` if the class is anonymous.</pre></div></div><div id='d_gf' class='de'><h1>Method <span class='n'>getOperations</span></h1><div class='re'><code>getOperations( self )</code></div><div class='ds'><pre>Returns the operations (methods and class methods) defined within this class.</pre></div></div><div id='d_hf' class='de'><h1>Method <span class='n'>getParentClassesRefs</span></h1><div class='re'><code>getParentClassesRefs( self )</code></div><div class='ds'><pre>Returns the list of inherited classes references. Note that they
		have to be interpreted in the class parent (a module)</pre></div></div><div id='d_if' class='de'><h1>Method <span class='n'>setParentClasses</span></h1><div class='re'><code>setParentClasses( self )</code></div><div class='ds'><pre>gives the list of parent classes that will</pre></div></div><div id='d_jf' class='de'><h1>Method <span class='n'>addAnnotation</span></h1><div class='re'><code>addAnnotation( self, annotation )</code></div><div class='ds'><pre>Adds an annotation to this element</pre></div></div><div id='d_kf' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><pre>Performs a deep clone of this element. Any mutation to the original won't
		change the copy.</pre></div></div><div id='d_lf' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><pre>Detaches the element from its parent (in case it was already attached).
		This should return this element, and set the parent to None.</pre></div></div><div id='d_mf' class='de'><h1>Method <span class='n'>getAbsoluteName</span></h1><div class='re'><code>getAbsoluteName( self )</code></div><div class='ds'><pre>Returns the absolute name for this element</pre></div></div><div id='d_nf' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type for this element</pre></div></div><div id='d_of' class='de'><h1>Method <span class='n'>getAnnotations</span></h1><div class='re'><code>getAnnotations( self, name=None )</code></div><div class='ds'><pre>Gets all the annotation with the given name associated to this element
		or all annotations if no name is specified.</pre></div></div><div id='d_pf' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><pre>Returns the dataflow accessible/bound to this element</pre></div></div><div id='d_qf' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><pre>Returns the parent context for this context (if any)</pre></div></div><div id='d_rf' class='de'><h1>Method <span class='n'>getSlot</span></h1><div class='re'><code>getSlot( self, name )</code></div><div class='ds'><pre>Returns the given evaluable bound to named slot.</pre></div></div><div id='d_sf' class='de'><h1>Method <span class='n'>getSlotNames</span></h1><div class='re'><code>getSlotNames( self )</code></div><div class='ds'><pre>Returns the list of slot names (in order) for this context</pre></div></div><div id='d_tf' class='de'><h1>Method <span class='n'>getSlots</span></h1><div class='re'><code>getSlots( self )</code></div><div class='ds'><pre>Returns (key, evaluable) pairs representing the slots within this
		context. In the case of context that may inherits slots, this only
		returns the slots that are owned by the context (ie. it does not
		include inherited slots)</pre></div></div><div id='d_uf' class='de'><h1>Method <span class='n'>hasAnnotation</span></h1><div class='re'><code>hasAnnotation( self, name )</code></div><div class='ds'><pre>Tells if the given element has an annotation with the given name</pre></div></div><div id='d_vf' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><pre>Tells if this element has a parent or not</pre></div></div><div id='d_wf' class='de'><h1>Method <span class='n'>hasSlot</span></h1><div class='re'><code>hasSlot( self, name )</code></div><div class='ds'><pre>Tells if the context has a slot with the given name.</pre></div></div><div id='d_xf' class='de'><h1>Method <span class='n'>removeAnnotation</span></h1><div class='re'><code>removeAnnotation( self, name )</code></div><div class='ds'><pre>Removes the annotations with the given name</pre></div></div><div id='d_yf' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><pre>Sets the abstract type for this element</pre></div></div><div id='d_zf' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, context )</code></div><div class='ds'><pre>Sets the parent context for this context.</pre></div></div><div id='d_Af' class='de'><h1>Method <span class='n'>setSlot</span></h1><div class='re'><code>setSlot( self, name, evaluable )</code></div><div class='ds'><pre>Binds the given evaluable to the named slot. If there is already a slot
		with the same name, then 'getSlot(name)' should return the evaluable
		given as parameter.<br />		In the default implementation, setSlot preserves the ''history'' of
		added slots, and will always return the latest one.</pre></div></div><div id='d_Ve' class='de'><h1>Class <span class='n'>IClass</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Cf' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IAttribute at 0x85d226c&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_Df' class='de'><h1>Method <span class='n'>getAbsoluteName</span></h1><div class='re'><code>getAbsoluteName( self )</code></div><div class='ds'><pre>Returns the absolute name for this element</pre></div></div><div id='d_Ef' class='de'><h1>Method <span class='n'>getDefaultValue</span></h1><div class='re'><code>getDefaultValue( self )</code></div><div class='ds'><pre>Gets the @methodault value for this attribute</pre></div></div><div id='d_Ff' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><pre>Returns the local name for this referencable element</pre></div></div><div id='d_Gf' class='de'><h1>Method <span class='n'>getTypeDescription</span></h1><div class='re'><code>getTypeDescription( self )</code></div><div class='ds'><pre>Returns type information (constraints) that are associated to this
		argument.</pre></div></div><div id='d_Hf' class='de'><h1>Method <span class='n'>setDefaultValue</span></h1><div class='re'><code>setDefaultValue( self )</code></div><div class='ds'><pre>Sets the @methodault value for this attribute</pre></div></div><div id='d_Bf' class='de'><h1>Class <span class='n'>IClassAttribute</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Jf' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IMethod at 0x85d250c&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_Kf' class='de'><h1>Method <span class='n'>addAnnotation</span></h1><div class='re'><code>addAnnotation( self, annotation )</code></div><div class='ds'><pre>Adds an annotation to this element</pre></div></div><div id='d_Lf' class='de'><h1>Method <span class='n'>addOperation</span></h1><div class='re'><code>addOperation( self, operation )</code></div><div class='ds'><pre>Adds the given operation as a child of this process.</pre></div></div><div id='d_Mf' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><pre>Performs a deep clone of this element. Any mutation to the original won't
		change the copy.</pre></div></div><div id='d_Nf' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><pre>Detaches the element from its parent (in case it was already attached).
		This should return this element, and set the parent to None.</pre></div></div><div id='d_Of' class='de'><h1>Method <span class='n'>endsWithTermination</span></h1><div class='re'><code>endsWithTermination( self )</code></div><div class='ds'><pre>Returns true if this function ends with a termination operation. This
		is especially useful for back-ends which want to know if they have to
		insert an explicit 'return' at the end (like Java).</pre></div></div><div id='d_Pf' class='de'><h1>Method <span class='n'>getAbsoluteName</span></h1><div class='re'><code>getAbsoluteName( self )</code></div><div class='ds'><pre>Returns the absolute name for this element</pre></div></div><div id='d_Qf' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type for this element</pre></div></div><div id='d_Rf' class='de'><h1>Method <span class='n'>getAnnotations</span></h1><div class='re'><code>getAnnotations( self, name=None )</code></div><div class='ds'><pre>Gets all the annotation with the given name associated to this element
		or all annotations if no name is specified.</pre></div></div><div id='d_Sf' class='de'><h1>Method <span class='n'>getArguments</span></h1><div class='re'><code>getArguments( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Tf' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><pre>Returns the dataflow accessible/bound to this element</pre></div></div><div id='d_Uf' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><pre>Returns this @protocol name. It can be `None` if the @protocol is anonymous.</pre></div></div><div id='d_Vf' class='de'><h1>Method <span class='n'>getOperations</span></h1><div class='re'><code>getOperations( self )</code></div><div class='ds'><pre>Returns the list of operations in this process.</pre></div></div><div id='d_Wf' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><pre>Returns this element parent</pre></div></div><div id='d_Xf' class='de'><h1>Method <span class='n'>getReturnTypeDescription</span></h1><div class='re'><code>getReturnTypeDescription( self )</code></div><div class='ds'><pre>Returns the return type description for this closure, if any</pre></div></div><div id='d_Yf' class='de'><h1>Method <span class='n'>getSlot</span></h1><div class='re'><code>getSlot( self, name )</code></div><div class='ds'><pre>Returns the given evaluable bound to named slot.</pre></div></div><div id='d_Zf' class='de'><h1>Method <span class='n'>getSlotNames</span></h1><div class='re'><code>getSlotNames( self )</code></div><div class='ds'><pre>Returns the list of slot names (in order) for this context</pre></div></div><div id='d_ag' class='de'><h1>Method <span class='n'>getSlots</span></h1><div class='re'><code>getSlots( self )</code></div><div class='ds'><pre>Returns (key, evaluable) pairs representing the slots within this
		context. In the case of context that may inherits slots, this only
		returns the slots that are owned by the context (ie. it does not
		include inherited slots)</pre></div></div><div id='d_bg' class='de'><h1>Method <span class='n'>hasAnnotation</span></h1><div class='re'><code>hasAnnotation( self, name )</code></div><div class='ds'><pre>Tells if the given element has an annotation with the given name</pre></div></div><div id='d_cg' class='de'><h1>Method <span class='n'>hasExplicitTermination</span></h1><div class='re'><code>hasExplicitTermination( self )</code></div><div class='ds'><pre>Returns true if this function has an operation with a termination,
		otherwise return false.</pre></div></div><div id='d_dg' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><pre>Tells if this element has a parent or not</pre></div></div><div id='d_eg' class='de'><h1>Method <span class='n'>hasSlot</span></h1><div class='re'><code>hasSlot( self, name )</code></div><div class='ds'><pre>Tells if the context has a slot with the given name.</pre></div></div><div id='d_fg' class='de'><h1>Method <span class='n'>isAbstract</span></h1><div class='re'><code>isAbstract( self )</code></div><div class='ds'><pre>Tells wether the given abstractable is abstract or not.</pre></div></div><div id='d_gg' class='de'><h1>Method <span class='n'>removeAnnotation</span></h1><div class='re'><code>removeAnnotation( self, name )</code></div><div class='ds'><pre>Removes the annotations with the given name</pre></div></div><div id='d_hg' class='de'><h1>Method <span class='n'>setAbstract</span></h1><div class='re'><code>setAbstract( self, isAbstract )</code></div><div class='ds'><pre>Sets wether the given abstractable is abstract or not.</pre></div></div><div id='d_ig' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><pre>Sets the abstract type for this element</pre></div></div><div id='d_jg' class='de'><h1>Method <span class='n'>setArguments</span></h1><div class='re'><code>setArguments( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_kg' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><pre>Sets this element parent</pre></div></div><div id='d_lg' class='de'><h1>Method <span class='n'>setReturnTypeDescription</span></h1><div class='re'><code>setReturnTypeDescription( self, description )</code></div><div class='ds'><pre>Sets the return type description for this closure, if any</pre></div></div><div id='d_mg' class='de'><h1>Method <span class='n'>setSlot</span></h1><div class='re'><code>setSlot( self, name, evaluable )</code></div><div class='ds'><pre>Binds the given evaluable to the named slot. If there is already a slot
		with the same name, then 'getSlot(name)' should return the evaluable
		given as parameter.<br />		In the default implementation, setSlot preserves the ''history'' of
		added slots, and will always return the latest one.</pre></div></div><div id='d_If' class='de'><h1>Class <span class='n'>IClassMethod</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_og' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IProcess at 0x85d241c&gt;, &lt;class lambdafactory.interfaces.IContext at 0x85d22fc&gt;)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_pg' class='de'><h1>Method <span class='n'>getArguments</span></h1><div class='re'><code>getArguments( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_qg' class='de'><h1>Method <span class='n'>getReturnTypeDescription</span></h1><div class='re'><code>getReturnTypeDescription( self )</code></div><div class='ds'><pre>Returns the return type description for this closure, if any</pre></div></div><div id='d_rg' class='de'><h1>Method <span class='n'>setArguments</span></h1><div class='re'><code>setArguments( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_sg' class='de'><h1>Method <span class='n'>setReturnTypeDescription</span></h1><div class='re'><code>setReturnTypeDescription( self, description )</code></div><div class='ds'><pre>Sets the return type description for this closure, if any</pre></div></div><div id='d_tg' class='de'><h1>Method <span class='n'>addAnnotation</span></h1><div class='re'><code>addAnnotation( self, annotation )</code></div><div class='ds'><pre>Adds an annotation to this element</pre></div></div><div id='d_ug' class='de'><h1>Method <span class='n'>addOperation</span></h1><div class='re'><code>addOperation( self, operation )</code></div><div class='ds'><pre>Adds the given operation as a child of this process.</pre></div></div><div id='d_vg' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><pre>Performs a deep clone of this element. Any mutation to the original won't
		change the copy.</pre></div></div><div id='d_wg' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><pre>Detaches the element from its parent (in case it was already attached).
		This should return this element, and set the parent to None.</pre></div></div><div id='d_xg' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type for this element</pre></div></div><div id='d_yg' class='de'><h1>Method <span class='n'>getAnnotations</span></h1><div class='re'><code>getAnnotations( self, name=None )</code></div><div class='ds'><pre>Gets all the annotation with the given name associated to this element
		or all annotations if no name is specified.</pre></div></div><div id='d_zg' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><pre>Returns the dataflow accessible/bound to this element</pre></div></div><div id='d_Ag' class='de'><h1>Method <span class='n'>getOperations</span></h1><div class='re'><code>getOperations( self )</code></div><div class='ds'><pre>Returns the list of operations in this process.</pre></div></div><div id='d_Bg' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><pre>Returns this element parent</pre></div></div><div id='d_Cg' class='de'><h1>Method <span class='n'>getSlot</span></h1><div class='re'><code>getSlot( self, name )</code></div><div class='ds'><pre>Returns the given evaluable bound to named slot.</pre></div></div><div id='d_Dg' class='de'><h1>Method <span class='n'>getSlotNames</span></h1><div class='re'><code>getSlotNames( self )</code></div><div class='ds'><pre>Returns the list of slot names (in order) for this context</pre></div></div><div id='d_Eg' class='de'><h1>Method <span class='n'>getSlots</span></h1><div class='re'><code>getSlots( self )</code></div><div class='ds'><pre>Returns (key, evaluable) pairs representing the slots within this
		context. In the case of context that may inherits slots, this only
		returns the slots that are owned by the context (ie. it does not
		include inherited slots)</pre></div></div><div id='d_Fg' class='de'><h1>Method <span class='n'>hasAnnotation</span></h1><div class='re'><code>hasAnnotation( self, name )</code></div><div class='ds'><pre>Tells if the given element has an annotation with the given name</pre></div></div><div id='d_Gg' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><pre>Tells if this element has a parent or not</pre></div></div><div id='d_Hg' class='de'><h1>Method <span class='n'>hasSlot</span></h1><div class='re'><code>hasSlot( self, name )</code></div><div class='ds'><pre>Tells if the context has a slot with the given name.</pre></div></div><div id='d_Ig' class='de'><h1>Method <span class='n'>removeAnnotation</span></h1><div class='re'><code>removeAnnotation( self, name )</code></div><div class='ds'><pre>Removes the annotations with the given name</pre></div></div><div id='d_Jg' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><pre>Sets the abstract type for this element</pre></div></div><div id='d_Kg' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><pre>Sets this element parent</pre></div></div><div id='d_Lg' class='de'><h1>Method <span class='n'>setSlot</span></h1><div class='re'><code>setSlot( self, name, evaluable )</code></div><div class='ds'><pre>Binds the given evaluable to the named slot. If there is already a slot
		with the same name, then 'getSlot(name)' should return the evaluable
		given as parameter.<br />		In the default implementation, setSlot preserves the ''history'' of
		added slots, and will always return the latest one.</pre></div></div><div id='d_ng' class='de'><h1>Class <span class='n'>IClosure</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Ng' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IAnnotation at 0x85c4d1c&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_Og' class='de'><h1>Method <span class='n'>getContent</span></h1><div class='re'><code>getContent( self )</code></div><div class='ds'><pre>Returns the content of this annotation.</pre></div></div><div id='d_Pg' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><pre>Returns the name of this annotation.</pre></div></div><div id='d_Qg' class='de'><h1>Method <span class='n'>setContent</span></h1><div class='re'><code>setContent( self, content )</code></div><div class='ds'><pre>Updates the content of this annotation.</pre></div></div><div id='d_Mg' class='de'><h1>Class <span class='n'>IComment</span></h1><div class='re'></div><div class='ds'><pre>A comment is an annotation that can occur anywhere in a source file.</pre></div></div><div id='d_Sg' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IOperation at 0x85d268c&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_Tg' class='de'><h1>Method <span class='n'>getLeftOperand</span></h1><div class='re'><code>getLeftOperand( self )</code></div><div class='ds'><pre>Returns the left operand of this computation.</pre></div></div><div id='d_Ug' class='de'><h1>Method <span class='n'>getOperand</span></h1><div class='re'><code>getOperand( self )</code></div><div class='ds'><pre>Returns the left operand of this computation.</pre></div></div><div id='d_Vg' class='de'><h1>Method <span class='n'>getOperands</span></h1><div class='re'><code>getOperands( self )</code></div><div class='ds'><pre>Returns the left (and right, if any) operands of this computation.</pre></div></div><div id='d_Wg' class='de'><h1>Method <span class='n'>getOperator</span></h1><div class='re'><code>getOperator( self )</code></div><div class='ds'><pre>Gets the operator for this computation</pre></div></div><div id='d_Xg' class='de'><h1>Method <span class='n'>getRightOperand</span></h1><div class='re'><code>getRightOperand( self )</code></div><div class='ds'><pre>Returns the right operand of this computation (if any)</pre></div></div><div id='d_Yg' class='de'><h1>Method <span class='n'>setLeftOperand</span></h1><div class='re'><code>setLeftOperand( self, operand )</code></div><div class='ds'><pre>Sets the left operand of this computation.</pre></div></div><div id='d_Zg' class='de'><h1>Method <span class='n'>setOperator</span></h1><div class='re'><code>setOperator( self, operator )</code></div><div class='ds'><pre>Sets the operator for this computation</pre></div></div><div id='d_ah' class='de'><h1>Method <span class='n'>setRightOperand</span></h1><div class='re'><code>setRightOperand( self, operand )</code></div><div class='ds'><pre>Sets the right operand of this computation</pre></div></div><div id='d_bh' class='de'><h1>Method <span class='n'>addAnnotation</span></h1><div class='re'><code>addAnnotation( self, annotation )</code></div><div class='ds'><pre>Adds an annotation to this element</pre></div></div><div id='d_ch' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><pre>Adds an argument to this operation. This should do checking of
		arguments (by expected internal type and number).</pre></div></div><div id='d_dh' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><pre>Performs a deep clone of this element. Any mutation to the original won't
		change the copy.</pre></div></div><div id='d_eh' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><pre>Detaches the element from its parent (in case it was already attached).
		This should return this element, and set the parent to None.</pre></div></div><div id='d_fh' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type for this element</pre></div></div><div id='d_gh' class='de'><h1>Method <span class='n'>getAnnotations</span></h1><div class='re'><code>getAnnotations( self, name=None )</code></div><div class='ds'><pre>Gets all the annotation with the given name associated to this element
		or all annotations if no name is specified.</pre></div></div><div id='d_hh' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><pre>Returns the dataflow accessible/bound to this element</pre></div></div><div id='d_ih' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><pre>Returns the ith arguments to this operation.</pre></div></div><div id='d_jh' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><pre>Returns the arguments to this operation.</pre></div></div><div id='d_kh' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><pre>Returns the *internal types* for this operations arguments. This is
		typically the list of interfaces or @protocols that the arguments must
		comply to.</pre></div></div><div id='d_lh' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><pre>Returns this element parent</pre></div></div><div id='d_mh' class='de'><h1>Method <span class='n'>hasAnnotation</span></h1><div class='re'><code>hasAnnotation( self, name )</code></div><div class='ds'><pre>Tells if the given element has an annotation with the given name</pre></div></div><div id='d_nh' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><pre>Tells if this element has a parent or not</pre></div></div><div id='d_oh' class='de'><h1>Method <span class='n'>removeAnnotation</span></h1><div class='re'><code>removeAnnotation( self, name )</code></div><div class='ds'><pre>Removes the annotations with the given name</pre></div></div><div id='d_ph' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><pre>Sets the abstract type for this element</pre></div></div><div id='d_qh' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><pre>Sets the given argument of this operation, by argument index.</pre></div></div><div id='d_rh' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><pre>Sets this element parent</pre></div></div><div id='d_sh' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.IOperator at 0x85d21ac&gt;, &lt;class lambdafactory.interfaces.IEvaluable at 0x85c4f2c&gt;, &lt;class lambdafactory.interfaces.IEvaluable at 0x85c4f2c&gt;]</code></div><div class='ds'><pre>list() -&gt; new list
list(sequence) -&gt; new list initialized from sequence's items</pre></div></div><div id='d_Rg' class='de'><h1>Class <span class='n'>IComputation</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_th' class='de'><h1>Class <span class='n'>IConstruct</span></h1><div class='re'></div><div class='ds'><pre>A construct is a high level programming element that allows to create a
	structure and hierarchy in the program.</pre></div></div><div id='d_vh' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IMethod at 0x85d250c&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_wh' class='de'><h1>Method <span class='n'>addAnnotation</span></h1><div class='re'><code>addAnnotation( self, annotation )</code></div><div class='ds'><pre>Adds an annotation to this element</pre></div></div><div id='d_xh' class='de'><h1>Method <span class='n'>addOperation</span></h1><div class='re'><code>addOperation( self, operation )</code></div><div class='ds'><pre>Adds the given operation as a child of this process.</pre></div></div><div id='d_yh' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><pre>Performs a deep clone of this element. Any mutation to the original won't
		change the copy.</pre></div></div><div id='d_zh' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><pre>Detaches the element from its parent (in case it was already attached).
		This should return this element, and set the parent to None.</pre></div></div><div id='d_Ah' class='de'><h1>Method <span class='n'>endsWithTermination</span></h1><div class='re'><code>endsWithTermination( self )</code></div><div class='ds'><pre>Returns true if this function ends with a termination operation. This
		is especially useful for back-ends which want to know if they have to
		insert an explicit 'return' at the end (like Java).</pre></div></div><div id='d_Bh' class='de'><h1>Method <span class='n'>getAbsoluteName</span></h1><div class='re'><code>getAbsoluteName( self )</code></div><div class='ds'><pre>Returns the absolute name for this element</pre></div></div><div id='d_Ch' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type for this element</pre></div></div><div id='d_Dh' class='de'><h1>Method <span class='n'>getAnnotations</span></h1><div class='re'><code>getAnnotations( self, name=None )</code></div><div class='ds'><pre>Gets all the annotation with the given name associated to this element
		or all annotations if no name is specified.</pre></div></div><div id='d_Eh' class='de'><h1>Method <span class='n'>getArguments</span></h1><div class='re'><code>getArguments( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Fh' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><pre>Returns the dataflow accessible/bound to this element</pre></div></div><div id='d_Gh' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><pre>Returns this @protocol name. It can be `None` if the @protocol is anonymous.</pre></div></div><div id='d_Hh' class='de'><h1>Method <span class='n'>getOperations</span></h1><div class='re'><code>getOperations( self )</code></div><div class='ds'><pre>Returns the list of operations in this process.</pre></div></div><div id='d_Ih' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><pre>Returns this element parent</pre></div></div><div id='d_Jh' class='de'><h1>Method <span class='n'>getReturnTypeDescription</span></h1><div class='re'><code>getReturnTypeDescription( self )</code></div><div class='ds'><pre>Returns the return type description for this closure, if any</pre></div></div><div id='d_Kh' class='de'><h1>Method <span class='n'>getSlot</span></h1><div class='re'><code>getSlot( self, name )</code></div><div class='ds'><pre>Returns the given evaluable bound to named slot.</pre></div></div><div id='d_Lh' class='de'><h1>Method <span class='n'>getSlotNames</span></h1><div class='re'><code>getSlotNames( self )</code></div><div class='ds'><pre>Returns the list of slot names (in order) for this context</pre></div></div><div id='d_Mh' class='de'><h1>Method <span class='n'>getSlots</span></h1><div class='re'><code>getSlots( self )</code></div><div class='ds'><pre>Returns (key, evaluable) pairs representing the slots within this
		context. In the case of context that may inherits slots, this only
		returns the slots that are owned by the context (ie. it does not
		include inherited slots)</pre></div></div><div id='d_Nh' class='de'><h1>Method <span class='n'>hasAnnotation</span></h1><div class='re'><code>hasAnnotation( self, name )</code></div><div class='ds'><pre>Tells if the given element has an annotation with the given name</pre></div></div><div id='d_Oh' class='de'><h1>Method <span class='n'>hasExplicitTermination</span></h1><div class='re'><code>hasExplicitTermination( self )</code></div><div class='ds'><pre>Returns true if this function has an operation with a termination,
		otherwise return false.</pre></div></div><div id='d_Ph' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><pre>Tells if this element has a parent or not</pre></div></div><div id='d_Qh' class='de'><h1>Method <span class='n'>hasSlot</span></h1><div class='re'><code>hasSlot( self, name )</code></div><div class='ds'><pre>Tells if the context has a slot with the given name.</pre></div></div><div id='d_Rh' class='de'><h1>Method <span class='n'>isAbstract</span></h1><div class='re'><code>isAbstract( self )</code></div><div class='ds'><pre>Tells wether the given abstractable is abstract or not.</pre></div></div><div id='d_Sh' class='de'><h1>Method <span class='n'>removeAnnotation</span></h1><div class='re'><code>removeAnnotation( self, name )</code></div><div class='ds'><pre>Removes the annotations with the given name</pre></div></div><div id='d_Th' class='de'><h1>Method <span class='n'>setAbstract</span></h1><div class='re'><code>setAbstract( self, isAbstract )</code></div><div class='ds'><pre>Sets wether the given abstractable is abstract or not.</pre></div></div><div id='d_Uh' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><pre>Sets the abstract type for this element</pre></div></div><div id='d_Vh' class='de'><h1>Method <span class='n'>setArguments</span></h1><div class='re'><code>setArguments( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Wh' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><pre>Sets this element parent</pre></div></div><div id='d_Xh' class='de'><h1>Method <span class='n'>setReturnTypeDescription</span></h1><div class='re'><code>setReturnTypeDescription( self, description )</code></div><div class='ds'><pre>Sets the return type description for this closure, if any</pre></div></div><div id='d_Yh' class='de'><h1>Method <span class='n'>setSlot</span></h1><div class='re'><code>setSlot( self, name, evaluable )</code></div><div class='ds'><pre>Binds the given evaluable to the named slot. If there is already a slot
		with the same name, then 'getSlot(name)' should return the evaluable
		given as parameter.<br />		In the default implementation, setSlot preserves the ''history'' of
		added slots, and will always return the latest one.</pre></div></div><div id='d_uh' class='de'><h1>Class <span class='n'>IConstructor</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_ai' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IElement at 0x85c4e6c&gt;, &lt;class lambdafactory.interfaces.IDataFlowOwner at 0x85c4e3c&gt;)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_bi' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><pre>Returns the parent context for this context (if any)</pre></div></div><div id='d_ci' class='de'><h1>Method <span class='n'>getSlot</span></h1><div class='re'><code>getSlot( self, name )</code></div><div class='ds'><pre>Returns the given evaluable bound to named slot.</pre></div></div><div id='d_di' class='de'><h1>Method <span class='n'>getSlotNames</span></h1><div class='re'><code>getSlotNames( self )</code></div><div class='ds'><pre>Returns the list of slot names (in order) for this context</pre></div></div><div id='d_ei' class='de'><h1>Method <span class='n'>getSlots</span></h1><div class='re'><code>getSlots( self )</code></div><div class='ds'><pre>Returns (key, evaluable) pairs representing the slots within this
		context. In the case of context that may inherits slots, this only
		returns the slots that are owned by the context (ie. it does not
		include inherited slots)</pre></div></div><div id='d_fi' class='de'><h1>Method <span class='n'>hasSlot</span></h1><div class='re'><code>hasSlot( self, name )</code></div><div class='ds'><pre>Tells if the context has a slot with the given name.</pre></div></div><div id='d_gi' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, context )</code></div><div class='ds'><pre>Sets the parent context for this context.</pre></div></div><div id='d_hi' class='de'><h1>Method <span class='n'>setSlot</span></h1><div class='re'><code>setSlot( self, name, evaluable )</code></div><div class='ds'><pre>Binds the given evaluable to the named slot. If there is already a slot
		with the same name, then 'getSlot(name)' should return the evaluable
		given as parameter.<br />		In the default implementation, setSlot preserves the ''history'' of
		added slots, and will always return the latest one.</pre></div></div><div id='d_ii' class='de'><h1>Method <span class='n'>addAnnotation</span></h1><div class='re'><code>addAnnotation( self, annotation )</code></div><div class='ds'><pre>Adds an annotation to this element</pre></div></div><div id='d_ji' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><pre>Performs a deep clone of this element. Any mutation to the original won't
		change the copy.</pre></div></div><div id='d_ki' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><pre>Detaches the element from its parent (in case it was already attached).
		This should return this element, and set the parent to None.</pre></div></div><div id='d_li' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type for this element</pre></div></div><div id='d_mi' class='de'><h1>Method <span class='n'>getAnnotations</span></h1><div class='re'><code>getAnnotations( self, name=None )</code></div><div class='ds'><pre>Gets all the annotation with the given name associated to this element
		or all annotations if no name is specified.</pre></div></div><div id='d_ni' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><pre>Returns the dataflow accessible/bound to this element</pre></div></div><div id='d_oi' class='de'><h1>Method <span class='n'>hasAnnotation</span></h1><div class='re'><code>hasAnnotation( self, name )</code></div><div class='ds'><pre>Tells if the given element has an annotation with the given name</pre></div></div><div id='d_pi' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><pre>Tells if this element has a parent or not</pre></div></div><div id='d_qi' class='de'><h1>Method <span class='n'>removeAnnotation</span></h1><div class='re'><code>removeAnnotation( self, name )</code></div><div class='ds'><pre>Removes the annotations with the given name</pre></div></div><div id='d_ri' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><pre>Sets the abstract type for this element</pre></div></div><div id='d_Zh' class='de'><h1>Class <span class='n'>IContext</span></h1><div class='re'></div><div class='ds'><pre>A context is an element that has slots, which bind evaluable elements
	(aka values) to names. Slots should be ordered, preserving the order in
	which they were added.</pre></div></div><div id='d_ti' class='de'><h1>Method <span class='n'>addChild</span></h1><div class='re'><code>addChild( self, child )</code></div><div class='ds'><pre>Adds the given dataflow as a child of this dataflow.</pre></div></div><div id='d_ui' class='de'><h1>Method <span class='n'>addDestination</span></h1><div class='re'><code>addDestination( self, dataflow )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_vi' class='de'><h1>Method <span class='n'>addSource</span></h1><div class='re'><code>addSource( self, dataflow )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_wi' class='de'><h1>Method <span class='n'>declareArgument</span></h1><div class='re'><code>declareArgument( self, name, value )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_xi' class='de'><h1>Method <span class='n'>declareEnvironment</span></h1><div class='re'><code>declareEnvironment( self, name, value )</code></div><div class='ds'><pre>Declares an environment variable with the given name, value
		and origin.</pre></div></div><div id='d_yi' class='de'><h1>Method <span class='n'>declareVariable</span></h1><div class='re'><code>declareVariable( self, name, value, origin=None )</code></div><div class='ds'><pre>Declares a (local) variable with the given name, value and
		origin</pre></div></div><div id='d_zi' class='de'><h1>Method <span class='n'>defines</span></h1><div class='re'><code>defines( self, name )</code></div><div class='ds'><pre>Tells if this dataflow, or any of its child dataflows defines
		the given name (symbol)</pre></div></div><div id='d_Ai' class='de'><h1>Method <span class='n'>getChildren</span></h1><div class='re'><code>getChildren( self )</code></div><div class='ds'><pre>Returns a list of the child dataflows for this dataflow.</pre></div></div><div id='d_Bi' class='de'><h1>Method <span class='n'>getDestinations</span></h1><div class='re'><code>getDestinations( self )</code></div><div class='ds'><pre>Returns the dataflows that are _destinations_, meaning that these
		dataflows will resolve if this dataflow if resolution fails, according tot
		the resolution scheme used.</pre></div></div><div id='d_Ci' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><pre>Returns the list of parent dataflows for this dataflow.</pre></div></div><div id='d_Di' class='de'><h1>Method <span class='n'>getRoot</span></h1><div class='re'><code>getRoot( self )</code></div><div class='ds'><pre>Returns the root of this dataflow (the root of the parent or this dataflow
		if it has no parent)</pre></div></div><div id='d_Ei' class='de'><h1>Method <span class='n'>getSlot</span></h1><div class='re'><code>getSlot( self, name )</code></div><div class='ds'><pre>Returns the slot with the given name, if any.</pre></div></div><div id='d_Fi' class='de'><h1>Method <span class='n'>getSlots</span></h1><div class='re'><code>getSlots( self )</code></div><div class='ds'><pre>Returns the list of slots defined for this dataflow.</pre></div></div><div id='d_Gi' class='de'><h1>Method <span class='n'>getSources</span></h1><div class='re'><code>getSources( self )</code></div><div class='ds'><pre>Returns the dataflows that are _sources_, meaning that if a slot is not
		resolved by this dataflow, it will look in the parent and then in the
		sources (depending on the resolution scheme, but this is the default)</pre></div></div><div id='d_Hi' class='de'><h1>Method <span class='n'>hasSlot</span></h1><div class='re'><code>hasSlot( self, name )</code></div><div class='ds'><pre>Tells if this dataflow defines slot with the given name.</pre></div></div><div id='d_Ii' class='de'><h1>Method <span class='n'>resolve</span></h1><div class='re'><code>resolve( self, name )</code></div><div class='ds'><pre>Returns a couple '(DataFlow slot, IElement)' or '(None,None)'
		corresponding to the resolution of the given 'name' in this dataflow.</pre></div></div><div id='d_Ji' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, parent )</code></div><div class='ds'><pre>Add the given dataflow as a parent of this dataflow.</pre></div></div><div id='d_si' class='de'><h1>Class <span class='n'>IDataFlow</span></h1><div class='re'></div><div class='ds'><pre>The DataFlow are ''dynamic contexts'' bound to the various program model
	elements. DataFlows are typically owned by elements which implement
	'IContext', and are linked together by rules defined in the 'Resolver'
	@protocol.<br />	The dataflow bound to most expressions is the one of the enclosing closure
	(whether it is a function, or method. The dataflow of a method is bound to
	its parent @protocol, which dataflow is also bound to the parent @protocol dataflow.<br />	While 'DataFlow' and 'Context' may appear very similar, they are not the
	same: contexts are elements that keep track of declared slots, while the
	dataflow make use of the context to weave the elements togeher.</pre></div></div><div id='d_Ki' class='de'><h1>Class <span class='n'>IDataFlowOwner</span></h1><div class='re'></div><div class='ds'><pre>DataFlow owners are elements that have their own dataflow. IContext are
	typical examples of elements that are dataflow owners</pre></div></div><div id='d_Mi' class='de'><h1>Method <span class='n'>addOperation</span></h1><div class='re'><code>addOperation( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Ni' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Oi' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Pi' class='de'><h1>Method <span class='n'>getOperations</span></h1><div class='re'><code>getOperations( self )</code></div><div class='ds'><pre>Returns the (ordered) list of operations that affected the slot.
		Operations usually constrain the dataflow abstract type, and
		exception/warnings/errors may be raised by the type system
		when a type constraint fails.</pre></div></div><div id='d_Qi' class='de'><h1>Method <span class='n'>getOrigin</span></h1><div class='re'><code>getOrigin( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Ri' class='de'><h1>Method <span class='n'>getOriginalValue</span></h1><div class='re'><code>getOriginalValue( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Li' class='de'><h1>Class <span class='n'>IDataFlowSlot</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Ti' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IMethod at 0x85d250c&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_Ui' class='de'><h1>Method <span class='n'>addAnnotation</span></h1><div class='re'><code>addAnnotation( self, annotation )</code></div><div class='ds'><pre>Adds an annotation to this element</pre></div></div><div id='d_Vi' class='de'><h1>Method <span class='n'>addOperation</span></h1><div class='re'><code>addOperation( self, operation )</code></div><div class='ds'><pre>Adds the given operation as a child of this process.</pre></div></div><div id='d_Wi' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><pre>Performs a deep clone of this element. Any mutation to the original won't
		change the copy.</pre></div></div><div id='d_Xi' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><pre>Detaches the element from its parent (in case it was already attached).
		This should return this element, and set the parent to None.</pre></div></div><div id='d_Yi' class='de'><h1>Method <span class='n'>endsWithTermination</span></h1><div class='re'><code>endsWithTermination( self )</code></div><div class='ds'><pre>Returns true if this function ends with a termination operation. This
		is especially useful for back-ends which want to know if they have to
		insert an explicit 'return' at the end (like Java).</pre></div></div><div id='d_Zi' class='de'><h1>Method <span class='n'>getAbsoluteName</span></h1><div class='re'><code>getAbsoluteName( self )</code></div><div class='ds'><pre>Returns the absolute name for this element</pre></div></div><div id='d_aj' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type for this element</pre></div></div><div id='d_bj' class='de'><h1>Method <span class='n'>getAnnotations</span></h1><div class='re'><code>getAnnotations( self, name=None )</code></div><div class='ds'><pre>Gets all the annotation with the given name associated to this element
		or all annotations if no name is specified.</pre></div></div><div id='d_cj' class='de'><h1>Method <span class='n'>getArguments</span></h1><div class='re'><code>getArguments( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_dj' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><pre>Returns the dataflow accessible/bound to this element</pre></div></div><div id='d_ej' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><pre>Returns this @protocol name. It can be `None` if the @protocol is anonymous.</pre></div></div><div id='d_fj' class='de'><h1>Method <span class='n'>getOperations</span></h1><div class='re'><code>getOperations( self )</code></div><div class='ds'><pre>Returns the list of operations in this process.</pre></div></div><div id='d_gj' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><pre>Returns this element parent</pre></div></div><div id='d_hj' class='de'><h1>Method <span class='n'>getReturnTypeDescription</span></h1><div class='re'><code>getReturnTypeDescription( self )</code></div><div class='ds'><pre>Returns the return type description for this closure, if any</pre></div></div><div id='d_ij' class='de'><h1>Method <span class='n'>getSlot</span></h1><div class='re'><code>getSlot( self, name )</code></div><div class='ds'><pre>Returns the given evaluable bound to named slot.</pre></div></div><div id='d_jj' class='de'><h1>Method <span class='n'>getSlotNames</span></h1><div class='re'><code>getSlotNames( self )</code></div><div class='ds'><pre>Returns the list of slot names (in order) for this context</pre></div></div><div id='d_kj' class='de'><h1>Method <span class='n'>getSlots</span></h1><div class='re'><code>getSlots( self )</code></div><div class='ds'><pre>Returns (key, evaluable) pairs representing the slots within this
		context. In the case of context that may inherits slots, this only
		returns the slots that are owned by the context (ie. it does not
		include inherited slots)</pre></div></div><div id='d_lj' class='de'><h1>Method <span class='n'>hasAnnotation</span></h1><div class='re'><code>hasAnnotation( self, name )</code></div><div class='ds'><pre>Tells if the given element has an annotation with the given name</pre></div></div><div id='d_mj' class='de'><h1>Method <span class='n'>hasExplicitTermination</span></h1><div class='re'><code>hasExplicitTermination( self )</code></div><div class='ds'><pre>Returns true if this function has an operation with a termination,
		otherwise return false.</pre></div></div><div id='d_nj' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><pre>Tells if this element has a parent or not</pre></div></div><div id='d_oj' class='de'><h1>Method <span class='n'>hasSlot</span></h1><div class='re'><code>hasSlot( self, name )</code></div><div class='ds'><pre>Tells if the context has a slot with the given name.</pre></div></div><div id='d_pj' class='de'><h1>Method <span class='n'>isAbstract</span></h1><div class='re'><code>isAbstract( self )</code></div><div class='ds'><pre>Tells wether the given abstractable is abstract or not.</pre></div></div><div id='d_qj' class='de'><h1>Method <span class='n'>removeAnnotation</span></h1><div class='re'><code>removeAnnotation( self, name )</code></div><div class='ds'><pre>Removes the annotations with the given name</pre></div></div><div id='d_rj' class='de'><h1>Method <span class='n'>setAbstract</span></h1><div class='re'><code>setAbstract( self, isAbstract )</code></div><div class='ds'><pre>Sets wether the given abstractable is abstract or not.</pre></div></div><div id='d_sj' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><pre>Sets the abstract type for this element</pre></div></div><div id='d_tj' class='de'><h1>Method <span class='n'>setArguments</span></h1><div class='re'><code>setArguments( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_uj' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><pre>Sets this element parent</pre></div></div><div id='d_vj' class='de'><h1>Method <span class='n'>setReturnTypeDescription</span></h1><div class='re'><code>setReturnTypeDescription( self, description )</code></div><div class='ds'><pre>Sets the return type description for this closure, if any</pre></div></div><div id='d_wj' class='de'><h1>Method <span class='n'>setSlot</span></h1><div class='re'><code>setSlot( self, name, evaluable )</code></div><div class='ds'><pre>Binds the given evaluable to the named slot. If there is already a slot
		with the same name, then 'getSlot(name)' should return the evaluable
		given as parameter.<br />		In the default implementation, setSlot preserves the ''history'' of
		added slots, and will always return the latest one.</pre></div></div><div id='d_Si' class='de'><h1>Class <span class='n'>IDestructor</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_yj' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IValue at 0x85d202c&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_zj' class='de'><h1>Method <span class='n'>getItems</span></h1><div class='re'><code>getItems( self )</code></div><div class='ds'><pre>Returns the items contained in this dict</pre></div></div><div id='d_Aj' class='de'><h1>Method <span class='n'>setValue</span></h1><div class='re'><code>setValue( self, key, value )</code></div><div class='ds'><pre>Sets the value to be associated to the given key (which must be an
		evaluable).</pre></div></div><div id='d_Bj' class='de'><h1>Method <span class='n'>addAnnotation</span></h1><div class='re'><code>addAnnotation( self, annotation )</code></div><div class='ds'><pre>Adds an annotation to this element</pre></div></div><div id='d_Cj' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><pre>Performs a deep clone of this element. Any mutation to the original won't
		change the copy.</pre></div></div><div id='d_Dj' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><pre>Detaches the element from its parent (in case it was already attached).
		This should return this element, and set the parent to None.</pre></div></div><div id='d_Ej' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type for this element</pre></div></div><div id='d_Fj' class='de'><h1>Method <span class='n'>getAnnotations</span></h1><div class='re'><code>getAnnotations( self, name=None )</code></div><div class='ds'><pre>Gets all the annotation with the given name associated to this element
		or all annotations if no name is specified.</pre></div></div><div id='d_Gj' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><pre>Returns the dataflow accessible/bound to this element</pre></div></div><div id='d_Hj' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><pre>Returns this element parent</pre></div></div><div id='d_Ij' class='de'><h1>Method <span class='n'>getResultAbstractType</span></h1><div class='re'><code>getResultAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type of the result of the evaluation of this
		evaluable</pre></div></div><div id='d_Jj' class='de'><h1>Method <span class='n'>hasAnnotation</span></h1><div class='re'><code>hasAnnotation( self, name )</code></div><div class='ds'><pre>Tells if the given element has an annotation with the given name</pre></div></div><div id='d_Kj' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><pre>Tells if this element has a parent or not</pre></div></div><div id='d_Lj' class='de'><h1>Method <span class='n'>removeAnnotation</span></h1><div class='re'><code>removeAnnotation( self, name )</code></div><div class='ds'><pre>Removes the annotations with the given name</pre></div></div><div id='d_Mj' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><pre>Sets the abstract type for this element</pre></div></div><div id='d_Nj' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><pre>Sets this element parent</pre></div></div><div id='d_Oj' class='de'><h1>Method <span class='n'>setResultAbstractType</span></h1><div class='re'><code>setResultAbstractType( self, abstractType )</code></div><div class='ds'><pre>Sets the abstract type for this operation result. This is usually
		invoked in the typing phase.</pre></div></div><div id='d_xj' class='de'><h1>Class <span class='n'>IDict</span></h1><div class='re'></div><div class='ds'><pre>A dictionary is a binding of key to values. It may or may not be ordered,
	depending on the implementation/model semantics.</pre></div></div><div id='d_Qj' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IAnnotation at 0x85c4d1c&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_Rj' class='de'><h1>Method <span class='n'>getContent</span></h1><div class='re'><code>getContent( self )</code></div><div class='ds'><pre>Returns the content of this annotation.</pre></div></div><div id='d_Sj' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><pre>Returns the name of this annotation.</pre></div></div><div id='d_Tj' class='de'><h1>Method <span class='n'>setContent</span></h1><div class='re'><code>setContent( self, content )</code></div><div class='ds'><pre>Updates the content of this annotation.</pre></div></div><div id='d_Pj' class='de'><h1>Class <span class='n'>IDocumentation</span></h1><div class='re'></div><div class='ds'><pre>Documentation is often attached to various language elements.
	Documentation can be found in coments (as in Java), or be directly embedded
	as values (as in Python).</pre></div></div><div id='d_Vj' class='de'><h1>Method <span class='n'>addAnnotation</span></h1><div class='re'><code>addAnnotation( self, annotation )</code></div><div class='ds'><pre>Adds an annotation to this element</pre></div></div><div id='d_Wj' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><pre>Performs a deep clone of this element. Any mutation to the original won't
		change the copy.</pre></div></div><div id='d_Xj' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><pre>Detaches the element from its parent (in case it was already attached).
		This should return this element, and set the parent to None.</pre></div></div><div id='d_Yj' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type for this element</pre></div></div><div id='d_Zj' class='de'><h1>Method <span class='n'>getAnnotations</span></h1><div class='re'><code>getAnnotations( self, name=None )</code></div><div class='ds'><pre>Gets all the annotation with the given name associated to this element
		or all annotations if no name is specified.</pre></div></div><div id='d_ak' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><pre>Returns the dataflow accessible/bound to this element</pre></div></div><div id='d_bk' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><pre>Returns this element parent</pre></div></div><div id='d_ck' class='de'><h1>Method <span class='n'>hasAnnotation</span></h1><div class='re'><code>hasAnnotation( self, name )</code></div><div class='ds'><pre>Tells if the given element has an annotation with the given name</pre></div></div><div id='d_dk' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><pre>Tells if this element has a parent or not</pre></div></div><div id='d_ek' class='de'><h1>Method <span class='n'>removeAnnotation</span></h1><div class='re'><code>removeAnnotation( self, name )</code></div><div class='ds'><pre>Removes the annotations with the given name</pre></div></div><div id='d_fk' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><pre>Sets the abstract type for this element</pre></div></div><div id='d_gk' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><pre>Sets this element parent</pre></div></div><div id='d_Uj' class='de'><h1>Class <span class='n'>IElement</span></h1><div class='re'></div><div class='ds'><pre>The core @protocol for every element.</pre></div></div><div id='d_ik' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IOperation at 0x85d268c&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_jk' class='de'><h1>Method <span class='n'>getCode</span></h1><div class='re'><code>getCode( self )</code></div><div class='ds'><pre>Returns the embedded code string.</pre></div></div><div id='d_kk' class='de'><h1>Method <span class='n'>getLanguage</span></h1><div class='re'><code>getLanguage( self )</code></div><div class='ds'><pre>Returns the language in which the emebedded code is written.</pre></div></div><div id='d_lk' class='de'><h1>Method <span class='n'>setCode</span></h1><div class='re'><code>setCode( self, code )</code></div><div class='ds'><pre>Sets the code of this embed operation.</pre></div></div><div id='d_mk' class='de'><h1>Method <span class='n'>setLanguage</span></h1><div class='re'><code>setLanguage( self, language )</code></div><div class='ds'><pre>Sets the language in which the emebedded code is written.</pre></div></div><div id='d_nk' class='de'><h1>Method <span class='n'>addAnnotation</span></h1><div class='re'><code>addAnnotation( self, annotation )</code></div><div class='ds'><pre>Adds an annotation to this element</pre></div></div><div id='d_ok' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><pre>Adds an argument to this operation. This should do checking of
		arguments (by expected internal type and number).</pre></div></div><div id='d_pk' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><pre>Performs a deep clone of this element. Any mutation to the original won't
		change the copy.</pre></div></div><div id='d_qk' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><pre>Detaches the element from its parent (in case it was already attached).
		This should return this element, and set the parent to None.</pre></div></div><div id='d_rk' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type for this element</pre></div></div><div id='d_sk' class='de'><h1>Method <span class='n'>getAnnotations</span></h1><div class='re'><code>getAnnotations( self, name=None )</code></div><div class='ds'><pre>Gets all the annotation with the given name associated to this element
		or all annotations if no name is specified.</pre></div></div><div id='d_tk' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><pre>Returns the dataflow accessible/bound to this element</pre></div></div><div id='d_uk' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><pre>Returns the ith arguments to this operation.</pre></div></div><div id='d_vk' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><pre>Returns the arguments to this operation.</pre></div></div><div id='d_wk' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><pre>Returns the *internal types* for this operations arguments. This is
		typically the list of interfaces or @protocols that the arguments must
		comply to.</pre></div></div><div id='d_xk' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><pre>Returns this element parent</pre></div></div><div id='d_yk' class='de'><h1>Method <span class='n'>hasAnnotation</span></h1><div class='re'><code>hasAnnotation( self, name )</code></div><div class='ds'><pre>Tells if the given element has an annotation with the given name</pre></div></div><div id='d_zk' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><pre>Tells if this element has a parent or not</pre></div></div><div id='d_Ak' class='de'><h1>Method <span class='n'>removeAnnotation</span></h1><div class='re'><code>removeAnnotation( self, name )</code></div><div class='ds'><pre>Removes the annotations with the given name</pre></div></div><div id='d_Bk' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><pre>Sets the abstract type for this element</pre></div></div><div id='d_Ck' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><pre>Sets the given argument of this operation, by argument index.</pre></div></div><div id='d_Dk' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><pre>Sets this element parent</pre></div></div><div id='d_Ek' class='de'><h1>list</h1><div class='re'><code>[]</code></div><div class='ds'><pre>list() -&gt; new list
list(sequence) -&gt; new list initialized from sequence's items</pre></div></div><div id='d_hk' class='de'><h1>Class <span class='n'>IEmbed</span></h1><div class='re'></div><div class='ds'><pre>An embedded operation represents a bit of verbatim code written in
	a different language. This allows for embedding code written specifically
	in a target language (which may happen for optimizing stuff, for instance).</pre></div></div><div id='d_Gk' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IEmbed at 0x85d2bcc&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_Hk' class='de'><h1>Method <span class='n'>addAnnotation</span></h1><div class='re'><code>addAnnotation( self, annotation )</code></div><div class='ds'><pre>Adds an annotation to this element</pre></div></div><div id='d_Ik' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><pre>Adds an argument to this operation. This should do checking of
		arguments (by expected internal type and number).</pre></div></div><div id='d_Jk' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><pre>Performs a deep clone of this element. Any mutation to the original won't
		change the copy.</pre></div></div><div id='d_Kk' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><pre>Detaches the element from its parent (in case it was already attached).
		This should return this element, and set the parent to None.</pre></div></div><div id='d_Lk' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type for this element</pre></div></div><div id='d_Mk' class='de'><h1>Method <span class='n'>getAnnotations</span></h1><div class='re'><code>getAnnotations( self, name=None )</code></div><div class='ds'><pre>Gets all the annotation with the given name associated to this element
		or all annotations if no name is specified.</pre></div></div><div id='d_Nk' class='de'><h1>Method <span class='n'>getCode</span></h1><div class='re'><code>getCode( self )</code></div><div class='ds'><pre>Returns the embedded code string.</pre></div></div><div id='d_Ok' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><pre>Returns the dataflow accessible/bound to this element</pre></div></div><div id='d_Pk' class='de'><h1>Method <span class='n'>getLanguage</span></h1><div class='re'><code>getLanguage( self )</code></div><div class='ds'><pre>Returns the language in which the emebedded code is written.</pre></div></div><div id='d_Qk' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><pre>Returns the ith arguments to this operation.</pre></div></div><div id='d_Rk' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><pre>Returns the arguments to this operation.</pre></div></div><div id='d_Sk' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><pre>Returns the *internal types* for this operations arguments. This is
		typically the list of interfaces or @protocols that the arguments must
		comply to.</pre></div></div><div id='d_Tk' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><pre>Returns this element parent</pre></div></div><div id='d_Uk' class='de'><h1>Method <span class='n'>hasAnnotation</span></h1><div class='re'><code>hasAnnotation( self, name )</code></div><div class='ds'><pre>Tells if the given element has an annotation with the given name</pre></div></div><div id='d_Vk' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><pre>Tells if this element has a parent or not</pre></div></div><div id='d_Wk' class='de'><h1>Method <span class='n'>removeAnnotation</span></h1><div class='re'><code>removeAnnotation( self, name )</code></div><div class='ds'><pre>Removes the annotations with the given name</pre></div></div><div id='d_Xk' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><pre>Sets the abstract type for this element</pre></div></div><div id='d_Yk' class='de'><h1>Method <span class='n'>setCode</span></h1><div class='re'><code>setCode( self, code )</code></div><div class='ds'><pre>Sets the code of this embed operation.</pre></div></div><div id='d_Zk' class='de'><h1>Method <span class='n'>setLanguage</span></h1><div class='re'><code>setLanguage( self, language )</code></div><div class='ds'><pre>Sets the language in which the emebedded code is written.</pre></div></div><div id='d_al' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><pre>Sets the given argument of this operation, by argument index.</pre></div></div><div id='d_bl' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><pre>Sets this element parent</pre></div></div><div id='d_Fk' class='de'><h1>Class <span class='n'>IEmbedTemplate</span></h1><div class='re'></div><div class='ds'><pre>The 'EmbedTemplate' is embedded ('Embed') that contains template
	expressions. It's up to the model writer to know how to expand the template
	to convert it to the target language.</pre></div></div><div id='d_dl' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IOperation at 0x85d268c&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_el' class='de'><h1>Method <span class='n'>getEnd</span></h1><div class='re'><code>getEnd( self )</code></div><div class='ds'><pre>Returns this enumeration end.</pre></div></div><div id='d_fl' class='de'><h1>Method <span class='n'>getStart</span></h1><div class='re'><code>getStart( self )</code></div><div class='ds'><pre>Returns this enumeration start.</pre></div></div><div id='d_gl' class='de'><h1>Method <span class='n'>getStep</span></h1><div class='re'><code>getStep( self )</code></div><div class='ds'><pre>Returns this enumeration step.</pre></div></div><div id='d_hl' class='de'><h1>Method <span class='n'>setStep</span></h1><div class='re'><code>setStep( self, value )</code></div><div class='ds'><pre>Sets this enumeration step</pre></div></div><div id='d_il' class='de'><h1>Method <span class='n'>addAnnotation</span></h1><div class='re'><code>addAnnotation( self, annotation )</code></div><div class='ds'><pre>Adds an annotation to this element</pre></div></div><div id='d_jl' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><pre>Adds an argument to this operation. This should do checking of
		arguments (by expected internal type and number).</pre></div></div><div id='d_kl' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><pre>Performs a deep clone of this element. Any mutation to the original won't
		change the copy.</pre></div></div><div id='d_ll' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><pre>Detaches the element from its parent (in case it was already attached).
		This should return this element, and set the parent to None.</pre></div></div><div id='d_ml' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type for this element</pre></div></div><div id='d_nl' class='de'><h1>Method <span class='n'>getAnnotations</span></h1><div class='re'><code>getAnnotations( self, name=None )</code></div><div class='ds'><pre>Gets all the annotation with the given name associated to this element
		or all annotations if no name is specified.</pre></div></div><div id='d_ol' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><pre>Returns the dataflow accessible/bound to this element</pre></div></div><div id='d_pl' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><pre>Returns the ith arguments to this operation.</pre></div></div><div id='d_ql' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><pre>Returns the arguments to this operation.</pre></div></div><div id='d_rl' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><pre>Returns the *internal types* for this operations arguments. This is
		typically the list of interfaces or @protocols that the arguments must
		comply to.</pre></div></div><div id='d_sl' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><pre>Returns this element parent</pre></div></div><div id='d_tl' class='de'><h1>Method <span class='n'>hasAnnotation</span></h1><div class='re'><code>hasAnnotation( self, name )</code></div><div class='ds'><pre>Tells if the given element has an annotation with the given name</pre></div></div><div id='d_ul' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><pre>Tells if this element has a parent or not</pre></div></div><div id='d_vl' class='de'><h1>Method <span class='n'>removeAnnotation</span></h1><div class='re'><code>removeAnnotation( self, name )</code></div><div class='ds'><pre>Removes the annotations with the given name</pre></div></div><div id='d_wl' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><pre>Sets the abstract type for this element</pre></div></div><div id='d_xl' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><pre>Sets the given argument of this operation, by argument index.</pre></div></div><div id='d_yl' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><pre>Sets this element parent</pre></div></div><div id='d_zl' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.IEvaluable at 0x85c4f2c&gt;, &lt;class lambdafactory.interfaces.IEvaluable at 0x85c4f2c&gt;, &lt;class lambdafactory.interfaces.IEvaluable at 0x85c4f2c&gt;]</code></div><div class='ds'><pre>list() -&gt; new list
list(sequence) -&gt; new list initialized from sequence's items</pre></div></div><div id='d_cl' class='de'><h1>Class <span class='n'>IEnumeration</span></h1><div class='re'></div><div class='ds'><pre>An enumeration produces values between a start and an end value, with the
	given step.</pre></div></div><div id='d_Bl' class='de'><h1>Method <span class='n'>getResultAbstractType</span></h1><div class='re'><code>getResultAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type of the result of the evaluation of this
		evaluable</pre></div></div><div id='d_Cl' class='de'><h1>Method <span class='n'>setResultAbstractType</span></h1><div class='re'><code>setResultAbstractType( self, abstractType )</code></div><div class='ds'><pre>Sets the abstract type for this operation result. This is usually
		invoked in the typing phase.</pre></div></div><div id='d_Al' class='de'><h1>Class <span class='n'>IEvaluable</span></h1><div class='re'></div><div class='ds'><pre>An evaluable is an element that can produce a value. Evaluable elements
	then have associated type information.</pre></div></div><div id='d_El' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IOperation at 0x85d268c&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_Fl' class='de'><h1>Method <span class='n'>getEvaluable</span></h1><div class='re'><code>getEvaluable( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Gl' class='de'><h1>Method <span class='n'>addAnnotation</span></h1><div class='re'><code>addAnnotation( self, annotation )</code></div><div class='ds'><pre>Adds an annotation to this element</pre></div></div><div id='d_Hl' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><pre>Adds an argument to this operation. This should do checking of
		arguments (by expected internal type and number).</pre></div></div><div id='d_Il' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><pre>Performs a deep clone of this element. Any mutation to the original won't
		change the copy.</pre></div></div><div id='d_Jl' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><pre>Detaches the element from its parent (in case it was already attached).
		This should return this element, and set the parent to None.</pre></div></div><div id='d_Kl' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type for this element</pre></div></div><div id='d_Ll' class='de'><h1>Method <span class='n'>getAnnotations</span></h1><div class='re'><code>getAnnotations( self, name=None )</code></div><div class='ds'><pre>Gets all the annotation with the given name associated to this element
		or all annotations if no name is specified.</pre></div></div><div id='d_Ml' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><pre>Returns the dataflow accessible/bound to this element</pre></div></div><div id='d_Nl' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><pre>Returns the ith arguments to this operation.</pre></div></div><div id='d_Ol' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><pre>Returns the arguments to this operation.</pre></div></div><div id='d_Pl' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><pre>Returns the *internal types* for this operations arguments. This is
		typically the list of interfaces or @protocols that the arguments must
		comply to.</pre></div></div><div id='d_Ql' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><pre>Returns this element parent</pre></div></div><div id='d_Rl' class='de'><h1>Method <span class='n'>hasAnnotation</span></h1><div class='re'><code>hasAnnotation( self, name )</code></div><div class='ds'><pre>Tells if the given element has an annotation with the given name</pre></div></div><div id='d_Sl' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><pre>Tells if this element has a parent or not</pre></div></div><div id='d_Tl' class='de'><h1>Method <span class='n'>removeAnnotation</span></h1><div class='re'><code>removeAnnotation( self, name )</code></div><div class='ds'><pre>Removes the annotations with the given name</pre></div></div><div id='d_Ul' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><pre>Sets the abstract type for this element</pre></div></div><div id='d_Vl' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><pre>Sets the given argument of this operation, by argument index.</pre></div></div><div id='d_Wl' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><pre>Sets this element parent</pre></div></div><div id='d_Xl' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.IEvaluable at 0x85c4f2c&gt;, &lt;class lambdafactory.interfaces.IEvaluable at 0x85c4f2c&gt;]</code></div><div class='ds'><pre>list() -&gt; new list
list(sequence) -&gt; new list initialized from sequence's items</pre></div></div><div id='d_Yl' class='de'><h1>list</h1><div class='re'><code>['Evaluable']</code></div><div class='ds'><pre>list() -&gt; new list
list(sequence) -&gt; new list initialized from sequence's items</pre></div></div><div id='d_Dl' class='de'><h1>Class <span class='n'>IEvaluation</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_am' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IInterruption at 0x85d2b0c&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_bm' class='de'><h1>Method <span class='n'>getValue</span></h1><div class='re'><code>getValue( self )</code></div><div class='ds'><pre>Returns the termination return evaluable.</pre></div></div><div id='d_cm' class='de'><h1>Method <span class='n'>addAnnotation</span></h1><div class='re'><code>addAnnotation( self, annotation )</code></div><div class='ds'><pre>Adds an annotation to this element</pre></div></div><div id='d_dm' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><pre>Adds an argument to this operation. This should do checking of
		arguments (by expected internal type and number).</pre></div></div><div id='d_em' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><pre>Performs a deep clone of this element. Any mutation to the original won't
		change the copy.</pre></div></div><div id='d_fm' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><pre>Detaches the element from its parent (in case it was already attached).
		This should return this element, and set the parent to None.</pre></div></div><div id='d_gm' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type for this element</pre></div></div><div id='d_hm' class='de'><h1>Method <span class='n'>getAnnotations</span></h1><div class='re'><code>getAnnotations( self, name=None )</code></div><div class='ds'><pre>Gets all the annotation with the given name associated to this element
		or all annotations if no name is specified.</pre></div></div><div id='d_im' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><pre>Returns the dataflow accessible/bound to this element</pre></div></div><div id='d_jm' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><pre>Returns the ith arguments to this operation.</pre></div></div><div id='d_km' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><pre>Returns the arguments to this operation.</pre></div></div><div id='d_lm' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><pre>Returns the *internal types* for this operations arguments. This is
		typically the list of interfaces or @protocols that the arguments must
		comply to.</pre></div></div><div id='d_mm' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><pre>Returns this element parent</pre></div></div><div id='d_nm' class='de'><h1>Method <span class='n'>hasAnnotation</span></h1><div class='re'><code>hasAnnotation( self, name )</code></div><div class='ds'><pre>Tells if the given element has an annotation with the given name</pre></div></div><div id='d_om' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><pre>Tells if this element has a parent or not</pre></div></div><div id='d_pm' class='de'><h1>Method <span class='n'>removeAnnotation</span></h1><div class='re'><code>removeAnnotation( self, name )</code></div><div class='ds'><pre>Removes the annotations with the given name</pre></div></div><div id='d_qm' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><pre>Sets the abstract type for this element</pre></div></div><div id='d_rm' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><pre>Sets the given argument of this operation, by argument index.</pre></div></div><div id='d_sm' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><pre>Sets this element parent</pre></div></div><div id='d_tm' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.IEvaluable at 0x85c4f2c&gt;]</code></div><div class='ds'><pre>list() -&gt; new list
list(sequence) -&gt; new list initialized from sequence's items</pre></div></div><div id='d_Zl' class='de'><h1>Class <span class='n'>IExcept</span></h1><div class='re'></div><div class='ds'><pre>An interruption that raises some value</pre></div></div><div id='d_vm' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IClosure at 0x85d24ac&gt;, &lt;class lambdafactory.interfaces.IReferencable at 0x85c4efc&gt;, &lt;class lambdafactory.interfaces.IAbstractable at 0x85c4fbc&gt;, &lt;class lambdafactory.interfaces.IConstruct at 0x85c4e9c&gt;)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_wm' class='de'><h1>Method <span class='n'>endsWithTermination</span></h1><div class='re'><code>endsWithTermination( self )</code></div><div class='ds'><pre>Returns true if this function ends with a termination operation. This
		is especially useful for back-ends which want to know if they have to
		insert an explicit 'return' at the end (like Java).</pre></div></div><div id='d_xm' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><pre>Returns this @protocol name. It can be `None` if the @protocol is anonymous.</pre></div></div><div id='d_ym' class='de'><h1>Method <span class='n'>hasExplicitTermination</span></h1><div class='re'><code>hasExplicitTermination( self )</code></div><div class='ds'><pre>Returns true if this function has an operation with a termination,
		otherwise return false.</pre></div></div><div id='d_zm' class='de'><h1>Method <span class='n'>addAnnotation</span></h1><div class='re'><code>addAnnotation( self, annotation )</code></div><div class='ds'><pre>Adds an annotation to this element</pre></div></div><div id='d_Am' class='de'><h1>Method <span class='n'>addOperation</span></h1><div class='re'><code>addOperation( self, operation )</code></div><div class='ds'><pre>Adds the given operation as a child of this process.</pre></div></div><div id='d_Bm' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><pre>Performs a deep clone of this element. Any mutation to the original won't
		change the copy.</pre></div></div><div id='d_Cm' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><pre>Detaches the element from its parent (in case it was already attached).
		This should return this element, and set the parent to None.</pre></div></div><div id='d_Dm' class='de'><h1>Method <span class='n'>getAbsoluteName</span></h1><div class='re'><code>getAbsoluteName( self )</code></div><div class='ds'><pre>Returns the absolute name for this element</pre></div></div><div id='d_Em' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type for this element</pre></div></div><div id='d_Fm' class='de'><h1>Method <span class='n'>getAnnotations</span></h1><div class='re'><code>getAnnotations( self, name=None )</code></div><div class='ds'><pre>Gets all the annotation with the given name associated to this element
		or all annotations if no name is specified.</pre></div></div><div id='d_Gm' class='de'><h1>Method <span class='n'>getArguments</span></h1><div class='re'><code>getArguments( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Hm' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><pre>Returns the dataflow accessible/bound to this element</pre></div></div><div id='d_Im' class='de'><h1>Method <span class='n'>getOperations</span></h1><div class='re'><code>getOperations( self )</code></div><div class='ds'><pre>Returns the list of operations in this process.</pre></div></div><div id='d_Jm' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><pre>Returns this element parent</pre></div></div><div id='d_Km' class='de'><h1>Method <span class='n'>getReturnTypeDescription</span></h1><div class='re'><code>getReturnTypeDescription( self )</code></div><div class='ds'><pre>Returns the return type description for this closure, if any</pre></div></div><div id='d_Lm' class='de'><h1>Method <span class='n'>getSlot</span></h1><div class='re'><code>getSlot( self, name )</code></div><div class='ds'><pre>Returns the given evaluable bound to named slot.</pre></div></div><div id='d_Mm' class='de'><h1>Method <span class='n'>getSlotNames</span></h1><div class='re'><code>getSlotNames( self )</code></div><div class='ds'><pre>Returns the list of slot names (in order) for this context</pre></div></div><div id='d_Nm' class='de'><h1>Method <span class='n'>getSlots</span></h1><div class='re'><code>getSlots( self )</code></div><div class='ds'><pre>Returns (key, evaluable) pairs representing the slots within this
		context. In the case of context that may inherits slots, this only
		returns the slots that are owned by the context (ie. it does not
		include inherited slots)</pre></div></div><div id='d_Om' class='de'><h1>Method <span class='n'>hasAnnotation</span></h1><div class='re'><code>hasAnnotation( self, name )</code></div><div class='ds'><pre>Tells if the given element has an annotation with the given name</pre></div></div><div id='d_Pm' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><pre>Tells if this element has a parent or not</pre></div></div><div id='d_Qm' class='de'><h1>Method <span class='n'>hasSlot</span></h1><div class='re'><code>hasSlot( self, name )</code></div><div class='ds'><pre>Tells if the context has a slot with the given name.</pre></div></div><div id='d_Rm' class='de'><h1>Method <span class='n'>isAbstract</span></h1><div class='re'><code>isAbstract( self )</code></div><div class='ds'><pre>Tells wether the given abstractable is abstract or not.</pre></div></div><div id='d_Sm' class='de'><h1>Method <span class='n'>removeAnnotation</span></h1><div class='re'><code>removeAnnotation( self, name )</code></div><div class='ds'><pre>Removes the annotations with the given name</pre></div></div><div id='d_Tm' class='de'><h1>Method <span class='n'>setAbstract</span></h1><div class='re'><code>setAbstract( self, isAbstract )</code></div><div class='ds'><pre>Sets wether the given abstractable is abstract or not.</pre></div></div><div id='d_Um' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><pre>Sets the abstract type for this element</pre></div></div><div id='d_Vm' class='de'><h1>Method <span class='n'>setArguments</span></h1><div class='re'><code>setArguments( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Wm' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><pre>Sets this element parent</pre></div></div><div id='d_Xm' class='de'><h1>Method <span class='n'>setReturnTypeDescription</span></h1><div class='re'><code>setReturnTypeDescription( self, description )</code></div><div class='ds'><pre>Sets the return type description for this closure, if any</pre></div></div><div id='d_Ym' class='de'><h1>Method <span class='n'>setSlot</span></h1><div class='re'><code>setSlot( self, name, evaluable )</code></div><div class='ds'><pre>Binds the given evaluable to the named slot. If there is already a slot
		with the same name, then 'getSlot(name)' should return the evaluable
		given as parameter.<br />		In the default implementation, setSlot preserves the ''history'' of
		added slots, and will always return the latest one.</pre></div></div><div id='d_um' class='de'><h1>Class <span class='n'>IFunction</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_an' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IProcess at 0x85d241c&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_bn' class='de'><h1>Method <span class='n'>addAnnotation</span></h1><div class='re'><code>addAnnotation( self, annotation )</code></div><div class='ds'><pre>Adds an annotation to this element</pre></div></div><div id='d_cn' class='de'><h1>Method <span class='n'>addOperation</span></h1><div class='re'><code>addOperation( self, operation )</code></div><div class='ds'><pre>Adds the given operation as a child of this process.</pre></div></div><div id='d_dn' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><pre>Performs a deep clone of this element. Any mutation to the original won't
		change the copy.</pre></div></div><div id='d_en' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><pre>Detaches the element from its parent (in case it was already attached).
		This should return this element, and set the parent to None.</pre></div></div><div id='d_fn' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type for this element</pre></div></div><div id='d_gn' class='de'><h1>Method <span class='n'>getAnnotations</span></h1><div class='re'><code>getAnnotations( self, name=None )</code></div><div class='ds'><pre>Gets all the annotation with the given name associated to this element
		or all annotations if no name is specified.</pre></div></div><div id='d_hn' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><pre>Returns the dataflow accessible/bound to this element</pre></div></div><div id='d_in' class='de'><h1>Method <span class='n'>getOperations</span></h1><div class='re'><code>getOperations( self )</code></div><div class='ds'><pre>Returns the list of operations in this process.</pre></div></div><div id='d_jn' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><pre>Returns this element parent</pre></div></div><div id='d_kn' class='de'><h1>Method <span class='n'>hasAnnotation</span></h1><div class='re'><code>hasAnnotation( self, name )</code></div><div class='ds'><pre>Tells if the given element has an annotation with the given name</pre></div></div><div id='d_ln' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><pre>Tells if this element has a parent or not</pre></div></div><div id='d_mn' class='de'><h1>Method <span class='n'>removeAnnotation</span></h1><div class='re'><code>removeAnnotation( self, name )</code></div><div class='ds'><pre>Removes the annotations with the given name</pre></div></div><div id='d_nn' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><pre>Sets the abstract type for this element</pre></div></div><div id='d_on' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><pre>Sets this element parent</pre></div></div><div id='d_Zm' class='de'><h1>Class <span class='n'>IGroup</span></h1><div class='re'></div><div class='ds'><pre>A block is a group of operations that share a common aspect. Groups
	are more likely to be used by program passes to further structure the
	program.<br />	Groups should generally not have their own context, as opposed to blocks
	which generally have a context of their own.</pre></div></div><div id='d_qn' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IImportOperation at 0x85d26bc&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_rn' class='de'><h1>Method <span class='n'>getAlias</span></h1><div class='re'><code>getAlias( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_sn' class='de'><h1>Method <span class='n'>getImportedModuleName</span></h1><div class='re'><code>getImportedModuleName( self )</code></div><div class='ds'><pre>Returns the list of names representing the modules to load</pre></div></div><div id='d_tn' class='de'><h1>Method <span class='n'>addAnnotation</span></h1><div class='re'><code>addAnnotation( self, annotation )</code></div><div class='ds'><pre>Adds an annotation to this element</pre></div></div><div id='d_un' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><pre>Adds an argument to this operation. This should do checking of
		arguments (by expected internal type and number).</pre></div></div><div id='d_vn' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><pre>Performs a deep clone of this element. Any mutation to the original won't
		change the copy.</pre></div></div><div id='d_wn' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><pre>Detaches the element from its parent (in case it was already attached).
		This should return this element, and set the parent to None.</pre></div></div><div id='d_xn' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type for this element</pre></div></div><div id='d_yn' class='de'><h1>Method <span class='n'>getAnnotations</span></h1><div class='re'><code>getAnnotations( self, name=None )</code></div><div class='ds'><pre>Gets all the annotation with the given name associated to this element
		or all annotations if no name is specified.</pre></div></div><div id='d_zn' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><pre>Returns the dataflow accessible/bound to this element</pre></div></div><div id='d_An' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><pre>Returns the ith arguments to this operation.</pre></div></div><div id='d_Bn' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><pre>Returns the arguments to this operation.</pre></div></div><div id='d_Cn' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><pre>Returns the *internal types* for this operations arguments. This is
		typically the list of interfaces or @protocols that the arguments must
		comply to.</pre></div></div><div id='d_Dn' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><pre>Returns this element parent</pre></div></div><div id='d_En' class='de'><h1>Method <span class='n'>hasAnnotation</span></h1><div class='re'><code>hasAnnotation( self, name )</code></div><div class='ds'><pre>Tells if the given element has an annotation with the given name</pre></div></div><div id='d_Fn' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><pre>Tells if this element has a parent or not</pre></div></div><div id='d_Gn' class='de'><h1>Method <span class='n'>removeAnnotation</span></h1><div class='re'><code>removeAnnotation( self, name )</code></div><div class='ds'><pre>Removes the annotations with the given name</pre></div></div><div id='d_Hn' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><pre>Sets the abstract type for this element</pre></div></div><div id='d_In' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><pre>Sets the given argument of this operation, by argument index.</pre></div></div><div id='d_Jn' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><pre>Sets this element parent</pre></div></div><div id='d_Kn' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.IEvaluable at 0x85c4f2c&gt;, &lt;class lambdafactory.interfaces.IEvaluable at 0x85c4f2c&gt;]</code></div><div class='ds'><pre>list() -&gt; new list
list(sequence) -&gt; new list initialized from sequence's items</pre></div></div><div id='d_Ln' class='de'><h1>list</h1><div class='re'><code>['ImportedModuleName', 'Alias']</code></div><div class='ds'><pre>list() -&gt; new list
list(sequence) -&gt; new list initialized from sequence's items</pre></div></div><div id='d_pn' class='de'><h1>Class <span class='n'>IImportModuleOperation</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Nn' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IImportOperation at 0x85d26bc&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_On' class='de'><h1>Method <span class='n'>getImportedModuleNames</span></h1><div class='re'><code>getImportedModuleNames( self )</code></div><div class='ds'><pre>Returns the list of names representing the modules to load</pre></div></div><div id='d_Pn' class='de'><h1>Method <span class='n'>addAnnotation</span></h1><div class='re'><code>addAnnotation( self, annotation )</code></div><div class='ds'><pre>Adds an annotation to this element</pre></div></div><div id='d_Qn' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><pre>Adds an argument to this operation. This should do checking of
		arguments (by expected internal type and number).</pre></div></div><div id='d_Rn' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><pre>Performs a deep clone of this element. Any mutation to the original won't
		change the copy.</pre></div></div><div id='d_Sn' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><pre>Detaches the element from its parent (in case it was already attached).
		This should return this element, and set the parent to None.</pre></div></div><div id='d_Tn' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type for this element</pre></div></div><div id='d_Un' class='de'><h1>Method <span class='n'>getAnnotations</span></h1><div class='re'><code>getAnnotations( self, name=None )</code></div><div class='ds'><pre>Gets all the annotation with the given name associated to this element
		or all annotations if no name is specified.</pre></div></div><div id='d_Vn' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><pre>Returns the dataflow accessible/bound to this element</pre></div></div><div id='d_Wn' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><pre>Returns the ith arguments to this operation.</pre></div></div><div id='d_Xn' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><pre>Returns the arguments to this operation.</pre></div></div><div id='d_Yn' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><pre>Returns the *internal types* for this operations arguments. This is
		typically the list of interfaces or @protocols that the arguments must
		comply to.</pre></div></div><div id='d_Zn' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><pre>Returns this element parent</pre></div></div><div id='d_ao' class='de'><h1>Method <span class='n'>hasAnnotation</span></h1><div class='re'><code>hasAnnotation( self, name )</code></div><div class='ds'><pre>Tells if the given element has an annotation with the given name</pre></div></div><div id='d_bo' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><pre>Tells if this element has a parent or not</pre></div></div><div id='d_co' class='de'><h1>Method <span class='n'>removeAnnotation</span></h1><div class='re'><code>removeAnnotation( self, name )</code></div><div class='ds'><pre>Removes the annotations with the given name</pre></div></div><div id='d_do' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><pre>Sets the abstract type for this element</pre></div></div><div id='d_eo' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><pre>Sets the given argument of this operation, by argument index.</pre></div></div><div id='d_fo' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><pre>Sets this element parent</pre></div></div><div id='d_go' class='de'><h1>list</h1><div class='re'><code>[[&lt;class lambdafactory.interfaces.IEvaluable at 0x85c4f2c&gt;]]</code></div><div class='ds'><pre>list() -&gt; new list
list(sequence) -&gt; new list initialized from sequence's items</pre></div></div><div id='d_ho' class='de'><h1>list</h1><div class='re'><code>['ImportedModuleNames']</code></div><div class='ds'><pre>list() -&gt; new list
list(sequence) -&gt; new list initialized from sequence's items</pre></div></div><div id='d_Mn' class='de'><h1>Class <span class='n'>IImportModulesOperation</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_jo' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IOperation at 0x85d268c&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_ko' class='de'><h1>Method <span class='n'>addAnnotation</span></h1><div class='re'><code>addAnnotation( self, annotation )</code></div><div class='ds'><pre>Adds an annotation to this element</pre></div></div><div id='d_lo' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><pre>Adds an argument to this operation. This should do checking of
		arguments (by expected internal type and number).</pre></div></div><div id='d_mo' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><pre>Performs a deep clone of this element. Any mutation to the original won't
		change the copy.</pre></div></div><div id='d_no' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><pre>Detaches the element from its parent (in case it was already attached).
		This should return this element, and set the parent to None.</pre></div></div><div id='d_oo' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type for this element</pre></div></div><div id='d_po' class='de'><h1>Method <span class='n'>getAnnotations</span></h1><div class='re'><code>getAnnotations( self, name=None )</code></div><div class='ds'><pre>Gets all the annotation with the given name associated to this element
		or all annotations if no name is specified.</pre></div></div><div id='d_qo' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><pre>Returns the dataflow accessible/bound to this element</pre></div></div><div id='d_ro' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><pre>Returns the ith arguments to this operation.</pre></div></div><div id='d_so' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><pre>Returns the arguments to this operation.</pre></div></div><div id='d_to' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><pre>Returns the *internal types* for this operations arguments. This is
		typically the list of interfaces or @protocols that the arguments must
		comply to.</pre></div></div><div id='d_uo' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><pre>Returns this element parent</pre></div></div><div id='d_vo' class='de'><h1>Method <span class='n'>hasAnnotation</span></h1><div class='re'><code>hasAnnotation( self, name )</code></div><div class='ds'><pre>Tells if the given element has an annotation with the given name</pre></div></div><div id='d_wo' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><pre>Tells if this element has a parent or not</pre></div></div><div id='d_xo' class='de'><h1>Method <span class='n'>removeAnnotation</span></h1><div class='re'><code>removeAnnotation( self, name )</code></div><div class='ds'><pre>Removes the annotations with the given name</pre></div></div><div id='d_yo' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><pre>Sets the abstract type for this element</pre></div></div><div id='d_zo' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><pre>Sets the given argument of this operation, by argument index.</pre></div></div><div id='d_Ao' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><pre>Sets this element parent</pre></div></div><div id='d_io' class='de'><h1>Class <span class='n'>IImportOperation</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Co' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IImportOperation at 0x85d26bc&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_Do' class='de'><h1>Method <span class='n'>getAlias</span></h1><div class='re'><code>getAlias( self )</code></div><div class='ds'><pre>Returns the (optional) alias which will allow to reference the
		element.</pre></div></div><div id='d_Eo' class='de'><h1>Method <span class='n'>getImportOrigin</span></h1><div class='re'><code>getImportOrigin( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Fo' class='de'><h1>Method <span class='n'>getImportedElement</span></h1><div class='re'><code>getImportedElement( self )</code></div><div class='ds'><pre>Returns a reference or a resolution that will allow to get the
		imported element.</pre></div></div><div id='d_Go' class='de'><h1>Method <span class='n'>addAnnotation</span></h1><div class='re'><code>addAnnotation( self, annotation )</code></div><div class='ds'><pre>Adds an annotation to this element</pre></div></div><div id='d_Ho' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><pre>Adds an argument to this operation. This should do checking of
		arguments (by expected internal type and number).</pre></div></div><div id='d_Io' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><pre>Performs a deep clone of this element. Any mutation to the original won't
		change the copy.</pre></div></div><div id='d_Jo' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><pre>Detaches the element from its parent (in case it was already attached).
		This should return this element, and set the parent to None.</pre></div></div><div id='d_Ko' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type for this element</pre></div></div><div id='d_Lo' class='de'><h1>Method <span class='n'>getAnnotations</span></h1><div class='re'><code>getAnnotations( self, name=None )</code></div><div class='ds'><pre>Gets all the annotation with the given name associated to this element
		or all annotations if no name is specified.</pre></div></div><div id='d_Mo' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><pre>Returns the dataflow accessible/bound to this element</pre></div></div><div id='d_No' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><pre>Returns the ith arguments to this operation.</pre></div></div><div id='d_Oo' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><pre>Returns the arguments to this operation.</pre></div></div><div id='d_Po' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><pre>Returns the *internal types* for this operations arguments. This is
		typically the list of interfaces or @protocols that the arguments must
		comply to.</pre></div></div><div id='d_Qo' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><pre>Returns this element parent</pre></div></div><div id='d_Ro' class='de'><h1>Method <span class='n'>hasAnnotation</span></h1><div class='re'><code>hasAnnotation( self, name )</code></div><div class='ds'><pre>Tells if the given element has an annotation with the given name</pre></div></div><div id='d_So' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><pre>Tells if this element has a parent or not</pre></div></div><div id='d_To' class='de'><h1>Method <span class='n'>removeAnnotation</span></h1><div class='re'><code>removeAnnotation( self, name )</code></div><div class='ds'><pre>Removes the annotations with the given name</pre></div></div><div id='d_Uo' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><pre>Sets the abstract type for this element</pre></div></div><div id='d_Vo' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><pre>Sets the given argument of this operation, by argument index.</pre></div></div><div id='d_Wo' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><pre>Sets this element parent</pre></div></div><div id='d_Xo' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.IEvaluable at 0x85c4f2c&gt;, &lt;class lambdafactory.interfaces.IEvaluable at 0x85c4f2c&gt;, &lt;class lambdafactory.interfaces.IEvaluable at 0x85c4f2c&gt;]</code></div><div class='ds'><pre>list() -&gt; new list
list(sequence) -&gt; new list initialized from sequence's items</pre></div></div><div id='d_Yo' class='de'><h1>list</h1><div class='re'><code>['ImportedElement', 'ImportOrigin', 'Alias']</code></div><div class='ds'><pre>list() -&gt; new list
list(sequence) -&gt; new list initialized from sequence's items</pre></div></div><div id='d_Bo' class='de'><h1>Class <span class='n'>IImportSymbolOperation</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_ap' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IImportOperation at 0x85d26bc&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_bp' class='de'><h1>Method <span class='n'>getImportOrigin</span></h1><div class='re'><code>getImportOrigin( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_cp' class='de'><h1>Method <span class='n'>getImportedElements</span></h1><div class='re'><code>getImportedElements( self )</code></div><div class='ds'><pre>Returns a reference or a resolution that will allow to get the
		imported element.</pre></div></div><div id='d_dp' class='de'><h1>Method <span class='n'>addAnnotation</span></h1><div class='re'><code>addAnnotation( self, annotation )</code></div><div class='ds'><pre>Adds an annotation to this element</pre></div></div><div id='d_ep' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><pre>Adds an argument to this operation. This should do checking of
		arguments (by expected internal type and number).</pre></div></div><div id='d_fp' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><pre>Performs a deep clone of this element. Any mutation to the original won't
		change the copy.</pre></div></div><div id='d_gp' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><pre>Detaches the element from its parent (in case it was already attached).
		This should return this element, and set the parent to None.</pre></div></div><div id='d_hp' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type for this element</pre></div></div><div id='d_ip' class='de'><h1>Method <span class='n'>getAnnotations</span></h1><div class='re'><code>getAnnotations( self, name=None )</code></div><div class='ds'><pre>Gets all the annotation with the given name associated to this element
		or all annotations if no name is specified.</pre></div></div><div id='d_jp' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><pre>Returns the dataflow accessible/bound to this element</pre></div></div><div id='d_kp' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><pre>Returns the ith arguments to this operation.</pre></div></div><div id='d_lp' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><pre>Returns the arguments to this operation.</pre></div></div><div id='d_mp' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><pre>Returns the *internal types* for this operations arguments. This is
		typically the list of interfaces or @protocols that the arguments must
		comply to.</pre></div></div><div id='d_np' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><pre>Returns this element parent</pre></div></div><div id='d_op' class='de'><h1>Method <span class='n'>hasAnnotation</span></h1><div class='re'><code>hasAnnotation( self, name )</code></div><div class='ds'><pre>Tells if the given element has an annotation with the given name</pre></div></div><div id='d_pp' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><pre>Tells if this element has a parent or not</pre></div></div><div id='d_qp' class='de'><h1>Method <span class='n'>removeAnnotation</span></h1><div class='re'><code>removeAnnotation( self, name )</code></div><div class='ds'><pre>Removes the annotations with the given name</pre></div></div><div id='d_rp' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><pre>Sets the abstract type for this element</pre></div></div><div id='d_sp' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><pre>Sets the given argument of this operation, by argument index.</pre></div></div><div id='d_tp' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><pre>Sets this element parent</pre></div></div><div id='d_up' class='de'><h1>list</h1><div class='re'><code>[[&lt;class lambdafactory.interfaces.IEvaluable at 0x85c4f2c&gt;], &lt;class lambdafactory.interfaces.IEvaluable at 0x85c4f2c&gt;]</code></div><div class='ds'><pre>list() -&gt; new list
list(sequence) -&gt; new list initialized from sequence's items</pre></div></div><div id='d_vp' class='de'><h1>list</h1><div class='re'><code>['ImportedElements', 'ImportOrigin']</code></div><div class='ds'><pre>list() -&gt; new list
list(sequence) -&gt; new list initialized from sequence's items</pre></div></div><div id='d_Zo' class='de'><h1>Class <span class='n'>IImportSymbolsOperation</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_xp' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IMethod at 0x85d250c&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_yp' class='de'><h1>Method <span class='n'>addAnnotation</span></h1><div class='re'><code>addAnnotation( self, annotation )</code></div><div class='ds'><pre>Adds an annotation to this element</pre></div></div><div id='d_zp' class='de'><h1>Method <span class='n'>addOperation</span></h1><div class='re'><code>addOperation( self, operation )</code></div><div class='ds'><pre>Adds the given operation as a child of this process.</pre></div></div><div id='d_Ap' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><pre>Performs a deep clone of this element. Any mutation to the original won't
		change the copy.</pre></div></div><div id='d_Bp' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><pre>Detaches the element from its parent (in case it was already attached).
		This should return this element, and set the parent to None.</pre></div></div><div id='d_Cp' class='de'><h1>Method <span class='n'>endsWithTermination</span></h1><div class='re'><code>endsWithTermination( self )</code></div><div class='ds'><pre>Returns true if this function ends with a termination operation. This
		is especially useful for back-ends which want to know if they have to
		insert an explicit 'return' at the end (like Java).</pre></div></div><div id='d_Dp' class='de'><h1>Method <span class='n'>getAbsoluteName</span></h1><div class='re'><code>getAbsoluteName( self )</code></div><div class='ds'><pre>Returns the absolute name for this element</pre></div></div><div id='d_Ep' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type for this element</pre></div></div><div id='d_Fp' class='de'><h1>Method <span class='n'>getAnnotations</span></h1><div class='re'><code>getAnnotations( self, name=None )</code></div><div class='ds'><pre>Gets all the annotation with the given name associated to this element
		or all annotations if no name is specified.</pre></div></div><div id='d_Gp' class='de'><h1>Method <span class='n'>getArguments</span></h1><div class='re'><code>getArguments( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Hp' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><pre>Returns the dataflow accessible/bound to this element</pre></div></div><div id='d_Ip' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><pre>Returns this @protocol name. It can be `None` if the @protocol is anonymous.</pre></div></div><div id='d_Jp' class='de'><h1>Method <span class='n'>getOperations</span></h1><div class='re'><code>getOperations( self )</code></div><div class='ds'><pre>Returns the list of operations in this process.</pre></div></div><div id='d_Kp' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><pre>Returns this element parent</pre></div></div><div id='d_Lp' class='de'><h1>Method <span class='n'>getReturnTypeDescription</span></h1><div class='re'><code>getReturnTypeDescription( self )</code></div><div class='ds'><pre>Returns the return type description for this closure, if any</pre></div></div><div id='d_Mp' class='de'><h1>Method <span class='n'>getSlot</span></h1><div class='re'><code>getSlot( self, name )</code></div><div class='ds'><pre>Returns the given evaluable bound to named slot.</pre></div></div><div id='d_Np' class='de'><h1>Method <span class='n'>getSlotNames</span></h1><div class='re'><code>getSlotNames( self )</code></div><div class='ds'><pre>Returns the list of slot names (in order) for this context</pre></div></div><div id='d_Op' class='de'><h1>Method <span class='n'>getSlots</span></h1><div class='re'><code>getSlots( self )</code></div><div class='ds'><pre>Returns (key, evaluable) pairs representing the slots within this
		context. In the case of context that may inherits slots, this only
		returns the slots that are owned by the context (ie. it does not
		include inherited slots)</pre></div></div><div id='d_Pp' class='de'><h1>Method <span class='n'>hasAnnotation</span></h1><div class='re'><code>hasAnnotation( self, name )</code></div><div class='ds'><pre>Tells if the given element has an annotation with the given name</pre></div></div><div id='d_Qp' class='de'><h1>Method <span class='n'>hasExplicitTermination</span></h1><div class='re'><code>hasExplicitTermination( self )</code></div><div class='ds'><pre>Returns true if this function has an operation with a termination,
		otherwise return false.</pre></div></div><div id='d_Rp' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><pre>Tells if this element has a parent or not</pre></div></div><div id='d_Sp' class='de'><h1>Method <span class='n'>hasSlot</span></h1><div class='re'><code>hasSlot( self, name )</code></div><div class='ds'><pre>Tells if the context has a slot with the given name.</pre></div></div><div id='d_Tp' class='de'><h1>Method <span class='n'>isAbstract</span></h1><div class='re'><code>isAbstract( self )</code></div><div class='ds'><pre>Tells wether the given abstractable is abstract or not.</pre></div></div><div id='d_Up' class='de'><h1>Method <span class='n'>removeAnnotation</span></h1><div class='re'><code>removeAnnotation( self, name )</code></div><div class='ds'><pre>Removes the annotations with the given name</pre></div></div><div id='d_Vp' class='de'><h1>Method <span class='n'>setAbstract</span></h1><div class='re'><code>setAbstract( self, isAbstract )</code></div><div class='ds'><pre>Sets wether the given abstractable is abstract or not.</pre></div></div><div id='d_Wp' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><pre>Sets the abstract type for this element</pre></div></div><div id='d_Xp' class='de'><h1>Method <span class='n'>setArguments</span></h1><div class='re'><code>setArguments( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Yp' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><pre>Sets this element parent</pre></div></div><div id='d_Zp' class='de'><h1>Method <span class='n'>setReturnTypeDescription</span></h1><div class='re'><code>setReturnTypeDescription( self, description )</code></div><div class='ds'><pre>Sets the return type description for this closure, if any</pre></div></div><div id='d_aq' class='de'><h1>Method <span class='n'>setSlot</span></h1><div class='re'><code>setSlot( self, name, evaluable )</code></div><div class='ds'><pre>Binds the given evaluable to the named slot. If there is already a slot
		with the same name, then 'getSlot(name)' should return the evaluable
		given as parameter.<br />		In the default implementation, setSlot preserves the ''history'' of
		added slots, and will always return the latest one.</pre></div></div><div id='d_wp' class='de'><h1>Class <span class='n'>IInstanceMethod</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_bq' class='de'><h1>Class <span class='n'>IInstanciable</span></h1><div class='re'></div><div class='ds'><pre>Instanciable is a property of some elements that allows them to be
	instanciated. Conceptually, an instanciation could be considered as a
	specific kind of invocation.</pre></div></div><div id='d_dq' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IOperation at 0x85d268c&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_eq' class='de'><h1>Method <span class='n'>getArguments</span></h1><div class='re'><code>getArguments( self )</code></div><div class='ds'><pre>Returns evaluable arguments.</pre></div></div><div id='d_fq' class='de'><h1>Method <span class='n'>getInstanciable</span></h1><div class='re'><code>getInstanciable( self )</code></div><div class='ds'><pre>Returns the instanciable used in this operation.</pre></div></div><div id='d_gq' class='de'><h1>Method <span class='n'>addAnnotation</span></h1><div class='re'><code>addAnnotation( self, annotation )</code></div><div class='ds'><pre>Adds an annotation to this element</pre></div></div><div id='d_hq' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><pre>Adds an argument to this operation. This should do checking of
		arguments (by expected internal type and number).</pre></div></div><div id='d_iq' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><pre>Performs a deep clone of this element. Any mutation to the original won't
		change the copy.</pre></div></div><div id='d_jq' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><pre>Detaches the element from its parent (in case it was already attached).
		This should return this element, and set the parent to None.</pre></div></div><div id='d_kq' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type for this element</pre></div></div><div id='d_lq' class='de'><h1>Method <span class='n'>getAnnotations</span></h1><div class='re'><code>getAnnotations( self, name=None )</code></div><div class='ds'><pre>Gets all the annotation with the given name associated to this element
		or all annotations if no name is specified.</pre></div></div><div id='d_mq' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><pre>Returns the dataflow accessible/bound to this element</pre></div></div><div id='d_nq' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><pre>Returns the ith arguments to this operation.</pre></div></div><div id='d_oq' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><pre>Returns the arguments to this operation.</pre></div></div><div id='d_pq' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><pre>Returns the *internal types* for this operations arguments. This is
		typically the list of interfaces or @protocols that the arguments must
		comply to.</pre></div></div><div id='d_qq' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><pre>Returns this element parent</pre></div></div><div id='d_rq' class='de'><h1>Method <span class='n'>hasAnnotation</span></h1><div class='re'><code>hasAnnotation( self, name )</code></div><div class='ds'><pre>Tells if the given element has an annotation with the given name</pre></div></div><div id='d_sq' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><pre>Tells if this element has a parent or not</pre></div></div><div id='d_tq' class='de'><h1>Method <span class='n'>removeAnnotation</span></h1><div class='re'><code>removeAnnotation( self, name )</code></div><div class='ds'><pre>Removes the annotations with the given name</pre></div></div><div id='d_uq' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><pre>Sets the abstract type for this element</pre></div></div><div id='d_vq' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><pre>Sets the given argument of this operation, by argument index.</pre></div></div><div id='d_wq' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><pre>Sets this element parent</pre></div></div><div id='d_xq' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.IEvaluable at 0x85c4f2c&gt;, [&lt;class lambdafactory.interfaces.IEvaluable at 0x85c4f2c&gt;]]</code></div><div class='ds'><pre>list() -&gt; new list
list(sequence) -&gt; new list initialized from sequence's items</pre></div></div><div id='d_cq' class='de'><h1>Class <span class='n'>IInstanciation</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_zq' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IOperation at 0x85d268c&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_Aq' class='de'><h1>Method <span class='n'>getConclusion</span></h1><div class='re'><code>getConclusion( self )</code></div><div class='ds'><pre>Returns the process that will conclude the interception (finally)</pre></div></div><div id='d_Bq' class='de'><h1>Method <span class='n'>getIntercept</span></h1><div class='re'><code>getIntercept( self )</code></div><div class='ds'><pre>Returns the process that will do the interception</pre></div></div><div id='d_Cq' class='de'><h1>Method <span class='n'>getProcess</span></h1><div class='re'><code>getProcess( self )</code></div><div class='ds'><pre>Returns the process that we will intercept interruptions from.</pre></div></div><div id='d_Dq' class='de'><h1>Method <span class='n'>setConclusion</span></h1><div class='re'><code>setConclusion( self, process )</code></div><div class='ds'><pre>Sets the process that will conclude the interception (finally)</pre></div></div><div id='d_Eq' class='de'><h1>Method <span class='n'>setIntercept</span></h1><div class='re'><code>setIntercept( self, process )</code></div><div class='ds'><pre>Sets the process that will do the interception</pre></div></div><div id='d_Fq' class='de'><h1>Method <span class='n'>setProcess</span></h1><div class='re'><code>setProcess( self, process )</code></div><div class='ds'><pre>Sets the process from which interruptions will be intercepted.</pre></div></div><div id='d_Gq' class='de'><h1>Method <span class='n'>addAnnotation</span></h1><div class='re'><code>addAnnotation( self, annotation )</code></div><div class='ds'><pre>Adds an annotation to this element</pre></div></div><div id='d_Hq' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><pre>Adds an argument to this operation. This should do checking of
		arguments (by expected internal type and number).</pre></div></div><div id='d_Iq' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><pre>Performs a deep clone of this element. Any mutation to the original won't
		change the copy.</pre></div></div><div id='d_Jq' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><pre>Detaches the element from its parent (in case it was already attached).
		This should return this element, and set the parent to None.</pre></div></div><div id='d_Kq' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type for this element</pre></div></div><div id='d_Lq' class='de'><h1>Method <span class='n'>getAnnotations</span></h1><div class='re'><code>getAnnotations( self, name=None )</code></div><div class='ds'><pre>Gets all the annotation with the given name associated to this element
		or all annotations if no name is specified.</pre></div></div><div id='d_Mq' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><pre>Returns the dataflow accessible/bound to this element</pre></div></div><div id='d_Nq' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><pre>Returns the ith arguments to this operation.</pre></div></div><div id='d_Oq' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><pre>Returns the arguments to this operation.</pre></div></div><div id='d_Pq' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><pre>Returns the *internal types* for this operations arguments. This is
		typically the list of interfaces or @protocols that the arguments must
		comply to.</pre></div></div><div id='d_Qq' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><pre>Returns this element parent</pre></div></div><div id='d_Rq' class='de'><h1>Method <span class='n'>hasAnnotation</span></h1><div class='re'><code>hasAnnotation( self, name )</code></div><div class='ds'><pre>Tells if the given element has an annotation with the given name</pre></div></div><div id='d_Sq' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><pre>Tells if this element has a parent or not</pre></div></div><div id='d_Tq' class='de'><h1>Method <span class='n'>removeAnnotation</span></h1><div class='re'><code>removeAnnotation( self, name )</code></div><div class='ds'><pre>Removes the annotations with the given name</pre></div></div><div id='d_Uq' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><pre>Sets the abstract type for this element</pre></div></div><div id='d_Vq' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><pre>Sets the given argument of this operation, by argument index.</pre></div></div><div id='d_Wq' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><pre>Sets this element parent</pre></div></div><div id='d_Xq' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.IProcess at 0x85d241c&gt;, &lt;class lambdafactory.interfaces.IProcess at 0x85d241c&gt;, &lt;class lambdafactory.interfaces.IProcess at 0x85d241c&gt;]</code></div><div class='ds'><pre>list() -&gt; new list
list(sequence) -&gt; new list initialized from sequence's items</pre></div></div><div id='d_yq' class='de'><h1>Class <span class='n'>IInterception</span></h1><div class='re'></div><div class='ds'><pre>An interception allows to intercept interruptions that propagage from an
	enclosed process to parent contexts.</pre></div></div><div id='d_Zq' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IAbstractClass at 0x85d235c&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_ar' class='de'><h1>Method <span class='n'>addAnnotation</span></h1><div class='re'><code>addAnnotation( self, annotation )</code></div><div class='ds'><pre>Adds an annotation to this element</pre></div></div><div id='d_br' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><pre>Performs a deep clone of this element. Any mutation to the original won't
		change the copy.</pre></div></div><div id='d_cr' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><pre>Detaches the element from its parent (in case it was already attached).
		This should return this element, and set the parent to None.</pre></div></div><div id='d_dr' class='de'><h1>Method <span class='n'>getAbsoluteName</span></h1><div class='re'><code>getAbsoluteName( self )</code></div><div class='ds'><pre>Returns the absolute name for this element</pre></div></div><div id='d_er' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type for this element</pre></div></div><div id='d_fr' class='de'><h1>Method <span class='n'>getAnnotations</span></h1><div class='re'><code>getAnnotations( self, name=None )</code></div><div class='ds'><pre>Gets all the annotation with the given name associated to this element
		or all annotations if no name is specified.</pre></div></div><div id='d_gr' class='de'><h1>Method <span class='n'>getAttributes</span></h1><div class='re'><code>getAttributes( self )</code></div><div class='ds'><pre>Returns the (non-class) attributes defined within this class.</pre></div></div><div id='d_hr' class='de'><h1>Method <span class='n'>getClassAttributes</span></h1><div class='re'><code>getClassAttributes( self )</code></div><div class='ds'><pre>Returns the class attributes defined within this class.</pre></div></div><div id='d_ir' class='de'><h1>Method <span class='n'>getClassMethods</span></h1><div class='re'><code>getClassMethods( self )</code></div><div class='ds'><pre>Returns the class method defined within this class.</pre></div></div><div id='d_jr' class='de'><h1>Method <span class='n'>getConstructors</span></h1><div class='re'><code>getConstructors( self )</code></div><div class='ds'><pre>Returns the constructors for this class</pre></div></div><div id='d_kr' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><pre>Returns the dataflow accessible/bound to this element</pre></div></div><div id='d_lr' class='de'><h1>Method <span class='n'>getDestructors</span></h1><div class='re'><code>getDestructors( self )</code></div><div class='ds'><pre>Returns the destructors for this class</pre></div></div><div id='d_mr' class='de'><h1>Method <span class='n'>getInheritedSlots</span></h1><div class='re'><code>getInheritedSlots( self )</code></div><div class='ds'><pre>gives the list of inherited slots</pre></div></div><div id='d_nr' class='de'><h1>Method <span class='n'>getInstanceMethods</span></h1><div class='re'><code>getInstanceMethods( self )</code></div><div class='ds'><pre>Returns the instance methods defined within this class.</pre></div></div><div id='d_or' class='de'><h1>Method <span class='n'>getMethods</span></h1><div class='re'><code>getMethods( self )</code></div><div class='ds'><pre>Returns the methods defined within this class.</pre></div></div><div id='d_pr' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><pre>Returns this class name. It can be `None` if the class is anonymous.</pre></div></div><div id='d_qr' class='de'><h1>Method <span class='n'>getOperations</span></h1><div class='re'><code>getOperations( self )</code></div><div class='ds'><pre>Returns the operations (methods and class methods) defined within this class.</pre></div></div><div id='d_rr' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><pre>Returns the parent context for this context (if any)</pre></div></div><div id='d_sr' class='de'><h1>Method <span class='n'>getParentClassesRefs</span></h1><div class='re'><code>getParentClassesRefs( self )</code></div><div class='ds'><pre>Returns the list of inherited classes references. Note that they
		have to be interpreted in the class parent (a module)</pre></div></div><div id='d_tr' class='de'><h1>Method <span class='n'>getSlot</span></h1><div class='re'><code>getSlot( self, name )</code></div><div class='ds'><pre>Returns the given evaluable bound to named slot.</pre></div></div><div id='d_ur' class='de'><h1>Method <span class='n'>getSlotNames</span></h1><div class='re'><code>getSlotNames( self )</code></div><div class='ds'><pre>Returns the list of slot names (in order) for this context</pre></div></div><div id='d_vr' class='de'><h1>Method <span class='n'>getSlots</span></h1><div class='re'><code>getSlots( self )</code></div><div class='ds'><pre>Returns (key, evaluable) pairs representing the slots within this
		context. In the case of context that may inherits slots, this only
		returns the slots that are owned by the context (ie. it does not
		include inherited slots)</pre></div></div><div id='d_wr' class='de'><h1>Method <span class='n'>hasAnnotation</span></h1><div class='re'><code>hasAnnotation( self, name )</code></div><div class='ds'><pre>Tells if the given element has an annotation with the given name</pre></div></div><div id='d_xr' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><pre>Tells if this element has a parent or not</pre></div></div><div id='d_yr' class='de'><h1>Method <span class='n'>hasSlot</span></h1><div class='re'><code>hasSlot( self, name )</code></div><div class='ds'><pre>Tells if the context has a slot with the given name.</pre></div></div><div id='d_zr' class='de'><h1>Method <span class='n'>isAbstract</span></h1><div class='re'><code>isAbstract( self )</code></div><div class='ds'><pre>Tells wether the given abstractable is abstract or not.</pre></div></div><div id='d_Ar' class='de'><h1>Method <span class='n'>removeAnnotation</span></h1><div class='re'><code>removeAnnotation( self, name )</code></div><div class='ds'><pre>Removes the annotations with the given name</pre></div></div><div id='d_Br' class='de'><h1>Method <span class='n'>setAbstract</span></h1><div class='re'><code>setAbstract( self, isAbstract )</code></div><div class='ds'><pre>Sets wether the given abstractable is abstract or not.</pre></div></div><div id='d_Cr' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><pre>Sets the abstract type for this element</pre></div></div><div id='d_Dr' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, context )</code></div><div class='ds'><pre>Sets the parent context for this context.</pre></div></div><div id='d_Er' class='de'><h1>Method <span class='n'>setParentClasses</span></h1><div class='re'><code>setParentClasses( self )</code></div><div class='ds'><pre>gives the list of parent classes that will</pre></div></div><div id='d_Fr' class='de'><h1>Method <span class='n'>setSlot</span></h1><div class='re'><code>setSlot( self, name, evaluable )</code></div><div class='ds'><pre>Binds the given evaluable to the named slot. If there is already a slot
		with the same name, then 'getSlot(name)' should return the evaluable
		given as parameter.<br />		In the default implementation, setSlot preserves the ''history'' of
		added slots, and will always return the latest one.</pre></div></div><div id='d_Yq' class='de'><h1>Class <span class='n'>IInterface</span></h1><div class='re'></div><div class='ds'><pre>An interface is an abstract @protocol that only has abstract elements.</pre></div></div><div id='d_Hr' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IOperation at 0x85d268c&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_Ir' class='de'><h1>Method <span class='n'>addAnnotation</span></h1><div class='re'><code>addAnnotation( self, annotation )</code></div><div class='ds'><pre>Adds an annotation to this element</pre></div></div><div id='d_Jr' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><pre>Adds an argument to this operation. This should do checking of
		arguments (by expected internal type and number).</pre></div></div><div id='d_Kr' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><pre>Performs a deep clone of this element. Any mutation to the original won't
		change the copy.</pre></div></div><div id='d_Lr' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><pre>Detaches the element from its parent (in case it was already attached).
		This should return this element, and set the parent to None.</pre></div></div><div id='d_Mr' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type for this element</pre></div></div><div id='d_Nr' class='de'><h1>Method <span class='n'>getAnnotations</span></h1><div class='re'><code>getAnnotations( self, name=None )</code></div><div class='ds'><pre>Gets all the annotation with the given name associated to this element
		or all annotations if no name is specified.</pre></div></div><div id='d_Or' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><pre>Returns the dataflow accessible/bound to this element</pre></div></div><div id='d_Pr' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><pre>Returns the ith arguments to this operation.</pre></div></div><div id='d_Qr' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><pre>Returns the arguments to this operation.</pre></div></div><div id='d_Rr' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><pre>Returns the *internal types* for this operations arguments. This is
		typically the list of interfaces or @protocols that the arguments must
		comply to.</pre></div></div><div id='d_Sr' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><pre>Returns this element parent</pre></div></div><div id='d_Tr' class='de'><h1>Method <span class='n'>hasAnnotation</span></h1><div class='re'><code>hasAnnotation( self, name )</code></div><div class='ds'><pre>Tells if the given element has an annotation with the given name</pre></div></div><div id='d_Ur' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><pre>Tells if this element has a parent or not</pre></div></div><div id='d_Vr' class='de'><h1>Method <span class='n'>removeAnnotation</span></h1><div class='re'><code>removeAnnotation( self, name )</code></div><div class='ds'><pre>Removes the annotations with the given name</pre></div></div><div id='d_Wr' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><pre>Sets the abstract type for this element</pre></div></div><div id='d_Xr' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><pre>Sets the given argument of this operation, by argument index.</pre></div></div><div id='d_Yr' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><pre>Sets this element parent</pre></div></div><div id='d_Gr' class='de'><h1>Class <span class='n'>IInterruption</span></h1><div class='re'></div><div class='ds'><pre>An interruption can be be used to halt the process.</pre></div></div><div id='d_as' class='de'><h1>Method <span class='n'>getArguments</span></h1><div class='re'><code>getArguments( self )</code></div><div class='ds'><pre>Returns a list of arguments (which are names associated with optional
		type information.</pre></div></div><div id='d_Zr' class='de'><h1>Class <span class='n'>IInvocable</span></h1><div class='re'></div><div class='ds'><pre>An invocable can be used in an invocation operation.</pre></div></div><div id='d_cs' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IOperation at 0x85d268c&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_ds' class='de'><h1>Method <span class='n'>getArguments</span></h1><div class='re'><code>getArguments( self )</code></div><div class='ds'><pre>Returns evaluable arguments.</pre></div></div><div id='d_es' class='de'><h1>Method <span class='n'>getTarget</span></h1><div class='re'><code>getTarget( self )</code></div><div class='ds'><pre>Returns the invocation target reference.</pre></div></div><div id='d_fs' class='de'><h1>Method <span class='n'>isByPositionOnly</span></h1><div class='re'><code>isByPositionOnly( self )</code></div><div class='ds'><pre>Tells if this invocation is only by position. Otherwise, some arguments
		are given by name, as list or as a map (and they should be handled in
		a specific way)</pre></div></div><div id='d_gs' class='de'><h1>Method <span class='n'>addAnnotation</span></h1><div class='re'><code>addAnnotation( self, annotation )</code></div><div class='ds'><pre>Adds an annotation to this element</pre></div></div><div id='d_hs' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><pre>Adds an argument to this operation. This should do checking of
		arguments (by expected internal type and number).</pre></div></div><div id='d_is' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><pre>Performs a deep clone of this element. Any mutation to the original won't
		change the copy.</pre></div></div><div id='d_js' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><pre>Detaches the element from its parent (in case it was already attached).
		This should return this element, and set the parent to None.</pre></div></div><div id='d_ks' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type for this element</pre></div></div><div id='d_ls' class='de'><h1>Method <span class='n'>getAnnotations</span></h1><div class='re'><code>getAnnotations( self, name=None )</code></div><div class='ds'><pre>Gets all the annotation with the given name associated to this element
		or all annotations if no name is specified.</pre></div></div><div id='d_ms' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><pre>Returns the dataflow accessible/bound to this element</pre></div></div><div id='d_ns' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><pre>Returns the ith arguments to this operation.</pre></div></div><div id='d_os' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><pre>Returns the arguments to this operation.</pre></div></div><div id='d_ps' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><pre>Returns the *internal types* for this operations arguments. This is
		typically the list of interfaces or @protocols that the arguments must
		comply to.</pre></div></div><div id='d_qs' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><pre>Returns this element parent</pre></div></div><div id='d_rs' class='de'><h1>Method <span class='n'>hasAnnotation</span></h1><div class='re'><code>hasAnnotation( self, name )</code></div><div class='ds'><pre>Tells if the given element has an annotation with the given name</pre></div></div><div id='d_ss' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><pre>Tells if this element has a parent or not</pre></div></div><div id='d_ts' class='de'><h1>Method <span class='n'>removeAnnotation</span></h1><div class='re'><code>removeAnnotation( self, name )</code></div><div class='ds'><pre>Removes the annotations with the given name</pre></div></div><div id='d_us' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><pre>Sets the abstract type for this element</pre></div></div><div id='d_vs' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><pre>Sets the given argument of this operation, by argument index.</pre></div></div><div id='d_ws' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><pre>Sets this element parent</pre></div></div><div id='d_xs' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.IEvaluable at 0x85c4f2c&gt;, [&lt;class lambdafactory.interfaces.IEvaluable at 0x85c4f2c&gt;]]</code></div><div class='ds'><pre>list() -&gt; new list
list(sequence) -&gt; new list initialized from sequence's items</pre></div></div><div id='d_bs' class='de'><h1>Class <span class='n'>IInvocation</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_zs' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IOperation at 0x85d268c&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_As' class='de'><h1>Method <span class='n'>getClosure</span></h1><div class='re'><code>getClosure( self )</code></div><div class='ds'><pre>Returns the closure that will be applied to the iterator.</pre></div></div><div id='d_Bs' class='de'><h1>Method <span class='n'>getIterator</span></h1><div class='re'><code>getIterator( self )</code></div><div class='ds'><pre>Returns this iteration iterator.</pre></div></div><div id='d_Cs' class='de'><h1>Method <span class='n'>addAnnotation</span></h1><div class='re'><code>addAnnotation( self, annotation )</code></div><div class='ds'><pre>Adds an annotation to this element</pre></div></div><div id='d_Ds' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><pre>Adds an argument to this operation. This should do checking of
		arguments (by expected internal type and number).</pre></div></div><div id='d_Es' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><pre>Performs a deep clone of this element. Any mutation to the original won't
		change the copy.</pre></div></div><div id='d_Fs' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><pre>Detaches the element from its parent (in case it was already attached).
		This should return this element, and set the parent to None.</pre></div></div><div id='d_Gs' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type for this element</pre></div></div><div id='d_Hs' class='de'><h1>Method <span class='n'>getAnnotations</span></h1><div class='re'><code>getAnnotations( self, name=None )</code></div><div class='ds'><pre>Gets all the annotation with the given name associated to this element
		or all annotations if no name is specified.</pre></div></div><div id='d_Is' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><pre>Returns the dataflow accessible/bound to this element</pre></div></div><div id='d_Js' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><pre>Returns the ith arguments to this operation.</pre></div></div><div id='d_Ks' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><pre>Returns the arguments to this operation.</pre></div></div><div id='d_Ls' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><pre>Returns the *internal types* for this operations arguments. This is
		typically the list of interfaces or @protocols that the arguments must
		comply to.</pre></div></div><div id='d_Ms' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><pre>Returns this element parent</pre></div></div><div id='d_Ns' class='de'><h1>Method <span class='n'>hasAnnotation</span></h1><div class='re'><code>hasAnnotation( self, name )</code></div><div class='ds'><pre>Tells if the given element has an annotation with the given name</pre></div></div><div id='d_Os' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><pre>Tells if this element has a parent or not</pre></div></div><div id='d_Ps' class='de'><h1>Method <span class='n'>removeAnnotation</span></h1><div class='re'><code>removeAnnotation( self, name )</code></div><div class='ds'><pre>Removes the annotations with the given name</pre></div></div><div id='d_Qs' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><pre>Sets the abstract type for this element</pre></div></div><div id='d_Rs' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><pre>Sets the given argument of this operation, by argument index.</pre></div></div><div id='d_Ss' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><pre>Sets this element parent</pre></div></div><div id='d_Ts' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.IEvaluable at 0x85c4f2c&gt;, &lt;class lambdafactory.interfaces.IEvaluable at 0x85c4f2c&gt;]</code></div><div class='ds'><pre>list() -&gt; new list
list(sequence) -&gt; new list initialized from sequence's items</pre></div></div><div id='d_ys' class='de'><h1>Class <span class='n'>IIteration</span></h1><div class='re'></div><div class='ds'><pre>An iteration is the multiple application of a process given a set of
	values produced by an iterator.</pre></div></div><div id='d_Vs' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IValue at 0x85d202c&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_Ws' class='de'><h1>Method <span class='n'>addValue</span></h1><div class='re'><code>addValue( self, value )</code></div><div class='ds'><pre>Adds a value to this list.</pre></div></div><div id='d_Xs' class='de'><h1>Method <span class='n'>getValues</span></h1><div class='re'><code>getValues( self )</code></div><div class='ds'><pre>Returns the values within this list.</pre></div></div><div id='d_Ys' class='de'><h1>Method <span class='n'>addAnnotation</span></h1><div class='re'><code>addAnnotation( self, annotation )</code></div><div class='ds'><pre>Adds an annotation to this element</pre></div></div><div id='d_Zs' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><pre>Performs a deep clone of this element. Any mutation to the original won't
		change the copy.</pre></div></div><div id='d_at' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><pre>Detaches the element from its parent (in case it was already attached).
		This should return this element, and set the parent to None.</pre></div></div><div id='d_bt' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type for this element</pre></div></div><div id='d_ct' class='de'><h1>Method <span class='n'>getAnnotations</span></h1><div class='re'><code>getAnnotations( self, name=None )</code></div><div class='ds'><pre>Gets all the annotation with the given name associated to this element
		or all annotations if no name is specified.</pre></div></div><div id='d_dt' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><pre>Returns the dataflow accessible/bound to this element</pre></div></div><div id='d_et' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><pre>Returns this element parent</pre></div></div><div id='d_ft' class='de'><h1>Method <span class='n'>getResultAbstractType</span></h1><div class='re'><code>getResultAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type of the result of the evaluation of this
		evaluable</pre></div></div><div id='d_gt' class='de'><h1>Method <span class='n'>hasAnnotation</span></h1><div class='re'><code>hasAnnotation( self, name )</code></div><div class='ds'><pre>Tells if the given element has an annotation with the given name</pre></div></div><div id='d_ht' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><pre>Tells if this element has a parent or not</pre></div></div><div id='d_it' class='de'><h1>Method <span class='n'>removeAnnotation</span></h1><div class='re'><code>removeAnnotation( self, name )</code></div><div class='ds'><pre>Removes the annotations with the given name</pre></div></div><div id='d_jt' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><pre>Sets the abstract type for this element</pre></div></div><div id='d_kt' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><pre>Sets this element parent</pre></div></div><div id='d_lt' class='de'><h1>Method <span class='n'>setResultAbstractType</span></h1><div class='re'><code>setResultAbstractType( self, abstractType )</code></div><div class='ds'><pre>Sets the abstract type for this operation result. This is usually
		invoked in the typing phase.</pre></div></div><div id='d_Us' class='de'><h1>Class <span class='n'>IList</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_nt' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IValue at 0x85d202c&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_ot' class='de'><h1>Method <span class='n'>getActualValue</span></h1><div class='re'><code>getActualValue( self )</code></div><div class='ds'><pre>Returns the (implementation language) value for this literal</pre></div></div><div id='d_pt' class='de'><h1>Method <span class='n'>addAnnotation</span></h1><div class='re'><code>addAnnotation( self, annotation )</code></div><div class='ds'><pre>Adds an annotation to this element</pre></div></div><div id='d_qt' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><pre>Performs a deep clone of this element. Any mutation to the original won't
		change the copy.</pre></div></div><div id='d_rt' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><pre>Detaches the element from its parent (in case it was already attached).
		This should return this element, and set the parent to None.</pre></div></div><div id='d_st' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type for this element</pre></div></div><div id='d_tt' class='de'><h1>Method <span class='n'>getAnnotations</span></h1><div class='re'><code>getAnnotations( self, name=None )</code></div><div class='ds'><pre>Gets all the annotation with the given name associated to this element
		or all annotations if no name is specified.</pre></div></div><div id='d_ut' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><pre>Returns the dataflow accessible/bound to this element</pre></div></div><div id='d_vt' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><pre>Returns this element parent</pre></div></div><div id='d_wt' class='de'><h1>Method <span class='n'>getResultAbstractType</span></h1><div class='re'><code>getResultAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type of the result of the evaluation of this
		evaluable</pre></div></div><div id='d_xt' class='de'><h1>Method <span class='n'>hasAnnotation</span></h1><div class='re'><code>hasAnnotation( self, name )</code></div><div class='ds'><pre>Tells if the given element has an annotation with the given name</pre></div></div><div id='d_yt' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><pre>Tells if this element has a parent or not</pre></div></div><div id='d_zt' class='de'><h1>Method <span class='n'>removeAnnotation</span></h1><div class='re'><code>removeAnnotation( self, name )</code></div><div class='ds'><pre>Removes the annotations with the given name</pre></div></div><div id='d_At' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><pre>Sets the abstract type for this element</pre></div></div><div id='d_Bt' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><pre>Sets this element parent</pre></div></div><div id='d_Ct' class='de'><h1>Method <span class='n'>setResultAbstractType</span></h1><div class='re'><code>setResultAbstractType( self, abstractType )</code></div><div class='ds'><pre>Sets the abstract type for this operation result. This is usually
		invoked in the typing phase.</pre></div></div><div id='d_mt' class='de'><h1>Class <span class='n'>ILiteral</span></h1><div class='re'></div><div class='ds'><pre>A literal is a value that does not need a context to be evaluated. The
	evaluation is direct.</pre></div></div><div id='d_Et' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IMatchOperation at 0x85d298c&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_Ft' class='de'><h1>Method <span class='n'>getExpression</span></h1><div class='re'><code>getExpression( self )</code></div><div class='ds'><pre>Returns the process that will be executed if the rule matches.</pre></div></div><div id='d_Gt' class='de'><h1>Method <span class='n'>setExpression</span></h1><div class='re'><code>setExpression( self, v )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Ht' class='de'><h1>Method <span class='n'>addAnnotation</span></h1><div class='re'><code>addAnnotation( self, annotation )</code></div><div class='ds'><pre>Adds an annotation to this element</pre></div></div><div id='d_It' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><pre>Adds an argument to this operation. This should do checking of
		arguments (by expected internal type and number).</pre></div></div><div id='d_Jt' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><pre>Performs a deep clone of this element. Any mutation to the original won't
		change the copy.</pre></div></div><div id='d_Kt' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><pre>Detaches the element from its parent (in case it was already attached).
		This should return this element, and set the parent to None.</pre></div></div><div id='d_Lt' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type for this element</pre></div></div><div id='d_Mt' class='de'><h1>Method <span class='n'>getAnnotations</span></h1><div class='re'><code>getAnnotations( self, name=None )</code></div><div class='ds'><pre>Gets all the annotation with the given name associated to this element
		or all annotations if no name is specified.</pre></div></div><div id='d_Nt' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><pre>Returns the dataflow accessible/bound to this element</pre></div></div><div id='d_Ot' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><pre>Returns the ith arguments to this operation.</pre></div></div><div id='d_Pt' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><pre>Returns the arguments to this operation.</pre></div></div><div id='d_Qt' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><pre>Returns the *internal types* for this operations arguments. This is
		typically the list of interfaces or @protocols that the arguments must
		comply to.</pre></div></div><div id='d_Rt' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><pre>Returns this element parent</pre></div></div><div id='d_St' class='de'><h1>Method <span class='n'>getPredicate</span></h1><div class='re'><code>getPredicate( self )</code></div><div class='ds'><pre>Returns the evaluable that acts as a predicate for this operation.</pre></div></div><div id='d_Tt' class='de'><h1>Method <span class='n'>hasAnnotation</span></h1><div class='re'><code>hasAnnotation( self, name )</code></div><div class='ds'><pre>Tells if the given element has an annotation with the given name</pre></div></div><div id='d_Ut' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><pre>Tells if this element has a parent or not</pre></div></div><div id='d_Vt' class='de'><h1>Method <span class='n'>removeAnnotation</span></h1><div class='re'><code>removeAnnotation( self, name )</code></div><div class='ds'><pre>Removes the annotations with the given name</pre></div></div><div id='d_Wt' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><pre>Sets the abstract type for this element</pre></div></div><div id='d_Xt' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><pre>Sets the given argument of this operation, by argument index.</pre></div></div><div id='d_Yt' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><pre>Sets this element parent</pre></div></div><div id='d_Zt' class='de'><h1>Method <span class='n'>setPredicate</span></h1><div class='re'><code>setPredicate( self, v )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_au' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.IEvaluable at 0x85c4f2c&gt;, &lt;class lambdafactory.interfaces.IEvaluable at 0x85c4f2c&gt;]</code></div><div class='ds'><pre>list() -&gt; new list
list(sequence) -&gt; new list initialized from sequence's items</pre></div></div><div id='d_Dt' class='de'><h1>Class <span class='n'>IMatchExpressionOperation</span></h1><div class='re'></div><div class='ds'><pre>A match expression is a predicate that is associated to an expression.
	This is typically used in conditional expressions like in C:<br />	&gt;	int a = ( b==2 ? 1 : 2 )</pre></div></div><div id='d_cu' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IOperation at 0x85d268c&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_du' class='de'><h1>Method <span class='n'>getPredicate</span></h1><div class='re'><code>getPredicate( self )</code></div><div class='ds'><pre>Returns the evaluable that acts as a predicate for this operation.</pre></div></div><div id='d_eu' class='de'><h1>Method <span class='n'>setPredicate</span></h1><div class='re'><code>setPredicate( self, v )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_fu' class='de'><h1>Method <span class='n'>addAnnotation</span></h1><div class='re'><code>addAnnotation( self, annotation )</code></div><div class='ds'><pre>Adds an annotation to this element</pre></div></div><div id='d_gu' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><pre>Adds an argument to this operation. This should do checking of
		arguments (by expected internal type and number).</pre></div></div><div id='d_hu' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><pre>Performs a deep clone of this element. Any mutation to the original won't
		change the copy.</pre></div></div><div id='d_iu' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><pre>Detaches the element from its parent (in case it was already attached).
		This should return this element, and set the parent to None.</pre></div></div><div id='d_ju' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type for this element</pre></div></div><div id='d_ku' class='de'><h1>Method <span class='n'>getAnnotations</span></h1><div class='re'><code>getAnnotations( self, name=None )</code></div><div class='ds'><pre>Gets all the annotation with the given name associated to this element
		or all annotations if no name is specified.</pre></div></div><div id='d_lu' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><pre>Returns the dataflow accessible/bound to this element</pre></div></div><div id='d_mu' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><pre>Returns the ith arguments to this operation.</pre></div></div><div id='d_nu' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><pre>Returns the arguments to this operation.</pre></div></div><div id='d_ou' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><pre>Returns the *internal types* for this operations arguments. This is
		typically the list of interfaces or @protocols that the arguments must
		comply to.</pre></div></div><div id='d_pu' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><pre>Returns this element parent</pre></div></div><div id='d_qu' class='de'><h1>Method <span class='n'>hasAnnotation</span></h1><div class='re'><code>hasAnnotation( self, name )</code></div><div class='ds'><pre>Tells if the given element has an annotation with the given name</pre></div></div><div id='d_ru' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><pre>Tells if this element has a parent or not</pre></div></div><div id='d_su' class='de'><h1>Method <span class='n'>removeAnnotation</span></h1><div class='re'><code>removeAnnotation( self, name )</code></div><div class='ds'><pre>Removes the annotations with the given name</pre></div></div><div id='d_tu' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><pre>Sets the abstract type for this element</pre></div></div><div id='d_uu' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><pre>Sets the given argument of this operation, by argument index.</pre></div></div><div id='d_vu' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><pre>Sets this element parent</pre></div></div><div id='d_bu' class='de'><h1>Class <span class='n'>IMatchOperation</span></h1><div class='re'></div><div class='ds'><pre>A match operation is the binding of an expression and a process.</pre></div></div><div id='d_xu' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IMatchOperation at 0x85d298c&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_yu' class='de'><h1>Method <span class='n'>getProcess</span></h1><div class='re'><code>getProcess( self )</code></div><div class='ds'><pre>Returns the process that will be executed if the rule matches.</pre></div></div><div id='d_zu' class='de'><h1>Method <span class='n'>setProcess</span></h1><div class='re'><code>setProcess( self, v )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Au' class='de'><h1>Method <span class='n'>addAnnotation</span></h1><div class='re'><code>addAnnotation( self, annotation )</code></div><div class='ds'><pre>Adds an annotation to this element</pre></div></div><div id='d_Bu' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><pre>Adds an argument to this operation. This should do checking of
		arguments (by expected internal type and number).</pre></div></div><div id='d_Cu' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><pre>Performs a deep clone of this element. Any mutation to the original won't
		change the copy.</pre></div></div><div id='d_Du' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><pre>Detaches the element from its parent (in case it was already attached).
		This should return this element, and set the parent to None.</pre></div></div><div id='d_Eu' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type for this element</pre></div></div><div id='d_Fu' class='de'><h1>Method <span class='n'>getAnnotations</span></h1><div class='re'><code>getAnnotations( self, name=None )</code></div><div class='ds'><pre>Gets all the annotation with the given name associated to this element
		or all annotations if no name is specified.</pre></div></div><div id='d_Gu' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><pre>Returns the dataflow accessible/bound to this element</pre></div></div><div id='d_Hu' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><pre>Returns the ith arguments to this operation.</pre></div></div><div id='d_Iu' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><pre>Returns the arguments to this operation.</pre></div></div><div id='d_Ju' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><pre>Returns the *internal types* for this operations arguments. This is
		typically the list of interfaces or @protocols that the arguments must
		comply to.</pre></div></div><div id='d_Ku' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><pre>Returns this element parent</pre></div></div><div id='d_Lu' class='de'><h1>Method <span class='n'>getPredicate</span></h1><div class='re'><code>getPredicate( self )</code></div><div class='ds'><pre>Returns the evaluable that acts as a predicate for this operation.</pre></div></div><div id='d_Mu' class='de'><h1>Method <span class='n'>hasAnnotation</span></h1><div class='re'><code>hasAnnotation( self, name )</code></div><div class='ds'><pre>Tells if the given element has an annotation with the given name</pre></div></div><div id='d_Nu' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><pre>Tells if this element has a parent or not</pre></div></div><div id='d_Ou' class='de'><h1>Method <span class='n'>removeAnnotation</span></h1><div class='re'><code>removeAnnotation( self, name )</code></div><div class='ds'><pre>Removes the annotations with the given name</pre></div></div><div id='d_Pu' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><pre>Sets the abstract type for this element</pre></div></div><div id='d_Qu' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><pre>Sets the given argument of this operation, by argument index.</pre></div></div><div id='d_Ru' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><pre>Sets this element parent</pre></div></div><div id='d_Su' class='de'><h1>Method <span class='n'>setPredicate</span></h1><div class='re'><code>setPredicate( self, v )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Tu' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.IEvaluable at 0x85c4f2c&gt;, &lt;class lambdafactory.interfaces.IProcess at 0x85d241c&gt;]</code></div><div class='ds'><pre>list() -&gt; new list
list(sequence) -&gt; new list initialized from sequence's items</pre></div></div><div id='d_wu' class='de'><h1>Class <span class='n'>IMatchProcessOperation</span></h1><div class='re'></div><div class='ds'><pre>A match process is a predicate associate to a process, which is typically
	used for implementing 'if', 'else', etc.</pre></div></div><div id='d_Vu' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IFunction at 0x85d24dc&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_Wu' class='de'><h1>Method <span class='n'>addAnnotation</span></h1><div class='re'><code>addAnnotation( self, annotation )</code></div><div class='ds'><pre>Adds an annotation to this element</pre></div></div><div id='d_Xu' class='de'><h1>Method <span class='n'>addOperation</span></h1><div class='re'><code>addOperation( self, operation )</code></div><div class='ds'><pre>Adds the given operation as a child of this process.</pre></div></div><div id='d_Yu' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><pre>Performs a deep clone of this element. Any mutation to the original won't
		change the copy.</pre></div></div><div id='d_Zu' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><pre>Detaches the element from its parent (in case it was already attached).
		This should return this element, and set the parent to None.</pre></div></div><div id='d_av' class='de'><h1>Method <span class='n'>endsWithTermination</span></h1><div class='re'><code>endsWithTermination( self )</code></div><div class='ds'><pre>Returns true if this function ends with a termination operation. This
		is especially useful for back-ends which want to know if they have to
		insert an explicit 'return' at the end (like Java).</pre></div></div><div id='d_bv' class='de'><h1>Method <span class='n'>getAbsoluteName</span></h1><div class='re'><code>getAbsoluteName( self )</code></div><div class='ds'><pre>Returns the absolute name for this element</pre></div></div><div id='d_cv' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type for this element</pre></div></div><div id='d_dv' class='de'><h1>Method <span class='n'>getAnnotations</span></h1><div class='re'><code>getAnnotations( self, name=None )</code></div><div class='ds'><pre>Gets all the annotation with the given name associated to this element
		or all annotations if no name is specified.</pre></div></div><div id='d_ev' class='de'><h1>Method <span class='n'>getArguments</span></h1><div class='re'><code>getArguments( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_fv' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><pre>Returns the dataflow accessible/bound to this element</pre></div></div><div id='d_gv' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><pre>Returns this @protocol name. It can be `None` if the @protocol is anonymous.</pre></div></div><div id='d_hv' class='de'><h1>Method <span class='n'>getOperations</span></h1><div class='re'><code>getOperations( self )</code></div><div class='ds'><pre>Returns the list of operations in this process.</pre></div></div><div id='d_iv' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><pre>Returns this element parent</pre></div></div><div id='d_jv' class='de'><h1>Method <span class='n'>getReturnTypeDescription</span></h1><div class='re'><code>getReturnTypeDescription( self )</code></div><div class='ds'><pre>Returns the return type description for this closure, if any</pre></div></div><div id='d_kv' class='de'><h1>Method <span class='n'>getSlot</span></h1><div class='re'><code>getSlot( self, name )</code></div><div class='ds'><pre>Returns the given evaluable bound to named slot.</pre></div></div><div id='d_lv' class='de'><h1>Method <span class='n'>getSlotNames</span></h1><div class='re'><code>getSlotNames( self )</code></div><div class='ds'><pre>Returns the list of slot names (in order) for this context</pre></div></div><div id='d_mv' class='de'><h1>Method <span class='n'>getSlots</span></h1><div class='re'><code>getSlots( self )</code></div><div class='ds'><pre>Returns (key, evaluable) pairs representing the slots within this
		context. In the case of context that may inherits slots, this only
		returns the slots that are owned by the context (ie. it does not
		include inherited slots)</pre></div></div><div id='d_nv' class='de'><h1>Method <span class='n'>hasAnnotation</span></h1><div class='re'><code>hasAnnotation( self, name )</code></div><div class='ds'><pre>Tells if the given element has an annotation with the given name</pre></div></div><div id='d_ov' class='de'><h1>Method <span class='n'>hasExplicitTermination</span></h1><div class='re'><code>hasExplicitTermination( self )</code></div><div class='ds'><pre>Returns true if this function has an operation with a termination,
		otherwise return false.</pre></div></div><div id='d_pv' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><pre>Tells if this element has a parent or not</pre></div></div><div id='d_qv' class='de'><h1>Method <span class='n'>hasSlot</span></h1><div class='re'><code>hasSlot( self, name )</code></div><div class='ds'><pre>Tells if the context has a slot with the given name.</pre></div></div><div id='d_rv' class='de'><h1>Method <span class='n'>isAbstract</span></h1><div class='re'><code>isAbstract( self )</code></div><div class='ds'><pre>Tells wether the given abstractable is abstract or not.</pre></div></div><div id='d_sv' class='de'><h1>Method <span class='n'>removeAnnotation</span></h1><div class='re'><code>removeAnnotation( self, name )</code></div><div class='ds'><pre>Removes the annotations with the given name</pre></div></div><div id='d_tv' class='de'><h1>Method <span class='n'>setAbstract</span></h1><div class='re'><code>setAbstract( self, isAbstract )</code></div><div class='ds'><pre>Sets wether the given abstractable is abstract or not.</pre></div></div><div id='d_uv' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><pre>Sets the abstract type for this element</pre></div></div><div id='d_vv' class='de'><h1>Method <span class='n'>setArguments</span></h1><div class='re'><code>setArguments( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_wv' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><pre>Sets this element parent</pre></div></div><div id='d_xv' class='de'><h1>Method <span class='n'>setReturnTypeDescription</span></h1><div class='re'><code>setReturnTypeDescription( self, description )</code></div><div class='ds'><pre>Sets the return type description for this closure, if any</pre></div></div><div id='d_yv' class='de'><h1>Method <span class='n'>setSlot</span></h1><div class='re'><code>setSlot( self, name, evaluable )</code></div><div class='ds'><pre>Binds the given evaluable to the named slot. If there is already a slot
		with the same name, then 'getSlot(name)' should return the evaluable
		given as parameter.<br />		In the default implementation, setSlot preserves the ''history'' of
		added slots, and will always return the latest one.</pre></div></div><div id='d_Uu' class='de'><h1>Class <span class='n'>IMethod</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Av' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IContext at 0x85d22fc&gt;, &lt;class lambdafactory.interfaces.IReferencable at 0x85c4efc&gt;, &lt;class lambdafactory.interfaces.IConstruct at 0x85c4e9c&gt;)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_Bv' class='de'><h1>Method <span class='n'>addImportOperation</span></h1><div class='re'><code>addImportOperation( self, operation )</code></div><div class='ds'><pre>Returns the list of import operations declared in this module
		</pre></div></div><div id='d_Cv' class='de'><h1>Method <span class='n'>getClasses</span></h1><div class='re'><code>getClasses( self )</code></div><div class='ds'><pre>Returns the list of classes defined in this module. This is mainly a
		convenience function.</pre></div></div><div id='d_Dv' class='de'><h1>Method <span class='n'>getImportOperations</span></h1><div class='re'><code>getImportOperations( self )</code></div><div class='ds'><pre>Returns the list of import operations declared in this module </pre></div></div><div id='d_Ev' class='de'><h1>Method <span class='n'>getParentName</span></h1><div class='re'><code>getParentName( self )</code></div><div class='ds'><pre>Returns the parent name of this module (if any) </pre></div></div><div id='d_Fv' class='de'><h1>Method <span class='n'>isImported</span></h1><div class='re'><code>isImported( self )</code></div><div class='ds'><pre>A stub module is a module that does not have any bound implementation.
		Stub modules are typically used by Programs when adding a module such
		as 'a.b.c' where 'a' and 'a.b' will be stub modules unless they were
		or will be imported.</pre></div></div><div id='d_Gv' class='de'><h1>Method <span class='n'>mergeWith</span></h1><div class='re'><code>mergeWith( self, module )</code></div><div class='ds'><pre>Merges this module with the given module</pre></div></div><div id='d_Hv' class='de'><h1>Method <span class='n'>setImported</span></h1><div class='re'><code>setImported( self, value=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Iv' class='de'><h1>Method <span class='n'>addAnnotation</span></h1><div class='re'><code>addAnnotation( self, annotation )</code></div><div class='ds'><pre>Adds an annotation to this element</pre></div></div><div id='d_Jv' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><pre>Performs a deep clone of this element. Any mutation to the original won't
		change the copy.</pre></div></div><div id='d_Kv' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><pre>Detaches the element from its parent (in case it was already attached).
		This should return this element, and set the parent to None.</pre></div></div><div id='d_Lv' class='de'><h1>Method <span class='n'>getAbsoluteName</span></h1><div class='re'><code>getAbsoluteName( self )</code></div><div class='ds'><pre>Returns the absolute name for this element</pre></div></div><div id='d_Mv' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type for this element</pre></div></div><div id='d_Nv' class='de'><h1>Method <span class='n'>getAnnotations</span></h1><div class='re'><code>getAnnotations( self, name=None )</code></div><div class='ds'><pre>Gets all the annotation with the given name associated to this element
		or all annotations if no name is specified.</pre></div></div><div id='d_Ov' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><pre>Returns the dataflow accessible/bound to this element</pre></div></div><div id='d_Pv' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><pre>Returns the local name for this referencable element</pre></div></div><div id='d_Qv' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><pre>Returns the parent context for this context (if any)</pre></div></div><div id='d_Rv' class='de'><h1>Method <span class='n'>getSlot</span></h1><div class='re'><code>getSlot( self, name )</code></div><div class='ds'><pre>Returns the given evaluable bound to named slot.</pre></div></div><div id='d_Sv' class='de'><h1>Method <span class='n'>getSlotNames</span></h1><div class='re'><code>getSlotNames( self )</code></div><div class='ds'><pre>Returns the list of slot names (in order) for this context</pre></div></div><div id='d_Tv' class='de'><h1>Method <span class='n'>getSlots</span></h1><div class='re'><code>getSlots( self )</code></div><div class='ds'><pre>Returns (key, evaluable) pairs representing the slots within this
		context. In the case of context that may inherits slots, this only
		returns the slots that are owned by the context (ie. it does not
		include inherited slots)</pre></div></div><div id='d_Uv' class='de'><h1>Method <span class='n'>hasAnnotation</span></h1><div class='re'><code>hasAnnotation( self, name )</code></div><div class='ds'><pre>Tells if the given element has an annotation with the given name</pre></div></div><div id='d_Vv' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><pre>Tells if this element has a parent or not</pre></div></div><div id='d_Wv' class='de'><h1>Method <span class='n'>hasSlot</span></h1><div class='re'><code>hasSlot( self, name )</code></div><div class='ds'><pre>Tells if the context has a slot with the given name.</pre></div></div><div id='d_Xv' class='de'><h1>Method <span class='n'>removeAnnotation</span></h1><div class='re'><code>removeAnnotation( self, name )</code></div><div class='ds'><pre>Removes the annotations with the given name</pre></div></div><div id='d_Yv' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><pre>Sets the abstract type for this element</pre></div></div><div id='d_Zv' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, context )</code></div><div class='ds'><pre>Sets the parent context for this context.</pre></div></div><div id='d_aw' class='de'><h1>Method <span class='n'>setSlot</span></h1><div class='re'><code>setSlot( self, name, evaluable )</code></div><div class='ds'><pre>Binds the given evaluable to the named slot. If there is already a slot
		with the same name, then 'getSlot(name)' should return the evaluable
		given as parameter.<br />		In the default implementation, setSlot preserves the ''history'' of
		added slots, and will always return the latest one.</pre></div></div><div id='d_zv' class='de'><h1>Class <span class='n'>IModule</span></h1><div class='re'></div><div class='ds'><pre>Note that a module 'getName' function returns the module absolute name</pre></div></div><div id='d_cw' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IAttribute at 0x85d226c&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_dw' class='de'><h1>Method <span class='n'>getAbsoluteName</span></h1><div class='re'><code>getAbsoluteName( self )</code></div><div class='ds'><pre>Returns the absolute name for this element</pre></div></div><div id='d_ew' class='de'><h1>Method <span class='n'>getDefaultValue</span></h1><div class='re'><code>getDefaultValue( self )</code></div><div class='ds'><pre>Gets the @methodault value for this attribute</pre></div></div><div id='d_fw' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><pre>Returns the local name for this referencable element</pre></div></div><div id='d_gw' class='de'><h1>Method <span class='n'>getTypeDescription</span></h1><div class='re'><code>getTypeDescription( self )</code></div><div class='ds'><pre>Returns type information (constraints) that are associated to this
		argument.</pre></div></div><div id='d_hw' class='de'><h1>Method <span class='n'>setDefaultValue</span></h1><div class='re'><code>setDefaultValue( self )</code></div><div class='ds'><pre>Sets the @methodault value for this attribute</pre></div></div><div id='d_bw' class='de'><h1>Class <span class='n'>IModuleAttribute</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_jw' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IAttributeMethod at 0x85d253c&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_kw' class='de'><h1>Method <span class='n'>addAnnotation</span></h1><div class='re'><code>addAnnotation( self, annotation )</code></div><div class='ds'><pre>Adds an annotation to this element</pre></div></div><div id='d_lw' class='de'><h1>Method <span class='n'>addOperation</span></h1><div class='re'><code>addOperation( self, operation )</code></div><div class='ds'><pre>Adds the given operation as a child of this process.</pre></div></div><div id='d_mw' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><pre>Performs a deep clone of this element. Any mutation to the original won't
		change the copy.</pre></div></div><div id='d_nw' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><pre>Detaches the element from its parent (in case it was already attached).
		This should return this element, and set the parent to None.</pre></div></div><div id='d_ow' class='de'><h1>Method <span class='n'>endsWithTermination</span></h1><div class='re'><code>endsWithTermination( self )</code></div><div class='ds'><pre>Returns true if this function ends with a termination operation. This
		is especially useful for back-ends which want to know if they have to
		insert an explicit 'return' at the end (like Java).</pre></div></div><div id='d_pw' class='de'><h1>Method <span class='n'>getAbsoluteName</span></h1><div class='re'><code>getAbsoluteName( self )</code></div><div class='ds'><pre>Returns the absolute name for this element</pre></div></div><div id='d_qw' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type for this element</pre></div></div><div id='d_rw' class='de'><h1>Method <span class='n'>getAnnotations</span></h1><div class='re'><code>getAnnotations( self, name=None )</code></div><div class='ds'><pre>Gets all the annotation with the given name associated to this element
		or all annotations if no name is specified.</pre></div></div><div id='d_sw' class='de'><h1>Method <span class='n'>getArguments</span></h1><div class='re'><code>getArguments( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_tw' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><pre>Returns the dataflow accessible/bound to this element</pre></div></div><div id='d_uw' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><pre>Returns this @protocol name. It can be `None` if the @protocol is anonymous.</pre></div></div><div id='d_vw' class='de'><h1>Method <span class='n'>getOperations</span></h1><div class='re'><code>getOperations( self )</code></div><div class='ds'><pre>Returns the list of operations in this process.</pre></div></div><div id='d_ww' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><pre>Returns this element parent</pre></div></div><div id='d_xw' class='de'><h1>Method <span class='n'>getReturnTypeDescription</span></h1><div class='re'><code>getReturnTypeDescription( self )</code></div><div class='ds'><pre>Returns the return type description for this closure, if any</pre></div></div><div id='d_yw' class='de'><h1>Method <span class='n'>getSlot</span></h1><div class='re'><code>getSlot( self, name )</code></div><div class='ds'><pre>Returns the given evaluable bound to named slot.</pre></div></div><div id='d_zw' class='de'><h1>Method <span class='n'>getSlotNames</span></h1><div class='re'><code>getSlotNames( self )</code></div><div class='ds'><pre>Returns the list of slot names (in order) for this context</pre></div></div><div id='d_Aw' class='de'><h1>Method <span class='n'>getSlots</span></h1><div class='re'><code>getSlots( self )</code></div><div class='ds'><pre>Returns (key, evaluable) pairs representing the slots within this
		context. In the case of context that may inherits slots, this only
		returns the slots that are owned by the context (ie. it does not
		include inherited slots)</pre></div></div><div id='d_Bw' class='de'><h1>Method <span class='n'>hasAnnotation</span></h1><div class='re'><code>hasAnnotation( self, name )</code></div><div class='ds'><pre>Tells if the given element has an annotation with the given name</pre></div></div><div id='d_Cw' class='de'><h1>Method <span class='n'>hasExplicitTermination</span></h1><div class='re'><code>hasExplicitTermination( self )</code></div><div class='ds'><pre>Returns true if this function has an operation with a termination,
		otherwise return false.</pre></div></div><div id='d_Dw' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><pre>Tells if this element has a parent or not</pre></div></div><div id='d_Ew' class='de'><h1>Method <span class='n'>hasSlot</span></h1><div class='re'><code>hasSlot( self, name )</code></div><div class='ds'><pre>Tells if the context has a slot with the given name.</pre></div></div><div id='d_Fw' class='de'><h1>Method <span class='n'>isAbstract</span></h1><div class='re'><code>isAbstract( self )</code></div><div class='ds'><pre>Tells wether the given abstractable is abstract or not.</pre></div></div><div id='d_Gw' class='de'><h1>Method <span class='n'>removeAnnotation</span></h1><div class='re'><code>removeAnnotation( self, name )</code></div><div class='ds'><pre>Removes the annotations with the given name</pre></div></div><div id='d_Hw' class='de'><h1>Method <span class='n'>setAbstract</span></h1><div class='re'><code>setAbstract( self, isAbstract )</code></div><div class='ds'><pre>Sets wether the given abstractable is abstract or not.</pre></div></div><div id='d_Iw' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><pre>Sets the abstract type for this element</pre></div></div><div id='d_Jw' class='de'><h1>Method <span class='n'>setArguments</span></h1><div class='re'><code>setArguments( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Kw' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><pre>Sets this element parent</pre></div></div><div id='d_Lw' class='de'><h1>Method <span class='n'>setReturnTypeDescription</span></h1><div class='re'><code>setReturnTypeDescription( self, description )</code></div><div class='ds'><pre>Sets the return type description for this closure, if any</pre></div></div><div id='d_Mw' class='de'><h1>Method <span class='n'>setSlot</span></h1><div class='re'><code>setSlot( self, name, evaluable )</code></div><div class='ds'><pre>Binds the given evaluable to the named slot. If there is already a slot
		with the same name, then 'getSlot(name)' should return the evaluable
		given as parameter.<br />		In the default implementation, setSlot preserves the ''history'' of
		added slots, and will always return the latest one.</pre></div></div><div id='d_iw' class='de'><h1>Class <span class='n'>IMutator</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Ow' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.ILiteral at 0x85d205c&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_Pw' class='de'><h1>Method <span class='n'>addAnnotation</span></h1><div class='re'><code>addAnnotation( self, annotation )</code></div><div class='ds'><pre>Adds an annotation to this element</pre></div></div><div id='d_Qw' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><pre>Performs a deep clone of this element. Any mutation to the original won't
		change the copy.</pre></div></div><div id='d_Rw' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><pre>Detaches the element from its parent (in case it was already attached).
		This should return this element, and set the parent to None.</pre></div></div><div id='d_Sw' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type for this element</pre></div></div><div id='d_Tw' class='de'><h1>Method <span class='n'>getActualValue</span></h1><div class='re'><code>getActualValue( self )</code></div><div class='ds'><pre>Returns the (implementation language) value for this literal</pre></div></div><div id='d_Uw' class='de'><h1>Method <span class='n'>getAnnotations</span></h1><div class='re'><code>getAnnotations( self, name=None )</code></div><div class='ds'><pre>Gets all the annotation with the given name associated to this element
		or all annotations if no name is specified.</pre></div></div><div id='d_Vw' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><pre>Returns the dataflow accessible/bound to this element</pre></div></div><div id='d_Ww' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><pre>Returns this element parent</pre></div></div><div id='d_Xw' class='de'><h1>Method <span class='n'>getResultAbstractType</span></h1><div class='re'><code>getResultAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type of the result of the evaluation of this
		evaluable</pre></div></div><div id='d_Yw' class='de'><h1>Method <span class='n'>hasAnnotation</span></h1><div class='re'><code>hasAnnotation( self, name )</code></div><div class='ds'><pre>Tells if the given element has an annotation with the given name</pre></div></div><div id='d_Zw' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><pre>Tells if this element has a parent or not</pre></div></div><div id='d_ax' class='de'><h1>Method <span class='n'>removeAnnotation</span></h1><div class='re'><code>removeAnnotation( self, name )</code></div><div class='ds'><pre>Removes the annotations with the given name</pre></div></div><div id='d_bx' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><pre>Sets the abstract type for this element</pre></div></div><div id='d_cx' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><pre>Sets this element parent</pre></div></div><div id='d_dx' class='de'><h1>Method <span class='n'>setResultAbstractType</span></h1><div class='re'><code>setResultAbstractType( self, abstractType )</code></div><div class='ds'><pre>Sets the abstract type for this operation result. This is usually
		invoked in the typing phase.</pre></div></div><div id='d_Nw' class='de'><h1>Class <span class='n'>INumber</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_fx' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IElement at 0x85c4e6c&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_gx' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><pre>Adds an argument to this operation. This should do checking of
		arguments (by expected internal type and number).</pre></div></div><div id='d_hx' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><pre>Returns the ith arguments to this operation.</pre></div></div><div id='d_ix' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><pre>Returns the arguments to this operation.</pre></div></div><div id='d_jx' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><pre>Returns the *internal types* for this operations arguments. This is
		typically the list of interfaces or @protocols that the arguments must
		comply to.</pre></div></div><div id='d_kx' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><pre>Sets the given argument of this operation, by argument index.</pre></div></div><div id='d_lx' class='de'><h1>Method <span class='n'>addAnnotation</span></h1><div class='re'><code>addAnnotation( self, annotation )</code></div><div class='ds'><pre>Adds an annotation to this element</pre></div></div><div id='d_mx' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><pre>Performs a deep clone of this element. Any mutation to the original won't
		change the copy.</pre></div></div><div id='d_nx' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><pre>Detaches the element from its parent (in case it was already attached).
		This should return this element, and set the parent to None.</pre></div></div><div id='d_ox' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type for this element</pre></div></div><div id='d_px' class='de'><h1>Method <span class='n'>getAnnotations</span></h1><div class='re'><code>getAnnotations( self, name=None )</code></div><div class='ds'><pre>Gets all the annotation with the given name associated to this element
		or all annotations if no name is specified.</pre></div></div><div id='d_qx' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><pre>Returns the dataflow accessible/bound to this element</pre></div></div><div id='d_rx' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><pre>Returns this element parent</pre></div></div><div id='d_sx' class='de'><h1>Method <span class='n'>hasAnnotation</span></h1><div class='re'><code>hasAnnotation( self, name )</code></div><div class='ds'><pre>Tells if the given element has an annotation with the given name</pre></div></div><div id='d_tx' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><pre>Tells if this element has a parent or not</pre></div></div><div id='d_ux' class='de'><h1>Method <span class='n'>removeAnnotation</span></h1><div class='re'><code>removeAnnotation( self, name )</code></div><div class='ds'><pre>Removes the annotations with the given name</pre></div></div><div id='d_vx' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><pre>Sets the abstract type for this element</pre></div></div><div id='d_wx' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><pre>Sets this element parent</pre></div></div><div id='d_ex' class='de'><h1>Class <span class='n'>IOperation</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_yx' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IReference at 0x85d214c&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_zx' class='de'><h1>Method <span class='n'>getPriority</span></h1><div class='re'><code>getPriority( self )</code></div><div class='ds'><pre>Gets the priority for this operator</pre></div></div><div id='d_Ax' class='de'><h1>Method <span class='n'>setPriority</span></h1><div class='re'><code>setPriority( self, priority )</code></div><div class='ds'><pre>Sets the priority for this operator</pre></div></div><div id='d_Bx' class='de'><h1>Method <span class='n'>addAnnotation</span></h1><div class='re'><code>addAnnotation( self, annotation )</code></div><div class='ds'><pre>Adds an annotation to this element</pre></div></div><div id='d_Cx' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><pre>Performs a deep clone of this element. Any mutation to the original won't
		change the copy.</pre></div></div><div id='d_Dx' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><pre>Detaches the element from its parent (in case it was already attached).
		This should return this element, and set the parent to None.</pre></div></div><div id='d_Ex' class='de'><h1>Method <span class='n'>getAbsoluteName</span></h1><div class='re'><code>getAbsoluteName( self )</code></div><div class='ds'><pre>Returns the absolute name for this element</pre></div></div><div id='d_Fx' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type for this element</pre></div></div><div id='d_Gx' class='de'><h1>Method <span class='n'>getAnnotations</span></h1><div class='re'><code>getAnnotations( self, name=None )</code></div><div class='ds'><pre>Gets all the annotation with the given name associated to this element
		or all annotations if no name is specified.</pre></div></div><div id='d_Hx' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><pre>Returns the dataflow accessible/bound to this element</pre></div></div><div id='d_Ix' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><pre>Returns the local name for this referencable element</pre></div></div><div id='d_Jx' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><pre>Returns this element parent</pre></div></div><div id='d_Kx' class='de'><h1>Method <span class='n'>getReferenceName</span></h1><div class='re'><code>getReferenceName( self )</code></div><div class='ds'><pre>Returns the name which this reference contains. The name is used by
		the resolution operation to actually resolve a value from the name.</pre></div></div><div id='d_Lx' class='de'><h1>Method <span class='n'>getResultAbstractType</span></h1><div class='re'><code>getResultAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type of the result of the evaluation of this
		evaluable</pre></div></div><div id='d_Mx' class='de'><h1>Method <span class='n'>hasAnnotation</span></h1><div class='re'><code>hasAnnotation( self, name )</code></div><div class='ds'><pre>Tells if the given element has an annotation with the given name</pre></div></div><div id='d_Nx' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><pre>Tells if this element has a parent or not</pre></div></div><div id='d_Ox' class='de'><h1>Method <span class='n'>removeAnnotation</span></h1><div class='re'><code>removeAnnotation( self, name )</code></div><div class='ds'><pre>Removes the annotations with the given name</pre></div></div><div id='d_Px' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><pre>Sets the abstract type for this element</pre></div></div><div id='d_Qx' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><pre>Sets this element parent</pre></div></div><div id='d_Rx' class='de'><h1>Method <span class='n'>setResultAbstractType</span></h1><div class='re'><code>setResultAbstractType( self, abstractType )</code></div><div class='ds'><pre>Sets the abstract type for this operation result. This is usually
		invoked in the typing phase.</pre></div></div><div id='d_xx' class='de'><h1>Class <span class='n'>IOperator</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Tx' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IElement at 0x85c4e6c&gt;, &lt;class lambdafactory.interfaces.ISlot at 0x85d21dc&gt;)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_Ux' class='de'><h1>Method <span class='n'>getValue</span></h1><div class='re'><code>getValue( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Vx' class='de'><h1>Method <span class='n'>isAsList</span></h1><div class='re'><code>isAsList( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Wx' class='de'><h1>Method <span class='n'>isAsMap</span></h1><div class='re'><code>isAsMap( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Xx' class='de'><h1>Method <span class='n'>isByName</span></h1><div class='re'><code>isByName( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Yx' class='de'><h1>Method <span class='n'>setAsList</span></h1><div class='re'><code>setAsList( self, v=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Zx' class='de'><h1>Method <span class='n'>setAsMap</span></h1><div class='re'><code>setAsMap( self, v=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_ay' class='de'><h1>Method <span class='n'>setByName</span></h1><div class='re'><code>setByName( self, n )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_by' class='de'><h1>Method <span class='n'>setValue</span></h1><div class='re'><code>setValue( self, v )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_cy' class='de'><h1>Method <span class='n'>addAnnotation</span></h1><div class='re'><code>addAnnotation( self, annotation )</code></div><div class='ds'><pre>Adds an annotation to this element</pre></div></div><div id='d_dy' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><pre>Performs a deep clone of this element. Any mutation to the original won't
		change the copy.</pre></div></div><div id='d_ey' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><pre>Detaches the element from its parent (in case it was already attached).
		This should return this element, and set the parent to None.</pre></div></div><div id='d_fy' class='de'><h1>Method <span class='n'>getAbsoluteName</span></h1><div class='re'><code>getAbsoluteName( self )</code></div><div class='ds'><pre>Returns the absolute name for this element</pre></div></div><div id='d_gy' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type for this element</pre></div></div><div id='d_hy' class='de'><h1>Method <span class='n'>getAnnotations</span></h1><div class='re'><code>getAnnotations( self, name=None )</code></div><div class='ds'><pre>Gets all the annotation with the given name associated to this element
		or all annotations if no name is specified.</pre></div></div><div id='d_iy' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><pre>Returns the dataflow accessible/bound to this element</pre></div></div><div id='d_jy' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><pre>Returns the local name for this referencable element</pre></div></div><div id='d_ky' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><pre>Returns this element parent</pre></div></div><div id='d_ly' class='de'><h1>Method <span class='n'>getTypeDescription</span></h1><div class='re'><code>getTypeDescription( self )</code></div><div class='ds'><pre>Returns type information (constraints) that are associated to this
		argument.</pre></div></div><div id='d_my' class='de'><h1>Method <span class='n'>hasAnnotation</span></h1><div class='re'><code>hasAnnotation( self, name )</code></div><div class='ds'><pre>Tells if the given element has an annotation with the given name</pre></div></div><div id='d_ny' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><pre>Tells if this element has a parent or not</pre></div></div><div id='d_oy' class='de'><h1>Method <span class='n'>removeAnnotation</span></h1><div class='re'><code>removeAnnotation( self, name )</code></div><div class='ds'><pre>Removes the annotations with the given name</pre></div></div><div id='d_py' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><pre>Sets the abstract type for this element</pre></div></div><div id='d_qy' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><pre>Sets this element parent</pre></div></div><div id='d_Sx' class='de'><h1>Class <span class='n'>IParameter</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_sy' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IElement at 0x85c4e6c&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_ty' class='de'><h1>Method <span class='n'>addOperation</span></h1><div class='re'><code>addOperation( self, operation )</code></div><div class='ds'><pre>Adds the given operation as a child of this process.</pre></div></div><div id='d_uy' class='de'><h1>Method <span class='n'>getOperations</span></h1><div class='re'><code>getOperations( self )</code></div><div class='ds'><pre>Returns the list of operations in this process.</pre></div></div><div id='d_vy' class='de'><h1>Method <span class='n'>addAnnotation</span></h1><div class='re'><code>addAnnotation( self, annotation )</code></div><div class='ds'><pre>Adds an annotation to this element</pre></div></div><div id='d_wy' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><pre>Performs a deep clone of this element. Any mutation to the original won't
		change the copy.</pre></div></div><div id='d_xy' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><pre>Detaches the element from its parent (in case it was already attached).
		This should return this element, and set the parent to None.</pre></div></div><div id='d_yy' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type for this element</pre></div></div><div id='d_zy' class='de'><h1>Method <span class='n'>getAnnotations</span></h1><div class='re'><code>getAnnotations( self, name=None )</code></div><div class='ds'><pre>Gets all the annotation with the given name associated to this element
		or all annotations if no name is specified.</pre></div></div><div id='d_Ay' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><pre>Returns the dataflow accessible/bound to this element</pre></div></div><div id='d_By' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><pre>Returns this element parent</pre></div></div><div id='d_Cy' class='de'><h1>Method <span class='n'>hasAnnotation</span></h1><div class='re'><code>hasAnnotation( self, name )</code></div><div class='ds'><pre>Tells if the given element has an annotation with the given name</pre></div></div><div id='d_Dy' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><pre>Tells if this element has a parent or not</pre></div></div><div id='d_Ey' class='de'><h1>Method <span class='n'>removeAnnotation</span></h1><div class='re'><code>removeAnnotation( self, name )</code></div><div class='ds'><pre>Removes the annotations with the given name</pre></div></div><div id='d_Fy' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><pre>Sets the abstract type for this element</pre></div></div><div id='d_Gy' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><pre>Sets this element parent</pre></div></div><div id='d_ry' class='de'><h1>Class <span class='n'>IProcess</span></h1><div class='re'></div><div class='ds'><pre>A process is a sequence of operations.</pre></div></div><div id='d_Iy' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IContext at 0x85d22fc&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_Jy' class='de'><h1>Method <span class='n'>addModule</span></h1><div class='re'><code>addModule( self, module )</code></div><div class='ds'><pre>Adds a module to this program. The module will be registered in
		the global module catalogue.</pre></div></div><div id='d_Ky' class='de'><h1>Method <span class='n'>getFactory</span></h1><div class='re'><code>getFactory( self )</code></div><div class='ds'><pre>Gets the factory that was used to create this program. It can be
		used to create more elements in the program.</pre></div></div><div id='d_Ly' class='de'><h1>Method <span class='n'>getModule</span></h1><div class='re'><code>getModule( self, moduleAbsoluteName )</code></div><div class='ds'><pre>Returns the module (if any) with the given absolute name</pre></div></div><div id='d_My' class='de'><h1>Method <span class='n'>getModules</span></h1><div class='re'><code>getModules( self )</code></div><div class='ds'><pre>Returns the list of modules declared/imported in this program</pre></div></div><div id='d_Ny' class='de'><h1>Method <span class='n'>setFactory</span></h1><div class='re'><code>setFactory( self, factory )</code></div><div class='ds'><pre>Sets the factory that was used to create this program</pre></div></div><div id='d_Oy' class='de'><h1>Method <span class='n'>addAnnotation</span></h1><div class='re'><code>addAnnotation( self, annotation )</code></div><div class='ds'><pre>Adds an annotation to this element</pre></div></div><div id='d_Py' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><pre>Performs a deep clone of this element. Any mutation to the original won't
		change the copy.</pre></div></div><div id='d_Qy' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><pre>Detaches the element from its parent (in case it was already attached).
		This should return this element, and set the parent to None.</pre></div></div><div id='d_Ry' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type for this element</pre></div></div><div id='d_Sy' class='de'><h1>Method <span class='n'>getAnnotations</span></h1><div class='re'><code>getAnnotations( self, name=None )</code></div><div class='ds'><pre>Gets all the annotation with the given name associated to this element
		or all annotations if no name is specified.</pre></div></div><div id='d_Ty' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><pre>Returns the dataflow accessible/bound to this element</pre></div></div><div id='d_Uy' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><pre>Returns the parent context for this context (if any)</pre></div></div><div id='d_Vy' class='de'><h1>Method <span class='n'>getSlot</span></h1><div class='re'><code>getSlot( self, name )</code></div><div class='ds'><pre>Returns the given evaluable bound to named slot.</pre></div></div><div id='d_Wy' class='de'><h1>Method <span class='n'>getSlotNames</span></h1><div class='re'><code>getSlotNames( self )</code></div><div class='ds'><pre>Returns the list of slot names (in order) for this context</pre></div></div><div id='d_Xy' class='de'><h1>Method <span class='n'>getSlots</span></h1><div class='re'><code>getSlots( self )</code></div><div class='ds'><pre>Returns (key, evaluable) pairs representing the slots within this
		context. In the case of context that may inherits slots, this only
		returns the slots that are owned by the context (ie. it does not
		include inherited slots)</pre></div></div><div id='d_Yy' class='de'><h1>Method <span class='n'>hasAnnotation</span></h1><div class='re'><code>hasAnnotation( self, name )</code></div><div class='ds'><pre>Tells if the given element has an annotation with the given name</pre></div></div><div id='d_Zy' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><pre>Tells if this element has a parent or not</pre></div></div><div id='d_az' class='de'><h1>Method <span class='n'>hasSlot</span></h1><div class='re'><code>hasSlot( self, name )</code></div><div class='ds'><pre>Tells if the context has a slot with the given name.</pre></div></div><div id='d_bz' class='de'><h1>Method <span class='n'>removeAnnotation</span></h1><div class='re'><code>removeAnnotation( self, name )</code></div><div class='ds'><pre>Removes the annotations with the given name</pre></div></div><div id='d_cz' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><pre>Sets the abstract type for this element</pre></div></div><div id='d_dz' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, context )</code></div><div class='ds'><pre>Sets the parent context for this context.</pre></div></div><div id='d_ez' class='de'><h1>Method <span class='n'>setSlot</span></h1><div class='re'><code>setSlot( self, name, evaluable )</code></div><div class='ds'><pre>Binds the given evaluable to the named slot. If there is already a slot
		with the same name, then 'getSlot(name)' should return the evaluable
		given as parameter.<br />		In the default implementation, setSlot preserves the ''history'' of
		added slots, and will always return the latest one.</pre></div></div><div id='d_Hy' class='de'><h1>Class <span class='n'>IProgram</span></h1><div class='re'></div><div class='ds'><pre>The program is the core context and entry point for almost every
	operation offered by LambdaFactory.</pre></div></div><div id='d_gz' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IAssignable at 0x85c4ecc&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_hz' class='de'><h1>Method <span class='n'>getAbsoluteName</span></h1><div class='re'><code>getAbsoluteName( self )</code></div><div class='ds'><pre>Returns the absolute name for this element</pre></div></div><div id='d_iz' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><pre>Returns the local name for this referencable element</pre></div></div><div id='d_fz' class='de'><h1>Class <span class='n'>IReferencable</span></h1><div class='re'></div><div class='ds'><pre>A referencable is an element that can be referenced either by id (it is
	unique and stable), or by a name (which is also not supposed to change).<br />	Types are good examples of referencables: they have an *absolute name* (like
	`Data.List`), but can also be bound to slots within contexts which give them
	"local names" (like `List := Data.List`)</pre></div></div><div id='d_kz' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IValue at 0x85d202c&gt;, &lt;class lambdafactory.interfaces.IReferencable at 0x85c4efc&gt;)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_lz' class='de'><h1>Method <span class='n'>getReferenceName</span></h1><div class='re'><code>getReferenceName( self )</code></div><div class='ds'><pre>Returns the name which this reference contains. The name is used by
		the resolution operation to actually resolve a value from the name.</pre></div></div><div id='d_mz' class='de'><h1>Method <span class='n'>addAnnotation</span></h1><div class='re'><code>addAnnotation( self, annotation )</code></div><div class='ds'><pre>Adds an annotation to this element</pre></div></div><div id='d_nz' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><pre>Performs a deep clone of this element. Any mutation to the original won't
		change the copy.</pre></div></div><div id='d_oz' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><pre>Detaches the element from its parent (in case it was already attached).
		This should return this element, and set the parent to None.</pre></div></div><div id='d_pz' class='de'><h1>Method <span class='n'>getAbsoluteName</span></h1><div class='re'><code>getAbsoluteName( self )</code></div><div class='ds'><pre>Returns the absolute name for this element</pre></div></div><div id='d_qz' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type for this element</pre></div></div><div id='d_rz' class='de'><h1>Method <span class='n'>getAnnotations</span></h1><div class='re'><code>getAnnotations( self, name=None )</code></div><div class='ds'><pre>Gets all the annotation with the given name associated to this element
		or all annotations if no name is specified.</pre></div></div><div id='d_sz' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><pre>Returns the dataflow accessible/bound to this element</pre></div></div><div id='d_tz' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><pre>Returns the local name for this referencable element</pre></div></div><div id='d_uz' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><pre>Returns this element parent</pre></div></div><div id='d_vz' class='de'><h1>Method <span class='n'>getResultAbstractType</span></h1><div class='re'><code>getResultAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type of the result of the evaluation of this
		evaluable</pre></div></div><div id='d_wz' class='de'><h1>Method <span class='n'>hasAnnotation</span></h1><div class='re'><code>hasAnnotation( self, name )</code></div><div class='ds'><pre>Tells if the given element has an annotation with the given name</pre></div></div><div id='d_xz' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><pre>Tells if this element has a parent or not</pre></div></div><div id='d_yz' class='de'><h1>Method <span class='n'>removeAnnotation</span></h1><div class='re'><code>removeAnnotation( self, name )</code></div><div class='ds'><pre>Removes the annotations with the given name</pre></div></div><div id='d_zz' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><pre>Sets the abstract type for this element</pre></div></div><div id='d_Az' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><pre>Sets this element parent</pre></div></div><div id='d_Bz' class='de'><h1>Method <span class='n'>setResultAbstractType</span></h1><div class='re'><code>setResultAbstractType( self, abstractType )</code></div><div class='ds'><pre>Sets the abstract type for this operation result. This is usually
		invoked in the typing phase.</pre></div></div><div id='d_jz' class='de'><h1>Class <span class='n'>IReference</span></h1><div class='re'></div><div class='ds'><pre>A reference is a name that can be converted into a value using a
	resolution operation (for instance).</pre></div></div><div id='d_Dz' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IOperation at 0x85d268c&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_Ez' class='de'><h1>Method <span class='n'>getCondition</span></h1><div class='re'><code>getCondition( self )</code></div><div class='ds'><pre>Gets the expression that is the condition for this repetition.</pre></div></div><div id='d_Fz' class='de'><h1>Method <span class='n'>getProcess</span></h1><div class='re'><code>getProcess( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Gz' class='de'><h1>Method <span class='n'>addAnnotation</span></h1><div class='re'><code>addAnnotation( self, annotation )</code></div><div class='ds'><pre>Adds an annotation to this element</pre></div></div><div id='d_Hz' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><pre>Adds an argument to this operation. This should do checking of
		arguments (by expected internal type and number).</pre></div></div><div id='d_Iz' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><pre>Performs a deep clone of this element. Any mutation to the original won't
		change the copy.</pre></div></div><div id='d_Jz' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><pre>Detaches the element from its parent (in case it was already attached).
		This should return this element, and set the parent to None.</pre></div></div><div id='d_Kz' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type for this element</pre></div></div><div id='d_Lz' class='de'><h1>Method <span class='n'>getAnnotations</span></h1><div class='re'><code>getAnnotations( self, name=None )</code></div><div class='ds'><pre>Gets all the annotation with the given name associated to this element
		or all annotations if no name is specified.</pre></div></div><div id='d_Mz' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><pre>Returns the dataflow accessible/bound to this element</pre></div></div><div id='d_Nz' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><pre>Returns the ith arguments to this operation.</pre></div></div><div id='d_Oz' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><pre>Returns the arguments to this operation.</pre></div></div><div id='d_Pz' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><pre>Returns the *internal types* for this operations arguments. This is
		typically the list of interfaces or @protocols that the arguments must
		comply to.</pre></div></div><div id='d_Qz' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><pre>Returns this element parent</pre></div></div><div id='d_Rz' class='de'><h1>Method <span class='n'>hasAnnotation</span></h1><div class='re'><code>hasAnnotation( self, name )</code></div><div class='ds'><pre>Tells if the given element has an annotation with the given name</pre></div></div><div id='d_Sz' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><pre>Tells if this element has a parent or not</pre></div></div><div id='d_Tz' class='de'><h1>Method <span class='n'>removeAnnotation</span></h1><div class='re'><code>removeAnnotation( self, name )</code></div><div class='ds'><pre>Removes the annotations with the given name</pre></div></div><div id='d_Uz' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><pre>Sets the abstract type for this element</pre></div></div><div id='d_Vz' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><pre>Sets the given argument of this operation, by argument index.</pre></div></div><div id='d_Wz' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><pre>Sets this element parent</pre></div></div><div id='d_Xz' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.IEvaluable at 0x85c4f2c&gt;, &lt;class lambdafactory.interfaces.IProcess at 0x85d241c&gt;]</code></div><div class='ds'><pre>list() -&gt; new list
list(sequence) -&gt; new list initialized from sequence's items</pre></div></div><div id='d_Cz' class='de'><h1>Class <span class='n'>IRepetition</span></h1><div class='re'></div><div class='ds'><pre>A repetition is the repetitive execution of a process according to a
	predicate expression which can be modified by the process.</pre></div></div><div id='d_Zz' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IOperation at 0x85d268c&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_aA' class='de'><h1>Method <span class='n'>getContext</span></h1><div class='re'><code>getContext( self )</code></div><div class='ds'><pre>Returns the (optional) context in which the resolution should occur.</pre></div></div><div id='d_bA' class='de'><h1>Method <span class='n'>getReference</span></h1><div class='re'><code>getReference( self )</code></div><div class='ds'><pre>Returns the reference to be resolved.</pre></div></div><div id='d_cA' class='de'><h1>Method <span class='n'>addAnnotation</span></h1><div class='re'><code>addAnnotation( self, annotation )</code></div><div class='ds'><pre>Adds an annotation to this element</pre></div></div><div id='d_dA' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><pre>Adds an argument to this operation. This should do checking of
		arguments (by expected internal type and number).</pre></div></div><div id='d_eA' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><pre>Performs a deep clone of this element. Any mutation to the original won't
		change the copy.</pre></div></div><div id='d_fA' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><pre>Detaches the element from its parent (in case it was already attached).
		This should return this element, and set the parent to None.</pre></div></div><div id='d_gA' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type for this element</pre></div></div><div id='d_hA' class='de'><h1>Method <span class='n'>getAnnotations</span></h1><div class='re'><code>getAnnotations( self, name=None )</code></div><div class='ds'><pre>Gets all the annotation with the given name associated to this element
		or all annotations if no name is specified.</pre></div></div><div id='d_iA' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><pre>Returns the dataflow accessible/bound to this element</pre></div></div><div id='d_jA' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><pre>Returns the ith arguments to this operation.</pre></div></div><div id='d_kA' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><pre>Returns the arguments to this operation.</pre></div></div><div id='d_lA' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><pre>Returns the *internal types* for this operations arguments. This is
		typically the list of interfaces or @protocols that the arguments must
		comply to.</pre></div></div><div id='d_mA' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><pre>Returns this element parent</pre></div></div><div id='d_nA' class='de'><h1>Method <span class='n'>hasAnnotation</span></h1><div class='re'><code>hasAnnotation( self, name )</code></div><div class='ds'><pre>Tells if the given element has an annotation with the given name</pre></div></div><div id='d_oA' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><pre>Tells if this element has a parent or not</pre></div></div><div id='d_pA' class='de'><h1>Method <span class='n'>removeAnnotation</span></h1><div class='re'><code>removeAnnotation( self, name )</code></div><div class='ds'><pre>Removes the annotations with the given name</pre></div></div><div id='d_qA' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><pre>Sets the abstract type for this element</pre></div></div><div id='d_rA' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><pre>Sets the given argument of this operation, by argument index.</pre></div></div><div id='d_sA' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><pre>Sets this element parent</pre></div></div><div id='d_tA' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.IReferencable at 0x85c4efc&gt;, &lt;class lambdafactory.interfaces.IEvaluable at 0x85c4f2c&gt;]</code></div><div class='ds'><pre>list() -&gt; new list
list(sequence) -&gt; new list initialized from sequence's items</pre></div></div><div id='d_Yz' class='de'><h1>Class <span class='n'>IResolution</span></h1><div class='re'></div><div class='ds'><pre>A resolution resolves a reference into a value.</pre></div></div><div id='d_vA' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IOperation at 0x85d268c&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_wA' class='de'><h1>Method <span class='n'>addRule</span></h1><div class='re'><code>addRule( self, evaluable )</code></div><div class='ds'><pre>Adds a rule to this operation.</pre></div></div><div id='d_xA' class='de'><h1>Method <span class='n'>getRules</span></h1><div class='re'><code>getRules( self )</code></div><div class='ds'><pre>Returns the ordered set of rule for this selection.</pre></div></div><div id='d_yA' class='de'><h1>Method <span class='n'>addAnnotation</span></h1><div class='re'><code>addAnnotation( self, annotation )</code></div><div class='ds'><pre>Adds an annotation to this element</pre></div></div><div id='d_zA' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><pre>Adds an argument to this operation. This should do checking of
		arguments (by expected internal type and number).</pre></div></div><div id='d_AA' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><pre>Performs a deep clone of this element. Any mutation to the original won't
		change the copy.</pre></div></div><div id='d_BA' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><pre>Detaches the element from its parent (in case it was already attached).
		This should return this element, and set the parent to None.</pre></div></div><div id='d_CA' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type for this element</pre></div></div><div id='d_DA' class='de'><h1>Method <span class='n'>getAnnotations</span></h1><div class='re'><code>getAnnotations( self, name=None )</code></div><div class='ds'><pre>Gets all the annotation with the given name associated to this element
		or all annotations if no name is specified.</pre></div></div><div id='d_EA' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><pre>Returns the dataflow accessible/bound to this element</pre></div></div><div id='d_FA' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><pre>Returns the ith arguments to this operation.</pre></div></div><div id='d_GA' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><pre>Returns the arguments to this operation.</pre></div></div><div id='d_HA' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><pre>Returns the *internal types* for this operations arguments. This is
		typically the list of interfaces or @protocols that the arguments must
		comply to.</pre></div></div><div id='d_IA' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><pre>Returns this element parent</pre></div></div><div id='d_JA' class='de'><h1>Method <span class='n'>hasAnnotation</span></h1><div class='re'><code>hasAnnotation( self, name )</code></div><div class='ds'><pre>Tells if the given element has an annotation with the given name</pre></div></div><div id='d_KA' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><pre>Tells if this element has a parent or not</pre></div></div><div id='d_LA' class='de'><h1>Method <span class='n'>removeAnnotation</span></h1><div class='re'><code>removeAnnotation( self, name )</code></div><div class='ds'><pre>Removes the annotations with the given name</pre></div></div><div id='d_MA' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><pre>Sets the abstract type for this element</pre></div></div><div id='d_NA' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><pre>Sets the given argument of this operation, by argument index.</pre></div></div><div id='d_OA' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><pre>Sets this element parent</pre></div></div><div id='d_PA' class='de'><h1>list</h1><div class='re'><code>[[&lt;class lambdafactory.interfaces.IMatchOperation at 0x85d298c&gt;]]</code></div><div class='ds'><pre>list() -&gt; new list
list(sequence) -&gt; new list initialized from sequence's items</pre></div></div><div id='d_uA' class='de'><h1>Class <span class='n'>ISelection</span></h1><div class='re'></div><div class='ds'><pre>Selections are the abstract objects behind `if`, `select` or
	pattern-matching operations. Each selection has match operations as
	arguments, which bind a subprocess to a predicate expression.</pre></div></div><div id='d_RA' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.ISubsetOperation at 0x85d28fc&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_SA' class='de'><h1>Method <span class='n'>getSliceEnd</span></h1><div class='re'><code>getSliceEnd( self )</code></div><div class='ds'><pre>Returns evaluable that will return the slice end</pre></div></div><div id='d_TA' class='de'><h1>Method <span class='n'>getSliceStart</span></h1><div class='re'><code>getSliceStart( self )</code></div><div class='ds'><pre>Returns evaluable that will return the slice start</pre></div></div><div id='d_UA' class='de'><h1>Method <span class='n'>addAnnotation</span></h1><div class='re'><code>addAnnotation( self, annotation )</code></div><div class='ds'><pre>Adds an annotation to this element</pre></div></div><div id='d_VA' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><pre>Adds an argument to this operation. This should do checking of
		arguments (by expected internal type and number).</pre></div></div><div id='d_WA' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><pre>Performs a deep clone of this element. Any mutation to the original won't
		change the copy.</pre></div></div><div id='d_XA' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><pre>Detaches the element from its parent (in case it was already attached).
		This should return this element, and set the parent to None.</pre></div></div><div id='d_YA' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type for this element</pre></div></div><div id='d_ZA' class='de'><h1>Method <span class='n'>getAnnotations</span></h1><div class='re'><code>getAnnotations( self, name=None )</code></div><div class='ds'><pre>Gets all the annotation with the given name associated to this element
		or all annotations if no name is specified.</pre></div></div><div id='d_aB' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><pre>Returns the dataflow accessible/bound to this element</pre></div></div><div id='d_bB' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><pre>Returns the ith arguments to this operation.</pre></div></div><div id='d_cB' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><pre>Returns the arguments to this operation.</pre></div></div><div id='d_dB' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><pre>Returns the *internal types* for this operations arguments. This is
		typically the list of interfaces or @protocols that the arguments must
		comply to.</pre></div></div><div id='d_eB' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><pre>Returns this element parent</pre></div></div><div id='d_fB' class='de'><h1>Method <span class='n'>getTarget</span></h1><div class='re'><code>getTarget( self )</code></div><div class='ds'><pre>Returns the operation target.</pre></div></div><div id='d_gB' class='de'><h1>Method <span class='n'>hasAnnotation</span></h1><div class='re'><code>hasAnnotation( self, name )</code></div><div class='ds'><pre>Tells if the given element has an annotation with the given name</pre></div></div><div id='d_hB' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><pre>Tells if this element has a parent or not</pre></div></div><div id='d_iB' class='de'><h1>Method <span class='n'>removeAnnotation</span></h1><div class='re'><code>removeAnnotation( self, name )</code></div><div class='ds'><pre>Removes the annotations with the given name</pre></div></div><div id='d_jB' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><pre>Sets the abstract type for this element</pre></div></div><div id='d_kB' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><pre>Sets the given argument of this operation, by argument index.</pre></div></div><div id='d_lB' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><pre>Sets this element parent</pre></div></div><div id='d_mB' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.IEvaluable at 0x85c4f2c&gt;, &lt;class lambdafactory.interfaces.IEvaluable at 0x85c4f2c&gt;, &lt;class lambdafactory.interfaces.IEvaluable at 0x85c4f2c&gt;]</code></div><div class='ds'><pre>list() -&gt; new list
list(sequence) -&gt; new list initialized from sequence's items</pre></div></div><div id='d_QA' class='de'><h1>Class <span class='n'>ISliceOperation</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_oB' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IReferencable at 0x85c4efc&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_pB' class='de'><h1>Method <span class='n'>getTypeDescription</span></h1><div class='re'><code>getTypeDescription( self )</code></div><div class='ds'><pre>Returns type information (constraints) that are associated to this
		argument.</pre></div></div><div id='d_qB' class='de'><h1>Method <span class='n'>getAbsoluteName</span></h1><div class='re'><code>getAbsoluteName( self )</code></div><div class='ds'><pre>Returns the absolute name for this element</pre></div></div><div id='d_rB' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><pre>Returns the local name for this referencable element</pre></div></div><div id='d_nB' class='de'><h1>Class <span class='n'>ISlot</span></h1><div class='re'></div><div class='ds'><pre>An argument is a reference with additional type information.</pre></div></div><div id='d_tB' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.ILiteral at 0x85d205c&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_uB' class='de'><h1>Method <span class='n'>addAnnotation</span></h1><div class='re'><code>addAnnotation( self, annotation )</code></div><div class='ds'><pre>Adds an annotation to this element</pre></div></div><div id='d_vB' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><pre>Performs a deep clone of this element. Any mutation to the original won't
		change the copy.</pre></div></div><div id='d_wB' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><pre>Detaches the element from its parent (in case it was already attached).
		This should return this element, and set the parent to None.</pre></div></div><div id='d_xB' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type for this element</pre></div></div><div id='d_yB' class='de'><h1>Method <span class='n'>getActualValue</span></h1><div class='re'><code>getActualValue( self )</code></div><div class='ds'><pre>Returns the (implementation language) value for this literal</pre></div></div><div id='d_zB' class='de'><h1>Method <span class='n'>getAnnotations</span></h1><div class='re'><code>getAnnotations( self, name=None )</code></div><div class='ds'><pre>Gets all the annotation with the given name associated to this element
		or all annotations if no name is specified.</pre></div></div><div id='d_AB' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><pre>Returns the dataflow accessible/bound to this element</pre></div></div><div id='d_BB' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><pre>Returns this element parent</pre></div></div><div id='d_CB' class='de'><h1>Method <span class='n'>getResultAbstractType</span></h1><div class='re'><code>getResultAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type of the result of the evaluation of this
		evaluable</pre></div></div><div id='d_DB' class='de'><h1>Method <span class='n'>hasAnnotation</span></h1><div class='re'><code>hasAnnotation( self, name )</code></div><div class='ds'><pre>Tells if the given element has an annotation with the given name</pre></div></div><div id='d_EB' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><pre>Tells if this element has a parent or not</pre></div></div><div id='d_FB' class='de'><h1>Method <span class='n'>removeAnnotation</span></h1><div class='re'><code>removeAnnotation( self, name )</code></div><div class='ds'><pre>Removes the annotations with the given name</pre></div></div><div id='d_GB' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><pre>Sets the abstract type for this element</pre></div></div><div id='d_HB' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><pre>Sets this element parent</pre></div></div><div id='d_IB' class='de'><h1>Method <span class='n'>setResultAbstractType</span></h1><div class='re'><code>setResultAbstractType( self, abstractType )</code></div><div class='ds'><pre>Sets the abstract type for this operation result. This is usually
		invoked in the typing phase.</pre></div></div><div id='d_sB' class='de'><h1>Class <span class='n'>IString</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_KB' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IOperation at 0x85d268c&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_LB' class='de'><h1>Method <span class='n'>getTarget</span></h1><div class='re'><code>getTarget( self )</code></div><div class='ds'><pre>Returns the operation target.</pre></div></div><div id='d_MB' class='de'><h1>Method <span class='n'>addAnnotation</span></h1><div class='re'><code>addAnnotation( self, annotation )</code></div><div class='ds'><pre>Adds an annotation to this element</pre></div></div><div id='d_NB' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><pre>Adds an argument to this operation. This should do checking of
		arguments (by expected internal type and number).</pre></div></div><div id='d_OB' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><pre>Performs a deep clone of this element. Any mutation to the original won't
		change the copy.</pre></div></div><div id='d_PB' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><pre>Detaches the element from its parent (in case it was already attached).
		This should return this element, and set the parent to None.</pre></div></div><div id='d_QB' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type for this element</pre></div></div><div id='d_RB' class='de'><h1>Method <span class='n'>getAnnotations</span></h1><div class='re'><code>getAnnotations( self, name=None )</code></div><div class='ds'><pre>Gets all the annotation with the given name associated to this element
		or all annotations if no name is specified.</pre></div></div><div id='d_SB' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><pre>Returns the dataflow accessible/bound to this element</pre></div></div><div id='d_TB' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><pre>Returns the ith arguments to this operation.</pre></div></div><div id='d_UB' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><pre>Returns the arguments to this operation.</pre></div></div><div id='d_VB' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><pre>Returns the *internal types* for this operations arguments. This is
		typically the list of interfaces or @protocols that the arguments must
		comply to.</pre></div></div><div id='d_WB' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><pre>Returns this element parent</pre></div></div><div id='d_XB' class='de'><h1>Method <span class='n'>hasAnnotation</span></h1><div class='re'><code>hasAnnotation( self, name )</code></div><div class='ds'><pre>Tells if the given element has an annotation with the given name</pre></div></div><div id='d_YB' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><pre>Tells if this element has a parent or not</pre></div></div><div id='d_ZB' class='de'><h1>Method <span class='n'>removeAnnotation</span></h1><div class='re'><code>removeAnnotation( self, name )</code></div><div class='ds'><pre>Removes the annotations with the given name</pre></div></div><div id='d_aC' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><pre>Sets the abstract type for this element</pre></div></div><div id='d_bC' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><pre>Sets the given argument of this operation, by argument index.</pre></div></div><div id='d_cC' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><pre>Sets this element parent</pre></div></div><div id='d_JB' class='de'><h1>Class <span class='n'>ISubsetOperation</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_eC' class='de'><h1>Method <span class='n'>getColumn</span></h1><div class='re'><code>getColumn( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_fC' class='de'><h1>Method <span class='n'>getLine</span></h1><div class='re'><code>getLine( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_gC' class='de'><h1>Method <span class='n'>getOffset</span></h1><div class='re'><code>getOffset( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_dC' class='de'><h1>Class <span class='n'>ISyntactic</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_iC' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IOperation at 0x85d268c&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_jC' class='de'><h1>Method <span class='n'>getReturnedEvaluable</span></h1><div class='re'><code>getReturnedEvaluable( self )</code></div><div class='ds'><pre>Returns the termination return evaluable.</pre></div></div><div id='d_kC' class='de'><h1>Method <span class='n'>addAnnotation</span></h1><div class='re'><code>addAnnotation( self, annotation )</code></div><div class='ds'><pre>Adds an annotation to this element</pre></div></div><div id='d_lC' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><pre>Adds an argument to this operation. This should do checking of
		arguments (by expected internal type and number).</pre></div></div><div id='d_mC' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><pre>Performs a deep clone of this element. Any mutation to the original won't
		change the copy.</pre></div></div><div id='d_nC' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><pre>Detaches the element from its parent (in case it was already attached).
		This should return this element, and set the parent to None.</pre></div></div><div id='d_oC' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type for this element</pre></div></div><div id='d_pC' class='de'><h1>Method <span class='n'>getAnnotations</span></h1><div class='re'><code>getAnnotations( self, name=None )</code></div><div class='ds'><pre>Gets all the annotation with the given name associated to this element
		or all annotations if no name is specified.</pre></div></div><div id='d_qC' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><pre>Returns the dataflow accessible/bound to this element</pre></div></div><div id='d_rC' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><pre>Returns the ith arguments to this operation.</pre></div></div><div id='d_sC' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><pre>Returns the arguments to this operation.</pre></div></div><div id='d_tC' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><pre>Returns the *internal types* for this operations arguments. This is
		typically the list of interfaces or @protocols that the arguments must
		comply to.</pre></div></div><div id='d_uC' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><pre>Returns this element parent</pre></div></div><div id='d_vC' class='de'><h1>Method <span class='n'>hasAnnotation</span></h1><div class='re'><code>hasAnnotation( self, name )</code></div><div class='ds'><pre>Tells if the given element has an annotation with the given name</pre></div></div><div id='d_wC' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><pre>Tells if this element has a parent or not</pre></div></div><div id='d_xC' class='de'><h1>Method <span class='n'>removeAnnotation</span></h1><div class='re'><code>removeAnnotation( self, name )</code></div><div class='ds'><pre>Removes the annotations with the given name</pre></div></div><div id='d_yC' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><pre>Sets the abstract type for this element</pre></div></div><div id='d_zC' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><pre>Sets the given argument of this operation, by argument index.</pre></div></div><div id='d_AC' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><pre>Sets this element parent</pre></div></div><div id='d_BC' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.IEvaluable at 0x85c4f2c&gt;]</code></div><div class='ds'><pre>list() -&gt; new list
list(sequence) -&gt; new list initialized from sequence's items</pre></div></div><div id='d_hC' class='de'><h1>Class <span class='n'>ITermination</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_DC' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IElement at 0x85c4e6c&gt;, &lt;class lambdafactory.interfaces.IEvaluable at 0x85c4f2c&gt;)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_EC' class='de'><h1>Method <span class='n'>addAnnotation</span></h1><div class='re'><code>addAnnotation( self, annotation )</code></div><div class='ds'><pre>Adds an annotation to this element</pre></div></div><div id='d_FC' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><pre>Performs a deep clone of this element. Any mutation to the original won't
		change the copy.</pre></div></div><div id='d_GC' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><pre>Detaches the element from its parent (in case it was already attached).
		This should return this element, and set the parent to None.</pre></div></div><div id='d_HC' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type for this element</pre></div></div><div id='d_IC' class='de'><h1>Method <span class='n'>getAnnotations</span></h1><div class='re'><code>getAnnotations( self, name=None )</code></div><div class='ds'><pre>Gets all the annotation with the given name associated to this element
		or all annotations if no name is specified.</pre></div></div><div id='d_JC' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><pre>Returns the dataflow accessible/bound to this element</pre></div></div><div id='d_KC' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><pre>Returns this element parent</pre></div></div><div id='d_LC' class='de'><h1>Method <span class='n'>getResultAbstractType</span></h1><div class='re'><code>getResultAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type of the result of the evaluation of this
		evaluable</pre></div></div><div id='d_MC' class='de'><h1>Method <span class='n'>hasAnnotation</span></h1><div class='re'><code>hasAnnotation( self, name )</code></div><div class='ds'><pre>Tells if the given element has an annotation with the given name</pre></div></div><div id='d_NC' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><pre>Tells if this element has a parent or not</pre></div></div><div id='d_OC' class='de'><h1>Method <span class='n'>removeAnnotation</span></h1><div class='re'><code>removeAnnotation( self, name )</code></div><div class='ds'><pre>Removes the annotations with the given name</pre></div></div><div id='d_PC' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><pre>Sets the abstract type for this element</pre></div></div><div id='d_QC' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><pre>Sets this element parent</pre></div></div><div id='d_RC' class='de'><h1>Method <span class='n'>setResultAbstractType</span></h1><div class='re'><code>setResultAbstractType( self, abstractType )</code></div><div class='ds'><pre>Sets the abstract type for this operation result. This is usually
		invoked in the typing phase.</pre></div></div><div id='d_CC' class='de'><h1>Class <span class='n'>IValue</span></h1><div class='re'></div><div class='ds'><pre>A value represents an atomic element of the language, like a number, a
	string, or a name (that can resolved by the language, acts as key for data
	structures, etc.).</pre></div></div><div id='d_a' class='de'><h1>Module <span class='n'>lambdafactory.interfaces</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_UC' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self, module=<module 'lambdafactory.model' from '/home/sebastien/Projects/Local/lib/python/lambdafactory/model.py'> )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_VC' class='de'><h1>Method <span class='n'>_arg</span></h1><div class='re'><code>_arg( self, name, typeinfo=None, optional=False )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_WC' class='de'><h1>Method <span class='n'>_attr</span></h1><div class='re'><code>_attr( self, name, typeinfo=None, value=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_XC' class='de'><h1>Method <span class='n'>_classattr</span></h1><div class='re'><code>_classattr( self, name, typeinfo=None, value=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_YC' class='de'><h1>Method <span class='n'>_dict</span></h1><div class='re'><code>_dict( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_ZC' class='de'><h1>Method <span class='n'>_ensureParam</span></h1><div class='re'><code>_ensureParam( self, value )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_aD' class='de'><h1>Method <span class='n'>_getImplementation</span></h1><div class='re'><code>_getImplementation( self, name )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_bD' class='de'><h1>Method <span class='n'>_list</span></h1><div class='re'><code>_list( self, *args )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_cD' class='de'><h1>Method <span class='n'>_moduleattr</span></h1><div class='re'><code>_moduleattr( self, name, typeinfo=None, value=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_dD' class='de'><h1>Method <span class='n'>_number</span></h1><div class='re'><code>_number( self, number )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_eD' class='de'><h1>Method <span class='n'>_op</span></h1><div class='re'><code>_op( self, symbol, priority=0 )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_fD' class='de'><h1>Method <span class='n'>_param</span></h1><div class='re'><code>_param( self, name=None, value=None, asList=False, asMap=False )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_gD' class='de'><h1>Method <span class='n'>_ref</span></h1><div class='re'><code>_ref( self, name )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_hD' class='de'><h1>Method <span class='n'>_slot</span></h1><div class='re'><code>_slot( self, name, typeinfo=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_iD' class='de'><h1>Method <span class='n'>_string</span></h1><div class='re'><code>_string( self, value )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_jD' class='de'><h1>Method <span class='n'>access</span></h1><div class='re'><code>access( self, target, _index )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_kD' class='de'><h1>Method <span class='n'>allocate</span></h1><div class='re'><code>allocate( self, slot, value=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_lD' class='de'><h1>Method <span class='n'>annotation</span></h1><div class='re'><code>annotation( self, name, content=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_mD' class='de'><h1>Method <span class='n'>assign</span></h1><div class='re'><code>assign( self, name, evaluable )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_nD' class='de'><h1>Method <span class='n'>breaks</span></h1><div class='re'><code>breaks( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_oD' class='de'><h1>Method <span class='n'>comment</span></h1><div class='re'><code>comment( self, content )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_pD' class='de'><h1>Method <span class='n'>compute</span></h1><div class='re'><code>compute( self, operatorName, leftOperand, rightOperand=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_qD' class='de'><h1>Method <span class='n'>createAccessor</span></h1><div class='re'><code>createAccessor( self, name, arguments=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_rD' class='de'><h1>Method <span class='n'>createBlock</span></h1><div class='re'><code>createBlock( self, *operations )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_sD' class='de'><h1>Method <span class='n'>createClass</span></h1><div class='re'><code>createClass( self, name, inherited=() )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_tD' class='de'><h1>Method <span class='n'>createClassMethod</span></h1><div class='re'><code>createClassMethod( self, name, arguments=() )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_uD' class='de'><h1>Method <span class='n'>createClosure</span></h1><div class='re'><code>createClosure( self, arguments, *operations )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_vD' class='de'><h1>Method <span class='n'>createConstructor</span></h1><div class='re'><code>createConstructor( self, arguments=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_wD' class='de'><h1>Method <span class='n'>createDataFlow</span></h1><div class='re'><code>createDataFlow( self, element, parent=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_xD' class='de'><h1>Method <span class='n'>createDataFlowSlot</span></h1><div class='re'><code>createDataFlowSlot( self, name, value, origin, slotType )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_yD' class='de'><h1>Method <span class='n'>createDestructor</span></h1><div class='re'><code>createDestructor( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_zD' class='de'><h1>Method <span class='n'>createFunction</span></h1><div class='re'><code>createFunction( self, name, arguments=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_AD' class='de'><h1>Method <span class='n'>createInterface</span></h1><div class='re'><code>createInterface( self, name, inherited=() )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_BD' class='de'><h1>Method <span class='n'>createMethod</span></h1><div class='re'><code>createMethod( self, name, arguments=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_CD' class='de'><h1>Method <span class='n'>createModule</span></h1><div class='re'><code>createModule( self, name )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_DD' class='de'><h1>Method <span class='n'>createMutator</span></h1><div class='re'><code>createMutator( self, name, arguments=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_ED' class='de'><h1>Method <span class='n'>createProgram</span></h1><div class='re'><code>createProgram( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_FD' class='de'><h1>Method <span class='n'>doc</span></h1><div class='re'><code>doc( self, content )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_GD' class='de'><h1>Method <span class='n'>embed</span></h1><div class='re'><code>embed( self, lang, code )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_HD' class='de'><h1>Method <span class='n'>embedTemplate</span></h1><div class='re'><code>embedTemplate( self, lang, code )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_ID' class='de'><h1>Method <span class='n'>enumerate</span></h1><div class='re'><code>enumerate( self, start, end, step=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_JD' class='de'><h1>Method <span class='n'>evaluate</span></h1><div class='re'><code>evaluate( self, evaluable )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_KD' class='de'><h1>Method <span class='n'>exception</span></h1><div class='re'><code>exception( self, exception )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_LD' class='de'><h1>Method <span class='n'>importModule</span></h1><div class='re'><code>importModule( self, name, alias )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_MD' class='de'><h1>Method <span class='n'>importModules</span></h1><div class='re'><code>importModules( self, names )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_ND' class='de'><h1>Method <span class='n'>importSymbol</span></h1><div class='re'><code>importSymbol( self, name, origin, alias )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_OD' class='de'><h1>Method <span class='n'>importSymbols</span></h1><div class='re'><code>importSymbols( self, names, origin )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_PD' class='de'><h1>Method <span class='n'>instanciate</span></h1><div class='re'><code>instanciate( self, evaluable, *arguments )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_QD' class='de'><h1>Method <span class='n'>intercept</span></h1><div class='re'><code>intercept( self, tryProcess, catchProcess=None, finallyProcess=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_RD' class='de'><h1>Method <span class='n'>invoke</span></h1><div class='re'><code>invoke( self, evaluable, *arguments )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_SD' class='de'><h1>Method <span class='n'>iterate</span></h1><div class='re'><code>iterate( self, evaluable, process )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_TD' class='de'><h1>Method <span class='n'>matchExpression</span></h1><div class='re'><code>matchExpression( self, evaluable, expression )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_UD' class='de'><h1>Method <span class='n'>matchProcess</span></h1><div class='re'><code>matchProcess( self, evaluable, process )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_VD' class='de'><h1>Method <span class='n'>repeat</span></h1><div class='re'><code>repeat( self, condition, process )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_WD' class='de'><h1>Method <span class='n'>resolve</span></h1><div class='re'><code>resolve( self, reference, context=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_XD' class='de'><h1>Method <span class='n'>returns</span></h1><div class='re'><code>returns( self, evaluable )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_YD' class='de'><h1>Method <span class='n'>rule</span></h1><div class='re'><code>rule( self, evaluable, process )</code></div><div class='ds'><pre>Alias for matchProcess</pre></div></div><div id='d_ZD' class='de'><h1>Method <span class='n'>select</span></h1><div class='re'><code>select( self, *rules )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_aE' class='de'><h1>Method <span class='n'>slice</span></h1><div class='re'><code>slice( self, target, _start, _end=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_TC' class='de'><h1>Class <span class='n'>Factory</span></h1><div class='re'></div><div class='ds'><pre>This class takes a module and look for classes with the same name as the
	`createXXX` methods and instanciates them.<br />	For instance, if you define a module with classes like `Value`, `Literal`,
	`Invocation`, `Function`, etc. you just have to give this module to the
	factory constructor and it will be used to generate the given element.</pre></div></div><div id='d_cE' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self, someClass, expectedClass, argument )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_dE' class='de'><h1>wrapper_descriptor</h1><div class='re'></div><div class='ds'><pre>x.__getitem__(y) &lt;==&gt; x[y]</pre></div></div><div id='d_eE' class='de'><h1>wrapper_descriptor</h1><div class='re'></div><div class='ds'><pre>x.__repr__() &lt;==&gt; repr(x)</pre></div></div><div id='d_fE' class='de'><h1>wrapper_descriptor</h1><div class='re'></div><div class='ds'><pre>x.__str__() &lt;==&gt; str(x)</pre></div></div><div id='d_gE' class='de'><h1>getset_descriptor</h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_hE' class='de'><h1>member_descriptor</h1><div class='re'></div><div class='ds'><pre>exception message</pre></div></div><div id='d_bE' class='de'><h1>Class <span class='n'>ModelBadArgument</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_jE' class='de'><h1>wrapper_descriptor</h1><div class='re'></div><div class='ds'><pre>x.__init__(...) initializes x; see x.__class__.__doc__ for signature</pre></div></div><div id='d_iE' class='de'><h1>Class <span class='n'>ModelException</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_kE' class='de'><h1>Function <span class='n'>assertImplements</span></h1><div class='re'><code>assertImplements( v, i )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_SC' class='de'><h1>Module <span class='n'>lambdafactory.modelbase</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_nE' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.passes.Pass at 0x857b20c&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_oE' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_pE' class='de'><h1>Method <span class='n'>_format</span></h1><div class='re'><code>_format( self, *values )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_qE' class='de'><h1>Method <span class='n'>_unique</span></h1><div class='re'><code>_unique( self, name )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_rE' class='de'><h1>Method <span class='n'>onProgram</span></h1><div class='re'><code>onProgram( self, element )</code></div><div class='ds'><pre>Writes a Program element</pre></div></div><div id='d_sE' class='de'><h1>Method <span class='n'>run</span></h1><div class='re'><code>run( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_tE' class='de'><h1>Method <span class='n'>write</span></h1><div class='re'><code>write( self, element )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_uE' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.IProgram at 0x85d23ec&gt;, &lt;class lambdafactory.interfaces.IClass at 0x85d232c&gt;, &lt;class lambdafactory.interfaces.IModule at 0x85d23bc&gt;, &lt;class lambdafactory.interfaces.IAccessor at 0x85d256c&gt;, &lt;class lambdafactory.interfaces.IMutator at 0x85d259c&gt;, &lt;class lambdafactory.interfaces.IDestructor at 0x85d25fc&gt;, &lt;class lambdafactory.interfaces.IConstructor at 0x85d25cc&gt;, &lt;class lambdafactory.interfaces.IClassMethod at 0x85d265c&gt;, &lt;class lambdafactory.interfaces.IMethod at 0x85d250c&gt;, &lt;class lambdafactory.interfaces.IFunction at 0x85d24dc&gt;, &lt;class lambdafactory.interfaces.IClosure at 0x85d24ac&gt;, &lt;class lambdafactory.interfaces.IBlock at 0x85d247c&gt;, &lt;class lambdafactory.interfaces.IModuleAttribute at 0x85d229c&gt;, &lt;class lambdafactory.interfaces.IClassAttribute at 0x85d22cc&gt;, &lt;class lambdafactory.interfaces.IAttribute at 0x85d226c&gt;, &lt;class lambdafactory.interfaces.IArgument at 0x85d220c&gt;, &lt;class lambdafactory.interfaces.IParameter at 0x85d223c&gt;, &lt;class lambdafactory.interfaces.IOperator at 0x85d21ac&gt;, &lt;class lambdafactory.interfaces.IReference at 0x85d214c&gt;, &lt;class lambdafactory.interfaces.INumber at 0x85d208c&gt;, &lt;class lambdafactory.interfaces.IString at 0x85d20bc&gt;, &lt;class lambdafactory.interfaces.IList at 0x85d20ec&gt;, &lt;class lambdafactory.interfaces.IDict at 0x85d211c&gt;, &lt;class lambdafactory.interfaces.IEnumeration at 0x85d2a7c&gt;, &lt;class lambdafactory.interfaces.IAllocation at 0x85d280c&gt;, &lt;class lambdafactory.interfaces.IAssignation at 0x85d27dc&gt;, &lt;class lambdafactory.interfaces.IComputation at 0x85d286c&gt;, &lt;class lambdafactory.interfaces.IInvocation at 0x85d289c&gt;, &lt;class lambdafactory.interfaces.IInstanciation at 0x85d28cc&gt;, &lt;class lambdafactory.interfaces.IResolution at 0x85d283c&gt;, &lt;class lambdafactory.interfaces.ISelection at 0x85d2a1c&gt;, &lt;class lambdafactory.interfaces.IRepetition at 0x85d2aac&gt;, &lt;class lambdafactory.interfaces.IIteration at 0x85d2a4c&gt;, &lt;class lambdafactory.interfaces.IAccessOperation at 0x85d292c&gt;, &lt;class lambdafactory.interfaces.ISliceOperation at 0x85d295c&gt;, &lt;class lambdafactory.interfaces.IEvaluation at 0x85d27ac&gt;, &lt;class lambdafactory.interfaces.ITermination at 0x85d2adc&gt;, &lt;class lambdafactory.interfaces.IBreaking at 0x85d2b3c&gt;, &lt;class lambdafactory.interfaces.IExcept at 0x85d2b6c&gt;, &lt;class lambdafactory.interfaces.IInterception at 0x85d2b9c&gt;, &lt;class lambdafactory.interfaces.IImportSymbolOperation at 0x85d26ec&gt;, &lt;class lambdafactory.interfaces.IImportSymbolsOperation at 0x85d271c&gt;, &lt;class lambdafactory.interfaces.IImportModuleOperation at 0x85d274c&gt;, &lt;class lambdafactory.interfaces.IImportModulesOperation at 0x85d277c&gt;, &lt;class lambdafactory.interfaces.IEmbed at 0x85d2bcc&gt;]</code></div><div class='ds'><pre>list() -&gt; new list
list(sequence) -&gt; new list initialized from sequence's items</pre></div></div><div id='d_vE' class='de'><h1>str</h1><div class='re'><code>''</code></div><div class='ds'><pre>str(object) -&gt; string<br />Return a nice string representation of the object.
If the argument is a string, the return value is the same object.</pre></div></div><div id='d_mE' class='de'><h1>Class <span class='n'>AbstractWriter</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_wE' class='de'><h1>Function <span class='n'>_flatten</span></h1><div class='re'><code>_flatten( value, res )</code></div><div class='ds'><pre>Flatten helper operation. See 'flatten'</pre></div></div><div id='d_xE' class='de'><h1>Function <span class='n'>_format</span></h1><div class='re'><code>_format( value, level=None )</code></div><div class='ds'><pre>Format helper operation. See @format</pre></div></div><div id='d_yE' class='de'><h1>Function <span class='n'>flatten</span></h1><div class='re'><code>flatten( *lists )</code></div><div class='ds'><pre>Flattens the given lists in a single list</pre></div></div><div id='d_zE' class='de'><h1>Function <span class='n'>format</span></h1><div class='re'><code>format( *values )</code></div><div class='ds'><pre>Formats a combination of string ang tuples. Strings are joined by
	newlines, and the content of the inner tuples gets indented</pre></div></div><div id='d_AE' class='de'><h1>Function <span class='n'>notEmpty</span></h1><div class='re'><code>notEmpty( p )</code></div><div class='ds'><pre>Returns None if the given parameter is empty.</pre></div></div><div id='d_BE' class='de'><h1>str</h1><div class='re'><code>'\t'</code></div><div class='ds'><pre>str(object) -&gt; string<br />Return a nice string representation of the object.
If the argument is a string, the return value is the same object.</pre></div></div><div id='d_CE' class='de'><h1>str</h1><div class='re'><code>'8&lt; ---[%s]---'</code></div><div class='ds'><pre>str(object) -&gt; string<br />Return a nice string representation of the object.
If the argument is a string, the return value is the same object.</pre></div></div><div id='d_lE' class='de'><h1>Module <span class='n'>lambdafactory.modelwriter</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_FE' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.modeltypes.TypeCollection at 0x40315adc&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_GE' class='de'><h1>Method <span class='n'>getType</span></h1><div class='re'><code>getType( self, name )</code></div><div class='ds'><pre>Returns the type with the given name, or None if it does not
		exist.</pre></div></div><div id='d_EE' class='de'><h1>Class <span class='n'>Behaviour</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_IE' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.modeltypes.TypeCollection at 0x40315adc&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_JE' class='de'><h1>Method <span class='n'>getType</span></h1><div class='re'><code>getType( self, name )</code></div><div class='ds'><pre>Returns the type with the given name, or None if it does not
		exist.</pre></div></div><div id='d_HE' class='de'><h1>Class <span class='n'>Data</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_LE' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.modeltypes.TypeCollection at 0x40315adc&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_ME' class='de'><h1>Method <span class='n'>getType</span></h1><div class='re'><code>getType( self, name )</code></div><div class='ds'><pre>Returns the type with the given name, or None if it does not
		exist.</pre></div></div><div id='d_KE' class='de'><h1>Class <span class='n'>Operations</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_OE' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.modeltypes.TypeCollection at 0x40315adc&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_PE' class='de'><h1>Method <span class='n'>getType</span></h1><div class='re'><code>getType( self, name )</code></div><div class='ds'><pre>Returns the type with the given name, or None if it does not
		exist.</pre></div></div><div id='d_NE' class='de'><h1>Class <span class='n'>Runtime</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_RE' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.modeltypes.TypeCollection at 0x40315adc&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_SE' class='de'><h1>Method <span class='n'>getType</span></h1><div class='re'><code>getType( self, name )</code></div><div class='ds'><pre>Returns the type with the given name, or None if it does not
		exist.</pre></div></div><div id='d_QE' class='de'><h1>Class <span class='n'>Structure</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_UE' class='de'><h1>Method <span class='n'>getType</span></h1><div class='re'><code>getType( self, name )</code></div><div class='ds'><pre>Returns the type with the given name, or None if it does not
		exist.</pre></div></div><div id='d_TE' class='de'><h1>Class <span class='n'>TypeCollection</span></h1><div class='re'></div><div class='ds'><pre>A type collection is a class that contains type definitions which can be
	easily retrieved using the @getType method.</pre></div></div><div id='d_VE' class='de'><h1>Function <span class='n'>typeForValue</span></h1><div class='re'><code>typeForValue( value, noneIs=<lambdafactory.typecast.Symbolic instance at 0x4030efec> )</code></div><div class='ds'><pre>Associates a type with the given value. This basically creates a typecast
	instance/subtype, using the types defined in this module, using the given
	value which is a program element (implements interfaces defined in
	LF 'interfaces' module).</pre></div></div><div id='d_WE' class='de'><h1>NoneType</h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_XE' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.modeltypes.Data at 0x40315e6c&gt;, &lt;class lambdafactory.modeltypes.Operations at 0x40315e9c&gt;, &lt;class lambdafactory.modeltypes.Structure at 0x40315ecc&gt;, &lt;class lambdafactory.modeltypes.Behaviour at 0x40315efc&gt;, &lt;class lambdafactory.modeltypes.Runtime at 0x40315f2c&gt;)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_DE' class='de'><h1>Module <span class='n'>lambdafactory.modeltypes</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_aF' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.typecast.Sequence at 0x40315d4c&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_bF' class='de'><h1>Method <span class='n'>__call__</span></h1><div class='re'><code>__call__( self )</code></div><div class='ds'><pre>A type instance can be used as a class to construct a new type, which
		will be cloned from the current type.</pre></div></div><div id='d_cF' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self, *args )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_dF' class='de'><h1>Method <span class='n'>__str__</span></h1><div class='re'><code>__str__( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_eF' class='de'><h1>Method <span class='n'>add</span></h1><div class='re'><code>add( self, theType )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_fF' class='de'><h1>Method <span class='n'>asString</span></h1><div class='re'><code>asString( self, fromTypes=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_gF' class='de'><h1>Method <span class='n'>clone</span></h1><div class='re'><code>clone( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_hF' class='de'><h1>Method <span class='n'>concreteType</span></h1><div class='re'><code>concreteType( self )</code></div><div class='ds'><pre>Returns the _concrete type_ for this abstract type.</pre></div></div><div id='d_iF' class='de'><h1>Method <span class='n'>definedBy</span></h1><div class='re'><code>definedBy( self, definition=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_jF' class='de'><h1>Method <span class='n'>elements</span></h1><div class='re'><code>elements( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_kF' class='de'><h1>Method <span class='n'>extend</span></h1><div class='re'><code>extend( self, othertype )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_lF' class='de'><h1>Method <span class='n'>isLike</span></h1><div class='re'><code>isLike( self, otherType )</code></div><div class='ds'><pre>The other type is like this one if the other is a sequence with the
		same length and that all elements are like the corresponding elements of
		this sequence.</pre></div></div><div id='d_mF' class='de'><h1>Method <span class='n'>isSameAs</span></h1><div class='re'><code>isSameAs( self, otherType )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_nF' class='de'><h1>Method <span class='n'>isSubtypeOf</span></h1><div class='re'><code>isSubtypeOf( self, otherType )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_oF' class='de'><h1>Method <span class='n'>length</span></h1><div class='re'><code>length( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_pF' class='de'><h1>Method <span class='n'>name</span></h1><div class='re'><code>name( self, name=None )</code></div><div class='ds'><pre>Returns/sets the name for this type. By defaults, types are unnamed.</pre></div></div><div id='d_qF' class='de'><h1>Method <span class='n'>result</span></h1><div class='re'><code>result( self )</code></div><div class='ds'><pre>Returns the result for this type. This is usually just the type
		itself, except for processes types.</pre></div></div><div id='d_rF' class='de'><h1>Method <span class='n'>setConcreteType</span></h1><div class='re'><code>setConcreteType( self, value )</code></div><div class='ds'><pre>Sets the _concrete type_ for this abstract type. The concrete type
		is a value which represents the type. For instance, if this type
		represents a class, then the concrete type would be the class instance.</pre></div></div><div id='d_sF' class='de'><h1>Method <span class='n'>setName</span></h1><div class='re'><code>setName( self, name )</code></div><div class='ds'><pre>Sets the name of this type</pre></div></div><div id='d_tF' class='de'><h1>Method <span class='n'>subtype</span></h1><div class='re'><code>subtype( self, name )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_ZE' class='de'><h1>Class <span class='n'>Arguments</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_vF' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.typecast.Type at 0x40315c5c&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_wF' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self, contentType, name=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_xF' class='de'><h1>Method <span class='n'>asString</span></h1><div class='re'><code>asString( self, fromTypes=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_yF' class='de'><h1>Method <span class='n'>content</span></h1><div class='re'><code>content( self )</code></div><div class='ds'><pre>Returns the type for the content of this array.</pre></div></div><div id='d_zF' class='de'><h1>Method <span class='n'>isLike</span></h1><div class='re'><code>isLike( self, otherType )</code></div><div class='ds'><pre>Othertype must be an Array with a content type that is the same type
		as the content type.</pre></div></div><div id='d_AF' class='de'><h1>Method <span class='n'>isSameAs</span></h1><div class='re'><code>isSameAs( self, otherType )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_BF' class='de'><h1>Method <span class='n'>isSubtypeOf</span></h1><div class='re'><code>isSubtypeOf( self, otherType )</code></div><div class='ds'><pre>Othertype must be an Array with a content type that is a subtype of
		this content type.</pre></div></div><div id='d_CF' class='de'><h1>Method <span class='n'>setContentType</span></h1><div class='re'><code>setContentType( self, theType )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_DF' class='de'><h1>Method <span class='n'>__call__</span></h1><div class='re'><code>__call__( self )</code></div><div class='ds'><pre>A type instance can be used as a class to construct a new type, which
		will be cloned from the current type.</pre></div></div><div id='d_EF' class='de'><h1>Method <span class='n'>__str__</span></h1><div class='re'><code>__str__( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_FF' class='de'><h1>Method <span class='n'>clone</span></h1><div class='re'><code>clone( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_GF' class='de'><h1>Method <span class='n'>concreteType</span></h1><div class='re'><code>concreteType( self )</code></div><div class='ds'><pre>Returns the _concrete type_ for this abstract type.</pre></div></div><div id='d_HF' class='de'><h1>Method <span class='n'>definedBy</span></h1><div class='re'><code>definedBy( self, definition=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_IF' class='de'><h1>Method <span class='n'>name</span></h1><div class='re'><code>name( self, name=None )</code></div><div class='ds'><pre>Returns/sets the name for this type. By defaults, types are unnamed.</pre></div></div><div id='d_JF' class='de'><h1>Method <span class='n'>result</span></h1><div class='re'><code>result( self )</code></div><div class='ds'><pre>Returns the result for this type. This is usually just the type
		itself, except for processes types.</pre></div></div><div id='d_KF' class='de'><h1>Method <span class='n'>setConcreteType</span></h1><div class='re'><code>setConcreteType( self, value )</code></div><div class='ds'><pre>Sets the _concrete type_ for this abstract type. The concrete type
		is a value which represents the type. For instance, if this type
		represents a class, then the concrete type would be the class instance.</pre></div></div><div id='d_LF' class='de'><h1>Method <span class='n'>setName</span></h1><div class='re'><code>setName( self, name )</code></div><div class='ds'><pre>Sets the name of this type</pre></div></div><div id='d_MF' class='de'><h1>Method <span class='n'>subtype</span></h1><div class='re'><code>subtype( self, name )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_uF' class='de'><h1>Class <span class='n'>Array</span></h1><div class='re'></div><div class='ds'><pre>A sequence is simply an ordered set of types.</pre></div></div><div id='d_OF' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.typecast.Type at 0x40315c5c&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_PF' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self, length, name=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_QF' class='de'><h1>Method <span class='n'>asString</span></h1><div class='re'><code>asString( self, fromType=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_RF' class='de'><h1>Method <span class='n'>clone</span></h1><div class='re'><code>clone( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_SF' class='de'><h1>Method <span class='n'>isLike</span></h1><div class='re'><code>isLike( self, otherType )</code></div><div class='ds'><pre>The other type is like this Cell if the other type is a cell of the
		same length as this one.</pre></div></div><div id='d_TF' class='de'><h1>Method <span class='n'>isSameAs</span></h1><div class='re'><code>isSameAs( self, otherType )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_UF' class='de'><h1>Method <span class='n'>isSubtypeOf</span></h1><div class='re'><code>isSubtypeOf( self, otherType )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_VF' class='de'><h1>Method <span class='n'>length</span></h1><div class='re'><code>length( self )</code></div><div class='ds'><pre>Returns the length (in bytes) for this cell.</pre></div></div><div id='d_WF' class='de'><h1>Method <span class='n'>__call__</span></h1><div class='re'><code>__call__( self )</code></div><div class='ds'><pre>A type instance can be used as a class to construct a new type, which
		will be cloned from the current type.</pre></div></div><div id='d_XF' class='de'><h1>Method <span class='n'>__str__</span></h1><div class='re'><code>__str__( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_YF' class='de'><h1>Method <span class='n'>concreteType</span></h1><div class='re'><code>concreteType( self )</code></div><div class='ds'><pre>Returns the _concrete type_ for this abstract type.</pre></div></div><div id='d_ZF' class='de'><h1>Method <span class='n'>definedBy</span></h1><div class='re'><code>definedBy( self, definition=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_aG' class='de'><h1>Method <span class='n'>name</span></h1><div class='re'><code>name( self, name=None )</code></div><div class='ds'><pre>Returns/sets the name for this type. By defaults, types are unnamed.</pre></div></div><div id='d_bG' class='de'><h1>Method <span class='n'>result</span></h1><div class='re'><code>result( self )</code></div><div class='ds'><pre>Returns the result for this type. This is usually just the type
		itself, except for processes types.</pre></div></div><div id='d_cG' class='de'><h1>Method <span class='n'>setConcreteType</span></h1><div class='re'><code>setConcreteType( self, value )</code></div><div class='ds'><pre>Sets the _concrete type_ for this abstract type. The concrete type
		is a value which represents the type. For instance, if this type
		represents a class, then the concrete type would be the class instance.</pre></div></div><div id='d_dG' class='de'><h1>Method <span class='n'>setName</span></h1><div class='re'><code>setName( self, name )</code></div><div class='ds'><pre>Sets the name of this type</pre></div></div><div id='d_eG' class='de'><h1>Method <span class='n'>subtype</span></h1><div class='re'><code>subtype( self, name )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_NF' class='de'><h1>Class <span class='n'>Cell</span></h1><div class='re'></div><div class='ds'><pre>A cell type represents a memory unit. It has a size (in bytes) the
	represents the length in memory.</pre></div></div><div id='d_gG' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.typecast.Map at 0x40315ddc&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_hG' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self, *args, **kwargs )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_iG' class='de'><h1>Method <span class='n'>clone</span></h1><div class='re'><code>clone( self, clone=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_jG' class='de'><h1>Method <span class='n'>element</span></h1><div class='re'><code>element( self, key )</code></div><div class='ds'><pre>Returns the element associated with the given key, or 'None' if it
		does not exist.</pre></div></div><div id='d_kG' class='de'><h1>Method <span class='n'>elements</span></h1><div class='re'><code>elements( self )</code></div><div class='ds'><pre>Returns a dict of the elements in this map.</pre></div></div><div id='d_lG' class='de'><h1>Method <span class='n'>extends</span></h1><div class='re'><code>extends( self, parent )</code></div><div class='ds'><pre>Add a new parent from which this Context inherits.</pre></div></div><div id='d_mG' class='de'><h1>Method <span class='n'>fullName</span></h1><div class='re'><code>fullName( self )</code></div><div class='ds'><pre>Returns the fully qualified name for this context, by
		concateniating the chain of parents name with '.'</pre></div></div><div id='d_nG' class='de'><h1>Method <span class='n'>parent</span></h1><div class='re'><code>parent( self, parent=None )</code></div><div class='ds'><pre>Returns the main parent for this context.</pre></div></div><div id='d_oG' class='de'><h1>Method <span class='n'>parents</span></h1><div class='re'><code>parents( self )</code></div><div class='ds'><pre>Returns a context parents, as a mutable list.</pre></div></div><div id='d_pG' class='de'><h1>Method <span class='n'>__call__</span></h1><div class='re'><code>__call__( self )</code></div><div class='ds'><pre>A type instance can be used as a class to construct a new type, which
		will be cloned from the current type.</pre></div></div><div id='d_qG' class='de'><h1>Method <span class='n'>__str__</span></h1><div class='re'><code>__str__( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_rG' class='de'><h1>Method <span class='n'>add</span></h1><div class='re'><code>add( self, name, theType )</code></div><div class='ds'><pre>This is a *deprecated* methods that is simply an alias for 'Map.set'.</pre></div></div><div id='d_sG' class='de'><h1>Method <span class='n'>asString</span></h1><div class='re'><code>asString( self, fromTypes=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_tG' class='de'><h1>Method <span class='n'>concreteType</span></h1><div class='re'><code>concreteType( self )</code></div><div class='ds'><pre>Returns the _concrete type_ for this abstract type.</pre></div></div><div id='d_uG' class='de'><h1>Method <span class='n'>definedBy</span></h1><div class='re'><code>definedBy( self, definition=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_vG' class='de'><h1>Method <span class='n'>elementNames</span></h1><div class='re'><code>elementNames( self )</code></div><div class='ds'><pre>Returns the list of slots/elements defined in this map.</pre></div></div><div id='d_wG' class='de'><h1>Method <span class='n'>get</span></h1><div class='re'><code>get( self, name )</code></div><div class='ds'><pre>Returns the type for the slot with the given name.</pre></div></div><div id='d_xG' class='de'><h1>Method <span class='n'>isLike</span></h1><div class='re'><code>isLike( self, otherType )</code></div><div class='ds'><pre>The other type is like this one if the other is a sequence with the
		same length and that all elements are like the corresponding elements of
		this sequence.</pre></div></div><div id='d_yG' class='de'><h1>Method <span class='n'>isSameAs</span></h1><div class='re'><code>isSameAs( self, otherType )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_zG' class='de'><h1>Method <span class='n'>isSubtypeOf</span></h1><div class='re'><code>isSubtypeOf( self, otherType )</code></div><div class='ds'><pre>The other type is a subtype of this one if for each element of this
		type, we find that the other type has a subtype.</pre></div></div><div id='d_AG' class='de'><h1>Method <span class='n'>name</span></h1><div class='re'><code>name( self, name=None )</code></div><div class='ds'><pre>Returns/sets the name for this type. By defaults, types are unnamed.</pre></div></div><div id='d_BG' class='de'><h1>Method <span class='n'>result</span></h1><div class='re'><code>result( self )</code></div><div class='ds'><pre>Returns the result for this type. This is usually just the type
		itself, except for processes types.</pre></div></div><div id='d_CG' class='de'><h1>Method <span class='n'>set</span></h1><div class='re'><code>set( self, name, theType )</code></div><div class='ds'><pre>Sets the slot with the given 'name' to have a value of the given
		type ('theType').</pre></div></div><div id='d_DG' class='de'><h1>Method <span class='n'>setConcreteType</span></h1><div class='re'><code>setConcreteType( self, value )</code></div><div class='ds'><pre>Sets the _concrete type_ for this abstract type. The concrete type
		is a value which represents the type. For instance, if this type
		represents a class, then the concrete type would be the class instance.</pre></div></div><div id='d_EG' class='de'><h1>Method <span class='n'>setName</span></h1><div class='re'><code>setName( self, name )</code></div><div class='ds'><pre>Sets the name of this type</pre></div></div><div id='d_FG' class='de'><h1>Method <span class='n'>subtype</span></h1><div class='re'><code>subtype( self, name )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_fG' class='de'><h1>Class <span class='n'>Context</span></h1><div class='re'></div><div class='ds'><pre>The Context type is the type that will probably be the most used in OO
	languages. A context can inherit from other contexts, in which case there is
	an explicit subtyping relationship.</pre></div></div><div id='d_HG' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_IG' class='de'><h1>Method <span class='n'>register</span></h1><div class='re'><code>register( self, name, _type )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_JG' class='de'><h1>Method <span class='n'>resolve</span></h1><div class='re'><code>resolve( self, typeName )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_GG' class='de'><h1>Class <span class='n'>Environment</span></h1><div class='re'></div><div class='ds'><pre>The environment stores types and names them. This allows to easily
	retrieve types from a given name.</pre></div></div><div id='d_KG' class='de'><h1>Class <span class='n'>InvalidArgument</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_MG' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.typecast.Type at 0x40315c5c&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_NG' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self, **kwargs )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_OG' class='de'><h1>Method <span class='n'>add</span></h1><div class='re'><code>add( self, name, theType )</code></div><div class='ds'><pre>This is a *deprecated* methods that is simply an alias for 'Map.set'.</pre></div></div><div id='d_PG' class='de'><h1>Method <span class='n'>asString</span></h1><div class='re'><code>asString( self, fromTypes=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_QG' class='de'><h1>Method <span class='n'>clone</span></h1><div class='re'><code>clone( self, clone=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_RG' class='de'><h1>Method <span class='n'>element</span></h1><div class='re'><code>element( self, key )</code></div><div class='ds'><pre>Returns the element associated to the given key.</pre></div></div><div id='d_SG' class='de'><h1>Method <span class='n'>elementNames</span></h1><div class='re'><code>elementNames( self )</code></div><div class='ds'><pre>Returns the list of slots/elements defined in this map.</pre></div></div><div id='d_TG' class='de'><h1>Method <span class='n'>elements</span></h1><div class='re'><code>elements( self )</code></div><div class='ds'><pre>Returns a dict of the elements in this map. Do not modify it.</pre></div></div><div id='d_UG' class='de'><h1>Method <span class='n'>get</span></h1><div class='re'><code>get( self, name )</code></div><div class='ds'><pre>Returns the type for the slot with the given name.</pre></div></div><div id='d_VG' class='de'><h1>Method <span class='n'>isLike</span></h1><div class='re'><code>isLike( self, otherType )</code></div><div class='ds'><pre>The other type is like this one if the other is a sequence with the
		same length and that all elements are like the corresponding elements of
		this sequence.</pre></div></div><div id='d_WG' class='de'><h1>Method <span class='n'>isSameAs</span></h1><div class='re'><code>isSameAs( self, otherType )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_XG' class='de'><h1>Method <span class='n'>isSubtypeOf</span></h1><div class='re'><code>isSubtypeOf( self, otherType )</code></div><div class='ds'><pre>The other type is a subtype of this one if for each element of this
		type, we find that the other type has a subtype.</pre></div></div><div id='d_YG' class='de'><h1>Method <span class='n'>set</span></h1><div class='re'><code>set( self, name, theType )</code></div><div class='ds'><pre>Sets the slot with the given 'name' to have a value of the given
		type ('theType').</pre></div></div><div id='d_ZG' class='de'><h1>Method <span class='n'>__call__</span></h1><div class='re'><code>__call__( self )</code></div><div class='ds'><pre>A type instance can be used as a class to construct a new type, which
		will be cloned from the current type.</pre></div></div><div id='d_aH' class='de'><h1>Method <span class='n'>__str__</span></h1><div class='re'><code>__str__( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_bH' class='de'><h1>Method <span class='n'>concreteType</span></h1><div class='re'><code>concreteType( self )</code></div><div class='ds'><pre>Returns the _concrete type_ for this abstract type.</pre></div></div><div id='d_cH' class='de'><h1>Method <span class='n'>definedBy</span></h1><div class='re'><code>definedBy( self, definition=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_dH' class='de'><h1>Method <span class='n'>name</span></h1><div class='re'><code>name( self, name=None )</code></div><div class='ds'><pre>Returns/sets the name for this type. By defaults, types are unnamed.</pre></div></div><div id='d_eH' class='de'><h1>Method <span class='n'>result</span></h1><div class='re'><code>result( self )</code></div><div class='ds'><pre>Returns the result for this type. This is usually just the type
		itself, except for processes types.</pre></div></div><div id='d_fH' class='de'><h1>Method <span class='n'>setConcreteType</span></h1><div class='re'><code>setConcreteType( self, value )</code></div><div class='ds'><pre>Sets the _concrete type_ for this abstract type. The concrete type
		is a value which represents the type. For instance, if this type
		represents a class, then the concrete type would be the class instance.</pre></div></div><div id='d_gH' class='de'><h1>Method <span class='n'>setName</span></h1><div class='re'><code>setName( self, name )</code></div><div class='ds'><pre>Sets the name of this type</pre></div></div><div id='d_hH' class='de'><h1>Method <span class='n'>subtype</span></h1><div class='re'><code>subtype( self, name )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_LG' class='de'><h1>Class <span class='n'>Map</span></h1><div class='re'></div><div class='ds'><pre>A map is simply an unordered set of types, mapped to names.</pre></div></div><div id='d_jH' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.typecast.Type at 0x40315c5c&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_kH' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self, *args )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_lH' class='de'><h1>Method <span class='n'>_ensureIntegrity</span></h1><div class='re'><code>_ensureIntegrity( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_mH' class='de'><h1>Method <span class='n'>add</span></h1><div class='re'><code>add( self, theType )</code></div><div class='ds'><pre>Adds the given type as an element to this process. The last added
		type becomes the result if one type was already added, the argument
		otherwise.</pre></div></div><div id='d_nH' class='de'><h1>Method <span class='n'>arguments</span></h1><div class='re'><code>arguments( self, args=None )</code></div><div class='ds'><pre>Returns the arguments of this process encapsulated in a sequence
		if there is more than one argument.</pre></div></div><div id='d_oH' class='de'><h1>Method <span class='n'>asString</span></h1><div class='re'><code>asString( self, fromTypes=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_pH' class='de'><h1>Method <span class='n'>clone</span></h1><div class='re'><code>clone( self, clone=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_qH' class='de'><h1>Method <span class='n'>elements</span></h1><div class='re'><code>elements( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_rH' class='de'><h1>Method <span class='n'>isLike</span></h1><div class='re'><code>isLike( self, otherType )</code></div><div class='ds'><pre>The other type is like this one if the other is a sequence with the
		same length and that all elements are like the corresponding elements of
		this sequence.</pre></div></div><div id='d_sH' class='de'><h1>Method <span class='n'>isSameAs</span></h1><div class='re'><code>isSameAs( self, otherType )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_tH' class='de'><h1>Method <span class='n'>isSubtypeOf</span></h1><div class='re'><code>isSubtypeOf( self, otherType )</code></div><div class='ds'><pre>The other type is like this one if the other is a sequence with the
		same length and that all elements are like the corresponding elements of
		this sequence.</pre></div></div><div id='d_uH' class='de'><h1>Method <span class='n'>peel</span></h1><div class='re'><code>peel( self )</code></div><div class='ds'><pre>If this process is (A, B)-&gt;C, will return (B)-&gt;C. You cannot peel a
		process that is (B)-&gt;C.</pre></div></div><div id='d_vH' class='de'><h1>Method <span class='n'>result</span></h1><div class='re'><code>result( self, result=None )</code></div><div class='ds'><pre>If there is not at least 2 addded types, the result is Nothing.</pre></div></div><div id='d_wH' class='de'><h1>Method <span class='n'>__call__</span></h1><div class='re'><code>__call__( self )</code></div><div class='ds'><pre>A type instance can be used as a class to construct a new type, which
		will be cloned from the current type.</pre></div></div><div id='d_xH' class='de'><h1>Method <span class='n'>__str__</span></h1><div class='re'><code>__str__( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_yH' class='de'><h1>Method <span class='n'>concreteType</span></h1><div class='re'><code>concreteType( self )</code></div><div class='ds'><pre>Returns the _concrete type_ for this abstract type.</pre></div></div><div id='d_zH' class='de'><h1>Method <span class='n'>definedBy</span></h1><div class='re'><code>definedBy( self, definition=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_AH' class='de'><h1>Method <span class='n'>name</span></h1><div class='re'><code>name( self, name=None )</code></div><div class='ds'><pre>Returns/sets the name for this type. By defaults, types are unnamed.</pre></div></div><div id='d_BH' class='de'><h1>Method <span class='n'>setConcreteType</span></h1><div class='re'><code>setConcreteType( self, value )</code></div><div class='ds'><pre>Sets the _concrete type_ for this abstract type. The concrete type
		is a value which represents the type. For instance, if this type
		represents a class, then the concrete type would be the class instance.</pre></div></div><div id='d_CH' class='de'><h1>Method <span class='n'>setName</span></h1><div class='re'><code>setName( self, name )</code></div><div class='ds'><pre>Sets the name of this type</pre></div></div><div id='d_DH' class='de'><h1>Method <span class='n'>subtype</span></h1><div class='re'><code>subtype( self, name )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_iH' class='de'><h1>Class <span class='n'>Process</span></h1><div class='re'></div><div class='ds'><pre>A process generates values by processing (optional) arguments.</pre></div></div><div id='d_EH' class='de'><h1>Class <span class='n'>SemanticError</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_GH' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.typecast.Type at 0x40315c5c&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_HH' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self, *args )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_IH' class='de'><h1>Method <span class='n'>add</span></h1><div class='re'><code>add( self, theType )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_JH' class='de'><h1>Method <span class='n'>asString</span></h1><div class='re'><code>asString( self, fromTypes=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_KH' class='de'><h1>Method <span class='n'>elements</span></h1><div class='re'><code>elements( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_LH' class='de'><h1>Method <span class='n'>extend</span></h1><div class='re'><code>extend( self, othertype )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_MH' class='de'><h1>Method <span class='n'>isLike</span></h1><div class='re'><code>isLike( self, otherType )</code></div><div class='ds'><pre>The other type is like this one if the other is a sequence with the
		same length and that all elements are like the corresponding elements of
		this sequence.</pre></div></div><div id='d_NH' class='de'><h1>Method <span class='n'>isSameAs</span></h1><div class='re'><code>isSameAs( self, otherType )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_OH' class='de'><h1>Method <span class='n'>isSubtypeOf</span></h1><div class='re'><code>isSubtypeOf( self, otherType )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_PH' class='de'><h1>Method <span class='n'>length</span></h1><div class='re'><code>length( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_QH' class='de'><h1>Method <span class='n'>__call__</span></h1><div class='re'><code>__call__( self )</code></div><div class='ds'><pre>A type instance can be used as a class to construct a new type, which
		will be cloned from the current type.</pre></div></div><div id='d_RH' class='de'><h1>Method <span class='n'>__str__</span></h1><div class='re'><code>__str__( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_SH' class='de'><h1>Method <span class='n'>clone</span></h1><div class='re'><code>clone( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_TH' class='de'><h1>Method <span class='n'>concreteType</span></h1><div class='re'><code>concreteType( self )</code></div><div class='ds'><pre>Returns the _concrete type_ for this abstract type.</pre></div></div><div id='d_UH' class='de'><h1>Method <span class='n'>definedBy</span></h1><div class='re'><code>definedBy( self, definition=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_VH' class='de'><h1>Method <span class='n'>name</span></h1><div class='re'><code>name( self, name=None )</code></div><div class='ds'><pre>Returns/sets the name for this type. By defaults, types are unnamed.</pre></div></div><div id='d_WH' class='de'><h1>Method <span class='n'>result</span></h1><div class='re'><code>result( self )</code></div><div class='ds'><pre>Returns the result for this type. This is usually just the type
		itself, except for processes types.</pre></div></div><div id='d_XH' class='de'><h1>Method <span class='n'>setConcreteType</span></h1><div class='re'><code>setConcreteType( self, value )</code></div><div class='ds'><pre>Sets the _concrete type_ for this abstract type. The concrete type
		is a value which represents the type. For instance, if this type
		represents a class, then the concrete type would be the class instance.</pre></div></div><div id='d_YH' class='de'><h1>Method <span class='n'>setName</span></h1><div class='re'><code>setName( self, name )</code></div><div class='ds'><pre>Sets the name of this type</pre></div></div><div id='d_ZH' class='de'><h1>Method <span class='n'>subtype</span></h1><div class='re'><code>subtype( self, name )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_FH' class='de'><h1>Class <span class='n'>Sequence</span></h1><div class='re'></div><div class='ds'><pre>A sequence is simply an ordered set of types.</pre></div></div><div id='d_bI' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.typecast.Type at 0x40315c5c&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_cI' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self, name )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_dI' class='de'><h1>Method <span class='n'>asString</span></h1><div class='re'><code>asString( self, fromType=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_eI' class='de'><h1>Method <span class='n'>clone</span></h1><div class='re'><code>clone( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_fI' class='de'><h1>Method <span class='n'>__call__</span></h1><div class='re'><code>__call__( self )</code></div><div class='ds'><pre>A type instance can be used as a class to construct a new type, which
		will be cloned from the current type.</pre></div></div><div id='d_gI' class='de'><h1>Method <span class='n'>__str__</span></h1><div class='re'><code>__str__( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_hI' class='de'><h1>Method <span class='n'>concreteType</span></h1><div class='re'><code>concreteType( self )</code></div><div class='ds'><pre>Returns the _concrete type_ for this abstract type.</pre></div></div><div id='d_iI' class='de'><h1>Method <span class='n'>definedBy</span></h1><div class='re'><code>definedBy( self, definition=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_jI' class='de'><h1>Method <span class='n'>isLike</span></h1><div class='re'><code>isLike( self, otherType )</code></div><div class='ds'><pre>Generic implementation of isLike. You should always call this method
		in subclasses, as it implements basic type systems rules such as
		isLike(Any).</pre></div></div><div id='d_kI' class='de'><h1>Method <span class='n'>isSameAs</span></h1><div class='re'><code>isSameAs( self, otherType )</code></div><div class='ds'><pre>Generic implementation of isSameAs. You should always call this method
		in subclasses.</pre></div></div><div id='d_lI' class='de'><h1>Method <span class='n'>isSubtypeOf</span></h1><div class='re'><code>isSubtypeOf( self, otherType )</code></div><div class='ds'><pre>Generic implementation of isSubtypeOf. You should always call this method
		in subclasses, as it implements basic type systems rules such as
		isSubtypeOf(Any).</pre></div></div><div id='d_mI' class='de'><h1>Method <span class='n'>name</span></h1><div class='re'><code>name( self, name=None )</code></div><div class='ds'><pre>Returns/sets the name for this type. By defaults, types are unnamed.</pre></div></div><div id='d_nI' class='de'><h1>Method <span class='n'>result</span></h1><div class='re'><code>result( self )</code></div><div class='ds'><pre>Returns the result for this type. This is usually just the type
		itself, except for processes types.</pre></div></div><div id='d_oI' class='de'><h1>Method <span class='n'>setConcreteType</span></h1><div class='re'><code>setConcreteType( self, value )</code></div><div class='ds'><pre>Sets the _concrete type_ for this abstract type. The concrete type
		is a value which represents the type. For instance, if this type
		represents a class, then the concrete type would be the class instance.</pre></div></div><div id='d_pI' class='de'><h1>Method <span class='n'>setName</span></h1><div class='re'><code>setName( self, name )</code></div><div class='ds'><pre>Sets the name of this type</pre></div></div><div id='d_qI' class='de'><h1>Method <span class='n'>subtype</span></h1><div class='re'><code>subtype( self, name )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_aI' class='de'><h1>Class <span class='n'>Symbolic</span></h1><div class='re'></div><div class='ds'><pre>Symbolic types are types that have no physical counter part but play a
	role in the type system. This is for instance the case with Any or Nil.</pre></div></div><div id='d_sI' class='de'><h1>Method <span class='n'>__call__</span></h1><div class='re'><code>__call__( self )</code></div><div class='ds'><pre>A type instance can be used as a class to construct a new type, which
		will be cloned from the current type.</pre></div></div><div id='d_tI' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self, name=None )</code></div><div class='ds'><pre>Creates a new anonymous type</pre></div></div><div id='d_uI' class='de'><h1>Method <span class='n'>__str__</span></h1><div class='re'><code>__str__( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_vI' class='de'><h1>Method <span class='n'>asString</span></h1><div class='re'><code>asString( self, fromTypes=None )</code></div><div class='ds'><pre>Returns a string representation of this type.</pre></div></div><div id='d_wI' class='de'><h1>Method <span class='n'>clone</span></h1><div class='re'><code>clone( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_xI' class='de'><h1>Method <span class='n'>concreteType</span></h1><div class='re'><code>concreteType( self )</code></div><div class='ds'><pre>Returns the _concrete type_ for this abstract type.</pre></div></div><div id='d_yI' class='de'><h1>Method <span class='n'>definedBy</span></h1><div class='re'><code>definedBy( self, definition=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_zI' class='de'><h1>Method <span class='n'>isLike</span></h1><div class='re'><code>isLike( self, otherType )</code></div><div class='ds'><pre>Generic implementation of isLike. You should always call this method
		in subclasses, as it implements basic type systems rules such as
		isLike(Any).</pre></div></div><div id='d_AI' class='de'><h1>Method <span class='n'>isSameAs</span></h1><div class='re'><code>isSameAs( self, otherType )</code></div><div class='ds'><pre>Generic implementation of isSameAs. You should always call this method
		in subclasses.</pre></div></div><div id='d_BI' class='de'><h1>Method <span class='n'>isSubtypeOf</span></h1><div class='re'><code>isSubtypeOf( self, otherType )</code></div><div class='ds'><pre>Generic implementation of isSubtypeOf. You should always call this method
		in subclasses, as it implements basic type systems rules such as
		isSubtypeOf(Any).</pre></div></div><div id='d_CI' class='de'><h1>Method <span class='n'>name</span></h1><div class='re'><code>name( self, name=None )</code></div><div class='ds'><pre>Returns/sets the name for this type. By defaults, types are unnamed.</pre></div></div><div id='d_DI' class='de'><h1>Method <span class='n'>result</span></h1><div class='re'><code>result( self )</code></div><div class='ds'><pre>Returns the result for this type. This is usually just the type
		itself, except for processes types.</pre></div></div><div id='d_EI' class='de'><h1>Method <span class='n'>setConcreteType</span></h1><div class='re'><code>setConcreteType( self, value )</code></div><div class='ds'><pre>Sets the _concrete type_ for this abstract type. The concrete type
		is a value which represents the type. For instance, if this type
		represents a class, then the concrete type would be the class instance.</pre></div></div><div id='d_FI' class='de'><h1>Method <span class='n'>setName</span></h1><div class='re'><code>setName( self, name )</code></div><div class='ds'><pre>Sets the name of this type</pre></div></div><div id='d_GI' class='de'><h1>Method <span class='n'>subtype</span></h1><div class='re'><code>subtype( self, name )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_rI' class='de'><h1>Class <span class='n'>Type</span></h1><div class='re'></div><div class='ds'><pre>Abstract class for all types.</pre></div></div><div id='d_II' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.typecast.Symbolic at 0x40315c8c&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_JI' class='de'><h1>Method <span class='n'>__call__</span></h1><div class='re'><code>__call__( self )</code></div><div class='ds'><pre>A type instance can be used as a class to construct a new type, which
		will be cloned from the current type.</pre></div></div><div id='d_KI' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self, name )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_LI' class='de'><h1>Method <span class='n'>__str__</span></h1><div class='re'><code>__str__( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_MI' class='de'><h1>Method <span class='n'>asString</span></h1><div class='re'><code>asString( self, fromType=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_NI' class='de'><h1>Method <span class='n'>clone</span></h1><div class='re'><code>clone( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_OI' class='de'><h1>Method <span class='n'>concreteType</span></h1><div class='re'><code>concreteType( self )</code></div><div class='ds'><pre>Returns the _concrete type_ for this abstract type.</pre></div></div><div id='d_PI' class='de'><h1>Method <span class='n'>definedBy</span></h1><div class='re'><code>definedBy( self, definition=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_QI' class='de'><h1>Method <span class='n'>isLike</span></h1><div class='re'><code>isLike( self, otherType )</code></div><div class='ds'><pre>Generic implementation of isLike. You should always call this method
		in subclasses, as it implements basic type systems rules such as
		isLike(Any).</pre></div></div><div id='d_RI' class='de'><h1>Method <span class='n'>isSameAs</span></h1><div class='re'><code>isSameAs( self, otherType )</code></div><div class='ds'><pre>Generic implementation of isSameAs. You should always call this method
		in subclasses.</pre></div></div><div id='d_SI' class='de'><h1>Method <span class='n'>isSubtypeOf</span></h1><div class='re'><code>isSubtypeOf( self, otherType )</code></div><div class='ds'><pre>Generic implementation of isSubtypeOf. You should always call this method
		in subclasses, as it implements basic type systems rules such as
		isSubtypeOf(Any).</pre></div></div><div id='d_TI' class='de'><h1>Method <span class='n'>name</span></h1><div class='re'><code>name( self, name=None )</code></div><div class='ds'><pre>Returns/sets the name for this type. By defaults, types are unnamed.</pre></div></div><div id='d_UI' class='de'><h1>Method <span class='n'>result</span></h1><div class='re'><code>result( self )</code></div><div class='ds'><pre>Returns the result for this type. This is usually just the type
		itself, except for processes types.</pre></div></div><div id='d_VI' class='de'><h1>Method <span class='n'>setConcreteType</span></h1><div class='re'><code>setConcreteType( self, value )</code></div><div class='ds'><pre>Sets the _concrete type_ for this abstract type. The concrete type
		is a value which represents the type. For instance, if this type
		represents a class, then the concrete type would be the class instance.</pre></div></div><div id='d_WI' class='de'><h1>Method <span class='n'>setName</span></h1><div class='re'><code>setName( self, name )</code></div><div class='ds'><pre>Sets the name of this type</pre></div></div><div id='d_XI' class='de'><h1>Method <span class='n'>subtype</span></h1><div class='re'><code>subtype( self, name )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_HI' class='de'><h1>Class <span class='n'>Unresolved</span></h1><div class='re'></div><div class='ds'><pre>Unresolved types are temporary types that can be resolved later
	when necessary.</pre></div></div><div id='d_YI' class='de'><h1>Function <span class='n'>Class</span></h1><div class='re'><code>Class( Context )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_ZI' class='de'><h1>Function <span class='n'>Interface</span></h1><div class='re'><code>Interface( Context )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_aJ' class='de'><h1>Function <span class='n'>Sequence_combine</span></h1><div class='re'><code>Sequence_combine( a, b, sequenceclass=<class lambdafactory.typecast.Sequence at 0x40315d4c> )</code></div><div class='ds'><pre>Combines the given arguments into a sequence. This follows the following
	rules:
		Nothing, Nothing     -&gt; Nothing
		Nothing, A           -&gt; A
		A,       B           -&gt; (A, B)
		(A, B),  C           -&gt; (A, B, C)   ( type = type(a) )
		(A, B),  (C, D)      -&gt; (A, B, C, D) ( type = type(a) )
		A     ,  (C, D)      -&gt; (A, B, C)   ( type = sequenceclass)
	</pre></div></div><div id='d_bJ' class='de'><h1>Function <span class='n'>Sequence_make</span></h1><div class='re'><code>Sequence_make( args, sequenceclass=<class lambdafactory.typecast.Sequence at 0x40315d4c> )</code></div><div class='ds'><pre>Tries to make a sequence from the given argumnents. This follows the
	following rules:<br />		len(args) == 0         -&gt; Nothing
		len(args) == 1         -&gt; args[1]
		otherwise              -&gt; (args....)
	</pre></div></div><div id='d_cJ' class='de'><h1>Function <span class='n'>bits</span></h1><div class='re'><code>bits( size )</code></div><div class='ds'><pre>Converts the given number of bits into bytes. This is simply for
	readibility purprose.</pre></div></div><div id='d_dJ' class='de'><h1>Function <span class='n'>isLike</span></h1><div class='re'><code>isLike( a, b )</code></div><div class='ds'><pre>Type (b) is like type (a) if (b) can be used where (a) can be used. When
	two types are alike but not the same, this usually means that one type is
	composed at some level of 'Any' or 'Rest' types.<br />	Not that isLike(a,b) does not imply isLike(b,a), as (a) may be a "broad"
	type (such as 'Any'), and (b) a particular type (say 'String').</pre></div></div><div id='d_eJ' class='de'><h1>Function <span class='n'>isSame</span></h1><div class='re'><code>isSame( a, b )</code></div><div class='ds'><pre>Type (b) is the same as (a) if (a) and (b) are identicial, that means
	that you can use b where you use a, and this also means that isSame(a,b) ==
	isSame(b,a). Basically, when (b) is same as (a), (b) can be considered as an
	alias for (a).</pre></div></div><div id='d_fJ' class='de'><h1>Function <span class='n'>isSubtype</span></h1><div class='re'><code>isSubtype( a, b )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_gJ' class='de'><h1>Function <span class='n'>isType</span></h1><div class='re'><code>isType( a )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_hJ' class='de'><h1>instance</h1><div class='re'></div><div class='ds'><pre>Symbolic types are types that have no physical counter part but play a
	role in the type system. This is for instance the case with Any or Nil.</pre></div></div><div id='d_iJ' class='de'><h1>instance</h1><div class='re'></div><div class='ds'><pre>Symbolic types are types that have no physical counter part but play a
	role in the type system. This is for instance the case with Any or Nil.</pre></div></div><div id='d_jJ' class='de'><h1>instance</h1><div class='re'></div><div class='ds'><pre>Symbolic types are types that have no physical counter part but play a
	role in the type system. This is for instance the case with Any or Nil.</pre></div></div><div id='d_kJ' class='de'><h1>instance</h1><div class='re'></div><div class='ds'><pre>Symbolic types are types that have no physical counter part but play a
	role in the type system. This is for instance the case with Any or Nil.</pre></div></div><div id='d_YE' class='de'><h1>Module <span class='n'>lambdafactory.typecast</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_nJ' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.passes.Pass at 0x857b20c&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_oJ' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self, args=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_pJ' class='de'><h1>Method <span class='n'>asHTML</span></h1><div class='re'><code>asHTML( self, title=None )</code></div><div class='ds'><pre>Returns the HTML document generated by this pass</pre></div></div><div id='d_qJ' class='de'><h1>Method <span class='n'>onModule</span></h1><div class='re'><code>onModule( self, module )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_rJ' class='de'><h1>Method <span class='n'>annotate</span></h1><div class='re'><code>annotate( self, value, name, content=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_sJ' class='de'><h1>Method <span class='n'>filter</span></h1><div class='re'><code>filter( self, list, interface )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_tJ' class='de'><h1>Method <span class='n'>filterContext</span></h1><div class='re'><code>filterContext( self, interface )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_uJ' class='de'><h1>Method <span class='n'>findInContext</span></h1><div class='re'><code>findInContext( self, interface )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_vJ' class='de'><h1>Method <span class='n'>getClassAncestors</span></h1><div class='re'><code>getClassAncestors( self, theClass=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_wJ' class='de'><h1>Method <span class='n'>getClassParents</span></h1><div class='re'><code>getClassParents( self, theClass )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_xJ' class='de'><h1>Method <span class='n'>getCurrentClass</span></h1><div class='re'><code>getCurrentClass( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_yJ' class='de'><h1>Method <span class='n'>getCurrentClassAncestors</span></h1><div class='re'><code>getCurrentClassAncestors( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_zJ' class='de'><h1>Method <span class='n'>getCurrentClassParents</span></h1><div class='re'><code>getCurrentClassParents( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_AJ' class='de'><h1>Method <span class='n'>getCurrentClosure</span></h1><div class='re'><code>getCurrentClosure( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_BJ' class='de'><h1>Method <span class='n'>getCurrentContext</span></h1><div class='re'><code>getCurrentContext( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_CJ' class='de'><h1>Method <span class='n'>getCurrentDataFlow</span></h1><div class='re'><code>getCurrentDataFlow( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_DJ' class='de'><h1>Method <span class='n'>getCurrentElement</span></h1><div class='re'><code>getCurrentElement( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_EJ' class='de'><h1>Method <span class='n'>getCurrentFunction</span></h1><div class='re'><code>getCurrentFunction( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_FJ' class='de'><h1>Method <span class='n'>getCurrentMethod</span></h1><div class='re'><code>getCurrentMethod( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_GJ' class='de'><h1>Method <span class='n'>getCurrentModule</span></h1><div class='re'><code>getCurrentModule( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_HJ' class='de'><h1>Method <span class='n'>getCurrentProcess</span></h1><div class='re'><code>getCurrentProcess( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_IJ' class='de'><h1>Method <span class='n'>getFactory</span></h1><div class='re'><code>getFactory( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_JJ' class='de'><h1>Method <span class='n'>getHandler</span></h1><div class='re'><code>getHandler( self, element )</code></div><div class='ds'><pre>Tells if the pass handles the given element. This basically iterates
		on the 'handles' property values (which are interfaces), when one
		interface matches the given 'element', then the corresponding 'onXXX'
		method is invoked, where 'XXX' is the interface
		name (without the leading 'I').</pre></div></div><div id='d_KJ' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><pre>Returns the name of this pass</pre></div></div><div id='d_LJ' class='de'><h1>Method <span class='n'>getParentElement</span></h1><div class='re'><code>getParentElement( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_MJ' class='de'><h1>Method <span class='n'>getProgram</span></h1><div class='re'><code>getProgram( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_NJ' class='de'><h1>Method <span class='n'>handle</span></h1><div class='re'><code>handle( self, element )</code></div><div class='ds'><pre>Handles a sungle element, without recursing through its children</pre></div></div><div id='d_OJ' class='de'><h1>Method <span class='n'>hasParentElement</span></h1><div class='re'><code>hasParentElement( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_PJ' class='de'><h1>Method <span class='n'>isIn</span></h1><div class='re'><code>isIn( self, interface )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_QJ' class='de'><h1>Method <span class='n'>resolve</span></h1><div class='re'><code>resolve( self, referenceOrName, contextOrDataFlow=None )</code></div><div class='ds'><pre>Resolves the given 'IReference' or String sing the given context
		('IContext') or dataflow ('IDataFlow'). This usually requires that
		you've applied a pass to create the dataflow (see the
		'lambdafactory.resolution.BasicDataFlow' pass).</pre></div></div><div id='d_RJ' class='de'><h1>Method <span class='n'>resolveAbsolute</span></h1><div class='re'><code>resolveAbsolute( self, referenceOrName )</code></div><div class='ds'><pre>Resolves the given reference or string expressed in absolute style
		('.'-separated list of names), starting from the root dataflow (the program
		dataflow).</pre></div></div><div id='d_SJ' class='de'><h1>Method <span class='n'>resolveAbsoluteOrLocal</span></h1><div class='re'><code>resolveAbsoluteOrLocal( self, referenceOrName, contextOrDataFlow=None )</code></div><div class='ds'><pre>Tries an absolute resolution first, then will look in the local scope if
		it fails.</pre></div></div><div id='d_TJ' class='de'><h1>Method <span class='n'>resolveLocalOrAbsolute</span></h1><div class='re'><code>resolveLocalOrAbsolute( self, referenceOrName, contextOrDataFlow=None )</code></div><div class='ds'><pre>Tries a local resolution first, then will look in the program scope if
		it fails.</pre></div></div><div id='d_UJ' class='de'><h1>Method <span class='n'>run</span></h1><div class='re'><code>run( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_VJ' class='de'><h1>Method <span class='n'>setEnvironment</span></h1><div class='re'><code>setEnvironment( self, environment )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_WJ' class='de'><h1>Method <span class='n'>setPass</span></h1><div class='re'><code>setPass( self, programPass )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_XJ' class='de'><h1>Method <span class='n'>walk</span></h1><div class='re'><code>walk( self, element )</code></div><div class='ds'><pre>Walks the given element, recursively walking the child elements when the
		handler does not return False</pre></div></div><div id='d_YJ' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.IModule at 0x85d23bc&gt;]</code></div><div class='ds'><pre>list() -&gt; new list
list(sequence) -&gt; new list initialized from sequence's items</pre></div></div><div id='d_ZJ' class='de'><h1>str</h1><div class='re'><code>'Documentation'</code></div><div class='ds'><pre>str(object) -&gt; string<br />Return a nice string representation of the object.
If the argument is a string, the return value is the same object.</pre></div></div><div id='d_mJ' class='de'><h1>Class <span class='n'>DocumentationPass</span></h1><div class='re'></div><div class='ds'><pre>The documentation pass will run SDoc on all the modules declared in this
	program, creating an HTML file.</pre></div></div><div id='d_bK' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.passes.Pass at 0x857b20c&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_cK' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_dK' class='de'><h1>Method <span class='n'>onModule</span></h1><div class='re'><code>onModule( self, module )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_eK' class='de'><h1>Method <span class='n'>onProgram</span></h1><div class='re'><code>onProgram( self, program )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_fK' class='de'><h1>Method <span class='n'>annotate</span></h1><div class='re'><code>annotate( self, value, name, content=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_gK' class='de'><h1>Method <span class='n'>filter</span></h1><div class='re'><code>filter( self, list, interface )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_hK' class='de'><h1>Method <span class='n'>filterContext</span></h1><div class='re'><code>filterContext( self, interface )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_iK' class='de'><h1>Method <span class='n'>findInContext</span></h1><div class='re'><code>findInContext( self, interface )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_jK' class='de'><h1>Method <span class='n'>getClassAncestors</span></h1><div class='re'><code>getClassAncestors( self, theClass=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_kK' class='de'><h1>Method <span class='n'>getClassParents</span></h1><div class='re'><code>getClassParents( self, theClass )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_lK' class='de'><h1>Method <span class='n'>getCurrentClass</span></h1><div class='re'><code>getCurrentClass( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_mK' class='de'><h1>Method <span class='n'>getCurrentClassAncestors</span></h1><div class='re'><code>getCurrentClassAncestors( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_nK' class='de'><h1>Method <span class='n'>getCurrentClassParents</span></h1><div class='re'><code>getCurrentClassParents( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_oK' class='de'><h1>Method <span class='n'>getCurrentClosure</span></h1><div class='re'><code>getCurrentClosure( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_pK' class='de'><h1>Method <span class='n'>getCurrentContext</span></h1><div class='re'><code>getCurrentContext( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_qK' class='de'><h1>Method <span class='n'>getCurrentDataFlow</span></h1><div class='re'><code>getCurrentDataFlow( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_rK' class='de'><h1>Method <span class='n'>getCurrentElement</span></h1><div class='re'><code>getCurrentElement( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_sK' class='de'><h1>Method <span class='n'>getCurrentFunction</span></h1><div class='re'><code>getCurrentFunction( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_tK' class='de'><h1>Method <span class='n'>getCurrentMethod</span></h1><div class='re'><code>getCurrentMethod( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_uK' class='de'><h1>Method <span class='n'>getCurrentModule</span></h1><div class='re'><code>getCurrentModule( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_vK' class='de'><h1>Method <span class='n'>getCurrentProcess</span></h1><div class='re'><code>getCurrentProcess( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_wK' class='de'><h1>Method <span class='n'>getFactory</span></h1><div class='re'><code>getFactory( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_xK' class='de'><h1>Method <span class='n'>getHandler</span></h1><div class='re'><code>getHandler( self, element )</code></div><div class='ds'><pre>Tells if the pass handles the given element. This basically iterates
		on the 'handles' property values (which are interfaces), when one
		interface matches the given 'element', then the corresponding 'onXXX'
		method is invoked, where 'XXX' is the interface
		name (without the leading 'I').</pre></div></div><div id='d_yK' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><pre>Returns the name of this pass</pre></div></div><div id='d_zK' class='de'><h1>Method <span class='n'>getParentElement</span></h1><div class='re'><code>getParentElement( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_AK' class='de'><h1>Method <span class='n'>getProgram</span></h1><div class='re'><code>getProgram( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_BK' class='de'><h1>Method <span class='n'>handle</span></h1><div class='re'><code>handle( self, element )</code></div><div class='ds'><pre>Handles a sungle element, without recursing through its children</pre></div></div><div id='d_CK' class='de'><h1>Method <span class='n'>hasParentElement</span></h1><div class='re'><code>hasParentElement( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_DK' class='de'><h1>Method <span class='n'>isIn</span></h1><div class='re'><code>isIn( self, interface )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_EK' class='de'><h1>Method <span class='n'>resolve</span></h1><div class='re'><code>resolve( self, referenceOrName, contextOrDataFlow=None )</code></div><div class='ds'><pre>Resolves the given 'IReference' or String sing the given context
		('IContext') or dataflow ('IDataFlow'). This usually requires that
		you've applied a pass to create the dataflow (see the
		'lambdafactory.resolution.BasicDataFlow' pass).</pre></div></div><div id='d_FK' class='de'><h1>Method <span class='n'>resolveAbsolute</span></h1><div class='re'><code>resolveAbsolute( self, referenceOrName )</code></div><div class='ds'><pre>Resolves the given reference or string expressed in absolute style
		('.'-separated list of names), starting from the root dataflow (the program
		dataflow).</pre></div></div><div id='d_GK' class='de'><h1>Method <span class='n'>resolveAbsoluteOrLocal</span></h1><div class='re'><code>resolveAbsoluteOrLocal( self, referenceOrName, contextOrDataFlow=None )</code></div><div class='ds'><pre>Tries an absolute resolution first, then will look in the local scope if
		it fails.</pre></div></div><div id='d_HK' class='de'><h1>Method <span class='n'>resolveLocalOrAbsolute</span></h1><div class='re'><code>resolveLocalOrAbsolute( self, referenceOrName, contextOrDataFlow=None )</code></div><div class='ds'><pre>Tries a local resolution first, then will look in the program scope if
		it fails.</pre></div></div><div id='d_IK' class='de'><h1>Method <span class='n'>run</span></h1><div class='re'><code>run( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_JK' class='de'><h1>Method <span class='n'>setEnvironment</span></h1><div class='re'><code>setEnvironment( self, environment )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_KK' class='de'><h1>Method <span class='n'>setPass</span></h1><div class='re'><code>setPass( self, programPass )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_LK' class='de'><h1>Method <span class='n'>walk</span></h1><div class='re'><code>walk( self, element )</code></div><div class='ds'><pre>Walks the given element, recursively walking the child elements when the
		handler does not return False</pre></div></div><div id='d_MK' class='de'><h1>list</h1><div class='re'><code>['assert', 'access', 'car', 'cdr', 'cons', 'createMapFromItems', 'error', 'filter', 'getChildrenOf', 'getClass', 'getClasses', 'getClassOf', 'getMethod', 'getMethodOf', 'getParentClass', 'getSuperMethod', 'invoke', 'isDefined', 'isFunction', 'isIn', 'isInstance', 'isList', 'isMap', 'isString', 'iterate', 'len', 'map', 'print', 'range', 'reduce', 'slice', 'sliceArguments']</code></div><div class='ds'><pre>list() -&gt; new list
list(sequence) -&gt; new list initialized from sequence's items</pre></div></div><div id='d_NK' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.IProgram at 0x85d23ec&gt;, &lt;class lambdafactory.interfaces.IModule at 0x85d23bc&gt;]</code></div><div class='ds'><pre>list() -&gt; new list
list(sequence) -&gt; new list initialized from sequence's items</pre></div></div><div id='d_OK' class='de'><h1>str</h1><div class='re'><code>'GlobalRuntime'</code></div><div class='ds'><pre>str(object) -&gt; string<br />Return a nice string representation of the object.
If the argument is a string, the return value is the same object.</pre></div></div><div id='d_aK' class='de'><h1>Class <span class='n'>ExtendJSRuntime</span></h1><div class='re'></div><div class='ds'><pre>This pass is like an importation and will simply bind the symbols</pre></div></div><div id='d_QK' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.passes.Pass at 0x857b20c&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_RK' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_SK' class='de'><h1>Method <span class='n'>onModule</span></h1><div class='re'><code>onModule( self, module )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_TK' class='de'><h1>Method <span class='n'>annotate</span></h1><div class='re'><code>annotate( self, value, name, content=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_UK' class='de'><h1>Method <span class='n'>filter</span></h1><div class='re'><code>filter( self, list, interface )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_VK' class='de'><h1>Method <span class='n'>filterContext</span></h1><div class='re'><code>filterContext( self, interface )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_WK' class='de'><h1>Method <span class='n'>findInContext</span></h1><div class='re'><code>findInContext( self, interface )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_XK' class='de'><h1>Method <span class='n'>getClassAncestors</span></h1><div class='re'><code>getClassAncestors( self, theClass=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_YK' class='de'><h1>Method <span class='n'>getClassParents</span></h1><div class='re'><code>getClassParents( self, theClass )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_ZK' class='de'><h1>Method <span class='n'>getCurrentClass</span></h1><div class='re'><code>getCurrentClass( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_aL' class='de'><h1>Method <span class='n'>getCurrentClassAncestors</span></h1><div class='re'><code>getCurrentClassAncestors( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_bL' class='de'><h1>Method <span class='n'>getCurrentClassParents</span></h1><div class='re'><code>getCurrentClassParents( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_cL' class='de'><h1>Method <span class='n'>getCurrentClosure</span></h1><div class='re'><code>getCurrentClosure( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_dL' class='de'><h1>Method <span class='n'>getCurrentContext</span></h1><div class='re'><code>getCurrentContext( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_eL' class='de'><h1>Method <span class='n'>getCurrentDataFlow</span></h1><div class='re'><code>getCurrentDataFlow( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_fL' class='de'><h1>Method <span class='n'>getCurrentElement</span></h1><div class='re'><code>getCurrentElement( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_gL' class='de'><h1>Method <span class='n'>getCurrentFunction</span></h1><div class='re'><code>getCurrentFunction( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_hL' class='de'><h1>Method <span class='n'>getCurrentMethod</span></h1><div class='re'><code>getCurrentMethod( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_iL' class='de'><h1>Method <span class='n'>getCurrentModule</span></h1><div class='re'><code>getCurrentModule( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_jL' class='de'><h1>Method <span class='n'>getCurrentProcess</span></h1><div class='re'><code>getCurrentProcess( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_kL' class='de'><h1>Method <span class='n'>getFactory</span></h1><div class='re'><code>getFactory( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_lL' class='de'><h1>Method <span class='n'>getHandler</span></h1><div class='re'><code>getHandler( self, element )</code></div><div class='ds'><pre>Tells if the pass handles the given element. This basically iterates
		on the 'handles' property values (which are interfaces), when one
		interface matches the given 'element', then the corresponding 'onXXX'
		method is invoked, where 'XXX' is the interface
		name (without the leading 'I').</pre></div></div><div id='d_mL' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><pre>Returns the name of this pass</pre></div></div><div id='d_nL' class='de'><h1>Method <span class='n'>getParentElement</span></h1><div class='re'><code>getParentElement( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_oL' class='de'><h1>Method <span class='n'>getProgram</span></h1><div class='re'><code>getProgram( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_pL' class='de'><h1>Method <span class='n'>handle</span></h1><div class='re'><code>handle( self, element )</code></div><div class='ds'><pre>Handles a sungle element, without recursing through its children</pre></div></div><div id='d_qL' class='de'><h1>Method <span class='n'>hasParentElement</span></h1><div class='re'><code>hasParentElement( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_rL' class='de'><h1>Method <span class='n'>isIn</span></h1><div class='re'><code>isIn( self, interface )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_sL' class='de'><h1>Method <span class='n'>resolve</span></h1><div class='re'><code>resolve( self, referenceOrName, contextOrDataFlow=None )</code></div><div class='ds'><pre>Resolves the given 'IReference' or String sing the given context
		('IContext') or dataflow ('IDataFlow'). This usually requires that
		you've applied a pass to create the dataflow (see the
		'lambdafactory.resolution.BasicDataFlow' pass).</pre></div></div><div id='d_tL' class='de'><h1>Method <span class='n'>resolveAbsolute</span></h1><div class='re'><code>resolveAbsolute( self, referenceOrName )</code></div><div class='ds'><pre>Resolves the given reference or string expressed in absolute style
		('.'-separated list of names), starting from the root dataflow (the program
		dataflow).</pre></div></div><div id='d_uL' class='de'><h1>Method <span class='n'>resolveAbsoluteOrLocal</span></h1><div class='re'><code>resolveAbsoluteOrLocal( self, referenceOrName, contextOrDataFlow=None )</code></div><div class='ds'><pre>Tries an absolute resolution first, then will look in the local scope if
		it fails.</pre></div></div><div id='d_vL' class='de'><h1>Method <span class='n'>resolveLocalOrAbsolute</span></h1><div class='re'><code>resolveLocalOrAbsolute( self, referenceOrName, contextOrDataFlow=None )</code></div><div class='ds'><pre>Tries a local resolution first, then will look in the program scope if
		it fails.</pre></div></div><div id='d_wL' class='de'><h1>Method <span class='n'>run</span></h1><div class='re'><code>run( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_xL' class='de'><h1>Method <span class='n'>setEnvironment</span></h1><div class='re'><code>setEnvironment( self, environment )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_yL' class='de'><h1>Method <span class='n'>setPass</span></h1><div class='re'><code>setPass( self, programPass )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_zL' class='de'><h1>Method <span class='n'>walk</span></h1><div class='re'><code>walk( self, element )</code></div><div class='ds'><pre>Walks the given element, recursively walking the child elements when the
		handler does not return False</pre></div></div><div id='d_AL' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.IModule at 0x85d23bc&gt;]</code></div><div class='ds'><pre>list() -&gt; new list
list(sequence) -&gt; new list initialized from sequence's items</pre></div></div><div id='d_BL' class='de'><h1>str</h1><div class='re'><code>'Importation'</code></div><div class='ds'><pre>str(object) -&gt; string<br />Return a nice string representation of the object.
If the argument is a string, the return value is the same object.</pre></div></div><div id='d_PK' class='de'><h1>Class <span class='n'>Importation</span></h1><div class='re'></div><div class='ds'><pre>The importation pass will look for importation operations ('IImportation'),
	will try to resolve the importations (according to the current environment)
	and will trigger the loading and parsing of each module into the current
	program.</pre></div></div><div id='d_DL' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.passes.PassContext at 0x857b1dc&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_EL' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_FL' class='de'><h1>Method <span class='n'>getHandler</span></h1><div class='re'><code>getHandler( self, element )</code></div><div class='ds'><pre>Tells if the pass handles the given element. This basically iterates
		on the 'handles' property values (which are interfaces), when one
		interface matches the given 'element', then the corresponding 'onXXX'
		method is invoked, where 'XXX' is the interface
		name (without the leading 'I').</pre></div></div><div id='d_GL' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><pre>Returns the name of this pass</pre></div></div><div id='d_HL' class='de'><h1>Method <span class='n'>annotate</span></h1><div class='re'><code>annotate( self, value, name, content=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_IL' class='de'><h1>Method <span class='n'>filter</span></h1><div class='re'><code>filter( self, list, interface )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_JL' class='de'><h1>Method <span class='n'>filterContext</span></h1><div class='re'><code>filterContext( self, interface )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_KL' class='de'><h1>Method <span class='n'>findInContext</span></h1><div class='re'><code>findInContext( self, interface )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_LL' class='de'><h1>Method <span class='n'>getClassAncestors</span></h1><div class='re'><code>getClassAncestors( self, theClass=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_ML' class='de'><h1>Method <span class='n'>getClassParents</span></h1><div class='re'><code>getClassParents( self, theClass )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_NL' class='de'><h1>Method <span class='n'>getCurrentClass</span></h1><div class='re'><code>getCurrentClass( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_OL' class='de'><h1>Method <span class='n'>getCurrentClassAncestors</span></h1><div class='re'><code>getCurrentClassAncestors( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_PL' class='de'><h1>Method <span class='n'>getCurrentClassParents</span></h1><div class='re'><code>getCurrentClassParents( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_QL' class='de'><h1>Method <span class='n'>getCurrentClosure</span></h1><div class='re'><code>getCurrentClosure( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_RL' class='de'><h1>Method <span class='n'>getCurrentContext</span></h1><div class='re'><code>getCurrentContext( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_SL' class='de'><h1>Method <span class='n'>getCurrentDataFlow</span></h1><div class='re'><code>getCurrentDataFlow( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_TL' class='de'><h1>Method <span class='n'>getCurrentElement</span></h1><div class='re'><code>getCurrentElement( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_UL' class='de'><h1>Method <span class='n'>getCurrentFunction</span></h1><div class='re'><code>getCurrentFunction( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_VL' class='de'><h1>Method <span class='n'>getCurrentMethod</span></h1><div class='re'><code>getCurrentMethod( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_WL' class='de'><h1>Method <span class='n'>getCurrentModule</span></h1><div class='re'><code>getCurrentModule( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_XL' class='de'><h1>Method <span class='n'>getCurrentProcess</span></h1><div class='re'><code>getCurrentProcess( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_YL' class='de'><h1>Method <span class='n'>getFactory</span></h1><div class='re'><code>getFactory( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_ZL' class='de'><h1>Method <span class='n'>getParentElement</span></h1><div class='re'><code>getParentElement( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_aM' class='de'><h1>Method <span class='n'>getProgram</span></h1><div class='re'><code>getProgram( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_bM' class='de'><h1>Method <span class='n'>handle</span></h1><div class='re'><code>handle( self, element )</code></div><div class='ds'><pre>Handles a sungle element, without recursing through its children</pre></div></div><div id='d_cM' class='de'><h1>Method <span class='n'>hasParentElement</span></h1><div class='re'><code>hasParentElement( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_dM' class='de'><h1>Method <span class='n'>isIn</span></h1><div class='re'><code>isIn( self, interface )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_eM' class='de'><h1>Method <span class='n'>resolve</span></h1><div class='re'><code>resolve( self, referenceOrName, contextOrDataFlow=None )</code></div><div class='ds'><pre>Resolves the given 'IReference' or String sing the given context
		('IContext') or dataflow ('IDataFlow'). This usually requires that
		you've applied a pass to create the dataflow (see the
		'lambdafactory.resolution.BasicDataFlow' pass).</pre></div></div><div id='d_fM' class='de'><h1>Method <span class='n'>resolveAbsolute</span></h1><div class='re'><code>resolveAbsolute( self, referenceOrName )</code></div><div class='ds'><pre>Resolves the given reference or string expressed in absolute style
		('.'-separated list of names), starting from the root dataflow (the program
		dataflow).</pre></div></div><div id='d_gM' class='de'><h1>Method <span class='n'>resolveAbsoluteOrLocal</span></h1><div class='re'><code>resolveAbsoluteOrLocal( self, referenceOrName, contextOrDataFlow=None )</code></div><div class='ds'><pre>Tries an absolute resolution first, then will look in the local scope if
		it fails.</pre></div></div><div id='d_hM' class='de'><h1>Method <span class='n'>resolveLocalOrAbsolute</span></h1><div class='re'><code>resolveLocalOrAbsolute( self, referenceOrName, contextOrDataFlow=None )</code></div><div class='ds'><pre>Tries a local resolution first, then will look in the program scope if
		it fails.</pre></div></div><div id='d_iM' class='de'><h1>Method <span class='n'>run</span></h1><div class='re'><code>run( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_jM' class='de'><h1>Method <span class='n'>setEnvironment</span></h1><div class='re'><code>setEnvironment( self, environment )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_kM' class='de'><h1>Method <span class='n'>setPass</span></h1><div class='re'><code>setPass( self, programPass )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_lM' class='de'><h1>Method <span class='n'>walk</span></h1><div class='re'><code>walk( self, element )</code></div><div class='ds'><pre>Walks the given element, recursively walking the child elements when the
		handler does not return False</pre></div></div><div id='d_mM' class='de'><h1>list</h1><div class='re'><code>[]</code></div><div class='ds'><pre>list() -&gt; new list
list(sequence) -&gt; new list initialized from sequence's items</pre></div></div><div id='d_CL' class='de'><h1>Class <span class='n'>Pass</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_oM' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self, environment=None, programPass=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_pM' class='de'><h1>Method <span class='n'>annotate</span></h1><div class='re'><code>annotate( self, value, name, content=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_qM' class='de'><h1>Method <span class='n'>filter</span></h1><div class='re'><code>filter( self, list, interface )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_rM' class='de'><h1>Method <span class='n'>filterContext</span></h1><div class='re'><code>filterContext( self, interface )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_sM' class='de'><h1>Method <span class='n'>findInContext</span></h1><div class='re'><code>findInContext( self, interface )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_tM' class='de'><h1>Method <span class='n'>getClassAncestors</span></h1><div class='re'><code>getClassAncestors( self, theClass=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_uM' class='de'><h1>Method <span class='n'>getClassParents</span></h1><div class='re'><code>getClassParents( self, theClass )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_vM' class='de'><h1>Method <span class='n'>getCurrentClass</span></h1><div class='re'><code>getCurrentClass( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_wM' class='de'><h1>Method <span class='n'>getCurrentClassAncestors</span></h1><div class='re'><code>getCurrentClassAncestors( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_xM' class='de'><h1>Method <span class='n'>getCurrentClassParents</span></h1><div class='re'><code>getCurrentClassParents( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_yM' class='de'><h1>Method <span class='n'>getCurrentClosure</span></h1><div class='re'><code>getCurrentClosure( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_zM' class='de'><h1>Method <span class='n'>getCurrentContext</span></h1><div class='re'><code>getCurrentContext( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_AM' class='de'><h1>Method <span class='n'>getCurrentDataFlow</span></h1><div class='re'><code>getCurrentDataFlow( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_BM' class='de'><h1>Method <span class='n'>getCurrentElement</span></h1><div class='re'><code>getCurrentElement( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_CM' class='de'><h1>Method <span class='n'>getCurrentFunction</span></h1><div class='re'><code>getCurrentFunction( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_DM' class='de'><h1>Method <span class='n'>getCurrentMethod</span></h1><div class='re'><code>getCurrentMethod( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_EM' class='de'><h1>Method <span class='n'>getCurrentModule</span></h1><div class='re'><code>getCurrentModule( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_FM' class='de'><h1>Method <span class='n'>getCurrentProcess</span></h1><div class='re'><code>getCurrentProcess( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_GM' class='de'><h1>Method <span class='n'>getFactory</span></h1><div class='re'><code>getFactory( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_HM' class='de'><h1>Method <span class='n'>getParentElement</span></h1><div class='re'><code>getParentElement( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_IM' class='de'><h1>Method <span class='n'>getProgram</span></h1><div class='re'><code>getProgram( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_JM' class='de'><h1>Method <span class='n'>handle</span></h1><div class='re'><code>handle( self, element )</code></div><div class='ds'><pre>Handles a sungle element, without recursing through its children</pre></div></div><div id='d_KM' class='de'><h1>Method <span class='n'>hasParentElement</span></h1><div class='re'><code>hasParentElement( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_LM' class='de'><h1>Method <span class='n'>isIn</span></h1><div class='re'><code>isIn( self, interface )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_MM' class='de'><h1>Method <span class='n'>resolve</span></h1><div class='re'><code>resolve( self, referenceOrName, contextOrDataFlow=None )</code></div><div class='ds'><pre>Resolves the given 'IReference' or String sing the given context
		('IContext') or dataflow ('IDataFlow'). This usually requires that
		you've applied a pass to create the dataflow (see the
		'lambdafactory.resolution.BasicDataFlow' pass).</pre></div></div><div id='d_NM' class='de'><h1>Method <span class='n'>resolveAbsolute</span></h1><div class='re'><code>resolveAbsolute( self, referenceOrName )</code></div><div class='ds'><pre>Resolves the given reference or string expressed in absolute style
		('.'-separated list of names), starting from the root dataflow (the program
		dataflow).</pre></div></div><div id='d_OM' class='de'><h1>Method <span class='n'>resolveAbsoluteOrLocal</span></h1><div class='re'><code>resolveAbsoluteOrLocal( self, referenceOrName, contextOrDataFlow=None )</code></div><div class='ds'><pre>Tries an absolute resolution first, then will look in the local scope if
		it fails.</pre></div></div><div id='d_PM' class='de'><h1>Method <span class='n'>resolveLocalOrAbsolute</span></h1><div class='re'><code>resolveLocalOrAbsolute( self, referenceOrName, contextOrDataFlow=None )</code></div><div class='ds'><pre>Tries a local resolution first, then will look in the program scope if
		it fails.</pre></div></div><div id='d_QM' class='de'><h1>Method <span class='n'>run</span></h1><div class='re'><code>run( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_RM' class='de'><h1>Method <span class='n'>setEnvironment</span></h1><div class='re'><code>setEnvironment( self, environment )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_SM' class='de'><h1>Method <span class='n'>setPass</span></h1><div class='re'><code>setPass( self, programPass )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_TM' class='de'><h1>Method <span class='n'>walk</span></h1><div class='re'><code>walk( self, element )</code></div><div class='ds'><pre>Walks the given element, recursively walking the child elements when the
		handler does not return False</pre></div></div><div id='d_nM' class='de'><h1>Class <span class='n'>PassContext</span></h1><div class='re'></div><div class='ds'><pre>The 'PassContext' represents the current state of one or more passes when
	walking the program. It offers access to the 'environment' (gives access
	to the program and various passes) but more importantly gives access
	to _dataflow-related primitives_ which allow you to resolve symbols
	an interrogate contexts.<br />	NOTE that a single pass context can be shared among various passes.</pre></div></div><div id='d_VM' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.passes.Pass at 0x857b20c&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_WM' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_XM' class='de'><h1>Method <span class='n'>annotate</span></h1><div class='re'><code>annotate( self, value, name, content=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_YM' class='de'><h1>Method <span class='n'>filter</span></h1><div class='re'><code>filter( self, list, interface )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_ZM' class='de'><h1>Method <span class='n'>filterContext</span></h1><div class='re'><code>filterContext( self, interface )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_aN' class='de'><h1>Method <span class='n'>findInContext</span></h1><div class='re'><code>findInContext( self, interface )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_bN' class='de'><h1>Method <span class='n'>getClassAncestors</span></h1><div class='re'><code>getClassAncestors( self, theClass=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_cN' class='de'><h1>Method <span class='n'>getClassParents</span></h1><div class='re'><code>getClassParents( self, theClass )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_dN' class='de'><h1>Method <span class='n'>getCurrentClass</span></h1><div class='re'><code>getCurrentClass( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_eN' class='de'><h1>Method <span class='n'>getCurrentClassAncestors</span></h1><div class='re'><code>getCurrentClassAncestors( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_fN' class='de'><h1>Method <span class='n'>getCurrentClassParents</span></h1><div class='re'><code>getCurrentClassParents( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_gN' class='de'><h1>Method <span class='n'>getCurrentClosure</span></h1><div class='re'><code>getCurrentClosure( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_hN' class='de'><h1>Method <span class='n'>getCurrentContext</span></h1><div class='re'><code>getCurrentContext( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_iN' class='de'><h1>Method <span class='n'>getCurrentDataFlow</span></h1><div class='re'><code>getCurrentDataFlow( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_jN' class='de'><h1>Method <span class='n'>getCurrentElement</span></h1><div class='re'><code>getCurrentElement( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_kN' class='de'><h1>Method <span class='n'>getCurrentFunction</span></h1><div class='re'><code>getCurrentFunction( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_lN' class='de'><h1>Method <span class='n'>getCurrentMethod</span></h1><div class='re'><code>getCurrentMethod( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_mN' class='de'><h1>Method <span class='n'>getCurrentModule</span></h1><div class='re'><code>getCurrentModule( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_nN' class='de'><h1>Method <span class='n'>getCurrentProcess</span></h1><div class='re'><code>getCurrentProcess( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_oN' class='de'><h1>Method <span class='n'>getFactory</span></h1><div class='re'><code>getFactory( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_pN' class='de'><h1>Method <span class='n'>getHandler</span></h1><div class='re'><code>getHandler( self, element )</code></div><div class='ds'><pre>Tells if the pass handles the given element. This basically iterates
		on the 'handles' property values (which are interfaces), when one
		interface matches the given 'element', then the corresponding 'onXXX'
		method is invoked, where 'XXX' is the interface
		name (without the leading 'I').</pre></div></div><div id='d_qN' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><pre>Returns the name of this pass</pre></div></div><div id='d_rN' class='de'><h1>Method <span class='n'>getParentElement</span></h1><div class='re'><code>getParentElement( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_sN' class='de'><h1>Method <span class='n'>getProgram</span></h1><div class='re'><code>getProgram( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_tN' class='de'><h1>Method <span class='n'>handle</span></h1><div class='re'><code>handle( self, element )</code></div><div class='ds'><pre>Handles a sungle element, without recursing through its children</pre></div></div><div id='d_uN' class='de'><h1>Method <span class='n'>hasParentElement</span></h1><div class='re'><code>hasParentElement( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_vN' class='de'><h1>Method <span class='n'>isIn</span></h1><div class='re'><code>isIn( self, interface )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_wN' class='de'><h1>Method <span class='n'>resolve</span></h1><div class='re'><code>resolve( self, referenceOrName, contextOrDataFlow=None )</code></div><div class='ds'><pre>Resolves the given 'IReference' or String sing the given context
		('IContext') or dataflow ('IDataFlow'). This usually requires that
		you've applied a pass to create the dataflow (see the
		'lambdafactory.resolution.BasicDataFlow' pass).</pre></div></div><div id='d_xN' class='de'><h1>Method <span class='n'>resolveAbsolute</span></h1><div class='re'><code>resolveAbsolute( self, referenceOrName )</code></div><div class='ds'><pre>Resolves the given reference or string expressed in absolute style
		('.'-separated list of names), starting from the root dataflow (the program
		dataflow).</pre></div></div><div id='d_yN' class='de'><h1>Method <span class='n'>resolveAbsoluteOrLocal</span></h1><div class='re'><code>resolveAbsoluteOrLocal( self, referenceOrName, contextOrDataFlow=None )</code></div><div class='ds'><pre>Tries an absolute resolution first, then will look in the local scope if
		it fails.</pre></div></div><div id='d_zN' class='de'><h1>Method <span class='n'>resolveLocalOrAbsolute</span></h1><div class='re'><code>resolveLocalOrAbsolute( self, referenceOrName, contextOrDataFlow=None )</code></div><div class='ds'><pre>Tries a local resolution first, then will look in the program scope if
		it fails.</pre></div></div><div id='d_AN' class='de'><h1>Method <span class='n'>run</span></h1><div class='re'><code>run( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_BN' class='de'><h1>Method <span class='n'>setEnvironment</span></h1><div class='re'><code>setEnvironment( self, environment )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_CN' class='de'><h1>Method <span class='n'>setPass</span></h1><div class='re'><code>setPass( self, programPass )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_DN' class='de'><h1>Method <span class='n'>walk</span></h1><div class='re'><code>walk( self, element )</code></div><div class='ds'><pre>Walks the given element, recursively walking the child elements when the
		handler does not return False</pre></div></div><div id='d_EN' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.IClosure at 0x85d24ac&gt;]</code></div><div class='ds'><pre>list() -&gt; new list
list(sequence) -&gt; new list initialized from sequence's items</pre></div></div><div id='d_FN' class='de'><h1>str</h1><div class='re'><code>'AsynchronousInvocationsExpansion'</code></div><div class='ds'><pre>str(object) -&gt; string<br />Return a nice string representation of the object.
If the argument is a string, the return value is the same object.</pre></div></div><div id='d_UM' class='de'><h1>Class <span class='n'>TransformAsynchronousInvocations</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_lJ' class='de'><h1>Module <span class='n'>lambdafactory.passes</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_IN' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_JN' class='de'><h1>Method <span class='n'>dedent</span></h1><div class='re'><code>dedent( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_KN' class='de'><h1>Method <span class='n'>echoError</span></h1><div class='re'><code>echoError( self, message )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_LN' class='de'><h1>Method <span class='n'>echoWarning</span></h1><div class='re'><code>echoWarning( self, message, element )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_MN' class='de'><h1>Method <span class='n'>error</span></h1><div class='re'><code>error( self, *message )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_NN' class='de'><h1>Method <span class='n'>indent</span></h1><div class='re'><code>indent( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_ON' class='de'><h1>Method <span class='n'>info</span></h1><div class='re'><code>info( self, *message )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_PN' class='de'><h1>Method <span class='n'>isDone</span></h1><div class='re'><code>isDone( self, message, element, update=True )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_QN' class='de'><h1>Method <span class='n'>onError</span></h1><div class='re'><code>onError( self, callback )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_RN' class='de'><h1>Method <span class='n'>onWarning</span></h1><div class='re'><code>onWarning( self, callback )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_SN' class='de'><h1>Method <span class='n'>warning</span></h1><div class='re'><code>warning( self, message, element=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_HN' class='de'><h1>Class <span class='n'>Reporter</span></h1><div class='re'></div><div class='ds'><pre>The reporter aggregates error reports that may happen during model
	construction and the different phases (dataflowing, typing, writing,
	etc).</pre></div></div><div id='d_TN' class='de'><h1>instance</h1><div class='re'></div><div class='ds'><pre>The reporter aggregates error reports that may happen during model
	construction and the different phases (dataflowing, typing, writing,
	etc).</pre></div></div><div id='d_GN' class='de'><h1>Module <span class='n'>lambdafactory.reporter</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div>
	<!-- descriptions-snip -->
</div>
<div id='hidden'>
	<!-- hidden-snip -->
	<div id='d_Wn' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><pre>Returns the ith arguments to this operation.</pre></div></div><div id='d_Wo' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><pre>Sets this element parent</pre></div></div><div id='d_Wl' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><pre>Sets this element parent</pre></div></div><div id='d_Wm' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><pre>Sets this element parent</pre></div></div><div id='d_Wj' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><pre>Performs a deep clone of this element. Any mutation to the original won't
		change the copy.</pre></div></div><div id='d_Wk' class='de'><h1>Method <span class='n'>removeAnnotation</span></h1><div class='re'><code>removeAnnotation( self, name )</code></div><div class='ds'><pre>Removes the annotations with the given name</pre></div></div><div id='d_Wh' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><pre>Sets this element parent</pre></div></div><div id='d_Wi' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><pre>Performs a deep clone of this element. Any mutation to the original won't
		change the copy.</pre></div></div><div id='d_Wf' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><pre>Returns this element parent</pre></div></div><div id='d_Wg' class='de'><h1>Method <span class='n'>getOperator</span></h1><div class='re'><code>getOperator( self )</code></div><div class='ds'><pre>Gets the operator for this computation</pre></div></div><div id='d_Wd' class='de'><h1>Method <span class='n'>getSlot</span></h1><div class='re'><code>getSlot( self, name )</code></div><div class='ds'><pre>Returns the given evaluable bound to named slot.</pre></div></div><div id='d_We' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IContext at 0x85d22fc&gt;, &lt;class lambdafactory.interfaces.IReferencable at 0x85c4efc&gt;, &lt;class lambdafactory.interfaces.IConstruct at 0x85c4e9c&gt;)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_Wb' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><pre>Returns this @protocol name. It can be `None` if the @protocol is anonymous.</pre></div></div><div id='d_Wc' class='de'><h1>Method <span class='n'>setKeywordsRest</span></h1><div class='re'><code>setKeywordsRest( self, value )</code></div><div class='ds'><pre>Tells this arguments represents ''the rest'' of the keyword argument in
		the invocation</pre></div></div><div id='d_Wz' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><pre>Sets this element parent</pre></div></div><div id='d_Wx' class='de'><h1>Method <span class='n'>isAsMap</span></h1><div class='re'><code>isAsMap( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Wy' class='de'><h1>Method <span class='n'>getSlotNames</span></h1><div class='re'><code>getSlotNames( self )</code></div><div class='ds'><pre>Returns the list of slot names (in order) for this context</pre></div></div><div id='d_Wv' class='de'><h1>Method <span class='n'>hasSlot</span></h1><div class='re'><code>hasSlot( self, name )</code></div><div class='ds'><pre>Tells if the context has a slot with the given name.</pre></div></div><div id='d_Ww' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><pre>Returns this element parent</pre></div></div><div id='d_Wt' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><pre>Sets the abstract type for this element</pre></div></div><div id='d_Wu' class='de'><h1>Method <span class='n'>addAnnotation</span></h1><div class='re'><code>addAnnotation( self, annotation )</code></div><div class='ds'><pre>Adds an annotation to this element</pre></div></div><div id='d_Wr' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><pre>Sets the abstract type for this element</pre></div></div><div id='d_Ws' class='de'><h1>Method <span class='n'>addValue</span></h1><div class='re'><code>addValue( self, value )</code></div><div class='ds'><pre>Adds a value to this list.</pre></div></div><div id='d_Wp' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><pre>Sets the abstract type for this element</pre></div></div><div id='d_Wq' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><pre>Sets this element parent</pre></div></div><div id='d_WL' class='de'><h1>Method <span class='n'>getCurrentModule</span></h1><div class='re'><code>getCurrentModule( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_WM' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_WJ' class='de'><h1>Method <span class='n'>setPass</span></h1><div class='re'><code>setPass( self, programPass )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_WK' class='de'><h1>Method <span class='n'>findInContext</span></h1><div class='re'><code>findInContext( self, interface )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_WH' class='de'><h1>Method <span class='n'>result</span></h1><div class='re'><code>result( self )</code></div><div class='ds'><pre>Returns the result for this type. This is usually just the type
		itself, except for processes types.</pre></div></div><div id='d_WI' class='de'><h1>Method <span class='n'>setName</span></h1><div class='re'><code>setName( self, name )</code></div><div class='ds'><pre>Sets the name of this type</pre></div></div><div id='d_WF' class='de'><h1>Method <span class='n'>__call__</span></h1><div class='re'><code>__call__( self )</code></div><div class='ds'><pre>A type instance can be used as a class to construct a new type, which
		will be cloned from the current type.</pre></div></div><div id='d_WG' class='de'><h1>Method <span class='n'>isSameAs</span></h1><div class='re'><code>isSameAs( self, otherType )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_WD' class='de'><h1>Method <span class='n'>resolve</span></h1><div class='re'><code>resolve( self, reference, context=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_WE' class='de'><h1>NoneType</h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_WB' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><pre>Returns this element parent</pre></div></div><div id='d_WC' class='de'><h1>Method <span class='n'>_attr</span></h1><div class='re'><code>_attr( self, name, typeinfo=None, value=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_WA' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><pre>Performs a deep clone of this element. Any mutation to the original won't
		change the copy.</pre></div></div><div id='GG' class='cr'><div class='n'><a href='javascript:dS("GG");'>Environment</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("GG","c");'><span class='special __bases__'><i>Base class</i></span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("GG","HG");'><span class='special __init__'>constructor</span></a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("GG","IG");'>register</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("GG","JG");'>resolve</a></div></div></div><div id='d_EA' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><pre>Returns the dataflow accessible/bound to this element</pre></div></div><div id='d_EB' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><pre>Tells if this element has a parent or not</pre></div></div><div id='d_EC' class='de'><h1>Method <span class='n'>addAnnotation</span></h1><div class='re'><code>addAnnotation( self, annotation )</code></div><div class='ds'><pre>Adds an annotation to this element</pre></div></div><div id='d_ED' class='de'><h1>Method <span class='n'>createProgram</span></h1><div class='re'><code>createProgram( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_EE' class='de'><h1>Class <span class='n'>Behaviour</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_EF' class='de'><h1>Method <span class='n'>__str__</span></h1><div class='re'><code>__str__( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_EG' class='de'><h1>Method <span class='n'>setName</span></h1><div class='re'><code>setName( self, name )</code></div><div class='ds'><pre>Sets the name of this type</pre></div></div><div id='d_EH' class='de'><h1>Class <span class='n'>SemanticError</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_EI' class='de'><h1>Method <span class='n'>setConcreteType</span></h1><div class='re'><code>setConcreteType( self, value )</code></div><div class='ds'><pre>Sets the _concrete type_ for this abstract type. The concrete type
		is a value which represents the type. For instance, if this type
		represents a class, then the concrete type would be the class instance.</pre></div></div><div id='d_EJ' class='de'><h1>Method <span class='n'>getCurrentFunction</span></h1><div class='re'><code>getCurrentFunction( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_EK' class='de'><h1>Method <span class='n'>resolve</span></h1><div class='re'><code>resolve( self, referenceOrName, contextOrDataFlow=None )</code></div><div class='ds'><pre>Resolves the given 'IReference' or String sing the given context
		('IContext') or dataflow ('IDataFlow'). This usually requires that
		you've applied a pass to create the dataflow (see the
		'lambdafactory.resolution.BasicDataFlow' pass).</pre></div></div><div id='d_EL' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_EM' class='de'><h1>Method <span class='n'>getCurrentModule</span></h1><div class='re'><code>getCurrentModule( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_EN' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.IClosure at 0x85d24ac&gt;]</code></div><div class='ds'><pre>list() -&gt; new list
list(sequence) -&gt; new list initialized from sequence's items</pre></div></div><div id='d_Ep' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type for this element</pre></div></div><div id='d_Eq' class='de'><h1>Method <span class='n'>setIntercept</span></h1><div class='re'><code>setIntercept( self, process )</code></div><div class='ds'><pre>Sets the process that will do the interception</pre></div></div><div id='d_Er' class='de'><h1>Method <span class='n'>setParentClasses</span></h1><div class='re'><code>setParentClasses( self )</code></div><div class='ds'><pre>gives the list of parent classes that will</pre></div></div><div id='d_Es' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><pre>Performs a deep clone of this element. Any mutation to the original won't
		change the copy.</pre></div></div><div id='d_Et' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IMatchOperation at 0x85d298c&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='Gr' class='cr'><div class='n'><a href='javascript:dS("Gr");'>IInterruption</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("Gr","Hr");'><span class='special __bases__'>IOperation</span></a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Gr","Ir");'>addAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Gr","Jr");'>addOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Gr","Kr");'>copy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Gr","Lr");'>detach</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Gr","Mr");'>getAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Gr","Nr");'>getAnnotations</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Gr","Or");'>getDataFlow</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Gr","Pr");'>getOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Gr","Qr");'>getOpArguments</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Gr","Rr");'>getOpArgumentsInternalTypes</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Gr","Sr");'>getParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Gr","Tr");'>hasAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Gr","Ur");'>hasParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Gr","Vr");'>removeAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Gr","Wr");'>setAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Gr","Xr");'>setOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Gr","Yr");'>setParent</a></div></div></div><div id='d_Ev' class='de'><h1>Method <span class='n'>getParentName</span></h1><div class='re'><code>getParentName( self )</code></div><div class='ds'><pre>Returns the parent name of this module (if any) </pre></div></div><div id='d_Ew' class='de'><h1>Method <span class='n'>hasSlot</span></h1><div class='re'><code>hasSlot( self, name )</code></div><div class='ds'><pre>Tells if the context has a slot with the given name.</pre></div></div><div id='d_Ex' class='de'><h1>Method <span class='n'>getAbsoluteName</span></h1><div class='re'><code>getAbsoluteName( self )</code></div><div class='ds'><pre>Returns the absolute name for this element</pre></div></div><div id='d_Ey' class='de'><h1>Method <span class='n'>removeAnnotation</span></h1><div class='re'><code>removeAnnotation( self, name )</code></div><div class='ds'><pre>Removes the annotations with the given name</pre></div></div><div id='d_Ez' class='de'><h1>Method <span class='n'>getCondition</span></h1><div class='re'><code>getCondition( self )</code></div><div class='ds'><pre>Gets the expression that is the condition for this repetition.</pre></div></div><div id='d_Eb' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><pre>Tells if this element has a parent or not</pre></div></div><div id='Gd' class='cr'><div class='n'><a href='javascript:dS("Gd");'>IAttributeMethod</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("Gd","Hd");'><span class='special __bases__'>IMethod</span></a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Gd","Id");'>addAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Gd","Jd");'>addOperation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Gd","Kd");'>copy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Gd","Ld");'>detach</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Gd","Md");'>endsWithTermination</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Gd","Nd");'>getAbsoluteName</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Gd","Od");'>getAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Gd","Pd");'>getAnnotations</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Gd","Qd");'>getArguments</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Gd","Rd");'>getDataFlow</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Gd","Sd");'>getName</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Gd","Td");'>getOperations</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Gd","Ud");'>getParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Gd","Vd");'>getReturnTypeDescription</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Gd","Wd");'>getSlot</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Gd","Xd");'>getSlotNames</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Gd","Yd");'>getSlots</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Gd","Zd");'>hasAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Gd","ae");'>hasExplicitTermination</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Gd","be");'>hasParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Gd","ce");'>hasSlot</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Gd","de");'>isAbstract</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Gd","ee");'>removeAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Gd","fe");'>setAbstract</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Gd","ge");'>setAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Gd","he");'>setArguments</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Gd","ie");'>setParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Gd","je");'>setReturnTypeDescription</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Gd","ke");'>setSlot</a></div></div></div><div id='d_Ed' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><pre>Returns the local name for this referencable element</pre></div></div><div id='d_Ee' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><pre>Adds an argument to this operation. This should do checking of
		arguments (by expected internal type and number).</pre></div></div><div id='d_Ef' class='de'><h1>Method <span class='n'>getDefaultValue</span></h1><div class='re'><code>getDefaultValue( self )</code></div><div class='ds'><pre>Gets the @methodault value for this attribute</pre></div></div><div id='d_Eg' class='de'><h1>Method <span class='n'>getSlots</span></h1><div class='re'><code>getSlots( self )</code></div><div class='ds'><pre>Returns (key, evaluable) pairs representing the slots within this
		context. In the case of context that may inherits slots, this only
		returns the slots that are owned by the context (ie. it does not
		include inherited slots)</pre></div></div><div id='d_Eh' class='de'><h1>Method <span class='n'>getArguments</span></h1><div class='re'><code>getArguments( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Ei' class='de'><h1>Method <span class='n'>getSlot</span></h1><div class='re'><code>getSlot( self, name )</code></div><div class='ds'><pre>Returns the slot with the given name, if any.</pre></div></div><div id='d_Ej' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type for this element</pre></div></div><div id='d_Ek' class='de'><h1>list</h1><div class='re'><code>[]</code></div><div class='ds'><pre>list() -&gt; new list
list(sequence) -&gt; new list initialized from sequence's items</pre></div></div><div id='d_El' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IOperation at 0x85d268c&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_Em' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type for this element</pre></div></div><div id='d_En' class='de'><h1>Method <span class='n'>hasAnnotation</span></h1><div class='re'><code>hasAnnotation( self, name )</code></div><div class='ds'><pre>Tells if the given element has an annotation with the given name</pre></div></div><div id='d_Eo' class='de'><h1>Method <span class='n'>getImportOrigin</span></h1><div class='re'><code>getImportOrigin( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_YD' class='de'><h1>Method <span class='n'>rule</span></h1><div class='re'><code>rule( self, evaluable, process )</code></div><div class='ds'><pre>Alias for matchProcess</pre></div></div><div id='d_YE' class='de'><h1>Module <span class='n'>lambdafactory.typecast</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_YF' class='de'><h1>Method <span class='n'>concreteType</span></h1><div class='re'><code>concreteType( self )</code></div><div class='ds'><pre>Returns the _concrete type_ for this abstract type.</pre></div></div><div id='d_YG' class='de'><h1>Method <span class='n'>set</span></h1><div class='re'><code>set( self, name, theType )</code></div><div class='ds'><pre>Sets the slot with the given 'name' to have a value of the given
		type ('theType').</pre></div></div><div id='d_YA' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type for this element</pre></div></div><div id='d_YB' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><pre>Tells if this element has a parent or not</pre></div></div><div id='d_YC' class='de'><h1>Method <span class='n'>_dict</span></h1><div class='re'><code>_dict( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_YL' class='de'><h1>Method <span class='n'>getFactory</span></h1><div class='re'><code>getFactory( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_YM' class='de'><h1>Method <span class='n'>filter</span></h1><div class='re'><code>filter( self, list, interface )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_YH' class='de'><h1>Method <span class='n'>setName</span></h1><div class='re'><code>setName( self, name )</code></div><div class='ds'><pre>Sets the name of this type</pre></div></div><div id='d_YI' class='de'><h1>Function <span class='n'>Class</span></h1><div class='re'><code>Class( Context )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_YJ' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.IModule at 0x85d23bc&gt;]</code></div><div class='ds'><pre>list() -&gt; new list
list(sequence) -&gt; new list initialized from sequence's items</pre></div></div><div id='d_YK' class='de'><h1>Method <span class='n'>getClassParents</span></h1><div class='re'><code>getClassParents( self, theClass )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Yd' class='de'><h1>Method <span class='n'>getSlots</span></h1><div class='re'><code>getSlots( self )</code></div><div class='ds'><pre>Returns (key, evaluable) pairs representing the slots within this
		context. In the case of context that may inherits slots, this only
		returns the slots that are owned by the context (ie. it does not
		include inherited slots)</pre></div></div><div id='d_Ye' class='de'><h1>Method <span class='n'>getClassAttributes</span></h1><div class='re'><code>getClassAttributes( self )</code></div><div class='ds'><pre>Returns the class attributes defined within this class.</pre></div></div><div id='d_Yf' class='de'><h1>Method <span class='n'>getSlot</span></h1><div class='re'><code>getSlot( self, name )</code></div><div class='ds'><pre>Returns the given evaluable bound to named slot.</pre></div></div><div id='d_Yg' class='de'><h1>Method <span class='n'>setLeftOperand</span></h1><div class='re'><code>setLeftOperand( self, operand )</code></div><div class='ds'><pre>Sets the left operand of this computation.</pre></div></div><div id='d_Yb' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><pre>Returns this element parent</pre></div></div><div id='d_Yc' class='de'><h1>Method <span class='n'>setRest</span></h1><div class='re'><code>setRest( self, value )</code></div><div class='ds'><pre>Tells this argument represents ''the rest'' of arguments in the
		invocation</pre></div></div><div id='d_Yl' class='de'><h1>list</h1><div class='re'><code>['Evaluable']</code></div><div class='ds'><pre>list() -&gt; new list
list(sequence) -&gt; new list initialized from sequence's items</pre></div></div><div id='d_Ym' class='de'><h1>Method <span class='n'>setSlot</span></h1><div class='re'><code>setSlot( self, name, evaluable )</code></div><div class='ds'><pre>Binds the given evaluable to the named slot. If there is already a slot
		with the same name, then 'getSlot(name)' should return the evaluable
		given as parameter.<br />		In the default implementation, setSlot preserves the ''history'' of
		added slots, and will always return the latest one.</pre></div></div><div id='d_Yn' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><pre>Returns the *internal types* for this operations arguments. This is
		typically the list of interfaces or @protocols that the arguments must
		comply to.</pre></div></div><div id='d_Yo' class='de'><h1>list</h1><div class='re'><code>['ImportedElement', 'ImportOrigin', 'Alias']</code></div><div class='ds'><pre>list() -&gt; new list
list(sequence) -&gt; new list initialized from sequence's items</pre></div></div><div id='d_Yh' class='de'><h1>Method <span class='n'>setSlot</span></h1><div class='re'><code>setSlot( self, name, evaluable )</code></div><div class='ds'><pre>Binds the given evaluable to the named slot. If there is already a slot
		with the same name, then 'getSlot(name)' should return the evaluable
		given as parameter.<br />		In the default implementation, setSlot preserves the ''history'' of
		added slots, and will always return the latest one.</pre></div></div><div id='d_Yi' class='de'><h1>Method <span class='n'>endsWithTermination</span></h1><div class='re'><code>endsWithTermination( self )</code></div><div class='ds'><pre>Returns true if this function ends with a termination operation. This
		is especially useful for back-ends which want to know if they have to
		insert an explicit 'return' at the end (like Java).</pre></div></div><div id='d_Yj' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type for this element</pre></div></div><div id='d_Yk' class='de'><h1>Method <span class='n'>setCode</span></h1><div class='re'><code>setCode( self, code )</code></div><div class='ds'><pre>Sets the code of this embed operation.</pre></div></div><div id='d_Yt' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><pre>Sets this element parent</pre></div></div><div id='d_Yu' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><pre>Performs a deep clone of this element. Any mutation to the original won't
		change the copy.</pre></div></div><div id='d_Yv' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><pre>Sets the abstract type for this element</pre></div></div><div id='d_Yw' class='de'><h1>Method <span class='n'>hasAnnotation</span></h1><div class='re'><code>hasAnnotation( self, name )</code></div><div class='ds'><pre>Tells if the given element has an annotation with the given name</pre></div></div><div id='d_Yp' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><pre>Sets this element parent</pre></div></div><div id='d_Yq' class='de'><h1>Class <span class='n'>IInterface</span></h1><div class='re'></div><div class='ds'><pre>An interface is an abstract @protocol that only has abstract elements.</pre></div></div><div id='d_Yr' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><pre>Sets this element parent</pre></div></div><div id='d_Ys' class='de'><h1>Method <span class='n'>addAnnotation</span></h1><div class='re'><code>addAnnotation( self, annotation )</code></div><div class='ds'><pre>Adds an annotation to this element</pre></div></div><div id='d_Yx' class='de'><h1>Method <span class='n'>setAsList</span></h1><div class='re'><code>setAsList( self, v=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Yy' class='de'><h1>Method <span class='n'>hasAnnotation</span></h1><div class='re'><code>hasAnnotation( self, name )</code></div><div class='ds'><pre>Tells if the given element has an annotation with the given name</pre></div></div><div id='d_Yz' class='de'><h1>Class <span class='n'>IResolution</span></h1><div class='re'></div><div class='ds'><pre>A resolution resolves a reference into a value.</pre></div></div><div id='ZE' class='cr'><div class='n'><a href='javascript:dS("ZE");'>Arguments</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("ZE","aF");'><span class='special __bases__'>Sequence</span></a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("ZE","bF");'><span class='special __call__'>when invoked</span></a></div><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("ZE","cF");'><span class='special __init__'>constructor</span></a></div><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("ZE","dF");'><span class='special __str__'>string conversion</span></a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ZE","eF");'>add</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ZE","fF");'>asString</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ZE","gF");'>clone</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ZE","hF");'>concreteType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ZE","iF");'>definedBy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ZE","jF");'>elements</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ZE","kF");'>extend</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ZE","lF");'>isLike</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ZE","mF");'>isSameAs</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ZE","nF");'>isSubtypeOf</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ZE","oF");'>length</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ZE","pF");'>name</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ZE","qF");'>result</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ZE","rF");'>setConcreteType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ZE","sF");'>setName</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ZE","tF");'>subtype</a></div></div></div><div id='Zl' class='cr'><div class='n'><a href='javascript:dS("Zl");'>IExcept</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("Zl","am");'><span class='special __bases__'>IInterruption</span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Zl","bm");'>getValue</a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Zl","cm");'>addAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Zl","dm");'>addOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Zl","em");'>copy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Zl","fm");'>detach</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Zl","gm");'>getAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Zl","hm");'>getAnnotations</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Zl","im");'>getDataFlow</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Zl","jm");'>getOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Zl","km");'>getOpArguments</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Zl","lm");'>getOpArgumentsInternalTypes</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Zl","mm");'>getParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Zl","nm");'>hasAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Zl","om");'>hasParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Zl","pm");'>removeAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Zl","qm");'>setAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Zl","rm");'>setOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Zl","sm");'>setParent</a></div></div><div class='t'>Values</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&bull;</span><a href='javascript:dO("Zl","tm");'>ARGS</a></div></div></div><div id='Zm' class='cr'><div class='n'><a href='javascript:dS("Zm");'>IGroup</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("Zm","an");'><span class='special __bases__'>IProcess</span></a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Zm","bn");'>addAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Zm","cn");'>addOperation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Zm","dn");'>copy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Zm","en");'>detach</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Zm","fn");'>getAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Zm","gn");'>getAnnotations</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Zm","hn");'>getDataFlow</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Zm","in");'>getOperations</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Zm","jn");'>getParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Zm","kn");'>hasAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Zm","ln");'>hasParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Zm","mn");'>removeAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Zm","nn");'>setAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Zm","on");'>setParent</a></div></div></div><div id='Zo' class='cr'><div class='n'><a href='javascript:dS("Zo");'>IImportSymbolsOperation</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("Zo","ap");'><span class='special __bases__'>IImportOperation</span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Zo","bp");'>getImportOrigin</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Zo","cp");'>getImportedElements</a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Zo","dp");'>addAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Zo","ep");'>addOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Zo","fp");'>copy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Zo","gp");'>detach</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Zo","hp");'>getAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Zo","ip");'>getAnnotations</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Zo","jp");'>getDataFlow</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Zo","kp");'>getOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Zo","lp");'>getOpArguments</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Zo","mp");'>getOpArgumentsInternalTypes</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Zo","np");'>getParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Zo","op");'>hasAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Zo","pp");'>hasParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Zo","qp");'>removeAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Zo","rp");'>setAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Zo","sp");'>setOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Zo","tp");'>setParent</a></div></div><div class='t'>Values</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&bull;</span><a href='javascript:dO("Zo","up");'>ARGS</a></div><div class='slot documented'><span
					class='prefix'>&bull;</span><a href='javascript:dO("Zo","vp");'>ARG_NAMES</a></div></div></div><div id='Zh' class='cr'><div class='n'><a href='javascript:dS("Zh");'>IContext</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("Zh","ai");'><span class='special __bases__'>IElement, IDataFlowOwner</span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Zh","bi");'>getParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Zh","ci");'>getSlot</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Zh","di");'>getSlotNames</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Zh","ei");'>getSlots</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Zh","fi");'>hasSlot</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Zh","gi");'>setParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Zh","hi");'>setSlot</a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Zh","ii");'>addAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Zh","ji");'>copy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Zh","ki");'>detach</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Zh","li");'>getAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Zh","mi");'>getAnnotations</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Zh","ni");'>getDataFlow</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Zh","oi");'>hasAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Zh","pi");'>hasParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Zh","qi");'>removeAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Zh","ri");'>setAbstractType</a></div></div></div><div id='k' class='cr'><div class='n'><a href='javascript:dS("k");'>IAbsoluteReference</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("k","l");'><span class='special __bases__'>IReference</span></a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("k","m");'>addAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("k","n");'>copy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("k","o");'>detach</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("k","p");'>getAbsoluteName</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("k","q");'>getAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("k","r");'>getAnnotations</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("k","s");'>getDataFlow</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("k","t");'>getName</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("k","u");'>getParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("k","v");'>getReferenceName</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("k","w");'>getResultAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("k","x");'>hasAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("k","y");'>hasParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("k","z");'>removeAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("k","A");'>setAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("k","B");'>setParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("k","C");'>setResultAbstractType</a></div></div></div><div id='Zr' class='cr'><div class='n'><a href='javascript:dS("Zr");'>IInvocable</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("Zr","c");'><span class='special __bases__'><i>Base class</i></span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Zr","as");'>getArguments</a></div></div></div><div id='mE' class='cr'><div class='n'><a href='javascript:dS("mE");'>AbstractWriter</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("mE","nE");'><span class='special __bases__'>Pass</span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("mE","oE");'><span class='special __init__'>constructor</span></a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("mE","pE");'><span class='protected'>_format</span></a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("mE","qE");'><span class='protected'>_unique</span></a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("mE","rE");'>onProgram</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("mE","sE");'>run</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("mE","tE");'>write</a></div></div><div class='t'>Values</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&bull;</span><a href='javascript:dO("mE","uE");'>HANDLES</a></div></div><div class='t'>Inhertied Values</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&bull;</span><a href='javascript:dO("mE","vE");'>NAME</a></div></div></div><div id='mJ' class='cr'><div class='n'><a href='javascript:dS("mJ");'>DocumentationPass</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("mJ","nJ");'><span class='special __bases__'>Pass</span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("mJ","oJ");'><span class='special __init__'>constructor</span></a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("mJ","pJ");'>asHTML</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("mJ","qJ");'>onModule</a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("mJ","rJ");'>annotate</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("mJ","sJ");'>filter</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("mJ","tJ");'>filterContext</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("mJ","uJ");'>findInContext</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("mJ","vJ");'>getClassAncestors</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("mJ","wJ");'>getClassParents</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("mJ","xJ");'>getCurrentClass</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("mJ","yJ");'>getCurrentClassAncestors</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("mJ","zJ");'>getCurrentClassParents</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("mJ","AJ");'>getCurrentClosure</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("mJ","BJ");'>getCurrentContext</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("mJ","CJ");'>getCurrentDataFlow</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("mJ","DJ");'>getCurrentElement</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("mJ","EJ");'>getCurrentFunction</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("mJ","FJ");'>getCurrentMethod</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("mJ","GJ");'>getCurrentModule</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("mJ","HJ");'>getCurrentProcess</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("mJ","IJ");'>getFactory</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("mJ","JJ");'>getHandler</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("mJ","KJ");'>getName</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("mJ","LJ");'>getParentElement</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("mJ","MJ");'>getProgram</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("mJ","NJ");'>handle</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("mJ","OJ");'>hasParentElement</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("mJ","PJ");'>isIn</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("mJ","QJ");'>resolve</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("mJ","RJ");'>resolveAbsolute</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("mJ","SJ");'>resolveAbsoluteOrLocal</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("mJ","TJ");'>resolveLocalOrAbsolute</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("mJ","UJ");'>run</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("mJ","VJ");'>setEnvironment</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("mJ","WJ");'>setPass</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("mJ","XJ");'>walk</a></div></div><div class='t'>Values</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&bull;</span><a href='javascript:dO("mJ","YJ");'>HANDLES</a></div><div class='slot documented'><span
					class='prefix'>&bull;</span><a href='javascript:dO("mJ","ZJ");'>NAME</a></div></div></div><div id='mt' class='cr'><div class='n'><a href='javascript:dS("mt");'>ILiteral</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("mt","nt");'><span class='special __bases__'>IValue</span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("mt","ot");'>getActualValue</a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("mt","pt");'>addAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("mt","qt");'>copy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("mt","rt");'>detach</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("mt","st");'>getAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("mt","tt");'>getAnnotations</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("mt","ut");'>getDataFlow</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("mt","vt");'>getParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("mt","wt");'>getResultAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("mt","xt");'>hasAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("mt","yt");'>hasParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("mt","zt");'>removeAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("mt","At");'>setAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("mt","Bt");'>setParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("mt","Ct");'>setResultAbstractType</a></div></div></div><div id='Lc' class='cr'><div class='n'><a href='javascript:dS("Lc");'>IAnnotation</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("Lc","c");'><span class='special __bases__'><i>Base class</i></span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Lc","Mc");'>getContent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Lc","Nc");'>getName</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Lc","Oc");'>setContent</a></div></div></div><div id='d_Ly' class='de'><h1>Method <span class='n'>getModule</span></h1><div class='re'><code>getModule( self, moduleAbsoluteName )</code></div><div class='ds'><pre>Returns the module (if any) with the given absolute name</pre></div></div><div id='Li' class='cr'><div class='n'><a href='javascript:dS("Li");'>IDataFlowSlot</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("Li","c");'><span class='special __bases__'><i>Base class</i></span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Li","Mi");'>addOperation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Li","Ni");'>getAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Li","Oi");'>getName</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Li","Pi");'>getOperations</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Li","Qi");'>getOrigin</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Li","Ri");'>getOriginalValue</a></div></div></div><div id='d_Lx' class='de'><h1>Method <span class='n'>getResultAbstractType</span></h1><div class='re'><code>getResultAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type of the result of the evaluation of this
		evaluable</pre></div></div><div id='LG' class='cr'><div class='n'><a href='javascript:dS("LG");'>Map</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("LG","MG");'><span class='special __bases__'>Type</span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("LG","NG");'><span class='special __init__'>constructor</span></a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("LG","OG");'>add</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("LG","PG");'>asString</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("LG","QG");'>clone</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("LG","RG");'>element</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("LG","SG");'>elementNames</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("LG","TG");'>elements</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("LG","UG");'>get</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("LG","VG");'>isLike</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("LG","WG");'>isSameAs</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("LG","XG");'>isSubtypeOf</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("LG","YG");'>set</a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("LG","ZG");'><span class='special __call__'>when invoked</span></a></div><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("LG","aH");'><span class='special __str__'>string conversion</span></a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("LG","bH");'>concreteType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("LG","cH");'>definedBy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("LG","dH");'>name</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("LG","eH");'>result</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("LG","fH");'>setConcreteType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("LG","gH");'>setName</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("LG","hH");'>subtype</a></div></div></div><div id='d_Ls' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><pre>Returns the *internal types* for this operations arguments. This is
		typically the list of interfaces or @protocols that the arguments must
		comply to.</pre></div></div><div id='d_Lr' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><pre>Detaches the element from its parent (in case it was already attached).
		This should return this element, and set the parent to None.</pre></div></div><div id='d_Lq' class='de'><h1>Method <span class='n'>getAnnotations</span></h1><div class='re'><code>getAnnotations( self, name=None )</code></div><div class='ds'><pre>Gets all the annotation with the given name associated to this element
		or all annotations if no name is specified.</pre></div></div><div id='d_Lp' class='de'><h1>Method <span class='n'>getReturnTypeDescription</span></h1><div class='re'><code>getReturnTypeDescription( self )</code></div><div class='ds'><pre>Returns the return type description for this closure, if any</pre></div></div><div id='d_Lw' class='de'><h1>Method <span class='n'>setReturnTypeDescription</span></h1><div class='re'><code>setReturnTypeDescription( self, description )</code></div><div class='ds'><pre>Sets the return type description for this closure, if any</pre></div></div><div id='d_Lv' class='de'><h1>Method <span class='n'>getAbsoluteName</span></h1><div class='re'><code>getAbsoluteName( self )</code></div><div class='ds'><pre>Returns the absolute name for this element</pre></div></div><div id='d_Lu' class='de'><h1>Method <span class='n'>getPredicate</span></h1><div class='re'><code>getPredicate( self )</code></div><div class='ds'><pre>Returns the evaluable that acts as a predicate for this operation.</pre></div></div><div id='d_Lt' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type for this element</pre></div></div><div id='d_Lk' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type for this element</pre></div></div><div id='d_Lj' class='de'><h1>Method <span class='n'>removeAnnotation</span></h1><div class='re'><code>removeAnnotation( self, name )</code></div><div class='ds'><pre>Removes the annotations with the given name</pre></div></div><div id='d_Li' class='de'><h1>Class <span class='n'>IDataFlowSlot</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Lh' class='de'><h1>Method <span class='n'>getSlotNames</span></h1><div class='re'><code>getSlotNames( self )</code></div><div class='ds'><pre>Returns the list of slot names (in order) for this context</pre></div></div><div id='d_Lo' class='de'><h1>Method <span class='n'>getAnnotations</span></h1><div class='re'><code>getAnnotations( self, name=None )</code></div><div class='ds'><pre>Gets all the annotation with the given name associated to this element
		or all annotations if no name is specified.</pre></div></div><div id='d_Ln' class='de'><h1>list</h1><div class='re'><code>['ImportedModuleName', 'Alias']</code></div><div class='ds'><pre>list() -&gt; new list
list(sequence) -&gt; new list initialized from sequence's items</pre></div></div><div id='d_xg' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type for this element</pre></div></div><div id='d_Lm' class='de'><h1>Method <span class='n'>getSlot</span></h1><div class='re'><code>getSlot( self, name )</code></div><div class='ds'><pre>Returns the given evaluable bound to named slot.</pre></div></div><div id='d_Ll' class='de'><h1>Method <span class='n'>getAnnotations</span></h1><div class='re'><code>getAnnotations( self, name=None )</code></div><div class='ds'><pre>Gets all the annotation with the given name associated to this element
		or all annotations if no name is specified.</pre></div></div><div id='d_DC' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IElement at 0x85c4e6c&gt;, &lt;class lambdafactory.interfaces.IEvaluable at 0x85c4f2c&gt;)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_B' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><pre>Sets this element parent</pre></div></div><div id='d_DA' class='de'><h1>Method <span class='n'>getAnnotations</span></h1><div class='re'><code>getAnnotations( self, name=None )</code></div><div class='ds'><pre>Gets all the annotation with the given name associated to this element
		or all annotations if no name is specified.</pre></div></div><div id='d_DG' class='de'><h1>Method <span class='n'>setConcreteType</span></h1><div class='re'><code>setConcreteType( self, value )</code></div><div class='ds'><pre>Sets the _concrete type_ for this abstract type. The concrete type
		is a value which represents the type. For instance, if this type
		represents a class, then the concrete type would be the class instance.</pre></div></div><div id='d_DF' class='de'><h1>Method <span class='n'>__call__</span></h1><div class='re'><code>__call__( self )</code></div><div class='ds'><pre>A type instance can be used as a class to construct a new type, which
		will be cloned from the current type.</pre></div></div><div id='d_DE' class='de'><h1>Module <span class='n'>lambdafactory.modeltypes</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_C' class='de'><h1>Method <span class='n'>setResultAbstractType</span></h1><div class='re'><code>setResultAbstractType( self, abstractType )</code></div><div class='ds'><pre>Sets the abstract type for this operation result. This is usually
		invoked in the typing phase.</pre></div></div><div id='d_DK' class='de'><h1>Method <span class='n'>isIn</span></h1><div class='re'><code>isIn( self, interface )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_DJ' class='de'><h1>Method <span class='n'>getCurrentElement</span></h1><div class='re'><code>getCurrentElement( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_DI' class='de'><h1>Method <span class='n'>result</span></h1><div class='re'><code>result( self )</code></div><div class='ds'><pre>Returns the result for this type. This is usually just the type
		itself, except for processes types.</pre></div></div><div id='d_DH' class='de'><h1>Method <span class='n'>subtype</span></h1><div class='re'><code>subtype( self, name )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_DN' class='de'><h1>Method <span class='n'>walk</span></h1><div class='re'><code>walk( self, element )</code></div><div class='ds'><pre>Walks the given element, recursively walking the child elements when the
		handler does not return False</pre></div></div><div id='d_DM' class='de'><h1>Method <span class='n'>getCurrentMethod</span></h1><div class='re'><code>getCurrentMethod( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_DL' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.passes.PassContext at 0x857b1dc&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_Ds' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><pre>Adds an argument to this operation. This should do checking of
		arguments (by expected internal type and number).</pre></div></div><div id='d_Dr' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, context )</code></div><div class='ds'><pre>Sets the parent context for this context.</pre></div></div><div id='d_Dq' class='de'><h1>Method <span class='n'>setConclusion</span></h1><div class='re'><code>setConclusion( self, process )</code></div><div class='ds'><pre>Sets the process that will conclude the interception (finally)</pre></div></div><div id='d_Dp' class='de'><h1>Method <span class='n'>getAbsoluteName</span></h1><div class='re'><code>getAbsoluteName( self )</code></div><div class='ds'><pre>Returns the absolute name for this element</pre></div></div><div id='d_Dw' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><pre>Tells if this element has a parent or not</pre></div></div><div id='d_Dv' class='de'><h1>Method <span class='n'>getImportOperations</span></h1><div class='re'><code>getImportOperations( self )</code></div><div class='ds'><pre>Returns the list of import operations declared in this module </pre></div></div><div id='d_Du' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><pre>Detaches the element from its parent (in case it was already attached).
		This should return this element, and set the parent to None.</pre></div></div><div id='d_Dt' class='de'><h1>Class <span class='n'>IMatchExpressionOperation</span></h1><div class='re'></div><div class='ds'><pre>A match expression is a predicate that is associated to an expression.
	This is typically used in conditional expressions like in C:<br />	&gt;	int a = ( b==2 ? 1 : 2 )</pre></div></div><div id='d_Lg' class='de'><h1>Method <span class='n'>setSlot</span></h1><div class='re'><code>setSlot( self, name, evaluable )</code></div><div class='ds'><pre>Binds the given evaluable to the named slot. If there is already a slot
		with the same name, then 'getSlot(name)' should return the evaluable
		given as parameter.<br />		In the default implementation, setSlot preserves the ''history'' of
		added slots, and will always return the latest one.</pre></div></div><div id='d_Dy' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><pre>Tells if this element has a parent or not</pre></div></div><div id='d_Dx' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><pre>Detaches the element from its parent (in case it was already attached).
		This should return this element, and set the parent to None.</pre></div></div><div id='d_G' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><pre>Performs a deep clone of this element. Any mutation to the original won't
		change the copy.</pre></div></div><div id='d_Dc' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><pre>Returns this element parent</pre></div></div><div id='d_Db' class='de'><h1>Method <span class='n'>hasAnnotation</span></h1><div class='re'><code>hasAnnotation( self, name )</code></div><div class='ds'><pre>Tells if the given element has an annotation with the given name</pre></div></div><div id='d_Dg' class='de'><h1>Method <span class='n'>getSlotNames</span></h1><div class='re'><code>getSlotNames( self )</code></div><div class='ds'><pre>Returns the list of slot names (in order) for this context</pre></div></div><div id='d_D' class='de'><h1>Class <span class='n'>IAbstractClass</span></h1><div class='re'></div><div class='ds'><pre>An abstract @protocol is a @protocol that has at least one abstract element.</pre></div></div><div id='d_De' class='de'><h1>Method <span class='n'>addAnnotation</span></h1><div class='re'><code>addAnnotation( self, annotation )</code></div><div class='ds'><pre>Adds an annotation to this element</pre></div></div><div id='d_Dd' class='de'><h1>Method <span class='n'>getAbsoluteName</span></h1><div class='re'><code>getAbsoluteName( self )</code></div><div class='ds'><pre>Returns the absolute name for this element</pre></div></div><div id='d_Dk' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><pre>Sets this element parent</pre></div></div><div id='d_Dj' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><pre>Detaches the element from its parent (in case it was already attached).
		This should return this element, and set the parent to None.</pre></div></div><div id='d_Di' class='de'><h1>Method <span class='n'>getRoot</span></h1><div class='re'><code>getRoot( self )</code></div><div class='ds'><pre>Returns the root of this dataflow (the root of the parent or this dataflow
		if it has no parent)</pre></div></div><div id='d_Ld' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><pre>Detaches the element from its parent (in case it was already attached).
		This should return this element, and set the parent to None.</pre></div></div><div id='d_Do' class='de'><h1>Method <span class='n'>getAlias</span></h1><div class='re'><code>getAlias( self )</code></div><div class='ds'><pre>Returns the (optional) alias which will allow to reference the
		element.</pre></div></div><div id='d_Dn' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><pre>Returns this element parent</pre></div></div><div id='d_Dm' class='de'><h1>Method <span class='n'>getAbsoluteName</span></h1><div class='re'><code>getAbsoluteName( self )</code></div><div class='ds'><pre>Returns the absolute name for this element</pre></div></div><div id='d_Dl' class='de'><h1>Class <span class='n'>IEvaluation</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_rE' class='de'><h1>Method <span class='n'>onProgram</span></h1><div class='re'><code>onProgram( self, element )</code></div><div class='ds'><pre>Writes a Program element</pre></div></div><div id='d_rD' class='de'><h1>Method <span class='n'>createBlock</span></h1><div class='re'><code>createBlock( self, *operations )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_rG' class='de'><h1>Method <span class='n'>add</span></h1><div class='re'><code>add( self, name, theType )</code></div><div class='ds'><pre>This is a *deprecated* methods that is simply an alias for 'Map.set'.</pre></div></div><div id='d_rF' class='de'><h1>Method <span class='n'>setConcreteType</span></h1><div class='re'><code>setConcreteType( self, value )</code></div><div class='ds'><pre>Sets the _concrete type_ for this abstract type. The concrete type
		is a value which represents the type. For instance, if this type
		represents a class, then the concrete type would be the class instance.</pre></div></div><div id='d_rA' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><pre>Sets the given argument of this operation, by argument index.</pre></div></div><div id='d_rC' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><pre>Returns the ith arguments to this operation.</pre></div></div><div id='d_rB' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><pre>Returns the local name for this referencable element</pre></div></div><div id='d_rM' class='de'><h1>Method <span class='n'>filterContext</span></h1><div class='re'><code>filterContext( self, interface )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_rL' class='de'><h1>Method <span class='n'>isIn</span></h1><div class='re'><code>isIn( self, interface )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_rN' class='de'><h1>Method <span class='n'>getParentElement</span></h1><div class='re'><code>getParentElement( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_rI' class='de'><h1>Class <span class='n'>Type</span></h1><div class='re'></div><div class='ds'><pre>Abstract class for all types.</pre></div></div><div id='d_rH' class='de'><h1>Method <span class='n'>isLike</span></h1><div class='re'><code>isLike( self, otherType )</code></div><div class='ds'><pre>The other type is like this one if the other is a sequence with the
		same length and that all elements are like the corresponding elements of
		this sequence.</pre></div></div><div id='d_rK' class='de'><h1>Method <span class='n'>getCurrentElement</span></h1><div class='re'><code>getCurrentElement( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_rJ' class='de'><h1>Method <span class='n'>annotate</span></h1><div class='re'><code>annotate( self, value, name, content=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Eu' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type for this element</pre></div></div><div id='d_re' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type for this element</pre></div></div><div id='d_rd' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><pre>Returns this element parent</pre></div></div><div id='d_rg' class='de'><h1>Method <span class='n'>setArguments</span></h1><div class='re'><code>setArguments( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_rf' class='de'><h1>Method <span class='n'>getSlot</span></h1><div class='re'><code>getSlot( self, name )</code></div><div class='ds'><pre>Returns the given evaluable bound to named slot.</pre></div></div><div id='d_rc' class='de'><h1>Method <span class='n'>getDefaultValue</span></h1><div class='re'><code>getDefaultValue( self )</code></div><div class='ds'><pre>Returns the expression that assigns the @methodault value.</pre></div></div><div id='d_rb' class='de'><h1>Method <span class='n'>addAnnotation</span></h1><div class='re'><code>addAnnotation( self, annotation )</code></div><div class='ds'><pre>Adds an annotation to this element</pre></div></div><div id='d_rm' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><pre>Sets the given argument of this operation, by argument index.</pre></div></div><div id='d_rl' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><pre>Returns the *internal types* for this operations arguments. This is
		typically the list of interfaces or @protocols that the arguments must
		comply to.</pre></div></div><div id='d_ro' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><pre>Returns the ith arguments to this operation.</pre></div></div><div id='d_rn' class='de'><h1>Method <span class='n'>getAlias</span></h1><div class='re'><code>getAlias( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_ri' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><pre>Sets the abstract type for this element</pre></div></div><div id='d_rh' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><pre>Sets this element parent</pre></div></div><div id='d_rk' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type for this element</pre></div></div><div id='d_rj' class='de'><h1>Method <span class='n'>setAbstract</span></h1><div class='re'><code>setAbstract( self, isAbstract )</code></div><div class='ds'><pre>Sets wether the given abstractable is abstract or not.</pre></div></div><div id='d_ru' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><pre>Tells if this element has a parent or not</pre></div></div><div id='d_rt' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><pre>Detaches the element from its parent (in case it was already attached).
		This should return this element, and set the parent to None.</pre></div></div><div id='d_rw' class='de'><h1>Method <span class='n'>getAnnotations</span></h1><div class='re'><code>getAnnotations( self, name=None )</code></div><div class='ds'><pre>Gets all the annotation with the given name associated to this element
		or all annotations if no name is specified.</pre></div></div><div id='d_rv' class='de'><h1>Method <span class='n'>isAbstract</span></h1><div class='re'><code>isAbstract( self )</code></div><div class='ds'><pre>Tells wether the given abstractable is abstract or not.</pre></div></div><div id='d_rq' class='de'><h1>Method <span class='n'>hasAnnotation</span></h1><div class='re'><code>hasAnnotation( self, name )</code></div><div class='ds'><pre>Tells if the given element has an annotation with the given name</pre></div></div><div id='d_rp' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><pre>Sets the abstract type for this element</pre></div></div><div id='d_rs' class='de'><h1>Method <span class='n'>hasAnnotation</span></h1><div class='re'><code>hasAnnotation( self, name )</code></div><div class='ds'><pre>Tells if the given element has an annotation with the given name</pre></div></div><div id='d_rr' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><pre>Returns the parent context for this context (if any)</pre></div></div><div id='d_ry' class='de'><h1>Class <span class='n'>IProcess</span></h1><div class='re'></div><div class='ds'><pre>A process is a sequence of operations.</pre></div></div><div id='d_rx' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><pre>Returns this element parent</pre></div></div><div id='d_rz' class='de'><h1>Method <span class='n'>getAnnotations</span></h1><div class='re'><code>getAnnotations( self, name=None )</code></div><div class='ds'><pre>Gets all the annotation with the given name associated to this element
		or all annotations if no name is specified.</pre></div></div><div id='rI' class='cr'><div class='n'><a href='javascript:dS("rI");'>Type</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("rI","c");'><span class='special __bases__'><i>Base class</i></span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("rI","sI");'><span class='special __call__'>when invoked</span></a></div><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("rI","tI");'><span class='special __init__'>constructor</span></a></div><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("rI","uI");'><span class='special __str__'>string conversion</span></a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("rI","vI");'>asString</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("rI","wI");'>clone</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("rI","xI");'>concreteType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("rI","yI");'>definedBy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("rI","zI");'>isLike</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("rI","AI");'>isSameAs</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("rI","BI");'>isSubtypeOf</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("rI","CI");'>name</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("rI","DI");'>result</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("rI","EI");'>setConcreteType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("rI","FI");'>setName</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("rI","GI");'>subtype</a></div></div></div><div id='d_LK' class='de'><h1>Method <span class='n'>walk</span></h1><div class='re'><code>walk( self, element )</code></div><div class='ds'><pre>Walks the given element, recursively walking the child elements when the
		handler does not return False</pre></div></div><div id='d_LJ' class='de'><h1>Method <span class='n'>getParentElement</span></h1><div class='re'><code>getParentElement( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='ry' class='cr'><div class='n'><a href='javascript:dS("ry");'>IProcess</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("ry","sy");'><span class='special __bases__'>IElement</span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ry","ty");'>addOperation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ry","uy");'>getOperations</a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ry","vy");'>addAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ry","wy");'>copy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ry","xy");'>detach</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ry","yy");'>getAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ry","zy");'>getAnnotations</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ry","Ay");'>getDataFlow</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ry","By");'>getParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ry","Cy");'>hasAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ry","Dy");'>hasParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ry","Ey");'>removeAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ry","Fy");'>setAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ry","Gy");'>setParent</a></div></div></div><div id='d_Ec' class='de'><h1>Method <span class='n'>hasAnnotation</span></h1><div class='re'><code>hasAnnotation( self, name )</code></div><div class='ds'><pre>Tells if the given element has an annotation with the given name</pre></div></div><div id='d_LN' class='de'><h1>Method <span class='n'>echoWarning</span></h1><div class='re'><code>echoWarning( self, message, element )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Vi' class='de'><h1>Method <span class='n'>addOperation</span></h1><div class='re'><code>addOperation( self, operation )</code></div><div class='ds'><pre>Adds the given operation as a child of this process.</pre></div></div><div id='d_Vh' class='de'><h1>Method <span class='n'>setArguments</span></h1><div class='re'><code>setArguments( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Vk' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><pre>Tells if this element has a parent or not</pre></div></div><div id='d_Vj' class='de'><h1>Method <span class='n'>addAnnotation</span></h1><div class='re'><code>addAnnotation( self, annotation )</code></div><div class='ds'><pre>Adds an annotation to this element</pre></div></div><div id='d_Vm' class='de'><h1>Method <span class='n'>setArguments</span></h1><div class='re'><code>setArguments( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Vl' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><pre>Sets the given argument of this operation, by argument index.</pre></div></div><div id='d_Vo' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><pre>Sets the given argument of this operation, by argument index.</pre></div></div><div id='d_Vn' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><pre>Returns the dataflow accessible/bound to this element</pre></div></div><div id='d_Vc' class='de'><h1>Method <span class='n'>setDefaultValue</span></h1><div class='re'><code>setDefaultValue( self, value )</code></div><div class='ds'><pre>Sets the @methodault value for this argument.</pre></div></div><div id='d_Vb' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><pre>Returns the dataflow accessible/bound to this element</pre></div></div><div id='d_Ve' class='de'><h1>Class <span class='n'>IClass</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Vd' class='de'><h1>Method <span class='n'>getReturnTypeDescription</span></h1><div class='re'><code>getReturnTypeDescription( self )</code></div><div class='ds'><pre>Returns the return type description for this closure, if any</pre></div></div><div id='d_Vg' class='de'><h1>Method <span class='n'>getOperands</span></h1><div class='re'><code>getOperands( self )</code></div><div class='ds'><pre>Returns the left (and right, if any) operands of this computation.</pre></div></div><div id='d_Vf' class='de'><h1>Method <span class='n'>getOperations</span></h1><div class='re'><code>getOperations( self )</code></div><div class='ds'><pre>Returns the list of operations in this process.</pre></div></div><div id='d_Vy' class='de'><h1>Method <span class='n'>getSlot</span></h1><div class='re'><code>getSlot( self, name )</code></div><div class='ds'><pre>Returns the given evaluable bound to named slot.</pre></div></div><div id='d_Vx' class='de'><h1>Method <span class='n'>isAsList</span></h1><div class='re'><code>isAsList( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Vz' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><pre>Sets the given argument of this operation, by argument index.</pre></div></div><div id='d_LB' class='de'><h1>Method <span class='n'>getTarget</span></h1><div class='re'><code>getTarget( self )</code></div><div class='ds'><pre>Returns the operation target.</pre></div></div><div id='d_Vq' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><pre>Sets the given argument of this operation, by argument index.</pre></div></div><div id='d_Vp' class='de'><h1>Method <span class='n'>setAbstract</span></h1><div class='re'><code>setAbstract( self, isAbstract )</code></div><div class='ds'><pre>Sets wether the given abstractable is abstract or not.</pre></div></div><div id='d_Vs' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IValue at 0x85d202c&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_Vr' class='de'><h1>Method <span class='n'>removeAnnotation</span></h1><div class='re'><code>removeAnnotation( self, name )</code></div><div class='ds'><pre>Removes the annotations with the given name</pre></div></div><div id='d_Vu' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IFunction at 0x85d24dc&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_Vt' class='de'><h1>Method <span class='n'>removeAnnotation</span></h1><div class='re'><code>removeAnnotation( self, name )</code></div><div class='ds'><pre>Removes the annotations with the given name</pre></div></div><div id='d_Vw' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><pre>Returns the dataflow accessible/bound to this element</pre></div></div><div id='d_Vv' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><pre>Tells if this element has a parent or not</pre></div></div><div id='d_VI' class='de'><h1>Method <span class='n'>setConcreteType</span></h1><div class='re'><code>setConcreteType( self, value )</code></div><div class='ds'><pre>Sets the _concrete type_ for this abstract type. The concrete type
		is a value which represents the type. For instance, if this type
		represents a class, then the concrete type would be the class instance.</pre></div></div><div id='d_VH' class='de'><h1>Method <span class='n'>name</span></h1><div class='re'><code>name( self, name=None )</code></div><div class='ds'><pre>Returns/sets the name for this type. By defaults, types are unnamed.</pre></div></div><div id='d_VK' class='de'><h1>Method <span class='n'>filterContext</span></h1><div class='re'><code>filterContext( self, interface )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_VJ' class='de'><h1>Method <span class='n'>setEnvironment</span></h1><div class='re'><code>setEnvironment( self, environment )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_VM' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.passes.Pass at 0x857b20c&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_VL' class='de'><h1>Method <span class='n'>getCurrentMethod</span></h1><div class='re'><code>getCurrentMethod( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_VA' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><pre>Adds an argument to this operation. This should do checking of
		arguments (by expected internal type and number).</pre></div></div><div id='d_LG' class='de'><h1>Class <span class='n'>Map</span></h1><div class='re'></div><div class='ds'><pre>A map is simply an unordered set of types, mapped to names.</pre></div></div><div id='d_VC' class='de'><h1>Method <span class='n'>_arg</span></h1><div class='re'><code>_arg( self, name, typeinfo=None, optional=False )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_VB' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><pre>Returns the *internal types* for this operations arguments. This is
		typically the list of interfaces or @protocols that the arguments must
		comply to.</pre></div></div><div id='d_VE' class='de'><h1>Function <span class='n'>typeForValue</span></h1><div class='re'><code>typeForValue( value, noneIs=<lambdafactory.typecast.Symbolic instance at 0x4030efec> )</code></div><div class='ds'><pre>Associates a type with the given value. This basically creates a typecast
	instance/subtype, using the types defined in this module, using the given
	value which is a program element (implements interfaces defined in
	LF 'interfaces' module).</pre></div></div><div id='d_VD' class='de'><h1>Method <span class='n'>repeat</span></h1><div class='re'><code>repeat( self, condition, process )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_VG' class='de'><h1>Method <span class='n'>isLike</span></h1><div class='re'><code>isLike( self, otherType )</code></div><div class='ds'><pre>The other type is like this one if the other is a sequence with the
		same length and that all elements are like the corresponding elements of
		this sequence.</pre></div></div><div id='d_LF' class='de'><h1>Method <span class='n'>setName</span></h1><div class='re'><code>setName( self, name )</code></div><div class='ds'><pre>Sets the name of this type</pre></div></div><div id='d_LE' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.modeltypes.TypeCollection at 0x40315adc&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_LD' class='de'><h1>Method <span class='n'>importModule</span></h1><div class='re'><code>importModule( self, name, alias )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_XG' class='de'><h1>Method <span class='n'>isSubtypeOf</span></h1><div class='re'><code>isSubtypeOf( self, otherType )</code></div><div class='ds'><pre>The other type is a subtype of this one if for each element of this
		type, we find that the other type has a subtype.</pre></div></div><div id='d_XF' class='de'><h1>Method <span class='n'>__str__</span></h1><div class='re'><code>__str__( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_XE' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.modeltypes.Data at 0x40315e6c&gt;, &lt;class lambdafactory.modeltypes.Operations at 0x40315e9c&gt;, &lt;class lambdafactory.modeltypes.Structure at 0x40315ecc&gt;, &lt;class lambdafactory.modeltypes.Behaviour at 0x40315efc&gt;, &lt;class lambdafactory.modeltypes.Runtime at 0x40315f2c&gt;)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_XD' class='de'><h1>Method <span class='n'>returns</span></h1><div class='re'><code>returns( self, evaluable )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_XC' class='de'><h1>Method <span class='n'>_classattr</span></h1><div class='re'><code>_classattr( self, name, typeinfo=None, value=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_XB' class='de'><h1>Method <span class='n'>hasAnnotation</span></h1><div class='re'><code>hasAnnotation( self, name )</code></div><div class='ds'><pre>Tells if the given element has an annotation with the given name</pre></div></div><div id='d_XA' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><pre>Detaches the element from its parent (in case it was already attached).
		This should return this element, and set the parent to None.</pre></div></div><div id='d_XM' class='de'><h1>Method <span class='n'>annotate</span></h1><div class='re'><code>annotate( self, value, name, content=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_XL' class='de'><h1>Method <span class='n'>getCurrentProcess</span></h1><div class='re'><code>getCurrentProcess( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_XK' class='de'><h1>Method <span class='n'>getClassAncestors</span></h1><div class='re'><code>getClassAncestors( self, theClass=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_XJ' class='de'><h1>Method <span class='n'>walk</span></h1><div class='re'><code>walk( self, element )</code></div><div class='ds'><pre>Walks the given element, recursively walking the child elements when the
		handler does not return False</pre></div></div><div id='d_XI' class='de'><h1>Method <span class='n'>subtype</span></h1><div class='re'><code>subtype( self, name )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_XH' class='de'><h1>Method <span class='n'>setConcreteType</span></h1><div class='re'><code>setConcreteType( self, value )</code></div><div class='ds'><pre>Sets the _concrete type_ for this abstract type. The concrete type
		is a value which represents the type. For instance, if this type
		represents a class, then the concrete type would be the class instance.</pre></div></div><div id='d_Xg' class='de'><h1>Method <span class='n'>getRightOperand</span></h1><div class='re'><code>getRightOperand( self )</code></div><div class='ds'><pre>Returns the right operand of this computation (if any)</pre></div></div><div id='d_Xf' class='de'><h1>Method <span class='n'>getReturnTypeDescription</span></h1><div class='re'><code>getReturnTypeDescription( self )</code></div><div class='ds'><pre>Returns the return type description for this closure, if any</pre></div></div><div id='d_Xe' class='de'><h1>Method <span class='n'>getAttributes</span></h1><div class='re'><code>getAttributes( self )</code></div><div class='ds'><pre>Returns the (non-class) attributes defined within this class.</pre></div></div><div id='d_Xd' class='de'><h1>Method <span class='n'>getSlotNames</span></h1><div class='re'><code>getSlotNames( self )</code></div><div class='ds'><pre>Returns the list of slot names (in order) for this context</pre></div></div><div id='d_Xc' class='de'><h1>Method <span class='n'>setOptional</span></h1><div class='re'><code>setOptional( self, value )</code></div><div class='ds'><pre>Sets this argument as optional or not.</pre></div></div><div id='d_Xb' class='de'><h1>Method <span class='n'>getOperations</span></h1><div class='re'><code>getOperations( self )</code></div><div class='ds'><pre>Returns the list of operations in this process.</pre></div></div><div id='d_Xo' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.IEvaluable at 0x85c4f2c&gt;, &lt;class lambdafactory.interfaces.IEvaluable at 0x85c4f2c&gt;, &lt;class lambdafactory.interfaces.IEvaluable at 0x85c4f2c&gt;]</code></div><div class='ds'><pre>list() -&gt; new list
list(sequence) -&gt; new list initialized from sequence's items</pre></div></div><div id='d_Xn' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><pre>Returns the arguments to this operation.</pre></div></div><div id='d_Xm' class='de'><h1>Method <span class='n'>setReturnTypeDescription</span></h1><div class='re'><code>setReturnTypeDescription( self, description )</code></div><div class='ds'><pre>Sets the return type description for this closure, if any</pre></div></div><div id='d_Xl' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.IEvaluable at 0x85c4f2c&gt;, &lt;class lambdafactory.interfaces.IEvaluable at 0x85c4f2c&gt;]</code></div><div class='ds'><pre>list() -&gt; new list
list(sequence) -&gt; new list initialized from sequence's items</pre></div></div><div id='d_Xk' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><pre>Sets the abstract type for this element</pre></div></div><div id='d_Xj' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><pre>Detaches the element from its parent (in case it was already attached).
		This should return this element, and set the parent to None.</pre></div></div><div id='d_Xi' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><pre>Detaches the element from its parent (in case it was already attached).
		This should return this element, and set the parent to None.</pre></div></div><div id='d_Xh' class='de'><h1>Method <span class='n'>setReturnTypeDescription</span></h1><div class='re'><code>setReturnTypeDescription( self, description )</code></div><div class='ds'><pre>Sets the return type description for this closure, if any</pre></div></div><div id='d_Xw' class='de'><h1>Method <span class='n'>getResultAbstractType</span></h1><div class='re'><code>getResultAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type of the result of the evaluation of this
		evaluable</pre></div></div><div id='d_Xv' class='de'><h1>Method <span class='n'>removeAnnotation</span></h1><div class='re'><code>removeAnnotation( self, name )</code></div><div class='ds'><pre>Removes the annotations with the given name</pre></div></div><div id='d_Xu' class='de'><h1>Method <span class='n'>addOperation</span></h1><div class='re'><code>addOperation( self, operation )</code></div><div class='ds'><pre>Adds the given operation as a child of this process.</pre></div></div><div id='d_Xt' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><pre>Sets the given argument of this operation, by argument index.</pre></div></div><div id='d_Xs' class='de'><h1>Method <span class='n'>getValues</span></h1><div class='re'><code>getValues( self )</code></div><div class='ds'><pre>Returns the values within this list.</pre></div></div><div id='d_Xr' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><pre>Sets the given argument of this operation, by argument index.</pre></div></div><div id='d_Xq' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.IProcess at 0x85d241c&gt;, &lt;class lambdafactory.interfaces.IProcess at 0x85d241c&gt;, &lt;class lambdafactory.interfaces.IProcess at 0x85d241c&gt;]</code></div><div class='ds'><pre>list() -&gt; new list
list(sequence) -&gt; new list initialized from sequence's items</pre></div></div><div id='d_Xp' class='de'><h1>Method <span class='n'>setArguments</span></h1><div class='re'><code>setArguments( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Xz' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.IEvaluable at 0x85c4f2c&gt;, &lt;class lambdafactory.interfaces.IProcess at 0x85d241c&gt;]</code></div><div class='ds'><pre>list() -&gt; new list
list(sequence) -&gt; new list initialized from sequence's items</pre></div></div><div id='d_Xy' class='de'><h1>Method <span class='n'>getSlots</span></h1><div class='re'><code>getSlots( self )</code></div><div class='ds'><pre>Returns (key, evaluable) pairs representing the slots within this
		context. In the case of context that may inherits slots, this only
		returns the slots that are owned by the context (ie. it does not
		include inherited slots)</pre></div></div><div id='d_Xx' class='de'><h1>Method <span class='n'>isByName</span></h1><div class='re'><code>isByName( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_cj' class='de'><h1>Method <span class='n'>getArguments</span></h1><div class='re'><code>getArguments( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_ck' class='de'><h1>Method <span class='n'>hasAnnotation</span></h1><div class='re'><code>hasAnnotation( self, name )</code></div><div class='ds'><pre>Tells if the given element has an annotation with the given name</pre></div></div><div id='d_ch' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><pre>Adds an argument to this operation. This should do checking of
		arguments (by expected internal type and number).</pre></div></div><div id='d_ci' class='de'><h1>Method <span class='n'>getSlot</span></h1><div class='re'><code>getSlot( self, name )</code></div><div class='ds'><pre>Returns the given evaluable bound to named slot.</pre></div></div><div id='d_cn' class='de'><h1>Method <span class='n'>addOperation</span></h1><div class='re'><code>addOperation( self, operation )</code></div><div class='ds'><pre>Adds the given operation as a child of this process.</pre></div></div><div id='d_co' class='de'><h1>Method <span class='n'>removeAnnotation</span></h1><div class='re'><code>removeAnnotation( self, name )</code></div><div class='ds'><pre>Removes the annotations with the given name</pre></div></div><div id='d_cl' class='de'><h1>Class <span class='n'>IEnumeration</span></h1><div class='re'></div><div class='ds'><pre>An enumeration produces values between a start and an end value, with the
	given step.</pre></div></div><div id='d_cm' class='de'><h1>Method <span class='n'>addAnnotation</span></h1><div class='re'><code>addAnnotation( self, annotation )</code></div><div class='ds'><pre>Adds an annotation to this element</pre></div></div><div id='d_cb' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><pre>Tells if this element has a parent or not</pre></div></div><div id='d_cc' class='de'><h1>Method <span class='n'>getSlots</span></h1><div class='re'><code>getSlots( self )</code></div><div class='ds'><pre>Returns (key, evaluable) pairs representing the slots within this
		context. In the case of context that may inherits slots, this only
		returns the slots that are owned by the context (ie. it does not
		include inherited slots)</pre></div></div><div id='d_cf' class='de'><h1>Method <span class='n'>getInheritedSlots</span></h1><div class='re'><code>getInheritedSlots( self )</code></div><div class='ds'><pre>gives the list of inherited slots</pre></div></div><div id='d_cg' class='de'><h1>Method <span class='n'>hasExplicitTermination</span></h1><div class='re'><code>hasExplicitTermination( self )</code></div><div class='ds'><pre>Returns true if this function has an operation with a termination,
		otherwise return false.</pre></div></div><div id='d_cd' class='de'><h1>Class <span class='n'>IAssignable</span></h1><div class='re'></div><div class='ds'><pre>Assignable elements are elements that can be bound to slots. In many
	languages, only a subset of elements can be assigned. For instance, in
	Java, you cannot assign a package to something:<br />	&gt;     Object my_package = java.lang.Object<br />	while in some other languages (like JavaScript), you could do that.</pre></div></div><div id='d_ce' class='de'><h1>Method <span class='n'>hasSlot</span></h1><div class='re'><code>hasSlot( self, name )</code></div><div class='ds'><pre>Tells if the context has a slot with the given name.</pre></div></div><div id='d_cz' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><pre>Sets the abstract type for this element</pre></div></div><div id='d_cx' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><pre>Sets this element parent</pre></div></div><div id='d_cy' class='de'><h1>Method <span class='n'>addAnnotation</span></h1><div class='re'><code>addAnnotation( self, annotation )</code></div><div class='ds'><pre>Adds an annotation to this element</pre></div></div><div id='d_cr' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><pre>Detaches the element from its parent (in case it was already attached).
		This should return this element, and set the parent to None.</pre></div></div><div id='d_cs' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IOperation at 0x85d268c&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_cp' class='de'><h1>Method <span class='n'>getImportedElements</span></h1><div class='re'><code>getImportedElements( self )</code></div><div class='ds'><pre>Returns a reference or a resolution that will allow to get the
		imported element.</pre></div></div><div id='d_cq' class='de'><h1>Class <span class='n'>IInstanciation</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_cv' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type for this element</pre></div></div><div id='d_cw' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IAttribute at 0x85d226c&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_ct' class='de'><h1>Method <span class='n'>getAnnotations</span></h1><div class='re'><code>getAnnotations( self, name=None )</code></div><div class='ds'><pre>Gets all the annotation with the given name associated to this element
		or all annotations if no name is specified.</pre></div></div><div id='d_cu' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IOperation at 0x85d268c&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_cJ' class='de'><h1>Function <span class='n'>bits</span></h1><div class='re'><code>bits( size )</code></div><div class='ds'><pre>Converts the given number of bits into bytes. This is simply for
	readibility purprose.</pre></div></div><div id='d_cK' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_cH' class='de'><h1>Method <span class='n'>definedBy</span></h1><div class='re'><code>definedBy( self, definition=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_cI' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self, name )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_cN' class='de'><h1>Method <span class='n'>getClassParents</span></h1><div class='re'><code>getClassParents( self, theClass )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_cL' class='de'><h1>Method <span class='n'>getCurrentClosure</span></h1><div class='re'><code>getCurrentClosure( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_cM' class='de'><h1>Method <span class='n'>hasParentElement</span></h1><div class='re'><code>hasParentElement( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_cB' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><pre>Returns the arguments to this operation.</pre></div></div><div id='d_cC' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><pre>Sets this element parent</pre></div></div><div id='d_cA' class='de'><h1>Method <span class='n'>addAnnotation</span></h1><div class='re'><code>addAnnotation( self, annotation )</code></div><div class='ds'><pre>Adds an annotation to this element</pre></div></div><div id='d_cF' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self, *args )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_cG' class='de'><h1>Method <span class='n'>setConcreteType</span></h1><div class='re'><code>setConcreteType( self, value )</code></div><div class='ds'><pre>Sets the _concrete type_ for this abstract type. The concrete type
		is a value which represents the type. For instance, if this type
		represents a class, then the concrete type would be the class instance.</pre></div></div><div id='d_cD' class='de'><h1>Method <span class='n'>_moduleattr</span></h1><div class='re'><code>_moduleattr( self, name, typeinfo=None, value=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_cE' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self, someClass, expectedClass, argument )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_qv' class='de'><h1>Method <span class='n'>hasSlot</span></h1><div class='re'><code>hasSlot( self, name )</code></div><div class='ds'><pre>Tells if the context has a slot with the given name.</pre></div></div><div id='QA' class='cr'><div class='n'><a href='javascript:dS("QA");'>ISliceOperation</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("QA","RA");'><span class='special __bases__'>ISubsetOperation</span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("QA","SA");'>getSliceEnd</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("QA","TA");'>getSliceStart</a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("QA","UA");'>addAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("QA","VA");'>addOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("QA","WA");'>copy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("QA","XA");'>detach</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("QA","YA");'>getAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("QA","ZA");'>getAnnotations</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("QA","aB");'>getDataFlow</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("QA","bB");'>getOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("QA","cB");'>getOpArguments</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("QA","dB");'>getOpArgumentsInternalTypes</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("QA","eB");'>getParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("QA","fB");'>getTarget</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("QA","gB");'>hasAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("QA","hB");'>hasParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("QA","iB");'>removeAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("QA","jB");'>setAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("QA","kB");'>setOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("QA","lB");'>setParent</a></div></div><div class='t'>Values</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&bull;</span><a href='javascript:dO("QA","mB");'>ARGS</a></div></div></div><div id='QE' class='cr'><div class='n'><a href='javascript:dS("QE");'>Structure</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("QE","RE");'><span class='special __bases__'>TypeCollection</span></a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("QE","SE");'>getType</a></div></div></div><div id='d_uA' class='de'><h1>Class <span class='n'>ISelection</span></h1><div class='re'></div><div class='ds'><pre>Selections are the abstract objects behind `if`, `select` or
	pattern-matching operations. Each selection has match operations as
	arguments, which bind a subprocess to a predicate expression.</pre></div></div><div id='d_uB' class='de'><h1>Method <span class='n'>addAnnotation</span></h1><div class='re'><code>addAnnotation( self, annotation )</code></div><div class='ds'><pre>Adds an annotation to this element</pre></div></div><div id='d_uC' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><pre>Returns this element parent</pre></div></div><div id='d_uD' class='de'><h1>Method <span class='n'>createClosure</span></h1><div class='re'><code>createClosure( self, arguments, *operations )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_uE' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.IProgram at 0x85d23ec&gt;, &lt;class lambdafactory.interfaces.IClass at 0x85d232c&gt;, &lt;class lambdafactory.interfaces.IModule at 0x85d23bc&gt;, &lt;class lambdafactory.interfaces.IAccessor at 0x85d256c&gt;, &lt;class lambdafactory.interfaces.IMutator at 0x85d259c&gt;, &lt;class lambdafactory.interfaces.IDestructor at 0x85d25fc&gt;, &lt;class lambdafactory.interfaces.IConstructor at 0x85d25cc&gt;, &lt;class lambdafactory.interfaces.IClassMethod at 0x85d265c&gt;, &lt;class lambdafactory.interfaces.IMethod at 0x85d250c&gt;, &lt;class lambdafactory.interfaces.IFunction at 0x85d24dc&gt;, &lt;class lambdafactory.interfaces.IClosure at 0x85d24ac&gt;, &lt;class lambdafactory.interfaces.IBlock at 0x85d247c&gt;, &lt;class lambdafactory.interfaces.IModuleAttribute at 0x85d229c&gt;, &lt;class lambdafactory.interfaces.IClassAttribute at 0x85d22cc&gt;, &lt;class lambdafactory.interfaces.IAttribute at 0x85d226c&gt;, &lt;class lambdafactory.interfaces.IArgument at 0x85d220c&gt;, &lt;class lambdafactory.interfaces.IParameter at 0x85d223c&gt;, &lt;class lambdafactory.interfaces.IOperator at 0x85d21ac&gt;, &lt;class lambdafactory.interfaces.IReference at 0x85d214c&gt;, &lt;class lambdafactory.interfaces.INumber at 0x85d208c&gt;, &lt;class lambdafactory.interfaces.IString at 0x85d20bc&gt;, &lt;class lambdafactory.interfaces.IList at 0x85d20ec&gt;, &lt;class lambdafactory.interfaces.IDict at 0x85d211c&gt;, &lt;class lambdafactory.interfaces.IEnumeration at 0x85d2a7c&gt;, &lt;class lambdafactory.interfaces.IAllocation at 0x85d280c&gt;, &lt;class lambdafactory.interfaces.IAssignation at 0x85d27dc&gt;, &lt;class lambdafactory.interfaces.IComputation at 0x85d286c&gt;, &lt;class lambdafactory.interfaces.IInvocation at 0x85d289c&gt;, &lt;class lambdafactory.interfaces.IInstanciation at 0x85d28cc&gt;, &lt;class lambdafactory.interfaces.IResolution at 0x85d283c&gt;, &lt;class lambdafactory.interfaces.ISelection at 0x85d2a1c&gt;, &lt;class lambdafactory.interfaces.IRepetition at 0x85d2aac&gt;, &lt;class lambdafactory.interfaces.IIteration at 0x85d2a4c&gt;, &lt;class lambdafactory.interfaces.IAccessOperation at 0x85d292c&gt;, &lt;class lambdafactory.interfaces.ISliceOperation at 0x85d295c&gt;, &lt;class lambdafactory.interfaces.IEvaluation at 0x85d27ac&gt;, &lt;class lambdafactory.interfaces.ITermination at 0x85d2adc&gt;, &lt;class lambdafactory.interfaces.IBreaking at 0x85d2b3c&gt;, &lt;class lambdafactory.interfaces.IExcept at 0x85d2b6c&gt;, &lt;class lambdafactory.interfaces.IInterception at 0x85d2b9c&gt;, &lt;class lambdafactory.interfaces.IImportSymbolOperation at 0x85d26ec&gt;, &lt;class lambdafactory.interfaces.IImportSymbolsOperation at 0x85d271c&gt;, &lt;class lambdafactory.interfaces.IImportModuleOperation at 0x85d274c&gt;, &lt;class lambdafactory.interfaces.IImportModulesOperation at 0x85d277c&gt;, &lt;class lambdafactory.interfaces.IEmbed at 0x85d2bcc&gt;]</code></div><div class='ds'><pre>list() -&gt; new list
list(sequence) -&gt; new list initialized from sequence's items</pre></div></div><div id='d_uF' class='de'><h1>Class <span class='n'>Array</span></h1><div class='re'></div><div class='ds'><pre>A sequence is simply an ordered set of types.</pre></div></div><div id='d_uG' class='de'><h1>Method <span class='n'>definedBy</span></h1><div class='re'><code>definedBy( self, definition=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_uH' class='de'><h1>Method <span class='n'>peel</span></h1><div class='re'><code>peel( self )</code></div><div class='ds'><pre>If this process is (A, B)-&gt;C, will return (B)-&gt;C. You cannot peel a
		process that is (B)-&gt;C.</pre></div></div><div id='d_uI' class='de'><h1>Method <span class='n'>__str__</span></h1><div class='re'><code>__str__( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_uJ' class='de'><h1>Method <span class='n'>findInContext</span></h1><div class='re'><code>findInContext( self, interface )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_uK' class='de'><h1>Method <span class='n'>getCurrentModule</span></h1><div class='re'><code>getCurrentModule( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_uL' class='de'><h1>Method <span class='n'>resolveAbsoluteOrLocal</span></h1><div class='re'><code>resolveAbsoluteOrLocal( self, referenceOrName, contextOrDataFlow=None )</code></div><div class='ds'><pre>Tries an absolute resolution first, then will look in the local scope if
		it fails.</pre></div></div><div id='d_uM' class='de'><h1>Method <span class='n'>getClassParents</span></h1><div class='re'><code>getClassParents( self, theClass )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_uN' class='de'><h1>Method <span class='n'>hasParentElement</span></h1><div class='re'><code>hasParentElement( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_ub' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><pre>Detaches the element from its parent (in case it was already attached).
		This should return this element, and set the parent to None.</pre></div></div><div id='d_uc' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><pre>Adds an argument to this operation. This should do checking of
		arguments (by expected internal type and number).</pre></div></div><div id='d_ud' class='de'><h1>Method <span class='n'>removeAnnotation</span></h1><div class='re'><code>removeAnnotation( self, name )</code></div><div class='ds'><pre>Removes the annotations with the given name</pre></div></div><div id='d_ue' class='de'><h1>Method <span class='n'>getOperations</span></h1><div class='re'><code>getOperations( self )</code></div><div class='ds'><pre>Returns the list of operations in this process.</pre></div></div><div id='d_uf' class='de'><h1>Method <span class='n'>hasAnnotation</span></h1><div class='re'><code>hasAnnotation( self, name )</code></div><div class='ds'><pre>Tells if the given element has an annotation with the given name</pre></div></div><div id='d_ug' class='de'><h1>Method <span class='n'>addOperation</span></h1><div class='re'><code>addOperation( self, operation )</code></div><div class='ds'><pre>Adds the given operation as a child of this process.</pre></div></div><div id='d_uh' class='de'><h1>Class <span class='n'>IConstructor</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_ui' class='de'><h1>Method <span class='n'>addDestination</span></h1><div class='re'><code>addDestination( self, dataflow )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_uj' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><pre>Sets this element parent</pre></div></div><div id='d_uk' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><pre>Returns the ith arguments to this operation.</pre></div></div><div id='d_ul' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><pre>Tells if this element has a parent or not</pre></div></div><div id='d_um' class='de'><h1>Class <span class='n'>IFunction</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_un' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><pre>Adds an argument to this operation. This should do checking of
		arguments (by expected internal type and number).</pre></div></div><div id='d_uo' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><pre>Returns this element parent</pre></div></div><div id='d_up' class='de'><h1>list</h1><div class='re'><code>[[&lt;class lambdafactory.interfaces.IEvaluable at 0x85c4f2c&gt;], &lt;class lambdafactory.interfaces.IEvaluable at 0x85c4f2c&gt;]</code></div><div class='ds'><pre>list() -&gt; new list
list(sequence) -&gt; new list initialized from sequence's items</pre></div></div><div id='d_uq' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><pre>Sets the abstract type for this element</pre></div></div><div id='d_ur' class='de'><h1>Method <span class='n'>getSlotNames</span></h1><div class='re'><code>getSlotNames( self )</code></div><div class='ds'><pre>Returns the list of slot names (in order) for this context</pre></div></div><div id='d_us' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><pre>Sets the abstract type for this element</pre></div></div><div id='d_ut' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><pre>Returns the dataflow accessible/bound to this element</pre></div></div><div id='d_uu' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><pre>Sets the given argument of this operation, by argument index.</pre></div></div><div id='d_uv' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><pre>Sets the abstract type for this element</pre></div></div><div id='d_uw' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><pre>Returns this @protocol name. It can be `None` if the @protocol is anonymous.</pre></div></div><div id='d_ux' class='de'><h1>Method <span class='n'>removeAnnotation</span></h1><div class='re'><code>removeAnnotation( self, name )</code></div><div class='ds'><pre>Removes the annotations with the given name</pre></div></div><div id='d_uy' class='de'><h1>Method <span class='n'>getOperations</span></h1><div class='re'><code>getOperations( self )</code></div><div class='ds'><pre>Returns the list of operations in this process.</pre></div></div><div id='d_uz' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><pre>Returns this element parent</pre></div></div><div id='dd' class='cr'><div class='n'><a href='javascript:dS("dd");'>IAssignation</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("dd","ed");'><span class='special __bases__'>IOperation</span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("dd","fd");'>getAssignedValue</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("dd","gd");'>getTarget</a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("dd","hd");'>addAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("dd","id");'>addOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("dd","jd");'>copy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("dd","kd");'>detach</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("dd","ld");'>getAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("dd","md");'>getAnnotations</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("dd","nd");'>getDataFlow</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("dd","od");'>getOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("dd","pd");'>getOpArguments</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("dd","qd");'>getOpArgumentsInternalTypes</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("dd","rd");'>getParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("dd","sd");'>hasAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("dd","td");'>hasParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("dd","ud");'>removeAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("dd","vd");'>setAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("dd","wd");'>setOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("dd","xd");'>setParent</a></div></div><div class='t'>Values</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&bull;</span><a href='javascript:dO("dd","yd");'>ARGS</a></div></div></div><div id='dC' class='cr'><div class='n'><a href='javascript:dS("dC");'>ISyntactic</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("dC","c");'><span class='special __bases__'><i>Base class</i></span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("dC","eC");'>getColumn</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("dC","fC");'>getLine</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("dC","gC");'>getOffset</a></div></div></div><div id='d_It' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><pre>Adds an argument to this operation. This should do checking of
		arguments (by expected internal type and number).</pre></div></div><div id='d_Iu' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><pre>Returns the arguments to this operation.</pre></div></div><div id='d_Iv' class='de'><h1>Method <span class='n'>addAnnotation</span></h1><div class='re'><code>addAnnotation( self, annotation )</code></div><div class='ds'><pre>Adds an annotation to this element</pre></div></div><div id='d_Iw' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><pre>Sets the abstract type for this element</pre></div></div><div id='d_Ip' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><pre>Returns this @protocol name. It can be `None` if the @protocol is anonymous.</pre></div></div><div id='d_Iq' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><pre>Performs a deep clone of this element. Any mutation to the original won't
		change the copy.</pre></div></div><div id='d_Ir' class='de'><h1>Method <span class='n'>addAnnotation</span></h1><div class='re'><code>addAnnotation( self, annotation )</code></div><div class='ds'><pre>Adds an annotation to this element</pre></div></div><div id='d_Is' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><pre>Returns the dataflow accessible/bound to this element</pre></div></div><div id='d_Ix' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><pre>Returns the local name for this referencable element</pre></div></div><div id='d_Iy' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IContext at 0x85d22fc&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_Iz' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><pre>Performs a deep clone of this element. Any mutation to the original won't
		change the copy.</pre></div></div><div id='d_Id' class='de'><h1>Method <span class='n'>addAnnotation</span></h1><div class='re'><code>addAnnotation( self, annotation )</code></div><div class='ds'><pre>Adds an annotation to this element</pre></div></div><div id='d_Ie' class='de'><h1>Method <span class='n'>getAnnotations</span></h1><div class='re'><code>getAnnotations( self, name=None )</code></div><div class='ds'><pre>Gets all the annotation with the given name associated to this element
		or all annotations if no name is specified.</pre></div></div><div id='d_If' class='de'><h1>Class <span class='n'>IClassMethod</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Ig' class='de'><h1>Method <span class='n'>removeAnnotation</span></h1><div class='re'><code>removeAnnotation( self, name )</code></div><div class='ds'><pre>Removes the annotations with the given name</pre></div></div><div id='d_Ib' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><pre>Sets this element parent</pre></div></div><div id='d_Ic' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><pre>Sets the given argument of this operation, by argument index.</pre></div></div><div id='d_Il' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><pre>Performs a deep clone of this element. Any mutation to the original won't
		change the copy.</pre></div></div><div id='d_Im' class='de'><h1>Method <span class='n'>getOperations</span></h1><div class='re'><code>getOperations( self )</code></div><div class='ds'><pre>Returns the list of operations in this process.</pre></div></div><div id='d_In' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><pre>Sets the given argument of this operation, by argument index.</pre></div></div><div id='d_Io' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><pre>Performs a deep clone of this element. Any mutation to the original won't
		change the copy.</pre></div></div><div id='d_Ih' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><pre>Returns this element parent</pre></div></div><div id='d_Ii' class='de'><h1>Method <span class='n'>resolve</span></h1><div class='re'><code>resolve( self, name )</code></div><div class='ds'><pre>Returns a couple '(DataFlow slot, IElement)' or '(None,None)'
		corresponding to the resolution of the given 'name' in this dataflow.</pre></div></div><div id='d_Ij' class='de'><h1>Method <span class='n'>getResultAbstractType</span></h1><div class='re'><code>getResultAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type of the result of the evaluation of this
		evaluable</pre></div></div><div id='d_Ik' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><pre>Adds an argument to this operation. This should do checking of
		arguments (by expected internal type and number).</pre></div></div><div id='d_ID' class='de'><h1>Method <span class='n'>enumerate</span></h1><div class='re'><code>enumerate( self, start, end, step=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_IE' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.modeltypes.TypeCollection at 0x40315adc&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_IF' class='de'><h1>Method <span class='n'>name</span></h1><div class='re'><code>name( self, name=None )</code></div><div class='ds'><pre>Returns/sets the name for this type. By defaults, types are unnamed.</pre></div></div><div id='d_IG' class='de'><h1>Method <span class='n'>register</span></h1><div class='re'><code>register( self, name, _type )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_IA' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><pre>Returns this element parent</pre></div></div><div id='d_IB' class='de'><h1>Method <span class='n'>setResultAbstractType</span></h1><div class='re'><code>setResultAbstractType( self, abstractType )</code></div><div class='ds'><pre>Sets the abstract type for this operation result. This is usually
		invoked in the typing phase.</pre></div></div><div id='d_IC' class='de'><h1>Method <span class='n'>getAnnotations</span></h1><div class='re'><code>getAnnotations( self, name=None )</code></div><div class='ds'><pre>Gets all the annotation with the given name associated to this element
		or all annotations if no name is specified.</pre></div></div><div id='d_IL' class='de'><h1>Method <span class='n'>filter</span></h1><div class='re'><code>filter( self, list, interface )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_IM' class='de'><h1>Method <span class='n'>getProgram</span></h1><div class='re'><code>getProgram( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_IN' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_IH' class='de'><h1>Method <span class='n'>add</span></h1><div class='re'><code>add( self, theType )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_II' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.typecast.Symbolic at 0x40315c8c&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_IJ' class='de'><h1>Method <span class='n'>getFactory</span></h1><div class='re'><code>getFactory( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_IK' class='de'><h1>Method <span class='n'>run</span></h1><div class='re'><code>run( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_GN' class='de'><h1>Module <span class='n'>lambdafactory.reporter</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='wu' class='cr'><div class='n'><a href='javascript:dS("wu");'>IMatchProcessOperation</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("wu","xu");'><span class='special __bases__'>IMatchOperation</span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("wu","yu");'>getProcess</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("wu","zu");'>setProcess</a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("wu","Au");'>addAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("wu","Bu");'>addOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("wu","Cu");'>copy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("wu","Du");'>detach</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("wu","Eu");'>getAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("wu","Fu");'>getAnnotations</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("wu","Gu");'>getDataFlow</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("wu","Hu");'>getOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("wu","Iu");'>getOpArguments</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("wu","Ju");'>getOpArgumentsInternalTypes</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("wu","Ku");'>getParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("wu","Lu");'>getPredicate</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("wu","Mu");'>hasAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("wu","Nu");'>hasParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("wu","Ou");'>removeAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("wu","Pu");'>setAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("wu","Qu");'>setOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("wu","Ru");'>setParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("wu","Su");'>setPredicate</a></div></div><div class='t'>Values</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&bull;</span><a href='javascript:dO("wu","Tu");'>ARGS</a></div></div></div><div id='d_GM' class='de'><h1>Method <span class='n'>getFactory</span></h1><div class='re'><code>getFactory( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_GJ' class='de'><h1>Method <span class='n'>getCurrentModule</span></h1><div class='re'><code>getCurrentModule( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_GK' class='de'><h1>Method <span class='n'>resolveAbsoluteOrLocal</span></h1><div class='re'><code>resolveAbsoluteOrLocal( self, referenceOrName, contextOrDataFlow=None )</code></div><div class='ds'><pre>Tries an absolute resolution first, then will look in the local scope if
		it fails.</pre></div></div><div id='d_GH' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.typecast.Type at 0x40315c5c&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='wp' class='cr'><div class='n'><a href='javascript:dS("wp");'>IInstanceMethod</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("wp","xp");'><span class='special __bases__'>IMethod</span></a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("wp","yp");'>addAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("wp","zp");'>addOperation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("wp","Ap");'>copy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("wp","Bp");'>detach</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("wp","Cp");'>endsWithTermination</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("wp","Dp");'>getAbsoluteName</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("wp","Ep");'>getAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("wp","Fp");'>getAnnotations</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("wp","Gp");'>getArguments</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("wp","Hp");'>getDataFlow</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("wp","Ip");'>getName</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("wp","Jp");'>getOperations</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("wp","Kp");'>getParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("wp","Lp");'>getReturnTypeDescription</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("wp","Mp");'>getSlot</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("wp","Np");'>getSlotNames</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("wp","Op");'>getSlots</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("wp","Pp");'>hasAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("wp","Qp");'>hasExplicitTermination</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("wp","Rp");'>hasParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("wp","Sp");'>hasSlot</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("wp","Tp");'>isAbstract</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("wp","Up");'>removeAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("wp","Vp");'>setAbstract</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("wp","Wp");'>setAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("wp","Xp");'>setArguments</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("wp","Yp");'>setParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("wp","Zp");'>setReturnTypeDescription</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("wp","aq");'>setSlot</a></div></div></div><div id='d_GF' class='de'><h1>Method <span class='n'>concreteType</span></h1><div class='re'><code>concreteType( self )</code></div><div class='ds'><pre>Returns the _concrete type_ for this abstract type.</pre></div></div><div id='d_GG' class='de'><h1>Class <span class='n'>Environment</span></h1><div class='re'></div><div class='ds'><pre>The environment stores types and names them. This allows to easily
	retrieve types from a given name.</pre></div></div><div id='d_GD' class='de'><h1>Method <span class='n'>embed</span></h1><div class='re'><code>embed( self, lang, code )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_GE' class='de'><h1>Method <span class='n'>getType</span></h1><div class='re'><code>getType( self, name )</code></div><div class='ds'><pre>Returns the type with the given name, or None if it does not
		exist.</pre></div></div><div id='d_GB' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><pre>Sets the abstract type for this element</pre></div></div><div id='d_GC' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><pre>Detaches the element from its parent (in case it was already attached).
		This should return this element, and set the parent to None.</pre></div></div><div id='d_GA' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><pre>Returns the arguments to this operation.</pre></div></div><div id='d_Gz' class='de'><h1>Method <span class='n'>addAnnotation</span></h1><div class='re'><code>addAnnotation( self, annotation )</code></div><div class='ds'><pre>Adds an annotation to this element</pre></div></div><div id='d_Gx' class='de'><h1>Method <span class='n'>getAnnotations</span></h1><div class='re'><code>getAnnotations( self, name=None )</code></div><div class='ds'><pre>Gets all the annotation with the given name associated to this element
		or all annotations if no name is specified.</pre></div></div><div id='d_Gy' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><pre>Sets this element parent</pre></div></div><div id='d_Gv' class='de'><h1>Method <span class='n'>mergeWith</span></h1><div class='re'><code>mergeWith( self, module )</code></div><div class='ds'><pre>Merges this module with the given module</pre></div></div><div id='d_Gw' class='de'><h1>Method <span class='n'>removeAnnotation</span></h1><div class='re'><code>removeAnnotation( self, name )</code></div><div class='ds'><pre>Removes the annotations with the given name</pre></div></div><div id='d_Gt' class='de'><h1>Method <span class='n'>setExpression</span></h1><div class='re'><code>setExpression( self, v )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Gu' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><pre>Returns the dataflow accessible/bound to this element</pre></div></div><div id='d_Gr' class='de'><h1>Class <span class='n'>IInterruption</span></h1><div class='re'></div><div class='ds'><pre>An interruption can be be used to halt the process.</pre></div></div><div id='d_Gs' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type for this element</pre></div></div><div id='d_Gp' class='de'><h1>Method <span class='n'>getArguments</span></h1><div class='re'><code>getArguments( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Gq' class='de'><h1>Method <span class='n'>addAnnotation</span></h1><div class='re'><code>addAnnotation( self, annotation )</code></div><div class='ds'><pre>Adds an annotation to this element</pre></div></div><div id='d_Gn' class='de'><h1>Method <span class='n'>removeAnnotation</span></h1><div class='re'><code>removeAnnotation( self, name )</code></div><div class='ds'><pre>Removes the annotations with the given name</pre></div></div><div id='d_Go' class='de'><h1>Method <span class='n'>addAnnotation</span></h1><div class='re'><code>addAnnotation( self, annotation )</code></div><div class='ds'><pre>Adds an annotation to this element</pre></div></div><div id='d_Gl' class='de'><h1>Method <span class='n'>addAnnotation</span></h1><div class='re'><code>addAnnotation( self, annotation )</code></div><div class='ds'><pre>Adds an annotation to this element</pre></div></div><div id='d_Gm' class='de'><h1>Method <span class='n'>getArguments</span></h1><div class='re'><code>getArguments( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Gj' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><pre>Returns the dataflow accessible/bound to this element</pre></div></div><div id='d_Gk' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IEmbed at 0x85d2bcc&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_Gh' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><pre>Returns this @protocol name. It can be `None` if the @protocol is anonymous.</pre></div></div><div id='d_Gi' class='de'><h1>Method <span class='n'>getSources</span></h1><div class='re'><code>getSources( self )</code></div><div class='ds'><pre>Returns the dataflows that are _sources_, meaning that if a slot is not
		resolved by this dataflow, it will look in the parent and then in the
		sources (depending on the resolution scheme, but this is the default)</pre></div></div><div id='d_Gf' class='de'><h1>Method <span class='n'>getTypeDescription</span></h1><div class='re'><code>getTypeDescription( self )</code></div><div class='ds'><pre>Returns type information (constraints) that are associated to this
		argument.</pre></div></div><div id='d_Gg' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><pre>Tells if this element has a parent or not</pre></div></div><div id='d_Gd' class='de'><h1>Class <span class='n'>IAttributeMethod</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Ge' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><pre>Detaches the element from its parent (in case it was already attached).
		This should return this element, and set the parent to None.</pre></div></div><div id='d_Gb' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><pre>Sets the abstract type for this element</pre></div></div><div id='d_Gc' class='de'><h1>Method <span class='n'>removeAnnotation</span></h1><div class='re'><code>removeAnnotation( self, name )</code></div><div class='ds'><pre>Removes the annotations with the given name</pre></div></div><div id='CL' class='cr'><div class='n'><a href='javascript:dS("CL");'>Pass</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("CL","DL");'><span class='special __bases__'>PassContext</span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("CL","EL");'><span class='special __init__'>constructor</span></a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("CL","FL");'>getHandler</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("CL","GL");'>getName</a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("CL","HL");'>annotate</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("CL","IL");'>filter</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("CL","JL");'>filterContext</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("CL","KL");'>findInContext</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("CL","LL");'>getClassAncestors</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("CL","ML");'>getClassParents</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("CL","NL");'>getCurrentClass</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("CL","OL");'>getCurrentClassAncestors</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("CL","PL");'>getCurrentClassParents</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("CL","QL");'>getCurrentClosure</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("CL","RL");'>getCurrentContext</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("CL","SL");'>getCurrentDataFlow</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("CL","TL");'>getCurrentElement</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("CL","UL");'>getCurrentFunction</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("CL","VL");'>getCurrentMethod</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("CL","WL");'>getCurrentModule</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("CL","XL");'>getCurrentProcess</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("CL","YL");'>getFactory</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("CL","ZL");'>getParentElement</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("CL","aM");'>getProgram</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("CL","bM");'>handle</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("CL","cM");'>hasParentElement</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("CL","dM");'>isIn</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("CL","eM");'>resolve</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("CL","fM");'>resolveAbsolute</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("CL","gM");'>resolveAbsoluteOrLocal</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("CL","hM");'>resolveLocalOrAbsolute</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("CL","iM");'>run</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("CL","jM");'>setEnvironment</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("CL","kM");'>setPass</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("CL","lM");'>walk</a></div></div><div class='t'>Values</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&bull;</span><a href='javascript:dO("CL","mM");'>HANDLES</a></div><div class='slot documented'><span
					class='prefix'>&bull;</span><a href='javascript:dO("CL","vE");'>NAME</a></div></div></div><div id='CC' class='cr'><div class='n'><a href='javascript:dS("CC");'>IValue</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("CC","DC");'><span class='special __bases__'>IElement, IEvaluable</span></a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("CC","EC");'>addAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("CC","FC");'>copy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("CC","GC");'>detach</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("CC","HC");'>getAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("CC","IC");'>getAnnotations</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("CC","JC");'>getDataFlow</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("CC","KC");'>getParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("CC","LC");'>getResultAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("CC","MC");'>hasAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("CC","NC");'>hasParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("CC","OC");'>removeAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("CC","PC");'>setAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("CC","QC");'>setParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("CC","RC");'>setResultAbstractType</a></div></div></div><div id='Cz' class='cr'><div class='n'><a href='javascript:dS("Cz");'>IRepetition</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("Cz","Dz");'><span class='special __bases__'>IOperation</span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Cz","Ez");'>getCondition</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Cz","Fz");'>getProcess</a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Cz","Gz");'>addAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Cz","Hz");'>addOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Cz","Iz");'>copy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Cz","Jz");'>detach</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Cz","Kz");'>getAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Cz","Lz");'>getAnnotations</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Cz","Mz");'>getDataFlow</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Cz","Nz");'>getOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Cz","Oz");'>getOpArguments</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Cz","Pz");'>getOpArgumentsInternalTypes</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Cz","Qz");'>getParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Cz","Rz");'>hasAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Cz","Sz");'>hasParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Cz","Tz");'>removeAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Cz","Uz");'>setAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Cz","Vz");'>setOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Cz","Wz");'>setParent</a></div></div><div class='t'>Values</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&bull;</span><a href='javascript:dO("Cz","Xz");'>ARGS</a></div></div></div><div id='d_xu' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IMatchOperation at 0x85d298c&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='iw' class='cr'><div class='n'><a href='javascript:dS("iw");'>IMutator</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("iw","jw");'><span class='special __bases__'>IAttributeMethod</span></a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("iw","kw");'>addAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("iw","lw");'>addOperation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("iw","mw");'>copy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("iw","nw");'>detach</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("iw","ow");'>endsWithTermination</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("iw","pw");'>getAbsoluteName</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("iw","qw");'>getAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("iw","rw");'>getAnnotations</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("iw","sw");'>getArguments</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("iw","tw");'>getDataFlow</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("iw","uw");'>getName</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("iw","vw");'>getOperations</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("iw","ww");'>getParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("iw","xw");'>getReturnTypeDescription</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("iw","yw");'>getSlot</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("iw","zw");'>getSlotNames</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("iw","Aw");'>getSlots</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("iw","Bw");'>hasAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("iw","Cw");'>hasExplicitTermination</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("iw","Dw");'>hasParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("iw","Ew");'>hasSlot</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("iw","Fw");'>isAbstract</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("iw","Gw");'>removeAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("iw","Hw");'>setAbstract</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("iw","Iw");'>setAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("iw","Jw");'>setArguments</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("iw","Kw");'>setParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("iw","Lw");'>setReturnTypeDescription</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("iw","Mw");'>setSlot</a></div></div></div><div id='io' class='cr'><div class='n'><a href='javascript:dS("io");'>IImportOperation</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("io","jo");'><span class='special __bases__'>IOperation</span></a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("io","ko");'>addAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("io","lo");'>addOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("io","mo");'>copy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("io","no");'>detach</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("io","oo");'>getAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("io","po");'>getAnnotations</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("io","qo");'>getDataFlow</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("io","ro");'>getOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("io","so");'>getOpArguments</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("io","to");'>getOpArgumentsInternalTypes</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("io","uo");'>getParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("io","vo");'>hasAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("io","wo");'>hasParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("io","xo");'>removeAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("io","yo");'>setAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("io","zo");'>setOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("io","Ao");'>setParent</a></div></div></div><div id='D' class='cr'><div class='n'><a href='javascript:dS("D");'>IAbstractClass</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("D","E");'><span class='special __bases__'>IClass, IAbstractable</span></a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("D","F");'>addAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("D","G");'>copy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("D","H");'>detach</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("D","I");'>getAbsoluteName</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("D","J");'>getAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("D","K");'>getAnnotations</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("D","L");'>getAttributes</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("D","M");'>getClassAttributes</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("D","N");'>getClassMethods</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("D","O");'>getConstructors</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("D","P");'>getDataFlow</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("D","Q");'>getDestructors</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("D","R");'>getInheritedSlots</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("D","S");'>getInstanceMethods</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("D","T");'>getMethods</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("D","U");'>getName</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("D","V");'>getOperations</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("D","W");'>getParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("D","X");'>getParentClassesRefs</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("D","Y");'>getSlot</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("D","Z");'>getSlotNames</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("D","ab");'>getSlots</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("D","bb");'>hasAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("D","cb");'>hasParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("D","db");'>hasSlot</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("D","eb");'>isAbstract</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("D","fb");'>removeAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("D","gb");'>setAbstract</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("D","hb");'>setAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("D","ib");'>setParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("D","jb");'>setParentClasses</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("D","kb");'>setSlot</a></div></div></div><div id='iH' class='cr'><div class='n'><a href='javascript:dS("iH");'>Process</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("iH","jH");'><span class='special __bases__'>Type</span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("iH","kH");'><span class='special __init__'>constructor</span></a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("iH","lH");'><span class='protected'>_ensureIntegrity</span></a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("iH","mH");'>add</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("iH","nH");'>arguments</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("iH","oH");'>asString</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("iH","pH");'>clone</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("iH","qH");'>elements</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("iH","rH");'>isLike</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("iH","sH");'>isSameAs</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("iH","tH");'>isSubtypeOf</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("iH","uH");'>peel</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("iH","vH");'>result</a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("iH","wH");'><span class='special __call__'>when invoked</span></a></div><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("iH","xH");'><span class='special __str__'>string conversion</span></a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("iH","yH");'>concreteType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("iH","zH");'>definedBy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("iH","AH");'>name</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("iH","BH");'>setConcreteType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("iH","CH");'>setName</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("iH","DH");'>subtype</a></div></div></div><div id='iE' class='cr'><div class='n'><a href='javascript:dS("iE");'>ModelException</a></div><div class='t'>Inhertied Values</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("iE","dE");'><span class='special __getitem__'>get item</span></a></div><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("iE","jE");'><span class='special __init__'>constructor</span></a></div><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("iE","eE");'><span class='special __repr__'>string repr</span></a></div><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("iE","fE");'><span class='special __str__'>string conversion</span></a></div><div class='slot documented'><span
					class='prefix'>&sdot;</span><a href='javascript:dO("iE","gE");'>args</a></div><div class='slot documented'><span
					class='prefix'>&sdot;</span><a href='javascript:dO("iE","hE");'>message</a></div></div></div><div id='Ve' class='cr'><div class='n'><a href='javascript:dS("Ve");'>IClass</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("Ve","We");'><span class='special __bases__'>IContext, IReferencable, IConstruct</span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Ve","Xe");'>getAttributes</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Ve","Ye");'>getClassAttributes</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Ve","Ze");'>getClassMethods</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Ve","af");'>getConstructors</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Ve","bf");'>getDestructors</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Ve","cf");'>getInheritedSlots</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Ve","df");'>getInstanceMethods</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Ve","ef");'>getMethods</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Ve","ff");'>getName</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Ve","gf");'>getOperations</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Ve","hf");'>getParentClassesRefs</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Ve","if");'>setParentClasses</a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Ve","jf");'>addAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Ve","kf");'>copy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Ve","lf");'>detach</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Ve","mf");'>getAbsoluteName</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Ve","nf");'>getAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Ve","of");'>getAnnotations</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Ve","pf");'>getDataFlow</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Ve","qf");'>getParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Ve","rf");'>getSlot</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Ve","sf");'>getSlotNames</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Ve","tf");'>getSlots</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Ve","uf");'>hasAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Ve","vf");'>hasParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Ve","wf");'>hasSlot</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Ve","xf");'>removeAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Ve","yf");'>setAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Ve","zf");'>setParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Ve","Af");'>setSlot</a></div></div></div><div id='d_bu' class='de'><h1>Class <span class='n'>IMatchOperation</span></h1><div class='re'></div><div class='ds'><pre>A match operation is the binding of an expression and a process.</pre></div></div><div id='d_bt' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type for this element</pre></div></div><div id='d_bw' class='de'><h1>Class <span class='n'>IModuleAttribute</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_bv' class='de'><h1>Method <span class='n'>getAbsoluteName</span></h1><div class='re'><code>getAbsoluteName( self )</code></div><div class='ds'><pre>Returns the absolute name for this element</pre></div></div><div id='d_bq' class='de'><h1>Class <span class='n'>IInstanciable</span></h1><div class='re'></div><div class='ds'><pre>Instanciable is a property of some elements that allows them to be
	instanciated. Conceptually, an instanciation could be considered as a
	specific kind of invocation.</pre></div></div><div id='d_bp' class='de'><h1>Method <span class='n'>getImportOrigin</span></h1><div class='re'><code>getImportOrigin( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_bs' class='de'><h1>Class <span class='n'>IInvocation</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_br' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><pre>Performs a deep clone of this element. Any mutation to the original won't
		change the copy.</pre></div></div><div id='d_by' class='de'><h1>Method <span class='n'>setValue</span></h1><div class='re'><code>setValue( self, v )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_bx' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><pre>Sets the abstract type for this element</pre></div></div><div id='d_bz' class='de'><h1>Method <span class='n'>removeAnnotation</span></h1><div class='re'><code>removeAnnotation( self, name )</code></div><div class='ds'><pre>Removes the annotations with the given name</pre></div></div><div id='d_be' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><pre>Tells if this element has a parent or not</pre></div></div><div id='d_bd' class='de'><h1>Method <span class='n'>getTypeDescription</span></h1><div class='re'><code>getTypeDescription( self )</code></div><div class='ds'><pre>Returns type information (constraints) that are associated to this
		argument.</pre></div></div><div id='d_bg' class='de'><h1>Method <span class='n'>hasAnnotation</span></h1><div class='re'><code>hasAnnotation( self, name )</code></div><div class='ds'><pre>Tells if the given element has an annotation with the given name</pre></div></div><div id='d_bf' class='de'><h1>Method <span class='n'>getDestructors</span></h1><div class='re'><code>getDestructors( self )</code></div><div class='ds'><pre>Returns the destructors for this class</pre></div></div><div id='d_bc' class='de'><h1>Method <span class='n'>getSlotNames</span></h1><div class='re'><code>getSlotNames( self )</code></div><div class='ds'><pre>Returns the list of slot names (in order) for this context</pre></div></div><div id='d_bb' class='de'><h1>Method <span class='n'>hasAnnotation</span></h1><div class='re'><code>hasAnnotation( self, name )</code></div><div class='ds'><pre>Tells if the given element has an annotation with the given name</pre></div></div><div id='d_bm' class='de'><h1>Method <span class='n'>getValue</span></h1><div class='re'><code>getValue( self )</code></div><div class='ds'><pre>Returns the termination return evaluable.</pre></div></div><div id='d_bl' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><pre>Sets this element parent</pre></div></div><div id='d_bo' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><pre>Tells if this element has a parent or not</pre></div></div><div id='d_bn' class='de'><h1>Method <span class='n'>addAnnotation</span></h1><div class='re'><code>addAnnotation( self, annotation )</code></div><div class='ds'><pre>Adds an annotation to this element</pre></div></div><div id='d_bi' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><pre>Returns the parent context for this context (if any)</pre></div></div><div id='d_bh' class='de'><h1>Method <span class='n'>addAnnotation</span></h1><div class='re'><code>addAnnotation( self, annotation )</code></div><div class='ds'><pre>Adds an annotation to this element</pre></div></div><div id='d_bk' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><pre>Returns this element parent</pre></div></div><div id='d_bj' class='de'><h1>Method <span class='n'>getAnnotations</span></h1><div class='re'><code>getAnnotations( self, name=None )</code></div><div class='ds'><pre>Gets all the annotation with the given name associated to this element
		or all annotations if no name is specified.</pre></div></div><div id='d_bE' class='de'><h1>Class <span class='n'>ModelBadArgument</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_bD' class='de'><h1>Method <span class='n'>_list</span></h1><div class='re'><code>_list( self, *args )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_bG' class='de'><h1>Method <span class='n'>result</span></h1><div class='re'><code>result( self )</code></div><div class='ds'><pre>Returns the result for this type. This is usually just the type
		itself, except for processes types.</pre></div></div><div id='d_bF' class='de'><h1>Method <span class='n'>__call__</span></h1><div class='re'><code>__call__( self )</code></div><div class='ds'><pre>A type instance can be used as a class to construct a new type, which
		will be cloned from the current type.</pre></div></div><div id='d_bA' class='de'><h1>Method <span class='n'>getReference</span></h1><div class='re'><code>getReference( self )</code></div><div class='ds'><pre>Returns the reference to be resolved.</pre></div></div><div id='d_bC' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><pre>Sets the given argument of this operation, by argument index.</pre></div></div><div id='d_bB' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><pre>Returns the ith arguments to this operation.</pre></div></div><div id='d_bM' class='de'><h1>Method <span class='n'>handle</span></h1><div class='re'><code>handle( self, element )</code></div><div class='ds'><pre>Handles a sungle element, without recursing through its children</pre></div></div><div id='d_bL' class='de'><h1>Method <span class='n'>getCurrentClassParents</span></h1><div class='re'><code>getCurrentClassParents( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_bN' class='de'><h1>Method <span class='n'>getClassAncestors</span></h1><div class='re'><code>getClassAncestors( self, theClass=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_bI' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.typecast.Type at 0x40315c5c&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_bH' class='de'><h1>Method <span class='n'>concreteType</span></h1><div class='re'><code>concreteType( self )</code></div><div class='ds'><pre>Returns the _concrete type_ for this abstract type.</pre></div></div><div id='d_bK' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.passes.Pass at 0x857b20c&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_bJ' class='de'><h1>Function <span class='n'>Sequence_make</span></h1><div class='re'><code>Sequence_make( args, sequenceclass=<class lambdafactory.typecast.Sequence at 0x40315d4c> )</code></div><div class='ds'><pre>Tries to make a sequence from the given argumnents. This follows the
	following rules:<br />		len(args) == 0         -&gt; Nothing
		len(args) == 1         -&gt; args[1]
		otherwise              -&gt; (args....)
	</pre></div></div><div id='d_FI' class='de'><h1>Method <span class='n'>setName</span></h1><div class='re'><code>setName( self, name )</code></div><div class='ds'><pre>Sets the name of this type</pre></div></div><div id='d_FH' class='de'><h1>Class <span class='n'>Sequence</span></h1><div class='re'></div><div class='ds'><pre>A sequence is simply an ordered set of types.</pre></div></div><div id='d_FK' class='de'><h1>Method <span class='n'>resolveAbsolute</span></h1><div class='re'><code>resolveAbsolute( self, referenceOrName )</code></div><div class='ds'><pre>Resolves the given reference or string expressed in absolute style
		('.'-separated list of names), starting from the root dataflow (the program
		dataflow).</pre></div></div><div id='HI' class='cr'><div class='n'><a href='javascript:dS("HI");'>Unresolved</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("HI","II");'><span class='special __bases__'>Symbolic</span></a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("HI","JI");'><span class='special __call__'>when invoked</span></a></div><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("HI","KI");'><span class='special __init__'>constructor</span></a></div><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("HI","LI");'><span class='special __str__'>string conversion</span></a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("HI","MI");'>asString</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("HI","NI");'>clone</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("HI","OI");'>concreteType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("HI","PI");'>definedBy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("HI","QI");'>isLike</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("HI","RI");'>isSameAs</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("HI","SI");'>isSubtypeOf</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("HI","TI");'>name</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("HI","UI");'>result</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("HI","VI");'>setConcreteType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("HI","WI");'>setName</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("HI","XI");'>subtype</a></div></div></div><div id='d_FM' class='de'><h1>Method <span class='n'>getCurrentProcess</span></h1><div class='re'><code>getCurrentProcess( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_FL' class='de'><h1>Method <span class='n'>getHandler</span></h1><div class='re'><code>getHandler( self, element )</code></div><div class='ds'><pre>Tells if the pass handles the given element. This basically iterates
		on the 'handles' property values (which are interfaces), when one
		interface matches the given 'element', then the corresponding 'onXXX'
		method is invoked, where 'XXX' is the interface
		name (without the leading 'I').</pre></div></div><div id='d_FN' class='de'><h1>str</h1><div class='re'><code>'AsynchronousInvocationsExpansion'</code></div><div class='ds'><pre>str(object) -&gt; string<br />Return a nice string representation of the object.
If the argument is a string, the return value is the same object.</pre></div></div><div id='d_FA' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><pre>Returns the ith arguments to this operation.</pre></div></div><div id='d_FC' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><pre>Performs a deep clone of this element. Any mutation to the original won't
		change the copy.</pre></div></div><div id='d_FB' class='de'><h1>Method <span class='n'>removeAnnotation</span></h1><div class='re'><code>removeAnnotation( self, name )</code></div><div class='ds'><pre>Removes the annotations with the given name</pre></div></div><div id='d_FE' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.modeltypes.TypeCollection at 0x40315adc&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_FD' class='de'><h1>Method <span class='n'>doc</span></h1><div class='re'><code>doc( self, content )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_FG' class='de'><h1>Method <span class='n'>subtype</span></h1><div class='re'><code>subtype( self, name )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='HE' class='cr'><div class='n'><a href='javascript:dS("HE");'>Data</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("HE","IE");'><span class='special __bases__'>TypeCollection</span></a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("HE","JE");'>getType</a></div></div></div><div id='d_Fy' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><pre>Sets the abstract type for this element</pre></div></div><div id='d_Fx' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type for this element</pre></div></div><div id='Hy' class='cr'><div class='n'><a href='javascript:dS("Hy");'>IProgram</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("Hy","Iy");'><span class='special __bases__'>IContext</span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Hy","Jy");'>addModule</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Hy","Ky");'>getFactory</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Hy","Ly");'>getModule</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Hy","My");'>getModules</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Hy","Ny");'>setFactory</a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Hy","Oy");'>addAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Hy","Py");'>copy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Hy","Qy");'>detach</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Hy","Ry");'>getAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Hy","Sy");'>getAnnotations</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Hy","Ty");'>getDataFlow</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Hy","Uy");'>getParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Hy","Vy");'>getSlot</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Hy","Wy");'>getSlotNames</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Hy","Xy");'>getSlots</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Hy","Yy");'>hasAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Hy","Zy");'>hasParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Hy","az");'>hasSlot</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Hy","bz");'>removeAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Hy","cz");'>setAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Hy","dz");'>setParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Hy","ez");'>setSlot</a></div></div></div><div id='d_Fq' class='de'><h1>Method <span class='n'>setProcess</span></h1><div class='re'><code>setProcess( self, process )</code></div><div class='ds'><pre>Sets the process from which interruptions will be intercepted.</pre></div></div><div id='d_Fp' class='de'><h1>Method <span class='n'>getAnnotations</span></h1><div class='re'><code>getAnnotations( self, name=None )</code></div><div class='ds'><pre>Gets all the annotation with the given name associated to this element
		or all annotations if no name is specified.</pre></div></div><div id='d_Fs' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><pre>Detaches the element from its parent (in case it was already attached).
		This should return this element, and set the parent to None.</pre></div></div><div id='d_Fr' class='de'><h1>Method <span class='n'>setSlot</span></h1><div class='re'><code>setSlot( self, name, evaluable )</code></div><div class='ds'><pre>Binds the given evaluable to the named slot. If there is already a slot
		with the same name, then 'getSlot(name)' should return the evaluable
		given as parameter.<br />		In the default implementation, setSlot preserves the ''history'' of
		added slots, and will always return the latest one.</pre></div></div><div id='d_Fu' class='de'><h1>Method <span class='n'>getAnnotations</span></h1><div class='re'><code>getAnnotations( self, name=None )</code></div><div class='ds'><pre>Gets all the annotation with the given name associated to this element
		or all annotations if no name is specified.</pre></div></div><div id='d_Ft' class='de'><h1>Method <span class='n'>getExpression</span></h1><div class='re'><code>getExpression( self )</code></div><div class='ds'><pre>Returns the process that will be executed if the rule matches.</pre></div></div><div id='d_Fw' class='de'><h1>Method <span class='n'>isAbstract</span></h1><div class='re'><code>isAbstract( self )</code></div><div class='ds'><pre>Tells wether the given abstractable is abstract or not.</pre></div></div><div id='d_Fv' class='de'><h1>Method <span class='n'>isImported</span></h1><div class='re'><code>isImported( self )</code></div><div class='ds'><pre>A stub module is a module that does not have any bound implementation.
		Stub modules are typically used by Programs when adding a module such
		as 'a.b.c' where 'a' and 'a.b' will be stub modules unless they were
		or will be imported.</pre></div></div><div id='d_Fi' class='de'><h1>Method <span class='n'>getSlots</span></h1><div class='re'><code>getSlots( self )</code></div><div class='ds'><pre>Returns the list of slots defined for this dataflow.</pre></div></div><div id='d_Fh' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><pre>Returns the dataflow accessible/bound to this element</pre></div></div><div id='d_Fk' class='de'><h1>Class <span class='n'>IEmbedTemplate</span></h1><div class='re'></div><div class='ds'><pre>The 'EmbedTemplate' is embedded ('Embed') that contains template
	expressions. It's up to the model writer to know how to expand the template
	to convert it to the target language.</pre></div></div><div id='d_Fj' class='de'><h1>Method <span class='n'>getAnnotations</span></h1><div class='re'><code>getAnnotations( self, name=None )</code></div><div class='ds'><pre>Gets all the annotation with the given name associated to this element
		or all annotations if no name is specified.</pre></div></div><div id='d_Fm' class='de'><h1>Method <span class='n'>getAnnotations</span></h1><div class='re'><code>getAnnotations( self, name=None )</code></div><div class='ds'><pre>Gets all the annotation with the given name associated to this element
		or all annotations if no name is specified.</pre></div></div><div id='d_Fl' class='de'><h1>Method <span class='n'>getEvaluable</span></h1><div class='re'><code>getEvaluable( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Fo' class='de'><h1>Method <span class='n'>getImportedElement</span></h1><div class='re'><code>getImportedElement( self )</code></div><div class='ds'><pre>Returns a reference or a resolution that will allow to get the
		imported element.</pre></div></div><div id='d_Fn' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><pre>Tells if this element has a parent or not</pre></div></div><div id='d_Fc' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><pre>Tells if this element has a parent or not</pre></div></div><div id='d_Fb' class='de'><h1>Method <span class='n'>removeAnnotation</span></h1><div class='re'><code>removeAnnotation( self, name )</code></div><div class='ds'><pre>Removes the annotations with the given name</pre></div></div><div id='d_Fe' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><pre>Performs a deep clone of this element. Any mutation to the original won't
		change the copy.</pre></div></div><div id='d_Fd' class='de'><h1>Method <span class='n'>getTypeDescription</span></h1><div class='re'><code>getTypeDescription( self )</code></div><div class='ds'><pre>Returns type information (constraints) that are associated to this
		argument.</pre></div></div><div id='d_Fg' class='de'><h1>Method <span class='n'>hasAnnotation</span></h1><div class='re'><code>hasAnnotation( self, name )</code></div><div class='ds'><pre>Tells if the given element has an annotation with the given name</pre></div></div><div id='d_Ff' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><pre>Returns the local name for this referencable element</pre></div></div><div id='d_tC' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><pre>Returns the *internal types* for this operations arguments. This is
		typically the list of interfaces or @protocols that the arguments must
		comply to.</pre></div></div><div id='d_tB' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.ILiteral at 0x85d205c&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_tA' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.IReferencable at 0x85c4efc&gt;, &lt;class lambdafactory.interfaces.IEvaluable at 0x85c4f2c&gt;]</code></div><div class='ds'><pre>list() -&gt; new list
list(sequence) -&gt; new list initialized from sequence's items</pre></div></div><div id='d_tG' class='de'><h1>Method <span class='n'>concreteType</span></h1><div class='re'><code>concreteType( self )</code></div><div class='ds'><pre>Returns the _concrete type_ for this abstract type.</pre></div></div><div id='d_tF' class='de'><h1>Method <span class='n'>subtype</span></h1><div class='re'><code>subtype( self, name )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_tE' class='de'><h1>Method <span class='n'>write</span></h1><div class='re'><code>write( self, element )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_tD' class='de'><h1>Method <span class='n'>createClassMethod</span></h1><div class='re'><code>createClassMethod( self, name, arguments=() )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_tK' class='de'><h1>Method <span class='n'>getCurrentMethod</span></h1><div class='re'><code>getCurrentMethod( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_tJ' class='de'><h1>Method <span class='n'>filterContext</span></h1><div class='re'><code>filterContext( self, interface )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_tI' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self, name=None )</code></div><div class='ds'><pre>Creates a new anonymous type</pre></div></div><div id='d_tH' class='de'><h1>Method <span class='n'>isSubtypeOf</span></h1><div class='re'><code>isSubtypeOf( self, otherType )</code></div><div class='ds'><pre>The other type is like this one if the other is a sequence with the
		same length and that all elements are like the corresponding elements of
		this sequence.</pre></div></div><div id='d_tN' class='de'><h1>Method <span class='n'>handle</span></h1><div class='re'><code>handle( self, element )</code></div><div class='ds'><pre>Handles a sungle element, without recursing through its children</pre></div></div><div id='d_tM' class='de'><h1>Method <span class='n'>getClassAncestors</span></h1><div class='re'><code>getClassAncestors( self, theClass=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_tL' class='de'><h1>Method <span class='n'>resolveAbsolute</span></h1><div class='re'><code>resolveAbsolute( self, referenceOrName )</code></div><div class='ds'><pre>Resolves the given reference or string expressed in absolute style
		('.'-separated list of names), starting from the root dataflow (the program
		dataflow).</pre></div></div><div id='d_tc' class='de'><h1>Method <span class='n'>addAnnotation</span></h1><div class='re'><code>addAnnotation( self, annotation )</code></div><div class='ds'><pre>Adds an annotation to this element</pre></div></div><div id='d_tb' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><pre>Performs a deep clone of this element. Any mutation to the original won't
		change the copy.</pre></div></div><div id='d_tg' class='de'><h1>Method <span class='n'>addAnnotation</span></h1><div class='re'><code>addAnnotation( self, annotation )</code></div><div class='ds'><pre>Adds an annotation to this element</pre></div></div><div id='d_tf' class='de'><h1>Method <span class='n'>getSlots</span></h1><div class='re'><code>getSlots( self )</code></div><div class='ds'><pre>Returns (key, evaluable) pairs representing the slots within this
		context. In the case of context that may inherits slots, this only
		returns the slots that are owned by the context (ie. it does not
		include inherited slots)</pre></div></div><div id='d_te' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><pre>Returns the dataflow accessible/bound to this element</pre></div></div><div id='d_td' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><pre>Tells if this element has a parent or not</pre></div></div><div id='d_tk' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><pre>Returns the dataflow accessible/bound to this element</pre></div></div><div id='d_tj' class='de'><h1>Method <span class='n'>setArguments</span></h1><div class='re'><code>setArguments( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_ti' class='de'><h1>Method <span class='n'>addChild</span></h1><div class='re'><code>addChild( self, child )</code></div><div class='ds'><pre>Adds the given dataflow as a child of this dataflow.</pre></div></div><div id='d_th' class='de'><h1>Class <span class='n'>IConstruct</span></h1><div class='re'></div><div class='ds'><pre>A construct is a high level programming element that allows to create a
	structure and hierarchy in the program.</pre></div></div><div id='d_to' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><pre>Returns the *internal types* for this operations arguments. This is
		typically the list of interfaces or @protocols that the arguments must
		comply to.</pre></div></div><div id='d_tn' class='de'><h1>Method <span class='n'>addAnnotation</span></h1><div class='re'><code>addAnnotation( self, annotation )</code></div><div class='ds'><pre>Adds an annotation to this element</pre></div></div><div id='d_tm' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.IEvaluable at 0x85c4f2c&gt;]</code></div><div class='ds'><pre>list() -&gt; new list
list(sequence) -&gt; new list initialized from sequence's items</pre></div></div><div id='d_tl' class='de'><h1>Method <span class='n'>hasAnnotation</span></h1><div class='re'><code>hasAnnotation( self, name )</code></div><div class='ds'><pre>Tells if the given element has an annotation with the given name</pre></div></div><div id='d_ts' class='de'><h1>Method <span class='n'>removeAnnotation</span></h1><div class='re'><code>removeAnnotation( self, name )</code></div><div class='ds'><pre>Removes the annotations with the given name</pre></div></div><div id='d_tr' class='de'><h1>Method <span class='n'>getSlot</span></h1><div class='re'><code>getSlot( self, name )</code></div><div class='ds'><pre>Returns the given evaluable bound to named slot.</pre></div></div><div id='d_tq' class='de'><h1>Method <span class='n'>removeAnnotation</span></h1><div class='re'><code>removeAnnotation( self, name )</code></div><div class='ds'><pre>Removes the annotations with the given name</pre></div></div><div id='d_tp' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><pre>Sets this element parent</pre></div></div><div id='d_tw' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><pre>Returns the dataflow accessible/bound to this element</pre></div></div><div id='d_tv' class='de'><h1>Method <span class='n'>setAbstract</span></h1><div class='re'><code>setAbstract( self, isAbstract )</code></div><div class='ds'><pre>Sets wether the given abstractable is abstract or not.</pre></div></div><div id='d_tu' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><pre>Sets the abstract type for this element</pre></div></div><div id='d_tt' class='de'><h1>Method <span class='n'>getAnnotations</span></h1><div class='re'><code>getAnnotations( self, name=None )</code></div><div class='ds'><pre>Gets all the annotation with the given name associated to this element
		or all annotations if no name is specified.</pre></div></div><div id='d_tz' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><pre>Returns the local name for this referencable element</pre></div></div><div id='d_ty' class='de'><h1>Method <span class='n'>addOperation</span></h1><div class='re'><code>addOperation( self, operation )</code></div><div class='ds'><pre>Adds the given operation as a child of this process.</pre></div></div><div id='d_tx' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><pre>Tells if this element has a parent or not</pre></div></div><div id='d_Hw' class='de'><h1>Method <span class='n'>setAbstract</span></h1><div class='re'><code>setAbstract( self, isAbstract )</code></div><div class='ds'><pre>Sets wether the given abstractable is abstract or not.</pre></div></div><div id='d_Hv' class='de'><h1>Method <span class='n'>setImported</span></h1><div class='re'><code>setImported( self, value=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Hu' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><pre>Returns the ith arguments to this operation.</pre></div></div><div id='d_Ht' class='de'><h1>Method <span class='n'>addAnnotation</span></h1><div class='re'><code>addAnnotation( self, annotation )</code></div><div class='ds'><pre>Adds an annotation to this element</pre></div></div><div id='d_Hs' class='de'><h1>Method <span class='n'>getAnnotations</span></h1><div class='re'><code>getAnnotations( self, name=None )</code></div><div class='ds'><pre>Gets all the annotation with the given name associated to this element
		or all annotations if no name is specified.</pre></div></div><div id='d_Hr' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IOperation at 0x85d268c&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_Hq' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><pre>Adds an argument to this operation. This should do checking of
		arguments (by expected internal type and number).</pre></div></div><div id='d_Hp' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><pre>Returns the dataflow accessible/bound to this element</pre></div></div><div id='d_Hz' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><pre>Adds an argument to this operation. This should do checking of
		arguments (by expected internal type and number).</pre></div></div><div id='d_Hy' class='de'><h1>Class <span class='n'>IProgram</span></h1><div class='re'></div><div class='ds'><pre>The program is the core context and entry point for almost every
	operation offered by LambdaFactory.</pre></div></div><div id='d_Hx' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><pre>Returns the dataflow accessible/bound to this element</pre></div></div><div id='d_Hg' class='de'><h1>Method <span class='n'>hasSlot</span></h1><div class='re'><code>hasSlot( self, name )</code></div><div class='ds'><pre>Tells if the context has a slot with the given name.</pre></div></div><div id='d_Hf' class='de'><h1>Method <span class='n'>setDefaultValue</span></h1><div class='re'><code>setDefaultValue( self )</code></div><div class='ds'><pre>Sets the @methodault value for this attribute</pre></div></div><div id='d_He' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type for this element</pre></div></div><div id='d_Hd' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IMethod at 0x85d250c&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_Hc' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><pre>Sets the abstract type for this element</pre></div></div><div id='d_Hb' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><pre>Sets the given argument of this operation, by argument index.</pre></div></div><div id='d_Ho' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><pre>Adds an argument to this operation. This should do checking of
		arguments (by expected internal type and number).</pre></div></div><div id='d_Hn' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><pre>Sets the abstract type for this element</pre></div></div><div id='d_Hm' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><pre>Returns the dataflow accessible/bound to this element</pre></div></div><div id='d_Hl' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><pre>Adds an argument to this operation. This should do checking of
		arguments (by expected internal type and number).</pre></div></div><div id='d_Hk' class='de'><h1>Method <span class='n'>addAnnotation</span></h1><div class='re'><code>addAnnotation( self, annotation )</code></div><div class='ds'><pre>Adds an annotation to this element</pre></div></div><div id='d_Hj' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><pre>Returns this element parent</pre></div></div><div id='d_Hi' class='de'><h1>Method <span class='n'>hasSlot</span></h1><div class='re'><code>hasSlot( self, name )</code></div><div class='ds'><pre>Tells if this dataflow defines slot with the given name.</pre></div></div><div id='d_Hh' class='de'><h1>Method <span class='n'>getOperations</span></h1><div class='re'><code>getOperations( self )</code></div><div class='ds'><pre>Returns the list of operations in this process.</pre></div></div><div id='d_HG' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_HF' class='de'><h1>Method <span class='n'>definedBy</span></h1><div class='re'><code>definedBy( self, definition=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_HE' class='de'><h1>Class <span class='n'>Data</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_HD' class='de'><h1>Method <span class='n'>embedTemplate</span></h1><div class='re'><code>embedTemplate( self, lang, code )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_HC' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type for this element</pre></div></div><div id='d_HB' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><pre>Sets this element parent</pre></div></div><div id='d_HA' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><pre>Returns the *internal types* for this operations arguments. This is
		typically the list of interfaces or @protocols that the arguments must
		comply to.</pre></div></div><div id='HN' class='cr'><div class='n'><a href='javascript:dS("HN");'>Reporter</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("HN","c");'><span class='special __bases__'><i>Base class</i></span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("HN","IN");'><span class='special __init__'>constructor</span></a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("HN","JN");'>dedent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("HN","KN");'>echoError</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("HN","LN");'>echoWarning</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("HN","MN");'>error</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("HN","NN");'>indent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("HN","ON");'>info</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("HN","PN");'>isDone</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("HN","QN");'>onError</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("HN","RN");'>onWarning</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("HN","SN");'>warning</a></div></div></div><div id='d_HM' class='de'><h1>Method <span class='n'>getParentElement</span></h1><div class='re'><code>getParentElement( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_HL' class='de'><h1>Method <span class='n'>annotate</span></h1><div class='re'><code>annotate( self, value, name, content=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_HK' class='de'><h1>Method <span class='n'>resolveLocalOrAbsolute</span></h1><div class='re'><code>resolveLocalOrAbsolute( self, referenceOrName, contextOrDataFlow=None )</code></div><div class='ds'><pre>Tries a local resolution first, then will look in the program scope if
		it fails.</pre></div></div><div id='d_HJ' class='de'><h1>Method <span class='n'>getCurrentProcess</span></h1><div class='re'><code>getCurrentProcess( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_HI' class='de'><h1>Class <span class='n'>Unresolved</span></h1><div class='re'></div><div class='ds'><pre>Unresolved types are temporary types that can be resolved later
	when necessary.</pre></div></div><div id='d_HH' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self, *args )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='nM' class='cr'><div class='n'><a href='javascript:dS("nM");'>PassContext</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("nM","c");'><span class='special __bases__'><i>Base class</i></span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("nM","oM");'><span class='special __init__'>constructor</span></a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("nM","pM");'>annotate</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("nM","qM");'>filter</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("nM","rM");'>filterContext</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("nM","sM");'>findInContext</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("nM","tM");'>getClassAncestors</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("nM","uM");'>getClassParents</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("nM","vM");'>getCurrentClass</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("nM","wM");'>getCurrentClassAncestors</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("nM","xM");'>getCurrentClassParents</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("nM","yM");'>getCurrentClosure</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("nM","zM");'>getCurrentContext</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("nM","AM");'>getCurrentDataFlow</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("nM","BM");'>getCurrentElement</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("nM","CM");'>getCurrentFunction</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("nM","DM");'>getCurrentMethod</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("nM","EM");'>getCurrentModule</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("nM","FM");'>getCurrentProcess</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("nM","GM");'>getFactory</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("nM","HM");'>getParentElement</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("nM","IM");'>getProgram</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("nM","JM");'>handle</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("nM","KM");'>hasParentElement</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("nM","LM");'>isIn</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("nM","MM");'>resolve</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("nM","NM");'>resolveAbsolute</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("nM","OM");'>resolveAbsoluteOrLocal</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("nM","PM");'>resolveLocalOrAbsolute</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("nM","QM");'>run</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("nM","RM");'>setEnvironment</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("nM","SM");'>setPass</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("nM","TM");'>walk</a></div></div></div><div id='nB' class='cr'><div class='n'><a href='javascript:dS("nB");'>ISlot</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("nB","oB");'><span class='special __bases__'>IReferencable</span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("nB","pB");'>getTypeDescription</a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("nB","qB");'>getAbsoluteName</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("nB","rB");'>getName</a></div></div></div><div id='ng' class='cr'><div class='n'><a href='javascript:dS("ng");'>IClosure</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("ng","og");'><span class='special __bases__'>IProcess, IContext</span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ng","pg");'>getArguments</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ng","qg");'>getReturnTypeDescription</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ng","rg");'>setArguments</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ng","sg");'>setReturnTypeDescription</a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ng","tg");'>addAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ng","ug");'>addOperation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ng","vg");'>copy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ng","wg");'>detach</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ng","xg");'>getAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ng","yg");'>getAnnotations</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ng","zg");'>getDataFlow</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ng","Ag");'>getOperations</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ng","Bg");'>getParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ng","Cg");'>getSlot</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ng","Dg");'>getSlotNames</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ng","Eg");'>getSlots</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ng","Fg");'>hasAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ng","Gg");'>hasParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ng","Hg");'>hasSlot</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ng","Ig");'>removeAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ng","Jg");'>setAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ng","Kg");'>setParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ng","Lg");'>setSlot</a></div></div></div><div id='d_FF' class='de'><h1>Method <span class='n'>clone</span></h1><div class='re'><code>clone( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_ZM' class='de'><h1>Method <span class='n'>filterContext</span></h1><div class='re'><code>filterContext( self, interface )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_ZL' class='de'><h1>Method <span class='n'>getParentElement</span></h1><div class='re'><code>getParentElement( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_ZI' class='de'><h1>Function <span class='n'>Interface</span></h1><div class='re'><code>Interface( Context )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_ZH' class='de'><h1>Method <span class='n'>subtype</span></h1><div class='re'><code>subtype( self, name )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_ZK' class='de'><h1>Method <span class='n'>getCurrentClass</span></h1><div class='re'><code>getCurrentClass( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_ZJ' class='de'><h1>str</h1><div class='re'><code>'Documentation'</code></div><div class='ds'><pre>str(object) -&gt; string<br />Return a nice string representation of the object.
If the argument is a string, the return value is the same object.</pre></div></div><div id='d_ZE' class='de'><h1>Class <span class='n'>Arguments</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_ZD' class='de'><h1>Method <span class='n'>select</span></h1><div class='re'><code>select( self, *rules )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_ZG' class='de'><h1>Method <span class='n'>__call__</span></h1><div class='re'><code>__call__( self )</code></div><div class='ds'><pre>A type instance can be used as a class to construct a new type, which
		will be cloned from the current type.</pre></div></div><div id='d_ZF' class='de'><h1>Method <span class='n'>definedBy</span></h1><div class='re'><code>definedBy( self, definition=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_ZA' class='de'><h1>Method <span class='n'>getAnnotations</span></h1><div class='re'><code>getAnnotations( self, name=None )</code></div><div class='ds'><pre>Gets all the annotation with the given name associated to this element
		or all annotations if no name is specified.</pre></div></div><div id='d_ZC' class='de'><h1>Method <span class='n'>_ensureParam</span></h1><div class='re'><code>_ensureParam( self, value )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_ZB' class='de'><h1>Method <span class='n'>removeAnnotation</span></h1><div class='re'><code>removeAnnotation( self, name )</code></div><div class='ds'><pre>Removes the annotations with the given name</pre></div></div><div id='d_Fz' class='de'><h1>Method <span class='n'>getProcess</span></h1><div class='re'><code>getProcess( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Zm' class='de'><h1>Class <span class='n'>IGroup</span></h1><div class='re'></div><div class='ds'><pre>A block is a group of operations that share a common aspect. Groups
	are more likely to be used by program passes to further structure the
	program.<br />	Groups should generally not have their own context, as opposed to blocks
	which generally have a context of their own.</pre></div></div><div id='d_Zl' class='de'><h1>Class <span class='n'>IExcept</span></h1><div class='re'></div><div class='ds'><pre>An interruption that raises some value</pre></div></div><div id='d_Zo' class='de'><h1>Class <span class='n'>IImportSymbolsOperation</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Zn' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><pre>Returns this element parent</pre></div></div><div id='d_Zi' class='de'><h1>Method <span class='n'>getAbsoluteName</span></h1><div class='re'><code>getAbsoluteName( self )</code></div><div class='ds'><pre>Returns the absolute name for this element</pre></div></div><div id='d_Zh' class='de'><h1>Class <span class='n'>IContext</span></h1><div class='re'></div><div class='ds'><pre>A context is an element that has slots, which bind evaluable elements
	(aka values) to names. Slots should be ordered, preserving the order in
	which they were added.</pre></div></div><div id='d_Zk' class='de'><h1>Method <span class='n'>setLanguage</span></h1><div class='re'><code>setLanguage( self, language )</code></div><div class='ds'><pre>Sets the language in which the emebedded code is written.</pre></div></div><div id='d_Zj' class='de'><h1>Method <span class='n'>getAnnotations</span></h1><div class='re'><code>getAnnotations( self, name=None )</code></div><div class='ds'><pre>Gets all the annotation with the given name associated to this element
		or all annotations if no name is specified.</pre></div></div><div id='d_Ze' class='de'><h1>Method <span class='n'>getClassMethods</span></h1><div class='re'><code>getClassMethods( self )</code></div><div class='ds'><pre>Returns the class method defined within this class.</pre></div></div><div id='d_Zd' class='de'><h1>Method <span class='n'>hasAnnotation</span></h1><div class='re'><code>hasAnnotation( self, name )</code></div><div class='ds'><pre>Tells if the given element has an annotation with the given name</pre></div></div><div id='d_Zg' class='de'><h1>Method <span class='n'>setOperator</span></h1><div class='re'><code>setOperator( self, operator )</code></div><div class='ds'><pre>Sets the operator for this computation</pre></div></div><div id='d_Zf' class='de'><h1>Method <span class='n'>getSlotNames</span></h1><div class='re'><code>getSlotNames( self )</code></div><div class='ds'><pre>Returns the list of slot names (in order) for this context</pre></div></div><div id='d_Zc' class='de'><h1>Method <span class='n'>getAbsoluteName</span></h1><div class='re'><code>getAbsoluteName( self )</code></div><div class='ds'><pre>Returns the absolute name for this element</pre></div></div><div id='d_Zb' class='de'><h1>Method <span class='n'>getReturnTypeDescription</span></h1><div class='re'><code>getReturnTypeDescription( self )</code></div><div class='ds'><pre>Returns the return type description for this closure, if any</pre></div></div><div id='d_Zy' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><pre>Tells if this element has a parent or not</pre></div></div><div id='d_Zx' class='de'><h1>Method <span class='n'>setAsMap</span></h1><div class='re'><code>setAsMap( self, v=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Zz' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IOperation at 0x85d268c&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_Zu' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><pre>Detaches the element from its parent (in case it was already attached).
		This should return this element, and set the parent to None.</pre></div></div><div id='d_Zt' class='de'><h1>Method <span class='n'>setPredicate</span></h1><div class='re'><code>setPredicate( self, v )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Zw' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><pre>Tells if this element has a parent or not</pre></div></div><div id='d_Zv' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, context )</code></div><div class='ds'><pre>Sets the parent context for this context.</pre></div></div><div id='d_Zq' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IAbstractClass at 0x85d235c&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_Zp' class='de'><h1>Method <span class='n'>setReturnTypeDescription</span></h1><div class='re'><code>setReturnTypeDescription( self, description )</code></div><div class='ds'><pre>Sets the return type description for this closure, if any</pre></div></div><div id='d_Zs' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><pre>Performs a deep clone of this element. Any mutation to the original won't
		change the copy.</pre></div></div><div id='d_Zr' class='de'><h1>Class <span class='n'>IInvocable</span></h1><div class='re'></div><div class='ds'><pre>An invocable can be used in an invocation operation.</pre></div></div><div id='d_ep' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><pre>Adds an argument to this operation. This should do checking of
		arguments (by expected internal type and number).</pre></div></div><div id='d_eq' class='de'><h1>Method <span class='n'>getArguments</span></h1><div class='re'><code>getArguments( self )</code></div><div class='ds'><pre>Returns evaluable arguments.</pre></div></div><div id='d_er' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type for this element</pre></div></div><div id='d_es' class='de'><h1>Method <span class='n'>getTarget</span></h1><div class='re'><code>getTarget( self )</code></div><div class='ds'><pre>Returns the invocation target reference.</pre></div></div><div id='d_et' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><pre>Returns this element parent</pre></div></div><div id='d_eu' class='de'><h1>Method <span class='n'>setPredicate</span></h1><div class='re'><code>setPredicate( self, v )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_ev' class='de'><h1>Method <span class='n'>getArguments</span></h1><div class='re'><code>getArguments( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_ew' class='de'><h1>Method <span class='n'>getDefaultValue</span></h1><div class='re'><code>getDefaultValue( self )</code></div><div class='ds'><pre>Gets the @methodault value for this attribute</pre></div></div><div id='d_ex' class='de'><h1>Class <span class='n'>IOperation</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_ey' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><pre>Detaches the element from its parent (in case it was already attached).
		This should return this element, and set the parent to None.</pre></div></div><div id='d_ez' class='de'><h1>Method <span class='n'>setSlot</span></h1><div class='re'><code>setSlot( self, name, evaluable )</code></div><div class='ds'><pre>Binds the given evaluable to the named slot. If there is already a slot
		with the same name, then 'getSlot(name)' should return the evaluable
		given as parameter.<br />		In the default implementation, setSlot preserves the ''history'' of
		added slots, and will always return the latest one.</pre></div></div><div id='d_eb' class='de'><h1>Method <span class='n'>isAbstract</span></h1><div class='re'><code>isAbstract( self )</code></div><div class='ds'><pre>Tells wether the given abstractable is abstract or not.</pre></div></div><div id='d_ec' class='de'><h1>Method <span class='n'>hasExplicitTermination</span></h1><div class='re'><code>hasExplicitTermination( self )</code></div><div class='ds'><pre>Returns true if this function has an operation with a termination,
		otherwise return false.</pre></div></div><div id='d_ed' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IOperation at 0x85d268c&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_ee' class='de'><h1>Method <span class='n'>removeAnnotation</span></h1><div class='re'><code>removeAnnotation( self, name )</code></div><div class='ds'><pre>Removes the annotations with the given name</pre></div></div><div id='d_ef' class='de'><h1>Method <span class='n'>getMethods</span></h1><div class='re'><code>getMethods( self )</code></div><div class='ds'><pre>Returns the methods defined within this class.</pre></div></div><div id='d_eg' class='de'><h1>Method <span class='n'>hasSlot</span></h1><div class='re'><code>hasSlot( self, name )</code></div><div class='ds'><pre>Tells if the context has a slot with the given name.</pre></div></div><div id='d_eh' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><pre>Detaches the element from its parent (in case it was already attached).
		This should return this element, and set the parent to None.</pre></div></div><div id='d_ei' class='de'><h1>Method <span class='n'>getSlots</span></h1><div class='re'><code>getSlots( self )</code></div><div class='ds'><pre>Returns (key, evaluable) pairs representing the slots within this
		context. In the case of context that may inherits slots, this only
		returns the slots that are owned by the context (ie. it does not
		include inherited slots)</pre></div></div><div id='d_ej' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><pre>Returns this @protocol name. It can be `None` if the @protocol is anonymous.</pre></div></div><div id='d_ek' class='de'><h1>Method <span class='n'>removeAnnotation</span></h1><div class='re'><code>removeAnnotation( self, name )</code></div><div class='ds'><pre>Removes the annotations with the given name</pre></div></div><div id='d_el' class='de'><h1>Method <span class='n'>getEnd</span></h1><div class='re'><code>getEnd( self )</code></div><div class='ds'><pre>Returns this enumeration end.</pre></div></div><div id='d_em' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><pre>Performs a deep clone of this element. Any mutation to the original won't
		change the copy.</pre></div></div><div id='d_en' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><pre>Detaches the element from its parent (in case it was already attached).
		This should return this element, and set the parent to None.</pre></div></div><div id='d_eo' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><pre>Sets the given argument of this operation, by argument index.</pre></div></div><div id='d_eA' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><pre>Performs a deep clone of this element. Any mutation to the original won't
		change the copy.</pre></div></div><div id='d_eB' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><pre>Returns this element parent</pre></div></div><div id='d_eC' class='de'><h1>Method <span class='n'>getColumn</span></h1><div class='re'><code>getColumn( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_eD' class='de'><h1>Method <span class='n'>_op</span></h1><div class='re'><code>_op( self, symbol, priority=0 )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_eE' class='de'><h1>wrapper_descriptor</h1><div class='re'></div><div class='ds'><pre>x.__repr__() &lt;==&gt; repr(x)</pre></div></div><div id='d_eF' class='de'><h1>Method <span class='n'>add</span></h1><div class='re'><code>add( self, theType )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_eG' class='de'><h1>Method <span class='n'>subtype</span></h1><div class='re'><code>subtype( self, name )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_eH' class='de'><h1>Method <span class='n'>result</span></h1><div class='re'><code>result( self )</code></div><div class='ds'><pre>Returns the result for this type. This is usually just the type
		itself, except for processes types.</pre></div></div><div id='d_eI' class='de'><h1>Method <span class='n'>clone</span></h1><div class='re'><code>clone( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_eJ' class='de'><h1>Function <span class='n'>isSame</span></h1><div class='re'><code>isSame( a, b )</code></div><div class='ds'><pre>Type (b) is the same as (a) if (a) and (b) are identicial, that means
	that you can use b where you use a, and this also means that isSame(a,b) ==
	isSame(b,a). Basically, when (b) is same as (a), (b) can be considered as an
	alias for (a).</pre></div></div><div id='d_eK' class='de'><h1>Method <span class='n'>onProgram</span></h1><div class='re'><code>onProgram( self, program )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_eL' class='de'><h1>Method <span class='n'>getCurrentDataFlow</span></h1><div class='re'><code>getCurrentDataFlow( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_eM' class='de'><h1>Method <span class='n'>resolve</span></h1><div class='re'><code>resolve( self, referenceOrName, contextOrDataFlow=None )</code></div><div class='ds'><pre>Resolves the given 'IReference' or String sing the given context
		('IContext') or dataflow ('IDataFlow'). This usually requires that
		you've applied a pass to create the dataflow (see the
		'lambdafactory.resolution.BasicDataFlow' pass).</pre></div></div><div id='d_eN' class='de'><h1>Method <span class='n'>getCurrentClassAncestors</span></h1><div class='re'><code>getCurrentClassAncestors( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_wN' class='de'><h1>Method <span class='n'>resolve</span></h1><div class='re'><code>resolve( self, referenceOrName, contextOrDataFlow=None )</code></div><div class='ds'><pre>Resolves the given 'IReference' or String sing the given context
		('IContext') or dataflow ('IDataFlow'). This usually requires that
		you've applied a pass to create the dataflow (see the
		'lambdafactory.resolution.BasicDataFlow' pass).</pre></div></div><div id='d_wL' class='de'><h1>Method <span class='n'>run</span></h1><div class='re'><code>run( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_wM' class='de'><h1>Method <span class='n'>getCurrentClassAncestors</span></h1><div class='re'><code>getCurrentClassAncestors( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_wJ' class='de'><h1>Method <span class='n'>getClassParents</span></h1><div class='re'><code>getClassParents( self, theClass )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_wK' class='de'><h1>Method <span class='n'>getFactory</span></h1><div class='re'><code>getFactory( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_wH' class='de'><h1>Method <span class='n'>__call__</span></h1><div class='re'><code>__call__( self )</code></div><div class='ds'><pre>A type instance can be used as a class to construct a new type, which
		will be cloned from the current type.</pre></div></div><div id='d_wI' class='de'><h1>Method <span class='n'>clone</span></h1><div class='re'><code>clone( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_wF' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self, contentType, name=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_wG' class='de'><h1>Method <span class='n'>get</span></h1><div class='re'><code>get( self, name )</code></div><div class='ds'><pre>Returns the type for the slot with the given name.</pre></div></div><div id='d_wD' class='de'><h1>Method <span class='n'>createDataFlow</span></h1><div class='re'><code>createDataFlow( self, element, parent=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_wE' class='de'><h1>Function <span class='n'>_flatten</span></h1><div class='re'><code>_flatten( value, res )</code></div><div class='ds'><pre>Flatten helper operation. See 'flatten'</pre></div></div><div id='d_wB' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><pre>Detaches the element from its parent (in case it was already attached).
		This should return this element, and set the parent to None.</pre></div></div><div id='d_wC' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><pre>Tells if this element has a parent or not</pre></div></div><div id='d_wA' class='de'><h1>Method <span class='n'>addRule</span></h1><div class='re'><code>addRule( self, evaluable )</code></div><div class='ds'><pre>Adds a rule to this operation.</pre></div></div><div id='d_wn' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><pre>Detaches the element from its parent (in case it was already attached).
		This should return this element, and set the parent to None.</pre></div></div><div id='d_wo' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><pre>Tells if this element has a parent or not</pre></div></div><div id='d_wl' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><pre>Sets the abstract type for this element</pre></div></div><div id='d_wm' class='de'><h1>Method <span class='n'>endsWithTermination</span></h1><div class='re'><code>endsWithTermination( self )</code></div><div class='ds'><pre>Returns true if this function ends with a termination operation. This
		is especially useful for back-ends which want to know if they have to
		insert an explicit 'return' at the end (like Java).</pre></div></div><div id='d_wj' class='de'><h1>Method <span class='n'>setSlot</span></h1><div class='re'><code>setSlot( self, name, evaluable )</code></div><div class='ds'><pre>Binds the given evaluable to the named slot. If there is already a slot
		with the same name, then 'getSlot(name)' should return the evaluable
		given as parameter.<br />		In the default implementation, setSlot preserves the ''history'' of
		added slots, and will always return the latest one.</pre></div></div><div id='d_wk' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><pre>Returns the *internal types* for this operations arguments. This is
		typically the list of interfaces or @protocols that the arguments must
		comply to.</pre></div></div><div id='d_wh' class='de'><h1>Method <span class='n'>addAnnotation</span></h1><div class='re'><code>addAnnotation( self, annotation )</code></div><div class='ds'><pre>Adds an annotation to this element</pre></div></div><div id='d_wi' class='de'><h1>Method <span class='n'>declareArgument</span></h1><div class='re'><code>declareArgument( self, name, value )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_wf' class='de'><h1>Method <span class='n'>hasSlot</span></h1><div class='re'><code>hasSlot( self, name )</code></div><div class='ds'><pre>Tells if the context has a slot with the given name.</pre></div></div><div id='d_wg' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><pre>Detaches the element from its parent (in case it was already attached).
		This should return this element, and set the parent to None.</pre></div></div><div id='d_wd' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><pre>Sets the given argument of this operation, by argument index.</pre></div></div><div id='d_we' class='de'><h1>Method <span class='n'>hasAnnotation</span></h1><div class='re'><code>hasAnnotation( self, name )</code></div><div class='ds'><pre>Tells if the given element has an annotation with the given name</pre></div></div><div id='d_wb' class='de'><h1>Method <span class='n'>getAnnotations</span></h1><div class='re'><code>getAnnotations( self, name=None )</code></div><div class='ds'><pre>Gets all the annotation with the given name associated to this element
		or all annotations if no name is specified.</pre></div></div><div id='d_wc' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><pre>Detaches the element from its parent (in case it was already attached).
		This should return this element, and set the parent to None.</pre></div></div><div id='d_wz' class='de'><h1>Method <span class='n'>hasAnnotation</span></h1><div class='re'><code>hasAnnotation( self, name )</code></div><div class='ds'><pre>Tells if the given element has an annotation with the given name</pre></div></div><div id='d_wx' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><pre>Sets this element parent</pre></div></div><div id='d_wy' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><pre>Performs a deep clone of this element. Any mutation to the original won't
		change the copy.</pre></div></div><div id='d_wv' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><pre>Sets this element parent</pre></div></div><div id='d_ww' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><pre>Returns this element parent</pre></div></div><div id='d_wt' class='de'><h1>Method <span class='n'>getResultAbstractType</span></h1><div class='re'><code>getResultAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type of the result of the evaluation of this
		evaluable</pre></div></div><div id='d_wu' class='de'><h1>Class <span class='n'>IMatchProcessOperation</span></h1><div class='re'></div><div class='ds'><pre>A match process is a predicate associate to a process, which is typically
	used for implementing 'if', 'else', etc.</pre></div></div><div id='d_wr' class='de'><h1>Method <span class='n'>hasAnnotation</span></h1><div class='re'><code>hasAnnotation( self, name )</code></div><div class='ds'><pre>Tells if the given element has an annotation with the given name</pre></div></div><div id='d_ws' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><pre>Sets this element parent</pre></div></div><div id='d_wp' class='de'><h1>Class <span class='n'>IInstanceMethod</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_wq' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><pre>Sets this element parent</pre></div></div><div id='Mg' class='cr'><div class='n'><a href='javascript:dS("Mg");'>IComment</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("Mg","Ng");'><span class='special __bases__'>IAnnotation</span></a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Mg","Og");'>getContent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Mg","Pg");'>getName</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Mg","Qg");'>setContent</a></div></div></div><div id='Mn' class='cr'><div class='n'><a href='javascript:dS("Mn");'>IImportModulesOperation</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("Mn","Nn");'><span class='special __bases__'>IImportOperation</span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Mn","On");'>getImportedModuleNames</a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Mn","Pn");'>addAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Mn","Qn");'>addOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Mn","Rn");'>copy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Mn","Sn");'>detach</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Mn","Tn");'>getAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Mn","Un");'>getAnnotations</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Mn","Vn");'>getDataFlow</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Mn","Wn");'>getOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Mn","Xn");'>getOpArguments</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Mn","Yn");'>getOpArgumentsInternalTypes</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Mn","Zn");'>getParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Mn","ao");'>hasAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Mn","bo");'>hasParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Mn","co");'>removeAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Mn","do");'>setAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Mn","eo");'>setOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Mn","fo");'>setParent</a></div></div><div class='t'>Values</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&bull;</span><a href='javascript:dO("Mn","go");'>ARGS</a></div><div class='slot documented'><span
					class='prefix'>&bull;</span><a href='javascript:dO("Mn","ho");'>ARG_NAMES</a></div></div></div><div id='d_Kr' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><pre>Performs a deep clone of this element. Any mutation to the original won't
		change the copy.</pre></div></div><div id='d_Ks' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><pre>Returns the arguments to this operation.</pre></div></div><div id='d_Kp' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><pre>Returns this element parent</pre></div></div><div id='d_Kq' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type for this element</pre></div></div><div id='d_Kv' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><pre>Detaches the element from its parent (in case it was already attached).
		This should return this element, and set the parent to None.</pre></div></div><div id='d_Kw' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><pre>Sets this element parent</pre></div></div><div id='d_Kt' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><pre>Detaches the element from its parent (in case it was already attached).
		This should return this element, and set the parent to None.</pre></div></div><div id='d_Ku' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><pre>Returns this element parent</pre></div></div><div id='d_Kz' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type for this element</pre></div></div><div id='d_Kx' class='de'><h1>Method <span class='n'>getReferenceName</span></h1><div class='re'><code>getReferenceName( self )</code></div><div class='ds'><pre>Returns the name which this reference contains. The name is used by
		the resolution operation to actually resolve a value from the name.</pre></div></div><div id='d_Ky' class='de'><h1>Method <span class='n'>getFactory</span></h1><div class='re'><code>getFactory( self )</code></div><div class='ds'><pre>Gets the factory that was used to create this program. It can be
		used to create more elements in the program.</pre></div></div><div id='d_Kb' class='de'><h1>Class <span class='n'>IAccessor</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Kc' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.ISlot at 0x85d21dc&gt;, &lt;class lambdafactory.interfaces.IEvaluable at 0x85c4f2c&gt;]</code></div><div class='ds'><pre>list() -&gt; new list
list(sequence) -&gt; new list initialized from sequence's items</pre></div></div><div id='d_Kf' class='de'><h1>Method <span class='n'>addAnnotation</span></h1><div class='re'><code>addAnnotation( self, annotation )</code></div><div class='ds'><pre>Adds an annotation to this element</pre></div></div><div id='d_Kg' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><pre>Sets this element parent</pre></div></div><div id='d_Kd' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><pre>Performs a deep clone of this element. Any mutation to the original won't
		change the copy.</pre></div></div><div id='d_Ke' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><pre>Returns the ith arguments to this operation.</pre></div></div><div id='d_Kj' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><pre>Tells if this element has a parent or not</pre></div></div><div id='d_Kk' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><pre>Detaches the element from its parent (in case it was already attached).
		This should return this element, and set the parent to None.</pre></div></div><div id='d_Kh' class='de'><h1>Method <span class='n'>getSlot</span></h1><div class='re'><code>getSlot( self, name )</code></div><div class='ds'><pre>Returns the given evaluable bound to named slot.</pre></div></div><div id='d_Ki' class='de'><h1>Class <span class='n'>IDataFlowOwner</span></h1><div class='re'></div><div class='ds'><pre>DataFlow owners are elements that have their own dataflow. IContext are
	typical examples of elements that are dataflow owners</pre></div></div><div id='d_Kn' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.IEvaluable at 0x85c4f2c&gt;, &lt;class lambdafactory.interfaces.IEvaluable at 0x85c4f2c&gt;]</code></div><div class='ds'><pre>list() -&gt; new list
list(sequence) -&gt; new list initialized from sequence's items</pre></div></div><div id='d_Ko' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type for this element</pre></div></div><div id='d_Kl' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type for this element</pre></div></div><div id='d_Km' class='de'><h1>Method <span class='n'>getReturnTypeDescription</span></h1><div class='re'><code>getReturnTypeDescription( self )</code></div><div class='ds'><pre>Returns the return type description for this closure, if any</pre></div></div><div id='d_KB' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IOperation at 0x85d268c&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_KC' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><pre>Returns this element parent</pre></div></div><div id='d_KA' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><pre>Tells if this element has a parent or not</pre></div></div><div id='d_KF' class='de'><h1>Method <span class='n'>setConcreteType</span></h1><div class='re'><code>setConcreteType( self, value )</code></div><div class='ds'><pre>Sets the _concrete type_ for this abstract type. The concrete type
		is a value which represents the type. For instance, if this type
		represents a class, then the concrete type would be the class instance.</pre></div></div><div id='d_KG' class='de'><h1>Class <span class='n'>InvalidArgument</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_KD' class='de'><h1>Method <span class='n'>exception</span></h1><div class='re'><code>exception( self, exception )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_KE' class='de'><h1>Class <span class='n'>Operations</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_KJ' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><pre>Returns the name of this pass</pre></div></div><div id='d_KK' class='de'><h1>Method <span class='n'>setPass</span></h1><div class='re'><code>setPass( self, programPass )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_KH' class='de'><h1>Method <span class='n'>elements</span></h1><div class='re'><code>elements( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_KI' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self, name )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_KN' class='de'><h1>Method <span class='n'>echoError</span></h1><div class='re'><code>echoError( self, message )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_KL' class='de'><h1>Method <span class='n'>findInContext</span></h1><div class='re'><code>findInContext( self, interface )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_KM' class='de'><h1>Method <span class='n'>hasParentElement</span></h1><div class='re'><code>hasParentElement( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_yd' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.IEvaluable at 0x85c4f2c&gt;, &lt;class lambdafactory.interfaces.IEvaluable at 0x85c4f2c&gt;]</code></div><div class='ds'><pre>list() -&gt; new list
list(sequence) -&gt; new list initialized from sequence's items</pre></div></div><div id='d_ye' class='de'><h1>Method <span class='n'>removeAnnotation</span></h1><div class='re'><code>removeAnnotation( self, name )</code></div><div class='ds'><pre>Removes the annotations with the given name</pre></div></div><div id='d_yf' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><pre>Sets the abstract type for this element</pre></div></div><div id='d_yg' class='de'><h1>Method <span class='n'>getAnnotations</span></h1><div class='re'><code>getAnnotations( self, name=None )</code></div><div class='ds'><pre>Gets all the annotation with the given name associated to this element
		or all annotations if no name is specified.</pre></div></div><div id='d_yb' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><pre>Returns the ith arguments to this operation.</pre></div></div><div id='d_yc' class='de'><h1>Method <span class='n'>getAnnotations</span></h1><div class='re'><code>getAnnotations( self, name=None )</code></div><div class='ds'><pre>Gets all the annotation with the given name associated to this element
		or all annotations if no name is specified.</pre></div></div><div id='d_yl' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><pre>Sets this element parent</pre></div></div><div id='d_ym' class='de'><h1>Method <span class='n'>hasExplicitTermination</span></h1><div class='re'><code>hasExplicitTermination( self )</code></div><div class='ds'><pre>Returns true if this function has an operation with a termination,
		otherwise return false.</pre></div></div><div id='d_yn' class='de'><h1>Method <span class='n'>getAnnotations</span></h1><div class='re'><code>getAnnotations( self, name=None )</code></div><div class='ds'><pre>Gets all the annotation with the given name associated to this element
		or all annotations if no name is specified.</pre></div></div><div id='d_yo' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><pre>Sets the abstract type for this element</pre></div></div><div id='d_yh' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><pre>Performs a deep clone of this element. Any mutation to the original won't
		change the copy.</pre></div></div><div id='d_yi' class='de'><h1>Method <span class='n'>declareVariable</span></h1><div class='re'><code>declareVariable( self, name, value, origin=None )</code></div><div class='ds'><pre>Declares a (local) variable with the given name, value and
		origin</pre></div></div><div id='d_yj' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IValue at 0x85d202c&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_yk' class='de'><h1>Method <span class='n'>hasAnnotation</span></h1><div class='re'><code>hasAnnotation( self, name )</code></div><div class='ds'><pre>Tells if the given element has an annotation with the given name</pre></div></div><div id='d_yt' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><pre>Tells if this element has a parent or not</pre></div></div><div id='d_yu' class='de'><h1>Method <span class='n'>getProcess</span></h1><div class='re'><code>getProcess( self )</code></div><div class='ds'><pre>Returns the process that will be executed if the rule matches.</pre></div></div><div id='d_yv' class='de'><h1>Method <span class='n'>setSlot</span></h1><div class='re'><code>setSlot( self, name, evaluable )</code></div><div class='ds'><pre>Binds the given evaluable to the named slot. If there is already a slot
		with the same name, then 'getSlot(name)' should return the evaluable
		given as parameter.<br />		In the default implementation, setSlot preserves the ''history'' of
		added slots, and will always return the latest one.</pre></div></div><div id='d_yw' class='de'><h1>Method <span class='n'>getSlot</span></h1><div class='re'><code>getSlot( self, name )</code></div><div class='ds'><pre>Returns the given evaluable bound to named slot.</pre></div></div><div id='d_yp' class='de'><h1>Method <span class='n'>addAnnotation</span></h1><div class='re'><code>addAnnotation( self, annotation )</code></div><div class='ds'><pre>Adds an annotation to this element</pre></div></div><div id='d_yq' class='de'><h1>Class <span class='n'>IInterception</span></h1><div class='re'></div><div class='ds'><pre>An interception allows to intercept interruptions that propagage from an
	enclosed process to parent contexts.</pre></div></div><div id='d_yr' class='de'><h1>Method <span class='n'>hasSlot</span></h1><div class='re'><code>hasSlot( self, name )</code></div><div class='ds'><pre>Tells if the context has a slot with the given name.</pre></div></div><div id='d_ys' class='de'><h1>Class <span class='n'>IIteration</span></h1><div class='re'></div><div class='ds'><pre>An iteration is the multiple application of a process given a set of
	values produced by an iterator.</pre></div></div><div id='d_yx' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IReference at 0x85d214c&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_yy' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type for this element</pre></div></div><div id='d_yz' class='de'><h1>Method <span class='n'>removeAnnotation</span></h1><div class='re'><code>removeAnnotation( self, name )</code></div><div class='ds'><pre>Removes the annotations with the given name</pre></div></div><div id='d_yD' class='de'><h1>Method <span class='n'>createDestructor</span></h1><div class='re'><code>createDestructor( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_yE' class='de'><h1>Function <span class='n'>flatten</span></h1><div class='re'><code>flatten( *lists )</code></div><div class='ds'><pre>Flattens the given lists in a single list</pre></div></div><div id='d_yF' class='de'><h1>Method <span class='n'>content</span></h1><div class='re'><code>content( self )</code></div><div class='ds'><pre>Returns the type for the content of this array.</pre></div></div><div id='d_yG' class='de'><h1>Method <span class='n'>isSameAs</span></h1><div class='re'><code>isSameAs( self, otherType )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_yA' class='de'><h1>Method <span class='n'>addAnnotation</span></h1><div class='re'><code>addAnnotation( self, annotation )</code></div><div class='ds'><pre>Adds an annotation to this element</pre></div></div><div id='d_yB' class='de'><h1>Method <span class='n'>getActualValue</span></h1><div class='re'><code>getActualValue( self )</code></div><div class='ds'><pre>Returns the (implementation language) value for this literal</pre></div></div><div id='d_yC' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><pre>Sets the abstract type for this element</pre></div></div><div id='d_yL' class='de'><h1>Method <span class='n'>setPass</span></h1><div class='re'><code>setPass( self, programPass )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_yM' class='de'><h1>Method <span class='n'>getCurrentClosure</span></h1><div class='re'><code>getCurrentClosure( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_yN' class='de'><h1>Method <span class='n'>resolveAbsoluteOrLocal</span></h1><div class='re'><code>resolveAbsoluteOrLocal( self, referenceOrName, contextOrDataFlow=None )</code></div><div class='ds'><pre>Tries an absolute resolution first, then will look in the local scope if
		it fails.</pre></div></div><div id='d_yH' class='de'><h1>Method <span class='n'>concreteType</span></h1><div class='re'><code>concreteType( self )</code></div><div class='ds'><pre>Returns the _concrete type_ for this abstract type.</pre></div></div><div id='d_yI' class='de'><h1>Method <span class='n'>definedBy</span></h1><div class='re'><code>definedBy( self, definition=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_yJ' class='de'><h1>Method <span class='n'>getCurrentClassAncestors</span></h1><div class='re'><code>getCurrentClassAncestors( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_yK' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><pre>Returns the name of this pass</pre></div></div><div id='GN' class='ro'><div class='n'><a href='javascript:dS("GN");'>lambdafactory.reporter</a></div><div class='t'>Classes</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("GN","HN");'>Reporter</a></div></div><div class='t'>Values</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&sdot;</span><a href='javascript:dO("GN","TN");'>DefaultReporter</a></div></div></div><div id='d_kI' class='de'><h1>Method <span class='n'>isSameAs</span></h1><div class='re'><code>isSameAs( self, otherType )</code></div><div class='ds'><pre>Generic implementation of isSameAs. You should always call this method
		in subclasses.</pre></div></div><div id='sB' class='cr'><div class='n'><a href='javascript:dS("sB");'>IString</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("sB","tB");'><span class='special __bases__'>ILiteral</span></a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("sB","uB");'>addAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("sB","vB");'>copy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("sB","wB");'>detach</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("sB","xB");'>getAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("sB","yB");'>getActualValue</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("sB","zB");'>getAnnotations</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("sB","AB");'>getDataFlow</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("sB","BB");'>getParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("sB","CB");'>getResultAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("sB","DB");'>hasAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("sB","EB");'>hasParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("sB","FB");'>removeAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("sB","GB");'>setAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("sB","HB");'>setParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("sB","IB");'>setResultAbstractType</a></div></div></div><div id='si' class='cr'><div class='n'><a href='javascript:dS("si");'>IDataFlow</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("si","c");'><span class='special __bases__'><i>Base class</i></span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("si","ti");'>addChild</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("si","ui");'>addDestination</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("si","vi");'>addSource</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("si","wi");'>declareArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("si","xi");'>declareEnvironment</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("si","yi");'>declareVariable</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("si","zi");'>defines</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("si","Ai");'>getChildren</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("si","Bi");'>getDestinations</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("si","Ci");'>getParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("si","Di");'>getRoot</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("si","Ei");'>getSlot</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("si","Fi");'>getSlots</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("si","Gi");'>getSources</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("si","Hi");'>hasSlot</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("si","Ii");'>resolve</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("si","Ji");'>setParent</a></div></div></div><div id='Rg' class='cr'><div class='n'><a href='javascript:dS("Rg");'>IComputation</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("Rg","Sg");'><span class='special __bases__'>IOperation</span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Rg","Tg");'>getLeftOperand</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Rg","Ug");'>getOperand</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Rg","Vg");'>getOperands</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Rg","Wg");'>getOperator</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Rg","Xg");'>getRightOperand</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Rg","Yg");'>setLeftOperand</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Rg","Zg");'>setOperator</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Rg","ah");'>setRightOperand</a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Rg","bh");'>addAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Rg","ch");'>addOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Rg","dh");'>copy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Rg","eh");'>detach</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Rg","fh");'>getAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Rg","gh");'>getAnnotations</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Rg","hh");'>getDataFlow</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Rg","ih");'>getOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Rg","jh");'>getOpArguments</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Rg","kh");'>getOpArgumentsInternalTypes</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Rg","lh");'>getParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Rg","mh");'>hasAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Rg","nh");'>hasParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Rg","oh");'>removeAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Rg","ph");'>setAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Rg","qh");'>setOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Rg","rh");'>setParent</a></div></div><div class='t'>Values</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&bull;</span><a href='javascript:dO("Rg","sh");'>ARGS</a></div></div></div><div id='d_FJ' class='de'><h1>Method <span class='n'>getCurrentMethod</span></h1><div class='re'><code>getCurrentMethod( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='ex' class='cr'><div class='n'><a href='javascript:dS("ex");'>IOperation</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("ex","fx");'><span class='special __bases__'>IElement</span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ex","gx");'>addOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ex","hx");'>getOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ex","ix");'>getOpArguments</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ex","jx");'>getOpArgumentsInternalTypes</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ex","kx");'>setOpArgument</a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ex","lx");'>addAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ex","mx");'>copy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ex","nx");'>detach</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ex","ox");'>getAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ex","px");'>getAnnotations</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ex","qx");'>getDataFlow</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ex","rx");'>getParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ex","sx");'>hasAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ex","tx");'>hasParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ex","ux");'>removeAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ex","vx");'>setAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ex","wx");'>setParent</a></div></div></div><div id='d_ds' class='de'><h1>Method <span class='n'>getArguments</span></h1><div class='re'><code>getArguments( self )</code></div><div class='ds'><pre>Returns evaluable arguments.</pre></div></div><div id='d_dr' class='de'><h1>Method <span class='n'>getAbsoluteName</span></h1><div class='re'><code>getAbsoluteName( self )</code></div><div class='ds'><pre>Returns the absolute name for this element</pre></div></div><div id='d_dq' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IOperation at 0x85d268c&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_dp' class='de'><h1>Method <span class='n'>addAnnotation</span></h1><div class='re'><code>addAnnotation( self, annotation )</code></div><div class='ds'><pre>Adds an annotation to this element</pre></div></div><div id='d_dw' class='de'><h1>Method <span class='n'>getAbsoluteName</span></h1><div class='re'><code>getAbsoluteName( self )</code></div><div class='ds'><pre>Returns the absolute name for this element</pre></div></div><div id='d_dv' class='de'><h1>Method <span class='n'>getAnnotations</span></h1><div class='re'><code>getAnnotations( self, name=None )</code></div><div class='ds'><pre>Gets all the annotation with the given name associated to this element
		or all annotations if no name is specified.</pre></div></div><div id='d_du' class='de'><h1>Method <span class='n'>getPredicate</span></h1><div class='re'><code>getPredicate( self )</code></div><div class='ds'><pre>Returns the evaluable that acts as a predicate for this operation.</pre></div></div><div id='d_dt' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><pre>Returns the dataflow accessible/bound to this element</pre></div></div><div id='d_dz' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, context )</code></div><div class='ds'><pre>Sets the parent context for this context.</pre></div></div><div id='d_dy' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><pre>Performs a deep clone of this element. Any mutation to the original won't
		change the copy.</pre></div></div><div id='d_dx' class='de'><h1>Method <span class='n'>setResultAbstractType</span></h1><div class='re'><code>setResultAbstractType( self, abstractType )</code></div><div class='ds'><pre>Sets the abstract type for this operation result. This is usually
		invoked in the typing phase.</pre></div></div><div id='d_dc' class='de'><h1>Method <span class='n'>hasAnnotation</span></h1><div class='re'><code>hasAnnotation( self, name )</code></div><div class='ds'><pre>Tells if the given element has an annotation with the given name</pre></div></div><div id='d_db' class='de'><h1>Method <span class='n'>hasSlot</span></h1><div class='re'><code>hasSlot( self, name )</code></div><div class='ds'><pre>Tells if the context has a slot with the given name.</pre></div></div><div id='d_dg' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><pre>Tells if this element has a parent or not</pre></div></div><div id='d_df' class='de'><h1>Method <span class='n'>getInstanceMethods</span></h1><div class='re'><code>getInstanceMethods( self )</code></div><div class='ds'><pre>Returns the instance methods defined within this class.</pre></div></div><div id='d_de' class='de'><h1>Method <span class='n'>isAbstract</span></h1><div class='re'><code>isAbstract( self )</code></div><div class='ds'><pre>Tells wether the given abstractable is abstract or not.</pre></div></div><div id='d_dd' class='de'><h1>Class <span class='n'>IAssignation</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_dk' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><pre>Tells if this element has a parent or not</pre></div></div><div id='d_dj' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><pre>Returns the dataflow accessible/bound to this element</pre></div></div><div id='d_di' class='de'><h1>Method <span class='n'>getSlotNames</span></h1><div class='re'><code>getSlotNames( self )</code></div><div class='ds'><pre>Returns the list of slot names (in order) for this context</pre></div></div><div id='d_dh' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><pre>Performs a deep clone of this element. Any mutation to the original won't
		change the copy.</pre></div></div><div id='d_do' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><pre>Sets the abstract type for this element</pre></div></div><div id='d_dn' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><pre>Performs a deep clone of this element. Any mutation to the original won't
		change the copy.</pre></div></div><div id='d_dm' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><pre>Adds an argument to this operation. This should do checking of
		arguments (by expected internal type and number).</pre></div></div><div id='d_dl' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IOperation at 0x85d268c&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_dC' class='de'><h1>Class <span class='n'>ISyntactic</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_dB' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><pre>Returns the *internal types* for this operations arguments. This is
		typically the list of interfaces or @protocols that the arguments must
		comply to.</pre></div></div><div id='d_dA' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><pre>Adds an argument to this operation. This should do checking of
		arguments (by expected internal type and number).</pre></div></div><div id='d_dG' class='de'><h1>Method <span class='n'>setName</span></h1><div class='re'><code>setName( self, name )</code></div><div class='ds'><pre>Sets the name of this type</pre></div></div><div id='d_dF' class='de'><h1>Method <span class='n'>__str__</span></h1><div class='re'><code>__str__( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_dE' class='de'><h1>wrapper_descriptor</h1><div class='re'></div><div class='ds'><pre>x.__getitem__(y) &lt;==&gt; x[y]</pre></div></div><div id='d_dD' class='de'><h1>Method <span class='n'>_number</span></h1><div class='re'><code>_number( self, number )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_dK' class='de'><h1>Method <span class='n'>onModule</span></h1><div class='re'><code>onModule( self, module )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_dJ' class='de'><h1>Function <span class='n'>isLike</span></h1><div class='re'><code>isLike( a, b )</code></div><div class='ds'><pre>Type (b) is like type (a) if (b) can be used where (a) can be used. When
	two types are alike but not the same, this usually means that one type is
	composed at some level of 'Any' or 'Rest' types.<br />	Not that isLike(a,b) does not imply isLike(b,a), as (a) may be a "broad"
	type (such as 'Any'), and (b) a particular type (say 'String').</pre></div></div><div id='d_dI' class='de'><h1>Method <span class='n'>asString</span></h1><div class='re'><code>asString( self, fromType=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_dH' class='de'><h1>Method <span class='n'>name</span></h1><div class='re'><code>name( self, name=None )</code></div><div class='ds'><pre>Returns/sets the name for this type. By defaults, types are unnamed.</pre></div></div><div id='d_dN' class='de'><h1>Method <span class='n'>getCurrentClass</span></h1><div class='re'><code>getCurrentClass( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_dM' class='de'><h1>Method <span class='n'>isIn</span></h1><div class='re'><code>isIn( self, interface )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_dL' class='de'><h1>Method <span class='n'>getCurrentContext</span></h1><div class='re'><code>getCurrentContext( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='xj' class='cr'><div class='n'><a href='javascript:dS("xj");'>IDict</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("xj","yj");'><span class='special __bases__'>IValue</span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("xj","zj");'>getItems</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("xj","Aj");'>setValue</a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("xj","Bj");'>addAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("xj","Cj");'>copy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("xj","Dj");'>detach</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("xj","Ej");'>getAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("xj","Fj");'>getAnnotations</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("xj","Gj");'>getDataFlow</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("xj","Hj");'>getParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("xj","Ij");'>getResultAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("xj","Jj");'>hasAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("xj","Kj");'>hasParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("xj","Lj");'>removeAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("xj","Mj");'>setAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("xj","Nj");'>setParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("xj","Oj");'>setResultAbstractType</a></div></div></div><div id='d_xf' class='de'><h1>Method <span class='n'>removeAnnotation</span></h1><div class='re'><code>removeAnnotation( self, name )</code></div><div class='ds'><pre>Removes the annotations with the given name</pre></div></div><div id='d_xe' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><pre>Tells if this element has a parent or not</pre></div></div><div id='d_xd' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><pre>Sets this element parent</pre></div></div><div id='d_xc' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type for this element</pre></div></div><div id='d_xb' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><pre>Returns the dataflow accessible/bound to this element</pre></div></div><div id='d_xo' class='de'><h1>Method <span class='n'>removeAnnotation</span></h1><div class='re'><code>removeAnnotation( self, name )</code></div><div class='ds'><pre>Removes the annotations with the given name</pre></div></div><div id='d_xn' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type for this element</pre></div></div><div id='d_xm' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><pre>Returns this @protocol name. It can be `None` if the @protocol is anonymous.</pre></div></div><div id='d_xl' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><pre>Sets the given argument of this operation, by argument index.</pre></div></div><div id='d_xk' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><pre>Returns this element parent</pre></div></div><div id='d_xj' class='de'><h1>Class <span class='n'>IDict</span></h1><div class='re'></div><div class='ds'><pre>A dictionary is a binding of key to values. It may or may not be ordered,
	depending on the implementation/model semantics.</pre></div></div><div id='d_xi' class='de'><h1>Method <span class='n'>declareEnvironment</span></h1><div class='re'><code>declareEnvironment( self, name, value )</code></div><div class='ds'><pre>Declares an environment variable with the given name, value
		and origin.</pre></div></div><div id='d_xh' class='de'><h1>Method <span class='n'>addOperation</span></h1><div class='re'><code>addOperation( self, operation )</code></div><div class='ds'><pre>Adds the given operation as a child of this process.</pre></div></div><div id='d_xw' class='de'><h1>Method <span class='n'>getReturnTypeDescription</span></h1><div class='re'><code>getReturnTypeDescription( self )</code></div><div class='ds'><pre>Returns the return type description for this closure, if any</pre></div></div><div id='d_xv' class='de'><h1>Method <span class='n'>setReturnTypeDescription</span></h1><div class='re'><code>setReturnTypeDescription( self, description )</code></div><div class='ds'><pre>Sets the return type description for this closure, if any</pre></div></div><div id='xx' class='cr'><div class='n'><a href='javascript:dS("xx");'>IOperator</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("xx","yx");'><span class='special __bases__'>IReference</span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("xx","zx");'>getPriority</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("xx","Ax");'>setPriority</a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("xx","Bx");'>addAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("xx","Cx");'>copy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("xx","Dx");'>detach</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("xx","Ex");'>getAbsoluteName</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("xx","Fx");'>getAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("xx","Gx");'>getAnnotations</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("xx","Hx");'>getDataFlow</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("xx","Ix");'>getName</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("xx","Jx");'>getParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("xx","Kx");'>getReferenceName</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("xx","Lx");'>getResultAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("xx","Mx");'>hasAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("xx","Nx");'>hasParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("xx","Ox");'>removeAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("xx","Px");'>setAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("xx","Qx");'>setParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("xx","Rx");'>setResultAbstractType</a></div></div></div><div id='d_xt' class='de'><h1>Method <span class='n'>hasAnnotation</span></h1><div class='re'><code>hasAnnotation( self, name )</code></div><div class='ds'><pre>Tells if the given element has an annotation with the given name</pre></div></div><div id='d_xs' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.IEvaluable at 0x85c4f2c&gt;, [&lt;class lambdafactory.interfaces.IEvaluable at 0x85c4f2c&gt;]]</code></div><div class='ds'><pre>list() -&gt; new list
list(sequence) -&gt; new list initialized from sequence's items</pre></div></div><div id='d_xr' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><pre>Tells if this element has a parent or not</pre></div></div><div id='d_xq' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.IEvaluable at 0x85c4f2c&gt;, [&lt;class lambdafactory.interfaces.IEvaluable at 0x85c4f2c&gt;]]</code></div><div class='ds'><pre>list() -&gt; new list
list(sequence) -&gt; new list initialized from sequence's items</pre></div></div><div id='d_xp' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IMethod at 0x85d250c&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_xz' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><pre>Tells if this element has a parent or not</pre></div></div><div id='d_xy' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><pre>Detaches the element from its parent (in case it was already attached).
		This should return this element, and set the parent to None.</pre></div></div><div id='d_xx' class='de'><h1>Class <span class='n'>IOperator</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_xG' class='de'><h1>Method <span class='n'>isLike</span></h1><div class='re'><code>isLike( self, otherType )</code></div><div class='ds'><pre>The other type is like this one if the other is a sequence with the
		same length and that all elements are like the corresponding elements of
		this sequence.</pre></div></div><div id='d_xF' class='de'><h1>Method <span class='n'>asString</span></h1><div class='re'><code>asString( self, fromTypes=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_xE' class='de'><h1>Function <span class='n'>_format</span></h1><div class='re'><code>_format( value, level=None )</code></div><div class='ds'><pre>Format helper operation. See @format</pre></div></div><div id='d_xD' class='de'><h1>Method <span class='n'>createDataFlowSlot</span></h1><div class='re'><code>createDataFlowSlot( self, name, value, origin, slotType )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_xC' class='de'><h1>Method <span class='n'>removeAnnotation</span></h1><div class='re'><code>removeAnnotation( self, name )</code></div><div class='ds'><pre>Removes the annotations with the given name</pre></div></div><div id='d_xB' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type for this element</pre></div></div><div id='d_xA' class='de'><h1>Method <span class='n'>getRules</span></h1><div class='re'><code>getRules( self )</code></div><div class='ds'><pre>Returns the ordered set of rule for this selection.</pre></div></div><div id='d_xN' class='de'><h1>Method <span class='n'>resolveAbsolute</span></h1><div class='re'><code>resolveAbsolute( self, referenceOrName )</code></div><div class='ds'><pre>Resolves the given reference or string expressed in absolute style
		('.'-separated list of names), starting from the root dataflow (the program
		dataflow).</pre></div></div><div id='d_xM' class='de'><h1>Method <span class='n'>getCurrentClassParents</span></h1><div class='re'><code>getCurrentClassParents( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_xL' class='de'><h1>Method <span class='n'>setEnvironment</span></h1><div class='re'><code>setEnvironment( self, environment )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_xK' class='de'><h1>Method <span class='n'>getHandler</span></h1><div class='re'><code>getHandler( self, element )</code></div><div class='ds'><pre>Tells if the pass handles the given element. This basically iterates
		on the 'handles' property values (which are interfaces), when one
		interface matches the given 'element', then the corresponding 'onXXX'
		method is invoked, where 'XXX' is the interface
		name (without the leading 'I').</pre></div></div><div id='d_xJ' class='de'><h1>Method <span class='n'>getCurrentClass</span></h1><div class='re'><code>getCurrentClass( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_xI' class='de'><h1>Method <span class='n'>concreteType</span></h1><div class='re'><code>concreteType( self )</code></div><div class='ds'><pre>Returns the _concrete type_ for this abstract type.</pre></div></div><div id='d_xH' class='de'><h1>Method <span class='n'>__str__</span></h1><div class='re'><code>__str__( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_vI' class='de'><h1>Method <span class='n'>asString</span></h1><div class='re'><code>asString( self, fromTypes=None )</code></div><div class='ds'><pre>Returns a string representation of this type.</pre></div></div><div id='d_vH' class='de'><h1>Method <span class='n'>result</span></h1><div class='re'><code>result( self, result=None )</code></div><div class='ds'><pre>If there is not at least 2 addded types, the result is Nothing.</pre></div></div><div id='d_vK' class='de'><h1>Method <span class='n'>getCurrentProcess</span></h1><div class='re'><code>getCurrentProcess( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_vJ' class='de'><h1>Method <span class='n'>getClassAncestors</span></h1><div class='re'><code>getClassAncestors( self, theClass=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_vM' class='de'><h1>Method <span class='n'>getCurrentClass</span></h1><div class='re'><code>getCurrentClass( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_vL' class='de'><h1>Method <span class='n'>resolveLocalOrAbsolute</span></h1><div class='re'><code>resolveLocalOrAbsolute( self, referenceOrName, contextOrDataFlow=None )</code></div><div class='ds'><pre>Tries a local resolution first, then will look in the program scope if
		it fails.</pre></div></div><div id='d_vN' class='de'><h1>Method <span class='n'>isIn</span></h1><div class='re'><code>isIn( self, interface )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_vA' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IOperation at 0x85d268c&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_vC' class='de'><h1>Method <span class='n'>hasAnnotation</span></h1><div class='re'><code>hasAnnotation( self, name )</code></div><div class='ds'><pre>Tells if the given element has an annotation with the given name</pre></div></div><div id='d_vB' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><pre>Performs a deep clone of this element. Any mutation to the original won't
		change the copy.</pre></div></div><div id='d_vE' class='de'><h1>str</h1><div class='re'><code>''</code></div><div class='ds'><pre>str(object) -&gt; string<br />Return a nice string representation of the object.
If the argument is a string, the return value is the same object.</pre></div></div><div id='d_vD' class='de'><h1>Method <span class='n'>createConstructor</span></h1><div class='re'><code>createConstructor( self, arguments=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_vG' class='de'><h1>Method <span class='n'>elementNames</span></h1><div class='re'><code>elementNames( self )</code></div><div class='ds'><pre>Returns the list of slots/elements defined in this map.</pre></div></div><div id='d_vF' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.typecast.Type at 0x40315c5c&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_vi' class='de'><h1>Method <span class='n'>addSource</span></h1><div class='re'><code>addSource( self, dataflow )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_vh' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IMethod at 0x85d250c&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_vk' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><pre>Returns the arguments to this operation.</pre></div></div><div id='d_vj' class='de'><h1>Method <span class='n'>setReturnTypeDescription</span></h1><div class='re'><code>setReturnTypeDescription( self, description )</code></div><div class='ds'><pre>Sets the return type description for this closure, if any</pre></div></div><div id='d_vm' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IClosure at 0x85d24ac&gt;, &lt;class lambdafactory.interfaces.IReferencable at 0x85c4efc&gt;, &lt;class lambdafactory.interfaces.IAbstractable at 0x85c4fbc&gt;, &lt;class lambdafactory.interfaces.IConstruct at 0x85c4e9c&gt;)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_vl' class='de'><h1>Method <span class='n'>removeAnnotation</span></h1><div class='re'><code>removeAnnotation( self, name )</code></div><div class='ds'><pre>Removes the annotations with the given name</pre></div></div><div id='d_vo' class='de'><h1>Method <span class='n'>hasAnnotation</span></h1><div class='re'><code>hasAnnotation( self, name )</code></div><div class='ds'><pre>Tells if the given element has an annotation with the given name</pre></div></div><div id='d_vn' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><pre>Performs a deep clone of this element. Any mutation to the original won't
		change the copy.</pre></div></div><div id='d_vc' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><pre>Performs a deep clone of this element. Any mutation to the original won't
		change the copy.</pre></div></div><div id='d_vb' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type for this element</pre></div></div><div id='d_ve' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><pre>Returns this element parent</pre></div></div><div id='d_vd' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><pre>Sets the abstract type for this element</pre></div></div><div id='d_vg' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><pre>Performs a deep clone of this element. Any mutation to the original won't
		change the copy.</pre></div></div><div id='d_vf' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><pre>Tells if this element has a parent or not</pre></div></div><div id='d_vy' class='de'><h1>Method <span class='n'>addAnnotation</span></h1><div class='re'><code>addAnnotation( self, annotation )</code></div><div class='ds'><pre>Adds an annotation to this element</pre></div></div><div id='d_vx' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><pre>Sets the abstract type for this element</pre></div></div><div id='d_vz' class='de'><h1>Method <span class='n'>getResultAbstractType</span></h1><div class='re'><code>getResultAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type of the result of the evaluation of this
		evaluable</pre></div></div><div id='d_vq' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><pre>Sets the given argument of this operation, by argument index.</pre></div></div><div id='d_vp' class='de'><h1>list</h1><div class='re'><code>['ImportedElements', 'ImportOrigin']</code></div><div class='ds'><pre>list() -&gt; new list
list(sequence) -&gt; new list initialized from sequence's items</pre></div></div><div id='d_vs' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><pre>Sets the given argument of this operation, by argument index.</pre></div></div><div id='d_vr' class='de'><h1>Method <span class='n'>getSlots</span></h1><div class='re'><code>getSlots( self )</code></div><div class='ds'><pre>Returns (key, evaluable) pairs representing the slots within this
		context. In the case of context that may inherits slots, this only
		returns the slots that are owned by the context (ie. it does not
		include inherited slots)</pre></div></div><div id='d_vu' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><pre>Sets this element parent</pre></div></div><div id='d_vt' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><pre>Returns this element parent</pre></div></div><div id='d_vw' class='de'><h1>Method <span class='n'>getOperations</span></h1><div class='re'><code>getOperations( self )</code></div><div class='ds'><pre>Returns the list of operations in this process.</pre></div></div><div id='d_vv' class='de'><h1>Method <span class='n'>setArguments</span></h1><div class='re'><code>setArguments( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='DE' class='ro'><div class='n'><a href='javascript:dS("DE");'>lambdafactory.modeltypes</a></div><div class='t'>Classes</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("DE","EE");'>Behaviour</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("DE","HE");'>Data</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("DE","KE");'>Operations</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("DE","NE");'>Runtime</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("DE","QE");'>Structure</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("DE","TE");'>TypeCollection</a></div></div><div class='t'>Functions</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&lambda;</span><a href='javascript:dO("DE","VE");'>typeForValue</a></div></div><div class='t'>Values</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&bull;</span><a href='javascript:dO("DE","WE");'>CATALOG</a></div><div class='slot documented'><span
					class='prefix'>&bull;</span><a href='javascript:dO("DE","XE");'>COLLECTIONS</a></div></div></div><div id='Dl' class='cr'><div class='n'><a href='javascript:dS("Dl");'>IEvaluation</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("Dl","El");'><span class='special __bases__'>IOperation</span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Dl","Fl");'>getEvaluable</a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Dl","Gl");'>addAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Dl","Hl");'>addOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Dl","Il");'>copy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Dl","Jl");'>detach</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Dl","Kl");'>getAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Dl","Ll");'>getAnnotations</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Dl","Ml");'>getDataFlow</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Dl","Nl");'>getOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Dl","Ol");'>getOpArguments</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Dl","Pl");'>getOpArgumentsInternalTypes</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Dl","Ql");'>getParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Dl","Rl");'>hasAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Dl","Sl");'>hasParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Dl","Tl");'>removeAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Dl","Ul");'>setAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Dl","Vl");'>setOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Dl","Wl");'>setParent</a></div></div><div class='t'>Values</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&bull;</span><a href='javascript:dO("Dl","Xl");'>ARGS</a></div><div class='slot documented'><span
					class='prefix'>&bull;</span><a href='javascript:dO("Dl","Yl");'>ARG_NAMES</a></div></div></div><div id='Dt' class='cr'><div class='n'><a href='javascript:dS("Dt");'>IMatchExpressionOperation</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("Dt","Et");'><span class='special __bases__'>IMatchOperation</span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Dt","Ft");'>getExpression</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Dt","Gt");'>setExpression</a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Dt","Ht");'>addAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Dt","It");'>addOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Dt","Jt");'>copy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Dt","Kt");'>detach</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Dt","Lt");'>getAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Dt","Mt");'>getAnnotations</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Dt","Nt");'>getDataFlow</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Dt","Ot");'>getOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Dt","Pt");'>getOpArguments</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Dt","Qt");'>getOpArgumentsInternalTypes</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Dt","Rt");'>getParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Dt","St");'>getPredicate</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Dt","Tt");'>hasAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Dt","Ut");'>hasParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Dt","Vt");'>removeAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Dt","Wt");'>setAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Dt","Xt");'>setOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Dt","Yt");'>setParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Dt","Zt");'>setPredicate</a></div></div><div class='t'>Values</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&bull;</span><a href='javascript:dO("Dt","au");'>ARGS</a></div></div></div><div id='d_Jy' class='de'><h1>Method <span class='n'>addModule</span></h1><div class='re'><code>addModule( self, module )</code></div><div class='ds'><pre>Adds a module to this program. The module will be registered in
		the global module catalogue.</pre></div></div><div id='d_Jx' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><pre>Returns this element parent</pre></div></div><div id='d_Jz' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><pre>Detaches the element from its parent (in case it was already attached).
		This should return this element, and set the parent to None.</pre></div></div><div id='d_Ju' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><pre>Returns the *internal types* for this operations arguments. This is
		typically the list of interfaces or @protocols that the arguments must
		comply to.</pre></div></div><div id='d_Jt' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><pre>Performs a deep clone of this element. Any mutation to the original won't
		change the copy.</pre></div></div><div id='d_Jw' class='de'><h1>Method <span class='n'>setArguments</span></h1><div class='re'><code>setArguments( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Jv' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><pre>Performs a deep clone of this element. Any mutation to the original won't
		change the copy.</pre></div></div><div id='d_Jq' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><pre>Detaches the element from its parent (in case it was already attached).
		This should return this element, and set the parent to None.</pre></div></div><div id='d_Jp' class='de'><h1>Method <span class='n'>getOperations</span></h1><div class='re'><code>getOperations( self )</code></div><div class='ds'><pre>Returns the list of operations in this process.</pre></div></div><div id='d_Js' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><pre>Returns the ith arguments to this operation.</pre></div></div><div id='d_Jr' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><pre>Adds an argument to this operation. This should do checking of
		arguments (by expected internal type and number).</pre></div></div><div id='d_Jm' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><pre>Returns this element parent</pre></div></div><div id='d_Jl' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><pre>Detaches the element from its parent (in case it was already attached).
		This should return this element, and set the parent to None.</pre></div></div><div id='d_Jo' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><pre>Detaches the element from its parent (in case it was already attached).
		This should return this element, and set the parent to None.</pre></div></div><div id='d_Jn' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><pre>Sets this element parent</pre></div></div><div id='d_Ji' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, parent )</code></div><div class='ds'><pre>Add the given dataflow as a parent of this dataflow.</pre></div></div><div id='d_Jh' class='de'><h1>Method <span class='n'>getReturnTypeDescription</span></h1><div class='re'><code>getReturnTypeDescription( self )</code></div><div class='ds'><pre>Returns the return type description for this closure, if any</pre></div></div><div id='d_Jk' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><pre>Performs a deep clone of this element. Any mutation to the original won't
		change the copy.</pre></div></div><div id='d_Jj' class='de'><h1>Method <span class='n'>hasAnnotation</span></h1><div class='re'><code>hasAnnotation( self, name )</code></div><div class='ds'><pre>Tells if the given element has an annotation with the given name</pre></div></div><div id='d_Je' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><pre>Returns the dataflow accessible/bound to this element</pre></div></div><div id='d_Jd' class='de'><h1>Method <span class='n'>addOperation</span></h1><div class='re'><code>addOperation( self, operation )</code></div><div class='ds'><pre>Adds the given operation as a child of this process.</pre></div></div><div id='d_Jg' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><pre>Sets the abstract type for this element</pre></div></div><div id='d_Jf' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IMethod at 0x85d250c&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_Jc' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><pre>Sets this element parent</pre></div></div><div id='d_Jb' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.IEvaluable at 0x85c4f2c&gt;, &lt;class lambdafactory.interfaces.IEvaluable at 0x85c4f2c&gt;]</code></div><div class='ds'><pre>list() -&gt; new list
list(sequence) -&gt; new list initialized from sequence's items</pre></div></div><div id='d_JM' class='de'><h1>Method <span class='n'>handle</span></h1><div class='re'><code>handle( self, element )</code></div><div class='ds'><pre>Handles a sungle element, without recursing through its children</pre></div></div><div id='d_JL' class='de'><h1>Method <span class='n'>filterContext</span></h1><div class='re'><code>filterContext( self, interface )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_JN' class='de'><h1>Method <span class='n'>dedent</span></h1><div class='re'><code>dedent( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_JI' class='de'><h1>Method <span class='n'>__call__</span></h1><div class='re'><code>__call__( self )</code></div><div class='ds'><pre>A type instance can be used as a class to construct a new type, which
		will be cloned from the current type.</pre></div></div><div id='d_JH' class='de'><h1>Method <span class='n'>asString</span></h1><div class='re'><code>asString( self, fromTypes=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_JK' class='de'><h1>Method <span class='n'>setEnvironment</span></h1><div class='re'><code>setEnvironment( self, environment )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_JJ' class='de'><h1>Method <span class='n'>getHandler</span></h1><div class='re'><code>getHandler( self, element )</code></div><div class='ds'><pre>Tells if the pass handles the given element. This basically iterates
		on the 'handles' property values (which are interfaces), when one
		interface matches the given 'element', then the corresponding 'onXXX'
		method is invoked, where 'XXX' is the interface
		name (without the leading 'I').</pre></div></div><div id='d_JE' class='de'><h1>Method <span class='n'>getType</span></h1><div class='re'><code>getType( self, name )</code></div><div class='ds'><pre>Returns the type with the given name, or None if it does not
		exist.</pre></div></div><div id='d_JD' class='de'><h1>Method <span class='n'>evaluate</span></h1><div class='re'><code>evaluate( self, evaluable )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_JG' class='de'><h1>Method <span class='n'>resolve</span></h1><div class='re'><code>resolve( self, typeName )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_JF' class='de'><h1>Method <span class='n'>result</span></h1><div class='re'><code>result( self )</code></div><div class='ds'><pre>Returns the result for this type. This is usually just the type
		itself, except for processes types.</pre></div></div><div id='d_JA' class='de'><h1>Method <span class='n'>hasAnnotation</span></h1><div class='re'><code>hasAnnotation( self, name )</code></div><div class='ds'><pre>Tells if the given element has an annotation with the given name</pre></div></div><div id='d_JC' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><pre>Returns the dataflow accessible/bound to this element</pre></div></div><div id='d_JB' class='de'><h1>Class <span class='n'>ISubsetOperation</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_DB' class='de'><h1>Method <span class='n'>hasAnnotation</span></h1><div class='re'><code>hasAnnotation( self, name )</code></div><div class='ds'><pre>Tells if the given element has an annotation with the given name</pre></div></div><div id='d_gA' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type for this element</pre></div></div><div id='d_gz' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IAssignable at 0x85c4ecc&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_gx' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><pre>Adds an argument to this operation. This should do checking of
		arguments (by expected internal type and number).</pre></div></div><div id='d_gy' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type for this element</pre></div></div><div id='d_gv' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><pre>Returns this @protocol name. It can be `None` if the @protocol is anonymous.</pre></div></div><div id='d_gw' class='de'><h1>Method <span class='n'>getTypeDescription</span></h1><div class='re'><code>getTypeDescription( self )</code></div><div class='ds'><pre>Returns type information (constraints) that are associated to this
		argument.</pre></div></div><div id='d_gt' class='de'><h1>Method <span class='n'>hasAnnotation</span></h1><div class='re'><code>hasAnnotation( self, name )</code></div><div class='ds'><pre>Tells if the given element has an annotation with the given name</pre></div></div><div id='d_gu' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><pre>Adds an argument to this operation. This should do checking of
		arguments (by expected internal type and number).</pre></div></div><div id='d_gr' class='de'><h1>Method <span class='n'>getAttributes</span></h1><div class='re'><code>getAttributes( self )</code></div><div class='ds'><pre>Returns the (non-class) attributes defined within this class.</pre></div></div><div id='d_gs' class='de'><h1>Method <span class='n'>addAnnotation</span></h1><div class='re'><code>addAnnotation( self, annotation )</code></div><div class='ds'><pre>Adds an annotation to this element</pre></div></div><div id='d_gp' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><pre>Detaches the element from its parent (in case it was already attached).
		This should return this element, and set the parent to None.</pre></div></div><div id='d_gq' class='de'><h1>Method <span class='n'>addAnnotation</span></h1><div class='re'><code>addAnnotation( self, annotation )</code></div><div class='ds'><pre>Adds an annotation to this element</pre></div></div><div id='d_gn' class='de'><h1>Method <span class='n'>getAnnotations</span></h1><div class='re'><code>getAnnotations( self, name=None )</code></div><div class='ds'><pre>Gets all the annotation with the given name associated to this element
		or all annotations if no name is specified.</pre></div></div><div id='d_go' class='de'><h1>list</h1><div class='re'><code>[[&lt;class lambdafactory.interfaces.IEvaluable at 0x85c4f2c&gt;]]</code></div><div class='ds'><pre>list() -&gt; new list
list(sequence) -&gt; new list initialized from sequence's items</pre></div></div><div id='d_gl' class='de'><h1>Method <span class='n'>getStep</span></h1><div class='re'><code>getStep( self )</code></div><div class='ds'><pre>Returns this enumeration step.</pre></div></div><div id='d_gm' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type for this element</pre></div></div><div id='d_gj' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><pre>Returns this element parent</pre></div></div><div id='d_gk' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><pre>Sets this element parent</pre></div></div><div id='d_gh' class='de'><h1>Method <span class='n'>getAnnotations</span></h1><div class='re'><code>getAnnotations( self, name=None )</code></div><div class='ds'><pre>Gets all the annotation with the given name associated to this element
		or all annotations if no name is specified.</pre></div></div><div id='d_gi' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, context )</code></div><div class='ds'><pre>Sets the parent context for this context.</pre></div></div><div id='d_gf' class='de'><h1>Method <span class='n'>getOperations</span></h1><div class='re'><code>getOperations( self )</code></div><div class='ds'><pre>Returns the operations (methods and class methods) defined within this class.</pre></div></div><div id='d_gg' class='de'><h1>Method <span class='n'>removeAnnotation</span></h1><div class='re'><code>removeAnnotation( self, name )</code></div><div class='ds'><pre>Removes the annotations with the given name</pre></div></div><div id='d_gd' class='de'><h1>Method <span class='n'>getTarget</span></h1><div class='re'><code>getTarget( self )</code></div><div class='ds'><pre>Returns this assignation target reference, which can be an evaluable
		(in case you assign to self.something, or a reference)</pre></div></div><div id='d_ge' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><pre>Sets the abstract type for this element</pre></div></div><div id='d_gb' class='de'><h1>Method <span class='n'>setAbstract</span></h1><div class='re'><code>setAbstract( self, isAbstract )</code></div><div class='ds'><pre>Sets wether the given abstractable is abstract or not.</pre></div></div><div id='d_gc' class='de'><h1>Method <span class='n'>hasSlot</span></h1><div class='re'><code>hasSlot( self, name )</code></div><div class='ds'><pre>Tells if the context has a slot with the given name.</pre></div></div><div id='d_gN' class='de'><h1>Method <span class='n'>getCurrentClosure</span></h1><div class='re'><code>getCurrentClosure( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_gL' class='de'><h1>Method <span class='n'>getCurrentFunction</span></h1><div class='re'><code>getCurrentFunction( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_gM' class='de'><h1>Method <span class='n'>resolveAbsoluteOrLocal</span></h1><div class='re'><code>resolveAbsoluteOrLocal( self, referenceOrName, contextOrDataFlow=None )</code></div><div class='ds'><pre>Tries an absolute resolution first, then will look in the local scope if
		it fails.</pre></div></div><div id='d_gJ' class='de'><h1>Function <span class='n'>isType</span></h1><div class='re'><code>isType( a )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_gK' class='de'><h1>Method <span class='n'>filter</span></h1><div class='re'><code>filter( self, list, interface )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_gH' class='de'><h1>Method <span class='n'>setName</span></h1><div class='re'><code>setName( self, name )</code></div><div class='ds'><pre>Sets the name of this type</pre></div></div><div id='d_gI' class='de'><h1>Method <span class='n'>__str__</span></h1><div class='re'><code>__str__( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_gF' class='de'><h1>Method <span class='n'>clone</span></h1><div class='re'><code>clone( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_gG' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.typecast.Map at 0x40315ddc&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_gD' class='de'><h1>Method <span class='n'>_ref</span></h1><div class='re'><code>_ref( self, name )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_gE' class='de'><h1>getset_descriptor</h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_gB' class='de'><h1>Method <span class='n'>hasAnnotation</span></h1><div class='re'><code>hasAnnotation( self, name )</code></div><div class='ds'><pre>Tells if the given element has an annotation with the given name</pre></div></div><div id='d_gC' class='de'><h1>Method <span class='n'>getOffset</span></h1><div class='re'><code>getOffset( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='uh' class='cr'><div class='n'><a href='javascript:dS("uh");'>IConstructor</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("uh","vh");'><span class='special __bases__'>IMethod</span></a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("uh","wh");'>addAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("uh","xh");'>addOperation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("uh","yh");'>copy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("uh","zh");'>detach</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("uh","Ah");'>endsWithTermination</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("uh","Bh");'>getAbsoluteName</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("uh","Ch");'>getAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("uh","Dh");'>getAnnotations</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("uh","Eh");'>getArguments</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("uh","Fh");'>getDataFlow</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("uh","Gh");'>getName</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("uh","Hh");'>getOperations</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("uh","Ih");'>getParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("uh","Jh");'>getReturnTypeDescription</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("uh","Kh");'>getSlot</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("uh","Lh");'>getSlotNames</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("uh","Mh");'>getSlots</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("uh","Nh");'>hasAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("uh","Oh");'>hasExplicitTermination</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("uh","Ph");'>hasParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("uh","Qh");'>hasSlot</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("uh","Rh");'>isAbstract</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("uh","Sh");'>removeAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("uh","Th");'>setAbstract</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("uh","Uh");'>setAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("uh","Vh");'>setArguments</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("uh","Wh");'>setParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("uh","Xh");'>setReturnTypeDescription</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("uh","Yh");'>setSlot</a></div></div></div><div id='jz' class='cr'><div class='n'><a href='javascript:dS("jz");'>IReference</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("jz","kz");'><span class='special __bases__'>IValue, IReferencable</span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("jz","lz");'>getReferenceName</a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("jz","mz");'>addAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("jz","nz");'>copy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("jz","oz");'>detach</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("jz","pz");'>getAbsoluteName</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("jz","qz");'>getAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("jz","rz");'>getAnnotations</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("jz","sz");'>getDataFlow</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("jz","tz");'>getName</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("jz","uz");'>getParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("jz","vz");'>getResultAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("jz","wz");'>hasAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("jz","xz");'>hasParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("jz","yz");'>removeAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("jz","zz");'>setAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("jz","Az");'>setParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("jz","Bz");'>setResultAbstractType</a></div></div></div><div id='d_HN' class='de'><h1>Class <span class='n'>Reporter</span></h1><div class='re'></div><div class='ds'><pre>The reporter aggregates error reports that may happen during model
	construction and the different phases (dataflowing, typing, writing,
	etc).</pre></div></div><div id='d_Dz' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IOperation at 0x85d268c&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_iD' class='de'><h1>Method <span class='n'>_string</span></h1><div class='re'><code>_string( self, value )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_iE' class='de'><h1>Class <span class='n'>ModelException</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_iF' class='de'><h1>Method <span class='n'>definedBy</span></h1><div class='re'><code>definedBy( self, definition=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_iG' class='de'><h1>Method <span class='n'>clone</span></h1><div class='re'><code>clone( self, clone=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_iA' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><pre>Returns the dataflow accessible/bound to this element</pre></div></div><div id='d_iB' class='de'><h1>Method <span class='n'>removeAnnotation</span></h1><div class='re'><code>removeAnnotation( self, name )</code></div><div class='ds'><pre>Removes the annotations with the given name</pre></div></div><div id='d_iC' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IOperation at 0x85d268c&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_iL' class='de'><h1>Method <span class='n'>getCurrentModule</span></h1><div class='re'><code>getCurrentModule( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_iM' class='de'><h1>Method <span class='n'>run</span></h1><div class='re'><code>run( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_iN' class='de'><h1>Method <span class='n'>getCurrentDataFlow</span></h1><div class='re'><code>getCurrentDataFlow( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_iH' class='de'><h1>Class <span class='n'>Process</span></h1><div class='re'></div><div class='ds'><pre>A process generates values by processing (optional) arguments.</pre></div></div><div id='d_iI' class='de'><h1>Method <span class='n'>definedBy</span></h1><div class='re'><code>definedBy( self, definition=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_iJ' class='de'><h1>instance</h1><div class='re'></div><div class='ds'><pre>Symbolic types are types that have no physical counter part but play a
	role in the type system. This is for instance the case with Any or Nil.</pre></div></div><div id='d_iK' class='de'><h1>Method <span class='n'>findInContext</span></h1><div class='re'><code>findInContext( self, interface )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_it' class='de'><h1>Method <span class='n'>removeAnnotation</span></h1><div class='re'><code>removeAnnotation( self, name )</code></div><div class='ds'><pre>Removes the annotations with the given name</pre></div></div><div id='d_iu' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><pre>Detaches the element from its parent (in case it was already attached).
		This should return this element, and set the parent to None.</pre></div></div><div id='d_iv' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><pre>Returns this element parent</pre></div></div><div id='d_iw' class='de'><h1>Class <span class='n'>IMutator</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_ip' class='de'><h1>Method <span class='n'>getAnnotations</span></h1><div class='re'><code>getAnnotations( self, name=None )</code></div><div class='ds'><pre>Gets all the annotation with the given name associated to this element
		or all annotations if no name is specified.</pre></div></div><div id='d_iq' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><pre>Performs a deep clone of this element. Any mutation to the original won't
		change the copy.</pre></div></div><div id='d_ir' class='de'><h1>Method <span class='n'>getClassMethods</span></h1><div class='re'><code>getClassMethods( self )</code></div><div class='ds'><pre>Returns the class method defined within this class.</pre></div></div><div id='d_is' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><pre>Performs a deep clone of this element. Any mutation to the original won't
		change the copy.</pre></div></div><div id='d_ix' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><pre>Returns the arguments to this operation.</pre></div></div><div id='d_iy' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><pre>Returns the dataflow accessible/bound to this element</pre></div></div><div id='d_iz' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><pre>Returns the local name for this referencable element</pre></div></div><div id='d_id' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><pre>Adds an argument to this operation. This should do checking of
		arguments (by expected internal type and number).</pre></div></div><div id='d_ie' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><pre>Sets this element parent</pre></div></div><div id='d_if' class='de'><h1>Method <span class='n'>setParentClasses</span></h1><div class='re'><code>setParentClasses( self )</code></div><div class='ds'><pre>gives the list of parent classes that will</pre></div></div><div id='d_ig' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><pre>Sets the abstract type for this element</pre></div></div><div id='d_ib' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, context )</code></div><div class='ds'><pre>Sets the parent context for this context.</pre></div></div><div id='d_ic' class='de'><h1>Method <span class='n'>removeAnnotation</span></h1><div class='re'><code>removeAnnotation( self, name )</code></div><div class='ds'><pre>Removes the annotations with the given name</pre></div></div><div id='d_il' class='de'><h1>Method <span class='n'>addAnnotation</span></h1><div class='re'><code>addAnnotation( self, annotation )</code></div><div class='ds'><pre>Adds an annotation to this element</pre></div></div><div id='d_im' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><pre>Returns the dataflow accessible/bound to this element</pre></div></div><div id='d_in' class='de'><h1>Method <span class='n'>getOperations</span></h1><div class='re'><code>getOperations( self )</code></div><div class='ds'><pre>Returns the list of operations in this process.</pre></div></div><div id='d_io' class='de'><h1>Class <span class='n'>IImportOperation</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_ih' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><pre>Returns the ith arguments to this operation.</pre></div></div><div id='d_ii' class='de'><h1>Method <span class='n'>addAnnotation</span></h1><div class='re'><code>addAnnotation( self, annotation )</code></div><div class='ds'><pre>Adds an annotation to this element</pre></div></div><div id='d_ij' class='de'><h1>Method <span class='n'>getSlot</span></h1><div class='re'><code>getSlot( self, name )</code></div><div class='ds'><pre>Returns the given evaluable bound to named slot.</pre></div></div><div id='d_Df' class='de'><h1>Method <span class='n'>getAbsoluteName</span></h1><div class='re'><code>getAbsoluteName( self )</code></div><div class='ds'><pre>Returns the absolute name for this element</pre></div></div><div id='d_Dh' class='de'><h1>Method <span class='n'>getAnnotations</span></h1><div class='re'><code>getAnnotations( self, name=None )</code></div><div class='ds'><pre>Gets all the annotation with the given name associated to this element
		or all annotations if no name is specified.</pre></div></div><div id='d_Mx' class='de'><h1>Method <span class='n'>hasAnnotation</span></h1><div class='re'><code>hasAnnotation( self, name )</code></div><div class='ds'><pre>Tells if the given element has an annotation with the given name</pre></div></div><div id='d_My' class='de'><h1>Method <span class='n'>getModules</span></h1><div class='re'><code>getModules( self )</code></div><div class='ds'><pre>Returns the list of modules declared/imported in this program</pre></div></div><div id='d_Mz' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><pre>Returns the dataflow accessible/bound to this element</pre></div></div><div id='d_Mp' class='de'><h1>Method <span class='n'>getSlot</span></h1><div class='re'><code>getSlot( self, name )</code></div><div class='ds'><pre>Returns the given evaluable bound to named slot.</pre></div></div><div id='d_Mq' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><pre>Returns the dataflow accessible/bound to this element</pre></div></div><div id='d_Mr' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type for this element</pre></div></div><div id='d_Ms' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><pre>Returns this element parent</pre></div></div><div id='d_Mt' class='de'><h1>Method <span class='n'>getAnnotations</span></h1><div class='re'><code>getAnnotations( self, name=None )</code></div><div class='ds'><pre>Gets all the annotation with the given name associated to this element
		or all annotations if no name is specified.</pre></div></div><div id='d_Mu' class='de'><h1>Method <span class='n'>hasAnnotation</span></h1><div class='re'><code>hasAnnotation( self, name )</code></div><div class='ds'><pre>Tells if the given element has an annotation with the given name</pre></div></div><div id='d_Mv' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type for this element</pre></div></div><div id='d_Mw' class='de'><h1>Method <span class='n'>setSlot</span></h1><div class='re'><code>setSlot( self, name, evaluable )</code></div><div class='ds'><pre>Binds the given evaluable to the named slot. If there is already a slot
		with the same name, then 'getSlot(name)' should return the evaluable
		given as parameter.<br />		In the default implementation, setSlot preserves the ''history'' of
		added slots, and will always return the latest one.</pre></div></div><div id='d_Mh' class='de'><h1>Method <span class='n'>getSlots</span></h1><div class='re'><code>getSlots( self )</code></div><div class='ds'><pre>Returns (key, evaluable) pairs representing the slots within this
		context. In the case of context that may inherits slots, this only
		returns the slots that are owned by the context (ie. it does not
		include inherited slots)</pre></div></div><div id='d_Mi' class='de'><h1>Method <span class='n'>addOperation</span></h1><div class='re'><code>addOperation( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Mj' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><pre>Sets the abstract type for this element</pre></div></div><div id='d_Mk' class='de'><h1>Method <span class='n'>getAnnotations</span></h1><div class='re'><code>getAnnotations( self, name=None )</code></div><div class='ds'><pre>Gets all the annotation with the given name associated to this element
		or all annotations if no name is specified.</pre></div></div><div id='d_Ml' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><pre>Returns the dataflow accessible/bound to this element</pre></div></div><div id='d_Mm' class='de'><h1>Method <span class='n'>getSlotNames</span></h1><div class='re'><code>getSlotNames( self )</code></div><div class='ds'><pre>Returns the list of slot names (in order) for this context</pre></div></div><div id='d_Mn' class='de'><h1>Class <span class='n'>IImportModulesOperation</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Mo' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><pre>Returns the dataflow accessible/bound to this element</pre></div></div><div id='d_Mb' class='de'><h1>Method <span class='n'>addAnnotation</span></h1><div class='re'><code>addAnnotation( self, annotation )</code></div><div class='ds'><pre>Adds an annotation to this element</pre></div></div><div id='d_Mc' class='de'><h1>Method <span class='n'>getContent</span></h1><div class='re'><code>getContent( self )</code></div><div class='ds'><pre>Returns the content of this annotation.</pre></div></div><div id='d_Md' class='de'><h1>Method <span class='n'>endsWithTermination</span></h1><div class='re'><code>endsWithTermination( self )</code></div><div class='ds'><pre>Returns true if this function ends with a termination operation. This
		is especially useful for back-ends which want to know if they have to
		insert an explicit 'return' at the end (like Java).</pre></div></div><div id='d_Me' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><pre>Returns the *internal types* for this operations arguments. This is
		typically the list of interfaces or @protocols that the arguments must
		comply to.</pre></div></div><div id='d_Mf' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><pre>Performs a deep clone of this element. Any mutation to the original won't
		change the copy.</pre></div></div><div id='d_Mg' class='de'><h1>Class <span class='n'>IComment</span></h1><div class='re'></div><div class='ds'><pre>A comment is an annotation that can occur anywhere in a source file.</pre></div></div><div id='d_MH' class='de'><h1>Method <span class='n'>isLike</span></h1><div class='re'><code>isLike( self, otherType )</code></div><div class='ds'><pre>The other type is like this one if the other is a sequence with the
		same length and that all elements are like the corresponding elements of
		this sequence.</pre></div></div><div id='d_MI' class='de'><h1>Method <span class='n'>asString</span></h1><div class='re'><code>asString( self, fromType=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_MJ' class='de'><h1>Method <span class='n'>getProgram</span></h1><div class='re'><code>getProgram( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_MK' class='de'><h1>list</h1><div class='re'><code>['assert', 'access', 'car', 'cdr', 'cons', 'createMapFromItems', 'error', 'filter', 'getChildrenOf', 'getClass', 'getClasses', 'getClassOf', 'getMethod', 'getMethodOf', 'getParentClass', 'getSuperMethod', 'invoke', 'isDefined', 'isFunction', 'isIn', 'isInstance', 'isList', 'isMap', 'isString', 'iterate', 'len', 'map', 'print', 'range', 'reduce', 'slice', 'sliceArguments']</code></div><div class='ds'><pre>list() -&gt; new list
list(sequence) -&gt; new list initialized from sequence's items</pre></div></div><div id='d_ML' class='de'><h1>Method <span class='n'>getClassParents</span></h1><div class='re'><code>getClassParents( self, theClass )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_MM' class='de'><h1>Method <span class='n'>resolve</span></h1><div class='re'><code>resolve( self, referenceOrName, contextOrDataFlow=None )</code></div><div class='ds'><pre>Resolves the given 'IReference' or String sing the given context
		('IContext') or dataflow ('IDataFlow'). This usually requires that
		you've applied a pass to create the dataflow (see the
		'lambdafactory.resolution.BasicDataFlow' pass).</pre></div></div><div id='d_MN' class='de'><h1>Method <span class='n'>error</span></h1><div class='re'><code>error( self, *message )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_MA' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><pre>Sets the abstract type for this element</pre></div></div><div id='d_MB' class='de'><h1>Method <span class='n'>addAnnotation</span></h1><div class='re'><code>addAnnotation( self, annotation )</code></div><div class='ds'><pre>Adds an annotation to this element</pre></div></div><div id='d_MC' class='de'><h1>Method <span class='n'>hasAnnotation</span></h1><div class='re'><code>hasAnnotation( self, name )</code></div><div class='ds'><pre>Tells if the given element has an annotation with the given name</pre></div></div><div id='d_MD' class='de'><h1>Method <span class='n'>importModules</span></h1><div class='re'><code>importModules( self, names )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_ME' class='de'><h1>Method <span class='n'>getType</span></h1><div class='re'><code>getType( self, name )</code></div><div class='ds'><pre>Returns the type with the given name, or None if it does not
		exist.</pre></div></div><div id='d_MF' class='de'><h1>Method <span class='n'>subtype</span></h1><div class='re'><code>subtype( self, name )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_MG' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.typecast.Type at 0x40315c5c&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_LI' class='de'><h1>Method <span class='n'>__str__</span></h1><div class='re'><code>__str__( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='If' class='cr'><div class='n'><a href='javascript:dS("If");'>IClassMethod</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("If","Jf");'><span class='special __bases__'>IMethod</span></a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("If","Kf");'>addAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("If","Lf");'>addOperation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("If","Mf");'>copy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("If","Nf");'>detach</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("If","Of");'>endsWithTermination</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("If","Pf");'>getAbsoluteName</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("If","Qf");'>getAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("If","Rf");'>getAnnotations</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("If","Sf");'>getArguments</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("If","Tf");'>getDataFlow</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("If","Uf");'>getName</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("If","Vf");'>getOperations</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("If","Wf");'>getParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("If","Xf");'>getReturnTypeDescription</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("If","Yf");'>getSlot</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("If","Zf");'>getSlotNames</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("If","ag");'>getSlots</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("If","bg");'>hasAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("If","cg");'>hasExplicitTermination</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("If","dg");'>hasParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("If","eg");'>hasSlot</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("If","fg");'>isAbstract</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("If","gg");'>removeAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("If","hg");'>setAbstract</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("If","ig");'>setAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("If","jg");'>setArguments</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("If","kg");'>setParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("If","lg");'>setReturnTypeDescription</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("If","mg");'>setSlot</a></div></div></div><div id='d_LH' class='de'><h1>Method <span class='n'>extend</span></h1><div class='re'><code>extend( self, othertype )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='cl' class='cr'><div class='n'><a href='javascript:dS("cl");'>IEnumeration</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("cl","dl");'><span class='special __bases__'>IOperation</span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("cl","el");'>getEnd</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("cl","fl");'>getStart</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("cl","gl");'>getStep</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("cl","hl");'>setStep</a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("cl","il");'>addAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("cl","jl");'>addOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("cl","kl");'>copy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("cl","ll");'>detach</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("cl","ml");'>getAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("cl","nl");'>getAnnotations</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("cl","ol");'>getDataFlow</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("cl","pl");'>getOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("cl","ql");'>getOpArguments</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("cl","rl");'>getOpArgumentsInternalTypes</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("cl","sl");'>getParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("cl","tl");'>hasAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("cl","ul");'>hasParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("cl","vl");'>removeAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("cl","wl");'>setAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("cl","xl");'>setOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("cl","yl");'>setParent</a></div></div><div class='t'>Values</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&bull;</span><a href='javascript:dO("cl","zl");'>ARGS</a></div></div></div><div id='cd' class='cr'><div class='n'><a href='javascript:dS("cd");'>IAssignable</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("cd","c");'><span class='special __bases__'><i>Base class</i></span></a></div></div></div><div id='d_LM' class='de'><h1>Method <span class='n'>isIn</span></h1><div class='re'><code>isIn( self, interface )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_LL' class='de'><h1>Method <span class='n'>getClassAncestors</span></h1><div class='re'><code>getClassAncestors( self, theClass=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_LC' class='de'><h1>Method <span class='n'>getResultAbstractType</span></h1><div class='re'><code>getResultAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type of the result of the evaluation of this
		evaluable</pre></div></div><div id='cq' class='cr'><div class='n'><a href='javascript:dS("cq");'>IInstanciation</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("cq","dq");'><span class='special __bases__'>IOperation</span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("cq","eq");'>getArguments</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("cq","fq");'>getInstanciable</a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("cq","gq");'>addAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("cq","hq");'>addOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("cq","iq");'>copy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("cq","jq");'>detach</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("cq","kq");'>getAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("cq","lq");'>getAnnotations</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("cq","mq");'>getDataFlow</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("cq","nq");'>getOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("cq","oq");'>getOpArguments</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("cq","pq");'>getOpArgumentsInternalTypes</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("cq","qq");'>getParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("cq","rq");'>hasAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("cq","sq");'>hasParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("cq","tq");'>removeAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("cq","uq");'>setAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("cq","vq");'>setOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("cq","wq");'>setParent</a></div></div><div class='t'>Values</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&bull;</span><a href='javascript:dO("cq","xq");'>ARGS</a></div></div></div><div id='ob' class='cr'><div class='n'><a href='javascript:dS("ob");'>IAccessOperation</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("ob","pb");'><span class='special __bases__'>ISubsetOperation</span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ob","qb");'>getIndex</a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ob","rb");'>addAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ob","sb");'>addOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ob","tb");'>copy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ob","ub");'>detach</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ob","vb");'>getAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ob","wb");'>getAnnotations</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ob","xb");'>getDataFlow</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ob","yb");'>getOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ob","zb");'>getOpArguments</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ob","Ab");'>getOpArgumentsInternalTypes</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ob","Bb");'>getParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ob","Cb");'>getTarget</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ob","Db");'>hasAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ob","Eb");'>hasParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ob","Fb");'>removeAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ob","Gb");'>setAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ob","Hb");'>setOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ob","Ib");'>setParent</a></div></div><div class='t'>Values</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&bull;</span><a href='javascript:dO("ob","Jb");'>ARGS</a></div></div></div><div id='Nw' class='cr'><div class='n'><a href='javascript:dS("Nw");'>INumber</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("Nw","Ow");'><span class='special __bases__'>ILiteral</span></a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Nw","Pw");'>addAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Nw","Qw");'>copy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Nw","Rw");'>detach</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Nw","Sw");'>getAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Nw","Tw");'>getActualValue</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Nw","Uw");'>getAnnotations</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Nw","Vw");'>getDataFlow</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Nw","Ww");'>getParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Nw","Xw");'>getResultAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Nw","Yw");'>hasAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Nw","Zw");'>hasParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Nw","ax");'>removeAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Nw","bx");'>setAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Nw","cx");'>setParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Nw","dx");'>setResultAbstractType</a></div></div></div><div id='NE' class='cr'><div class='n'><a href='javascript:dS("NE");'>Runtime</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("NE","OE");'><span class='special __bases__'>TypeCollection</span></a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("NE","PE");'>getType</a></div></div></div><div id='NF' class='cr'><div class='n'><a href='javascript:dS("NF");'>Cell</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("NF","OF");'><span class='special __bases__'>Type</span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("NF","PF");'><span class='special __init__'>constructor</span></a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("NF","QF");'>asString</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("NF","RF");'>clone</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("NF","SF");'>isLike</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("NF","TF");'>isSameAs</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("NF","UF");'>isSubtypeOf</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("NF","VF");'>length</a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("NF","WF");'><span class='special __call__'>when invoked</span></a></div><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("NF","XF");'><span class='special __str__'>string conversion</span></a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("NF","YF");'>concreteType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("NF","ZF");'>definedBy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("NF","aG");'>name</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("NF","bG");'>result</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("NF","cG");'>setConcreteType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("NF","dG");'>setName</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("NF","eG");'>subtype</a></div></div></div><div id='d_fy' class='de'><h1>Method <span class='n'>getAbsoluteName</span></h1><div class='re'><code>getAbsoluteName( self )</code></div><div class='ds'><pre>Returns the absolute name for this element</pre></div></div><div id='d_fx' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IElement at 0x85c4e6c&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_fz' class='de'><h1>Class <span class='n'>IReferencable</span></h1><div class='re'></div><div class='ds'><pre>A referencable is an element that can be referenced either by id (it is
	unique and stable), or by a name (which is also not supposed to change).<br />	Types are good examples of referencables: they have an *absolute name* (like
	`Data.List`), but can also be bound to slots within contexts which give them
	"local names" (like `List := Data.List`)</pre></div></div><div id='d_fq' class='de'><h1>Method <span class='n'>getInstanciable</span></h1><div class='re'><code>getInstanciable( self )</code></div><div class='ds'><pre>Returns the instanciable used in this operation.</pre></div></div><div id='d_fp' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><pre>Performs a deep clone of this element. Any mutation to the original won't
		change the copy.</pre></div></div><div id='d_fs' class='de'><h1>Method <span class='n'>isByPositionOnly</span></h1><div class='re'><code>isByPositionOnly( self )</code></div><div class='ds'><pre>Tells if this invocation is only by position. Otherwise, some arguments
		are given by name, as list or as a map (and they should be handled in
		a specific way)</pre></div></div><div id='d_fr' class='de'><h1>Method <span class='n'>getAnnotations</span></h1><div class='re'><code>getAnnotations( self, name=None )</code></div><div class='ds'><pre>Gets all the annotation with the given name associated to this element
		or all annotations if no name is specified.</pre></div></div><div id='d_fu' class='de'><h1>Method <span class='n'>addAnnotation</span></h1><div class='re'><code>addAnnotation( self, annotation )</code></div><div class='ds'><pre>Adds an annotation to this element</pre></div></div><div id='d_ft' class='de'><h1>Method <span class='n'>getResultAbstractType</span></h1><div class='re'><code>getResultAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type of the result of the evaluation of this
		evaluable</pre></div></div><div id='d_fw' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><pre>Returns the local name for this referencable element</pre></div></div><div id='d_fv' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><pre>Returns the dataflow accessible/bound to this element</pre></div></div><div id='d_fi' class='de'><h1>Method <span class='n'>hasSlot</span></h1><div class='re'><code>hasSlot( self, name )</code></div><div class='ds'><pre>Tells if the context has a slot with the given name.</pre></div></div><div id='d_fh' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type for this element</pre></div></div><div id='d_fk' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><pre>Sets the abstract type for this element</pre></div></div><div id='d_fj' class='de'><h1>Method <span class='n'>getOperations</span></h1><div class='re'><code>getOperations( self )</code></div><div class='ds'><pre>Returns the list of operations in this process.</pre></div></div><div id='d_fm' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><pre>Detaches the element from its parent (in case it was already attached).
		This should return this element, and set the parent to None.</pre></div></div><div id='d_fl' class='de'><h1>Method <span class='n'>getStart</span></h1><div class='re'><code>getStart( self )</code></div><div class='ds'><pre>Returns this enumeration start.</pre></div></div><div id='d_fo' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><pre>Sets this element parent</pre></div></div><div id='d_fn' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type for this element</pre></div></div><div id='d_fc' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><pre>Tells if this element has a parent or not</pre></div></div><div id='d_fb' class='de'><h1>Method <span class='n'>removeAnnotation</span></h1><div class='re'><code>removeAnnotation( self, name )</code></div><div class='ds'><pre>Removes the annotations with the given name</pre></div></div><div id='d_fe' class='de'><h1>Method <span class='n'>setAbstract</span></h1><div class='re'><code>setAbstract( self, isAbstract )</code></div><div class='ds'><pre>Sets wether the given abstractable is abstract or not.</pre></div></div><div id='d_fd' class='de'><h1>Method <span class='n'>getAssignedValue</span></h1><div class='re'><code>getAssignedValue( self )</code></div><div class='ds'><pre>Returns this assigned evaluable.</pre></div></div><div id='d_fg' class='de'><h1>Method <span class='n'>isAbstract</span></h1><div class='re'><code>isAbstract( self )</code></div><div class='ds'><pre>Tells wether the given abstractable is abstract or not.</pre></div></div><div id='d_ff' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><pre>Returns this class name. It can be `None` if the class is anonymous.</pre></div></div><div id='d_fI' class='de'><h1>Method <span class='n'>__call__</span></h1><div class='re'><code>__call__( self )</code></div><div class='ds'><pre>A type instance can be used as a class to construct a new type, which
		will be cloned from the current type.</pre></div></div><div id='d_fH' class='de'><h1>Method <span class='n'>setConcreteType</span></h1><div class='re'><code>setConcreteType( self, value )</code></div><div class='ds'><pre>Sets the _concrete type_ for this abstract type. The concrete type
		is a value which represents the type. For instance, if this type
		represents a class, then the concrete type would be the class instance.</pre></div></div><div id='d_fK' class='de'><h1>Method <span class='n'>annotate</span></h1><div class='re'><code>annotate( self, value, name, content=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_fJ' class='de'><h1>Function <span class='n'>isSubtype</span></h1><div class='re'><code>isSubtype( a, b )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_fM' class='de'><h1>Method <span class='n'>resolveAbsolute</span></h1><div class='re'><code>resolveAbsolute( self, referenceOrName )</code></div><div class='ds'><pre>Resolves the given reference or string expressed in absolute style
		('.'-separated list of names), starting from the root dataflow (the program
		dataflow).</pre></div></div><div id='d_fL' class='de'><h1>Method <span class='n'>getCurrentElement</span></h1><div class='re'><code>getCurrentElement( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_fN' class='de'><h1>Method <span class='n'>getCurrentClassParents</span></h1><div class='re'><code>getCurrentClassParents( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_fA' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><pre>Detaches the element from its parent (in case it was already attached).
		This should return this element, and set the parent to None.</pre></div></div><div id='d_fC' class='de'><h1>Method <span class='n'>getLine</span></h1><div class='re'><code>getLine( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_ik' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IOperation at 0x85d268c&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_fE' class='de'><h1>wrapper_descriptor</h1><div class='re'></div><div class='ds'><pre>x.__str__() &lt;==&gt; str(x)</pre></div></div><div id='d_fD' class='de'><h1>Method <span class='n'>_param</span></h1><div class='re'><code>_param( self, name=None, value=None, asList=False, asMap=False )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_fG' class='de'><h1>Class <span class='n'>Context</span></h1><div class='re'></div><div class='ds'><pre>The Context type is the type that will probably be the most used in OO
	languages. A context can inherit from other contexts, in which case there is
	an explicit subtyping relationship.</pre></div></div><div id='d_fF' class='de'><h1>Method <span class='n'>asString</span></h1><div class='re'><code>asString( self, fromTypes=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_zm' class='de'><h1>Method <span class='n'>addAnnotation</span></h1><div class='re'><code>addAnnotation( self, annotation )</code></div><div class='ds'><pre>Adds an annotation to this element</pre></div></div><div id='d_zl' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.IEvaluable at 0x85c4f2c&gt;, &lt;class lambdafactory.interfaces.IEvaluable at 0x85c4f2c&gt;, &lt;class lambdafactory.interfaces.IEvaluable at 0x85c4f2c&gt;]</code></div><div class='ds'><pre>list() -&gt; new list
list(sequence) -&gt; new list initialized from sequence's items</pre></div></div><div id='d_zo' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><pre>Sets the given argument of this operation, by argument index.</pre></div></div><div id='d_zn' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><pre>Returns the dataflow accessible/bound to this element</pre></div></div><div id='d_zi' class='de'><h1>Method <span class='n'>defines</span></h1><div class='re'><code>defines( self, name )</code></div><div class='ds'><pre>Tells if this dataflow, or any of its child dataflows defines
		the given name (symbol)</pre></div></div><div id='d_zh' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><pre>Detaches the element from its parent (in case it was already attached).
		This should return this element, and set the parent to None.</pre></div></div><div id='d_zk' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><pre>Tells if this element has a parent or not</pre></div></div><div id='d_zj' class='de'><h1>Method <span class='n'>getItems</span></h1><div class='re'><code>getItems( self )</code></div><div class='ds'><pre>Returns the items contained in this dict</pre></div></div><div id='d_ze' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><pre>Sets the abstract type for this element</pre></div></div><div id='d_zd' class='de'><h1>Class <span class='n'>IAttribute</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_zg' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><pre>Returns the dataflow accessible/bound to this element</pre></div></div><div id='d_zf' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, context )</code></div><div class='ds'><pre>Sets the parent context for this context.</pre></div></div><div id='d_zc' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><pre>Returns the dataflow accessible/bound to this element</pre></div></div><div id='d_zb' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><pre>Returns the arguments to this operation.</pre></div></div><div id='d_zy' class='de'><h1>Method <span class='n'>getAnnotations</span></h1><div class='re'><code>getAnnotations( self, name=None )</code></div><div class='ds'><pre>Gets all the annotation with the given name associated to this element
		or all annotations if no name is specified.</pre></div></div><div id='d_zx' class='de'><h1>Method <span class='n'>getPriority</span></h1><div class='re'><code>getPriority( self )</code></div><div class='ds'><pre>Gets the priority for this operator</pre></div></div><div id='d_zz' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><pre>Sets the abstract type for this element</pre></div></div><div id='d_zu' class='de'><h1>Method <span class='n'>setProcess</span></h1><div class='re'><code>setProcess( self, v )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_zt' class='de'><h1>Method <span class='n'>removeAnnotation</span></h1><div class='re'><code>removeAnnotation( self, name )</code></div><div class='ds'><pre>Removes the annotations with the given name</pre></div></div><div id='d_zw' class='de'><h1>Method <span class='n'>getSlotNames</span></h1><div class='re'><code>getSlotNames( self )</code></div><div class='ds'><pre>Returns the list of slot names (in order) for this context</pre></div></div><div id='d_zv' class='de'><h1>Class <span class='n'>IModule</span></h1><div class='re'></div><div class='ds'><pre>Note that a module 'getName' function returns the module absolute name</pre></div></div><div id='d_zq' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IOperation at 0x85d268c&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_zp' class='de'><h1>Method <span class='n'>addOperation</span></h1><div class='re'><code>addOperation( self, operation )</code></div><div class='ds'><pre>Adds the given operation as a child of this process.</pre></div></div><div id='d_zs' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IOperation at 0x85d268c&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_zr' class='de'><h1>Method <span class='n'>isAbstract</span></h1><div class='re'><code>isAbstract( self )</code></div><div class='ds'><pre>Tells wether the given abstractable is abstract or not.</pre></div></div><div id='d_zM' class='de'><h1>Method <span class='n'>getCurrentContext</span></h1><div class='re'><code>getCurrentContext( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_zL' class='de'><h1>Method <span class='n'>walk</span></h1><div class='re'><code>walk( self, element )</code></div><div class='ds'><pre>Walks the given element, recursively walking the child elements when the
		handler does not return False</pre></div></div><div id='d_zN' class='de'><h1>Method <span class='n'>resolveLocalOrAbsolute</span></h1><div class='re'><code>resolveLocalOrAbsolute( self, referenceOrName, contextOrDataFlow=None )</code></div><div class='ds'><pre>Tries a local resolution first, then will look in the program scope if
		it fails.</pre></div></div><div id='d_zI' class='de'><h1>Method <span class='n'>isLike</span></h1><div class='re'><code>isLike( self, otherType )</code></div><div class='ds'><pre>Generic implementation of isLike. You should always call this method
		in subclasses, as it implements basic type systems rules such as
		isLike(Any).</pre></div></div><div id='d_zH' class='de'><h1>Method <span class='n'>definedBy</span></h1><div class='re'><code>definedBy( self, definition=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_zK' class='de'><h1>Method <span class='n'>getParentElement</span></h1><div class='re'><code>getParentElement( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_zJ' class='de'><h1>Method <span class='n'>getCurrentClassParents</span></h1><div class='re'><code>getCurrentClassParents( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_zE' class='de'><h1>Function <span class='n'>format</span></h1><div class='re'><code>format( *values )</code></div><div class='ds'><pre>Formats a combination of string ang tuples. Strings are joined by
	newlines, and the content of the inner tuples gets indented</pre></div></div><div id='d_zD' class='de'><h1>Method <span class='n'>createFunction</span></h1><div class='re'><code>createFunction( self, name, arguments=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_zG' class='de'><h1>Method <span class='n'>isSubtypeOf</span></h1><div class='re'><code>isSubtypeOf( self, otherType )</code></div><div class='ds'><pre>The other type is a subtype of this one if for each element of this
		type, we find that the other type has a subtype.</pre></div></div><div id='d_zF' class='de'><h1>Method <span class='n'>isLike</span></h1><div class='re'><code>isLike( self, otherType )</code></div><div class='ds'><pre>Othertype must be an Array with a content type that is the same type
		as the content type.</pre></div></div><div id='d_zA' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><pre>Adds an argument to this operation. This should do checking of
		arguments (by expected internal type and number).</pre></div></div><div id='d_zC' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><pre>Sets the given argument of this operation, by argument index.</pre></div></div><div id='d_zB' class='de'><h1>Method <span class='n'>getAnnotations</span></h1><div class='re'><code>getAnnotations( self, name=None )</code></div><div class='ds'><pre>Gets all the annotation with the given name associated to this element
		or all annotations if no name is specified.</pre></div></div><div id='d_DD' class='de'><h1>Method <span class='n'>createMutator</span></h1><div class='re'><code>createMutator( self, name, arguments=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_hG' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self, *args, **kwargs )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_hF' class='de'><h1>Method <span class='n'>concreteType</span></h1><div class='re'><code>concreteType( self )</code></div><div class='ds'><pre>Returns the _concrete type_ for this abstract type.</pre></div></div><div id='d_hE' class='de'><h1>member_descriptor</h1><div class='re'></div><div class='ds'><pre>exception message</pre></div></div><div id='d_hD' class='de'><h1>Method <span class='n'>_slot</span></h1><div class='re'><code>_slot( self, name, typeinfo=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_hC' class='de'><h1>Class <span class='n'>ITermination</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_hB' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><pre>Tells if this element has a parent or not</pre></div></div><div id='d_hA' class='de'><h1>Method <span class='n'>getAnnotations</span></h1><div class='re'><code>getAnnotations( self, name=None )</code></div><div class='ds'><pre>Gets all the annotation with the given name associated to this element
		or all annotations if no name is specified.</pre></div></div><div id='d_hN' class='de'><h1>Method <span class='n'>getCurrentContext</span></h1><div class='re'><code>getCurrentContext( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_hM' class='de'><h1>Method <span class='n'>resolveLocalOrAbsolute</span></h1><div class='re'><code>resolveLocalOrAbsolute( self, referenceOrName, contextOrDataFlow=None )</code></div><div class='ds'><pre>Tries a local resolution first, then will look in the program scope if
		it fails.</pre></div></div><div id='d_hL' class='de'><h1>Method <span class='n'>getCurrentMethod</span></h1><div class='re'><code>getCurrentMethod( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_hK' class='de'><h1>Method <span class='n'>filterContext</span></h1><div class='re'><code>filterContext( self, interface )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_hJ' class='de'><h1>instance</h1><div class='re'></div><div class='ds'><pre>Symbolic types are types that have no physical counter part but play a
	role in the type system. This is for instance the case with Any or Nil.</pre></div></div><div id='d_hI' class='de'><h1>Method <span class='n'>concreteType</span></h1><div class='re'><code>concreteType( self )</code></div><div class='ds'><pre>Returns the _concrete type_ for this abstract type.</pre></div></div><div id='d_hH' class='de'><h1>Method <span class='n'>subtype</span></h1><div class='re'><code>subtype( self, name )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_hw' class='de'><h1>Method <span class='n'>setDefaultValue</span></h1><div class='re'><code>setDefaultValue( self )</code></div><div class='ds'><pre>Sets the @methodault value for this attribute</pre></div></div><div id='d_hv' class='de'><h1>Method <span class='n'>getOperations</span></h1><div class='re'><code>getOperations( self )</code></div><div class='ds'><pre>Returns the list of operations in this process.</pre></div></div><div id='d_hu' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><pre>Performs a deep clone of this element. Any mutation to the original won't
		change the copy.</pre></div></div><div id='d_ht' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><pre>Tells if this element has a parent or not</pre></div></div><div id='d_hs' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><pre>Adds an argument to this operation. This should do checking of
		arguments (by expected internal type and number).</pre></div></div><div id='d_hr' class='de'><h1>Method <span class='n'>getClassAttributes</span></h1><div class='re'><code>getClassAttributes( self )</code></div><div class='ds'><pre>Returns the class attributes defined within this class.</pre></div></div><div id='d_hq' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><pre>Adds an argument to this operation. This should do checking of
		arguments (by expected internal type and number).</pre></div></div><div id='d_hp' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type for this element</pre></div></div><div id='d_hz' class='de'><h1>Method <span class='n'>getAbsoluteName</span></h1><div class='re'><code>getAbsoluteName( self )</code></div><div class='ds'><pre>Returns the absolute name for this element</pre></div></div><div id='d_hy' class='de'><h1>Method <span class='n'>getAnnotations</span></h1><div class='re'><code>getAnnotations( self, name=None )</code></div><div class='ds'><pre>Gets all the annotation with the given name associated to this element
		or all annotations if no name is specified.</pre></div></div><div id='d_hx' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><pre>Returns the ith arguments to this operation.</pre></div></div><div id='d_hg' class='de'><h1>Method <span class='n'>setAbstract</span></h1><div class='re'><code>setAbstract( self, isAbstract )</code></div><div class='ds'><pre>Sets wether the given abstractable is abstract or not.</pre></div></div><div id='d_hf' class='de'><h1>Method <span class='n'>getParentClassesRefs</span></h1><div class='re'><code>getParentClassesRefs( self )</code></div><div class='ds'><pre>Returns the list of inherited classes references. Note that they
		have to be interpreted in the class parent (a module)</pre></div></div><div id='d_he' class='de'><h1>Method <span class='n'>setArguments</span></h1><div class='re'><code>setArguments( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_hd' class='de'><h1>Method <span class='n'>addAnnotation</span></h1><div class='re'><code>addAnnotation( self, annotation )</code></div><div class='ds'><pre>Adds an annotation to this element</pre></div></div><div id='d_hc' class='de'><h1>Method <span class='n'>isAbstract</span></h1><div class='re'><code>isAbstract( self )</code></div><div class='ds'><pre>Tells wether the given abstractable is abstract or not.</pre></div></div><div id='d_hb' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><pre>Sets the abstract type for this element</pre></div></div><div id='d_ho' class='de'><h1>list</h1><div class='re'><code>['ImportedModuleNames']</code></div><div class='ds'><pre>list() -&gt; new list
list(sequence) -&gt; new list initialized from sequence's items</pre></div></div><div id='d_hn' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><pre>Returns the dataflow accessible/bound to this element</pre></div></div><div id='d_hm' class='de'><h1>Method <span class='n'>getAnnotations</span></h1><div class='re'><code>getAnnotations( self, name=None )</code></div><div class='ds'><pre>Gets all the annotation with the given name associated to this element
		or all annotations if no name is specified.</pre></div></div><div id='d_hl' class='de'><h1>Method <span class='n'>setStep</span></h1><div class='re'><code>setStep( self, value )</code></div><div class='ds'><pre>Sets this enumeration step</pre></div></div><div id='d_hk' class='de'><h1>Class <span class='n'>IEmbed</span></h1><div class='re'></div><div class='ds'><pre>An embedded operation represents a bit of verbatim code written in
	a different language. This allows for embedding code written specifically
	in a target language (which may happen for optimizing stuff, for instance).</pre></div></div><div id='d_hj' class='de'><h1>Method <span class='n'>getReturnTypeDescription</span></h1><div class='re'><code>getReturnTypeDescription( self )</code></div><div class='ds'><pre>Returns the return type description for this closure, if any</pre></div></div><div id='d_hi' class='de'><h1>Method <span class='n'>setSlot</span></h1><div class='re'><code>setSlot( self, name, evaluable )</code></div><div class='ds'><pre>Binds the given evaluable to the named slot. If there is already a slot
		with the same name, then 'getSlot(name)' should return the evaluable
		given as parameter.<br />		In the default implementation, setSlot preserves the ''history'' of
		added slots, and will always return the latest one.</pre></div></div><div id='d_hh' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><pre>Returns the dataflow accessible/bound to this element</pre></div></div><div id='th' class='cr'><div class='n'><a href='javascript:dS("th");'>IConstruct</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("th","c");'><span class='special __bases__'><i>Base class</i></span></a></div></div></div><div id='d_Z' class='de'><h1>Method <span class='n'>getSlotNames</span></h1><div class='re'><code>getSlotNames( self )</code></div><div class='ds'><pre>Returns the list of slot names (in order) for this context</pre></div></div><div id='d_Lz' class='de'><h1>Method <span class='n'>getAnnotations</span></h1><div class='re'><code>getAnnotations( self, name=None )</code></div><div class='ds'><pre>Gets all the annotation with the given name associated to this element
		or all annotations if no name is specified.</pre></div></div><div id='d_X' class='de'><h1>Method <span class='n'>getParentClassesRefs</span></h1><div class='re'><code>getParentClassesRefs( self )</code></div><div class='ds'><pre>Returns the list of inherited classes references. Note that they
		have to be interpreted in the class parent (a module)</pre></div></div><div id='d_Y' class='de'><h1>Method <span class='n'>getSlot</span></h1><div class='re'><code>getSlot( self, name )</code></div><div class='ds'><pre>Returns the given evaluable bound to named slot.</pre></div></div><div id='d_R' class='de'><h1>Method <span class='n'>getInheritedSlots</span></h1><div class='re'><code>getInheritedSlots( self )</code></div><div class='ds'><pre>gives the list of inherited slots</pre></div></div><div id='d_S' class='de'><h1>Method <span class='n'>getInstanceMethods</span></h1><div class='re'><code>getInstanceMethods( self )</code></div><div class='ds'><pre>Returns the instance methods defined within this class.</pre></div></div><div id='d_P' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><pre>Returns the dataflow accessible/bound to this element</pre></div></div><div id='d_Q' class='de'><h1>Method <span class='n'>getDestructors</span></h1><div class='re'><code>getDestructors( self )</code></div><div class='ds'><pre>Returns the destructors for this class</pre></div></div><div id='d_V' class='de'><h1>Method <span class='n'>getOperations</span></h1><div class='re'><code>getOperations( self )</code></div><div class='ds'><pre>Returns the operations (methods and class methods) defined within this class.</pre></div></div><div id='d_W' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><pre>Returns the parent context for this context (if any)</pre></div></div><div id='d_T' class='de'><h1>Method <span class='n'>getMethods</span></h1><div class='re'><code>getMethods( self )</code></div><div class='ds'><pre>Returns the methods defined within this class.</pre></div></div><div id='d_U' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><pre>Returns this class name. It can be `None` if the class is anonymous.</pre></div></div><div id='d_J' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type for this element</pre></div></div><div id='d_K' class='de'><h1>Method <span class='n'>getAnnotations</span></h1><div class='re'><code>getAnnotations( self, name=None )</code></div><div class='ds'><pre>Gets all the annotation with the given name associated to this element
		or all annotations if no name is specified.</pre></div></div><div id='d_H' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><pre>Detaches the element from its parent (in case it was already attached).
		This should return this element, and set the parent to None.</pre></div></div><div id='d_I' class='de'><h1>Method <span class='n'>getAbsoluteName</span></h1><div class='re'><code>getAbsoluteName( self )</code></div><div class='ds'><pre>Returns the absolute name for this element</pre></div></div><div id='d_N' class='de'><h1>Method <span class='n'>getClassMethods</span></h1><div class='re'><code>getClassMethods( self )</code></div><div class='ds'><pre>Returns the class method defined within this class.</pre></div></div><div id='d_O' class='de'><h1>Method <span class='n'>getConstructors</span></h1><div class='re'><code>getConstructors( self )</code></div><div class='ds'><pre>Returns the constructors for this class</pre></div></div><div id='d_L' class='de'><h1>Method <span class='n'>getAttributes</span></h1><div class='re'><code>getAttributes( self )</code></div><div class='ds'><pre>Returns the (non-class) attributes defined within this class.</pre></div></div><div id='d_M' class='de'><h1>Method <span class='n'>getClassAttributes</span></h1><div class='re'><code>getClassAttributes( self )</code></div><div class='ds'><pre>Returns the class attributes defined within this class.</pre></div></div><div id='d_Lc' class='de'><h1>Class <span class='n'>IAnnotation</span></h1><div class='re'></div><div class='ds'><pre>An annotation is some information that is not used for the actual
	program, but annotates/gives meta-information about is elements.</pre></div></div><div id='d_Lb' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IAttributeMethod at 0x85d253c&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_A' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><pre>Sets the abstract type for this element</pre></div></div><div id='d_F' class='de'><h1>Method <span class='n'>addAnnotation</span></h1><div class='re'><code>addAnnotation( self, annotation )</code></div><div class='ds'><pre>Adds an annotation to this element</pre></div></div><div id='d_Lf' class='de'><h1>Method <span class='n'>addOperation</span></h1><div class='re'><code>addOperation( self, operation )</code></div><div class='ds'><pre>Adds the given operation as a child of this process.</pre></div></div><div id='d_Le' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><pre>Returns the arguments to this operation.</pre></div></div><div id='d_E' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IClass at 0x85d232c&gt;, &lt;class lambdafactory.interfaces.IAbstractable at 0x85c4fbc&gt;)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_z' class='de'><h1>Method <span class='n'>removeAnnotation</span></h1><div class='re'><code>removeAnnotation( self, name )</code></div><div class='ds'><pre>Removes the annotations with the given name</pre></div></div><div id='d_x' class='de'><h1>Method <span class='n'>hasAnnotation</span></h1><div class='re'><code>hasAnnotation( self, name )</code></div><div class='ds'><pre>Tells if the given element has an annotation with the given name</pre></div></div><div id='d_y' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><pre>Tells if this element has a parent or not</pre></div></div><div id='d_r' class='de'><h1>Method <span class='n'>getAnnotations</span></h1><div class='re'><code>getAnnotations( self, name=None )</code></div><div class='ds'><pre>Gets all the annotation with the given name associated to this element
		or all annotations if no name is specified.</pre></div></div><div id='d_s' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><pre>Returns the dataflow accessible/bound to this element</pre></div></div><div id='d_p' class='de'><h1>Method <span class='n'>getAbsoluteName</span></h1><div class='re'><code>getAbsoluteName( self )</code></div><div class='ds'><pre>Returns the absolute name for this element</pre></div></div><div id='d_q' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type for this element</pre></div></div><div id='d_v' class='de'><h1>Method <span class='n'>getReferenceName</span></h1><div class='re'><code>getReferenceName( self )</code></div><div class='ds'><pre>Returns the name which this reference contains. The name is used by
		the resolution operation to actually resolve a value from the name.</pre></div></div><div id='d_w' class='de'><h1>Method <span class='n'>getResultAbstractType</span></h1><div class='re'><code>getResultAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type of the result of the evaluation of this
		evaluable</pre></div></div><div id='d_t' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><pre>Returns the local name for this referencable element</pre></div></div><div id='d_u' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><pre>Returns this element parent</pre></div></div><div id='d_j' class='de'><h1>int</h1><div class='re'></div><div class='ds'><pre>int(x[, base]) -&gt; integer<br />Convert a string or number to an integer, if possible.  A floating point
argument will be truncated towards zero (this does not include a string
representation of a floating point number!)  When converting a string, use
the optional base.  It is an error to supply a base when converting a
non-string. If the argument is outside the integer range a long object
will be returned instead.</pre></div></div><div id='d_k' class='de'><h1>Class <span class='n'>IAbsoluteReference</span></h1><div class='re'></div><div class='ds'><pre>An absolute reference is a specific kind of reference that does not
	necessarily resolve in the current context, but will rather use the program
	root context as a starting point.</pre></div></div><div id='d_h' class='de'><h1>str</h1><div class='re'><code>'__main__'</code></div><div class='ds'><pre>str(object) -&gt; string<br />Return a nice string representation of the object.
If the argument is a string, the return value is the same object.</pre></div></div><div id='d_i' class='de'><h1>str</h1><div class='re'><code>'__moduleinit__'</code></div><div class='ds'><pre>str(object) -&gt; string<br />Return a nice string representation of the object.
If the argument is a string, the return value is the same object.</pre></div></div><div id='d_n' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><pre>Performs a deep clone of this element. Any mutation to the original won't
		change the copy.</pre></div></div><div id='d_o' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><pre>Detaches the element from its parent (in case it was already attached).
		This should return this element, and set the parent to None.</pre></div></div><div id='d_l' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IReference at 0x85d214c&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_m' class='de'><h1>Method <span class='n'>addAnnotation</span></h1><div class='re'><code>addAnnotation( self, annotation )</code></div><div class='ds'><pre>Adds an annotation to this element</pre></div></div><div id='d_b' class='de'><h1>Class <span class='n'>Constants</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_c' class='de'><h1>tuple</h1><div class='re'><code>()</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_LA' class='de'><h1>Method <span class='n'>removeAnnotation</span></h1><div class='re'><code>removeAnnotation( self, name )</code></div><div class='ds'><pre>Removes the annotations with the given name</pre></div></div><div id='d_a' class='de'><h1>Module <span class='n'>lambdafactory.interfaces</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_f' class='de'><h1>str</h1><div class='re'><code>'__currentvalue__'</code></div><div class='ds'><pre>str(object) -&gt; string<br />Return a nice string representation of the object.
If the argument is a string, the return value is the same object.</pre></div></div><div id='d_g' class='de'><h1>str</h1><div class='re'><code>'__destroy__'</code></div><div class='ds'><pre>str(object) -&gt; string<br />Return a nice string representation of the object.
If the argument is a string, the return value is the same object.</pre></div></div><div id='d_d' class='de'><h1>str</h1><div class='re'><code>'__init__'</code></div><div class='ds'><pre>str(object) -&gt; string<br />Return a nice string representation of the object.
If the argument is a string, the return value is the same object.</pre></div></div><div id='d_e' class='de'><h1>str</h1><div class='re'><code>'__current__'</code></div><div class='ds'><pre>str(object) -&gt; string<br />Return a nice string representation of the object.
If the argument is a string, the return value is the same object.</pre></div></div><div id='EH' class='cr'><div class='n'><a href='javascript:dS("EH");'>SemanticError</a></div><div class='t'>Inhertied Values</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("EH","dE");'><span class='special __getitem__'>get item</span></a></div><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("EH","jE");'><span class='special __init__'>constructor</span></a></div><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("EH","eE");'><span class='special __repr__'>string repr</span></a></div><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("EH","fE");'><span class='special __str__'>string conversion</span></a></div><div class='slot documented'><span
					class='prefix'>&sdot;</span><a href='javascript:dO("EH","gE");'>args</a></div><div class='slot documented'><span
					class='prefix'>&sdot;</span><a href='javascript:dO("EH","hE");'>message</a></div></div></div><div id='d_ON' class='de'><h1>Method <span class='n'>info</span></h1><div class='re'><code>info( self, *message )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='Sx' class='cr'><div class='n'><a href='javascript:dS("Sx");'>IParameter</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("Sx","Tx");'><span class='special __bases__'>IElement, ISlot</span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Sx","Ux");'>getValue</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Sx","Vx");'>isAsList</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Sx","Wx");'>isAsMap</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Sx","Xx");'>isByName</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Sx","Yx");'>setAsList</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Sx","Zx");'>setAsMap</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Sx","ay");'>setByName</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Sx","by");'>setValue</a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Sx","cy");'>addAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Sx","dy");'>copy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Sx","ey");'>detach</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Sx","fy");'>getAbsoluteName</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Sx","gy");'>getAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Sx","hy");'>getAnnotations</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Sx","iy");'>getDataFlow</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Sx","jy");'>getName</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Sx","ky");'>getParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Sx","ly");'>getTypeDescription</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Sx","my");'>hasAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Sx","ny");'>hasParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Sx","oy");'>removeAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Sx","py");'>setAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Sx","qy");'>setParent</a></div></div></div><div id='Si' class='cr'><div class='n'><a href='javascript:dS("Si");'>IDestructor</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("Si","Ti");'><span class='special __bases__'>IMethod</span></a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Si","Ui");'>addAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Si","Vi");'>addOperation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Si","Wi");'>copy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Si","Xi");'>detach</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Si","Yi");'>endsWithTermination</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Si","Zi");'>getAbsoluteName</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Si","aj");'>getAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Si","bj");'>getAnnotations</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Si","cj");'>getArguments</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Si","dj");'>getDataFlow</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Si","ej");'>getName</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Si","fj");'>getOperations</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Si","gj");'>getParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Si","hj");'>getReturnTypeDescription</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Si","ij");'>getSlot</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Si","jj");'>getSlotNames</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Si","kj");'>getSlots</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Si","lj");'>hasAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Si","mj");'>hasExplicitTermination</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Si","nj");'>hasParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Si","oj");'>hasSlot</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Si","pj");'>isAbstract</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Si","qj");'>removeAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Si","rj");'>setAbstract</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Si","sj");'>setAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Si","tj");'>setArguments</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Si","uj");'>setParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Si","vj");'>setReturnTypeDescription</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Si","wj");'>setSlot</a></div></div></div><div id='SC' class='ro'><div class='n'><a href='javascript:dS("SC");'>lambdafactory.modelbase</a></div><div class='t'>Classes</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("SC","TC");'>Factory</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("SC","bE");'>ModelBadArgument</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("SC","iE");'>ModelException</a></div></div><div class='t'>Functions</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&lambda;</span><a href='javascript:dO("SC","kE");'>assertImplements</a></div></div></div><div id='d_kB' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><pre>Sets the given argument of this operation, by argument index.</pre></div></div><div id='d_kC' class='de'><h1>Method <span class='n'>addAnnotation</span></h1><div class='re'><code>addAnnotation( self, annotation )</code></div><div class='ds'><pre>Adds an annotation to this element</pre></div></div><div id='d_kA' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><pre>Returns the arguments to this operation.</pre></div></div><div id='d_kF' class='de'><h1>Method <span class='n'>extend</span></h1><div class='re'><code>extend( self, othertype )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_kG' class='de'><h1>Method <span class='n'>elements</span></h1><div class='re'><code>elements( self )</code></div><div class='ds'><pre>Returns a dict of the elements in this map.</pre></div></div><div id='d_kD' class='de'><h1>Method <span class='n'>allocate</span></h1><div class='re'><code>allocate( self, slot, value=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_kE' class='de'><h1>Function <span class='n'>assertImplements</span></h1><div class='re'><code>assertImplements( v, i )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_kJ' class='de'><h1>instance</h1><div class='re'></div><div class='ds'><pre>Symbolic types are types that have no physical counter part but play a
	role in the type system. This is for instance the case with Any or Nil.</pre></div></div><div id='d_kK' class='de'><h1>Method <span class='n'>getClassParents</span></h1><div class='re'><code>getClassParents( self, theClass )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_kH' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self, *args )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_VF' class='de'><h1>Method <span class='n'>length</span></h1><div class='re'><code>length( self )</code></div><div class='ds'><pre>Returns the length (in bytes) for this cell.</pre></div></div><div id='d_kN' class='de'><h1>Method <span class='n'>getCurrentFunction</span></h1><div class='re'><code>getCurrentFunction( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_kL' class='de'><h1>Method <span class='n'>getFactory</span></h1><div class='re'><code>getFactory( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_kM' class='de'><h1>Method <span class='n'>setPass</span></h1><div class='re'><code>setPass( self, programPass )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_kr' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><pre>Returns the dataflow accessible/bound to this element</pre></div></div><div id='d_ks' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type for this element</pre></div></div><div id='d_kp' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><pre>Returns the ith arguments to this operation.</pre></div></div><div id='d_kq' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type for this element</pre></div></div><div id='d_kv' class='de'><h1>Method <span class='n'>getSlot</span></h1><div class='re'><code>getSlot( self, name )</code></div><div class='ds'><pre>Returns the given evaluable bound to named slot.</pre></div></div><div id='d_kw' class='de'><h1>Method <span class='n'>addAnnotation</span></h1><div class='re'><code>addAnnotation( self, annotation )</code></div><div class='ds'><pre>Adds an annotation to this element</pre></div></div><div id='d_kt' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><pre>Sets this element parent</pre></div></div><div id='d_ku' class='de'><h1>Method <span class='n'>getAnnotations</span></h1><div class='re'><code>getAnnotations( self, name=None )</code></div><div class='ds'><pre>Gets all the annotation with the given name associated to this element
		or all annotations if no name is specified.</pre></div></div><div id='d_kz' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IValue at 0x85d202c&gt;, &lt;class lambdafactory.interfaces.IReferencable at 0x85c4efc&gt;)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_kx' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><pre>Sets the given argument of this operation, by argument index.</pre></div></div><div id='d_ky' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><pre>Returns this element parent</pre></div></div><div id='d_kb' class='de'><h1>Method <span class='n'>setSlot</span></h1><div class='re'><code>setSlot( self, name, evaluable )</code></div><div class='ds'><pre>Binds the given evaluable to the named slot. If there is already a slot
		with the same name, then 'getSlot(name)' should return the evaluable
		given as parameter.<br />		In the default implementation, setSlot preserves the ''history'' of
		added slots, and will always return the latest one.</pre></div></div><div id='d_kc' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><pre>Sets the abstract type for this element</pre></div></div><div id='d_kf' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><pre>Performs a deep clone of this element. Any mutation to the original won't
		change the copy.</pre></div></div><div id='d_kg' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><pre>Sets this element parent</pre></div></div><div id='d_kd' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><pre>Detaches the element from its parent (in case it was already attached).
		This should return this element, and set the parent to None.</pre></div></div><div id='d_ke' class='de'><h1>Method <span class='n'>setSlot</span></h1><div class='re'><code>setSlot( self, name, evaluable )</code></div><div class='ds'><pre>Binds the given evaluable to the named slot. If there is already a slot
		with the same name, then 'getSlot(name)' should return the evaluable
		given as parameter.<br />		In the default implementation, setSlot preserves the ''history'' of
		added slots, and will always return the latest one.</pre></div></div><div id='d_kj' class='de'><h1>Method <span class='n'>getSlots</span></h1><div class='re'><code>getSlots( self )</code></div><div class='ds'><pre>Returns (key, evaluable) pairs representing the slots within this
		context. In the case of context that may inherits slots, this only
		returns the slots that are owned by the context (ie. it does not
		include inherited slots)</pre></div></div><div id='d_kk' class='de'><h1>Method <span class='n'>getLanguage</span></h1><div class='re'><code>getLanguage( self )</code></div><div class='ds'><pre>Returns the language in which the emebedded code is written.</pre></div></div><div id='d_kh' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><pre>Returns the *internal types* for this operations arguments. This is
		typically the list of interfaces or @protocols that the arguments must
		comply to.</pre></div></div><div id='d_ki' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><pre>Detaches the element from its parent (in case it was already attached).
		This should return this element, and set the parent to None.</pre></div></div><div id='d_kn' class='de'><h1>Method <span class='n'>hasAnnotation</span></h1><div class='re'><code>hasAnnotation( self, name )</code></div><div class='ds'><pre>Tells if the given element has an annotation with the given name</pre></div></div><div id='d_ko' class='de'><h1>Method <span class='n'>addAnnotation</span></h1><div class='re'><code>addAnnotation( self, annotation )</code></div><div class='ds'><pre>Adds an annotation to this element</pre></div></div><div id='d_kl' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><pre>Performs a deep clone of this element. Any mutation to the original won't
		change the copy.</pre></div></div><div id='d_km' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><pre>Returns the arguments to this operation.</pre></div></div><div id='fz' class='cr'><div class='n'><a href='javascript:dS("fz");'>IReferencable</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("fz","gz");'><span class='special __bases__'>IAssignable</span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("fz","hz");'>getAbsoluteName</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("fz","iz");'>getName</a></div></div></div><div id='a' class='ro'><div class='n'><a href='javascript:dS("a");'>lambdafactory.interfaces</a></div><div class='t'>Classes</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","b");'>Constants</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","k");'>IAbsoluteReference</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","D");'>IAbstractClass</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","lb");'>IAbstractable</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","ob");'>IAccessOperation</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","Kb");'>IAccessor</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","pc");'>IAllocation</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","Lc");'>IAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","Pc");'>IArgument</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","cd");'>IAssignable</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","dd");'>IAssignation</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","zd");'>IAttribute</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","Gd");'>IAttributeMethod</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","le");'>IBlock</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","Be");'>IBreaking</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","Ve");'>IClass</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","Bf");'>IClassAttribute</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","If");'>IClassMethod</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","ng");'>IClosure</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","Mg");'>IComment</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","Rg");'>IComputation</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","th");'>IConstruct</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","uh");'>IConstructor</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","Zh");'>IContext</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","si");'>IDataFlow</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","Ki");'>IDataFlowOwner</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","Li");'>IDataFlowSlot</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","Si");'>IDestructor</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","xj");'>IDict</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","Pj");'>IDocumentation</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","Uj");'>IElement</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","hk");'>IEmbed</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","Fk");'>IEmbedTemplate</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","cl");'>IEnumeration</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","Al");'>IEvaluable</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","Dl");'>IEvaluation</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","Zl");'>IExcept</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","um");'>IFunction</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","Zm");'>IGroup</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","pn");'>IImportModuleOperation</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","Mn");'>IImportModulesOperation</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","io");'>IImportOperation</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","Bo");'>IImportSymbolOperation</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","Zo");'>IImportSymbolsOperation</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","wp");'>IInstanceMethod</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","bq");'>IInstanciable</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","cq");'>IInstanciation</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","yq");'>IInterception</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","Yq");'>IInterface</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","Gr");'>IInterruption</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","Zr");'>IInvocable</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","bs");'>IInvocation</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","ys");'>IIteration</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","Us");'>IList</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","mt");'>ILiteral</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","Dt");'>IMatchExpressionOperation</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","bu");'>IMatchOperation</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","wu");'>IMatchProcessOperation</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","Uu");'>IMethod</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","zv");'>IModule</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","bw");'>IModuleAttribute</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","iw");'>IMutator</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","Nw");'>INumber</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","ex");'>IOperation</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","xx");'>IOperator</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","Sx");'>IParameter</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","ry");'>IProcess</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","Hy");'>IProgram</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","fz");'>IReferencable</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","jz");'>IReference</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","Cz");'>IRepetition</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","Yz");'>IResolution</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","uA");'>ISelection</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","QA");'>ISliceOperation</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","nB");'>ISlot</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","sB");'>IString</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","JB");'>ISubsetOperation</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","dC");'>ISyntactic</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","hC");'>ITermination</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","CC");'>IValue</a></div></div></div><div id='fG' class='cr'><div class='n'><a href='javascript:dS("fG");'>Context</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("fG","gG");'><span class='special __bases__'>Map</span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("fG","hG");'><span class='special __init__'>constructor</span></a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("fG","iG");'>clone</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("fG","jG");'>element</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("fG","kG");'>elements</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("fG","lG");'>extends</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("fG","mG");'>fullName</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("fG","nG");'>parent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("fG","oG");'>parents</a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("fG","pG");'><span class='special __call__'>when invoked</span></a></div><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("fG","qG");'><span class='special __str__'>string conversion</span></a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("fG","rG");'>add</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("fG","sG");'>asString</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("fG","tG");'>concreteType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("fG","uG");'>definedBy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("fG","vG");'>elementNames</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("fG","wG");'>get</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("fG","xG");'>isLike</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("fG","yG");'>isSameAs</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("fG","zG");'>isSubtypeOf</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("fG","AG");'>name</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("fG","BG");'>result</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("fG","CG");'>set</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("fG","DG");'>setConcreteType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("fG","EG");'>setName</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("fG","FG");'>subtype</a></div></div></div><div id='yq' class='cr'><div class='n'><a href='javascript:dS("yq");'>IInterception</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("yq","zq");'><span class='special __bases__'>IOperation</span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("yq","Aq");'>getConclusion</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("yq","Bq");'>getIntercept</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("yq","Cq");'>getProcess</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("yq","Dq");'>setConclusion</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("yq","Eq");'>setIntercept</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("yq","Fq");'>setProcess</a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("yq","Gq");'>addAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("yq","Hq");'>addOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("yq","Iq");'>copy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("yq","Jq");'>detach</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("yq","Kq");'>getAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("yq","Lq");'>getAnnotations</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("yq","Mq");'>getDataFlow</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("yq","Nq");'>getOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("yq","Oq");'>getOpArguments</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("yq","Pq");'>getOpArgumentsInternalTypes</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("yq","Qq");'>getParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("yq","Rq");'>hasAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("yq","Sq");'>hasParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("yq","Tq");'>removeAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("yq","Uq");'>setAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("yq","Vq");'>setOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("yq","Wq");'>setParent</a></div></div><div class='t'>Values</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&bull;</span><a href='javascript:dO("yq","Xq");'>ARGS</a></div></div></div><div id='ys' class='cr'><div class='n'><a href='javascript:dS("ys");'>IIteration</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("ys","zs");'><span class='special __bases__'>IOperation</span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ys","As");'>getClosure</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ys","Bs");'>getIterator</a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ys","Cs");'>addAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ys","Ds");'>addOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ys","Es");'>copy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ys","Fs");'>detach</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ys","Gs");'>getAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ys","Hs");'>getAnnotations</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ys","Is");'>getDataFlow</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ys","Js");'>getOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ys","Ks");'>getOpArguments</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ys","Ls");'>getOpArgumentsInternalTypes</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ys","Ms");'>getParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ys","Ns");'>hasAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ys","Os");'>hasParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ys","Ps");'>removeAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ys","Qs");'>setAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ys","Rs");'>setOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ys","Ss");'>setParent</a></div></div><div class='t'>Values</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&bull;</span><a href='javascript:dO("ys","Ts");'>ARGS</a></div></div></div><div id='d_QL' class='de'><h1>Method <span class='n'>getCurrentClosure</span></h1><div class='re'><code>getCurrentClosure( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_QM' class='de'><h1>Method <span class='n'>run</span></h1><div class='re'><code>run( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_QN' class='de'><h1>Method <span class='n'>onError</span></h1><div class='re'><code>onError( self, callback )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_QH' class='de'><h1>Method <span class='n'>__call__</span></h1><div class='re'><code>__call__( self )</code></div><div class='ds'><pre>A type instance can be used as a class to construct a new type, which
		will be cloned from the current type.</pre></div></div><div id='d_QI' class='de'><h1>Method <span class='n'>isLike</span></h1><div class='re'><code>isLike( self, otherType )</code></div><div class='ds'><pre>Generic implementation of isLike. You should always call this method
		in subclasses, as it implements basic type systems rules such as
		isLike(Any).</pre></div></div><div id='d_QJ' class='de'><h1>Method <span class='n'>resolve</span></h1><div class='re'><code>resolve( self, referenceOrName, contextOrDataFlow=None )</code></div><div class='ds'><pre>Resolves the given 'IReference' or String sing the given context
		('IContext') or dataflow ('IDataFlow'). This usually requires that
		you've applied a pass to create the dataflow (see the
		'lambdafactory.resolution.BasicDataFlow' pass).</pre></div></div><div id='d_QK' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.passes.Pass at 0x857b20c&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_QD' class='de'><h1>Method <span class='n'>intercept</span></h1><div class='re'><code>intercept( self, tryProcess, catchProcess=None, finallyProcess=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_QE' class='de'><h1>Class <span class='n'>Structure</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_QF' class='de'><h1>Method <span class='n'>asString</span></h1><div class='re'><code>asString( self, fromType=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_QG' class='de'><h1>Method <span class='n'>clone</span></h1><div class='re'><code>clone( self, clone=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_QA' class='de'><h1>Class <span class='n'>ISliceOperation</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_QB' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type for this element</pre></div></div><div id='d_QC' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><pre>Sets this element parent</pre></div></div><div id='d_Qx' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><pre>Sets this element parent</pre></div></div><div id='d_Qy' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><pre>Detaches the element from its parent (in case it was already attached).
		This should return this element, and set the parent to None.</pre></div></div><div id='d_Qz' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><pre>Returns this element parent</pre></div></div><div id='d_Qt' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><pre>Returns the *internal types* for this operations arguments. This is
		typically the list of interfaces or @protocols that the arguments must
		comply to.</pre></div></div><div id='d_Qu' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><pre>Sets the given argument of this operation, by argument index.</pre></div></div><div id='d_Qv' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><pre>Returns the parent context for this context (if any)</pre></div></div><div id='d_Qw' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><pre>Performs a deep clone of this element. Any mutation to the original won't
		change the copy.</pre></div></div><div id='d_Qp' class='de'><h1>Method <span class='n'>hasExplicitTermination</span></h1><div class='re'><code>hasExplicitTermination( self )</code></div><div class='ds'><pre>Returns true if this function has an operation with a termination,
		otherwise return false.</pre></div></div><div id='d_Qq' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><pre>Returns this element parent</pre></div></div><div id='d_Qr' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><pre>Returns the arguments to this operation.</pre></div></div><div id='d_Qs' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><pre>Sets the abstract type for this element</pre></div></div><div id='d_Ql' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><pre>Returns this element parent</pre></div></div><div id='d_Qm' class='de'><h1>Method <span class='n'>hasSlot</span></h1><div class='re'><code>hasSlot( self, name )</code></div><div class='ds'><pre>Tells if the context has a slot with the given name.</pre></div></div><div id='d_Qn' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><pre>Adds an argument to this operation. This should do checking of
		arguments (by expected internal type and number).</pre></div></div><div id='d_Qo' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><pre>Returns this element parent</pre></div></div><div id='d_Qh' class='de'><h1>Method <span class='n'>hasSlot</span></h1><div class='re'><code>hasSlot( self, name )</code></div><div class='ds'><pre>Tells if the context has a slot with the given name.</pre></div></div><div id='d_Qi' class='de'><h1>Method <span class='n'>getOrigin</span></h1><div class='re'><code>getOrigin( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Qj' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IAnnotation at 0x85c4d1c&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_Qk' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><pre>Returns the ith arguments to this operation.</pre></div></div><div id='d_Qd' class='de'><h1>Method <span class='n'>getArguments</span></h1><div class='re'><code>getArguments( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Qe' class='de'><h1>Method <span class='n'>removeAnnotation</span></h1><div class='re'><code>removeAnnotation( self, name )</code></div><div class='ds'><pre>Removes the annotations with the given name</pre></div></div><div id='d_Qf' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type for this element</pre></div></div><div id='d_Qg' class='de'><h1>Method <span class='n'>setContent</span></h1><div class='re'><code>setContent( self, content )</code></div><div class='ds'><pre>Updates the content of this annotation.</pre></div></div><div id='d_Qb' class='de'><h1>Method <span class='n'>endsWithTermination</span></h1><div class='re'><code>endsWithTermination( self )</code></div><div class='ds'><pre>Returns true if this function ends with a termination operation. This
		is especially useful for back-ends which want to know if they have to
		insert an explicit 'return' at the end (like Java).</pre></div></div><div id='d_Qc' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.ISlot at 0x85d21dc&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_OF' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.typecast.Type at 0x40315c5c&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_OG' class='de'><h1>Method <span class='n'>add</span></h1><div class='re'><code>add( self, name, theType )</code></div><div class='ds'><pre>This is a *deprecated* methods that is simply an alias for 'Map.set'.</pre></div></div><div id='d_OD' class='de'><h1>Method <span class='n'>importSymbols</span></h1><div class='re'><code>importSymbols( self, names, origin )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_OE' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.modeltypes.TypeCollection at 0x40315adc&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_OB' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><pre>Performs a deep clone of this element. Any mutation to the original won't
		change the copy.</pre></div></div><div id='d_OC' class='de'><h1>Method <span class='n'>removeAnnotation</span></h1><div class='re'><code>removeAnnotation( self, name )</code></div><div class='ds'><pre>Removes the annotations with the given name</pre></div></div><div id='d_OA' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><pre>Sets this element parent</pre></div></div><div id='EE' class='cr'><div class='n'><a href='javascript:dS("EE");'>Behaviour</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("EE","FE");'><span class='special __bases__'>TypeCollection</span></a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("EE","GE");'>getType</a></div></div></div><div id='d_OL' class='de'><h1>Method <span class='n'>getCurrentClassAncestors</span></h1><div class='re'><code>getCurrentClassAncestors( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_OM' class='de'><h1>Method <span class='n'>resolveAbsoluteOrLocal</span></h1><div class='re'><code>resolveAbsoluteOrLocal( self, referenceOrName, contextOrDataFlow=None )</code></div><div class='ds'><pre>Tries an absolute resolution first, then will look in the local scope if
		it fails.</pre></div></div><div id='d_OJ' class='de'><h1>Method <span class='n'>hasParentElement</span></h1><div class='re'><code>hasParentElement( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_OK' class='de'><h1>str</h1><div class='re'><code>'GlobalRuntime'</code></div><div class='ds'><pre>str(object) -&gt; string<br />Return a nice string representation of the object.
If the argument is a string, the return value is the same object.</pre></div></div><div id='d_OH' class='de'><h1>Method <span class='n'>isSubtypeOf</span></h1><div class='re'><code>isSubtypeOf( self, otherType )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_OI' class='de'><h1>Method <span class='n'>concreteType</span></h1><div class='re'><code>concreteType( self )</code></div><div class='ds'><pre>Returns the _concrete type_ for this abstract type.</pre></div></div><div id='d_Of' class='de'><h1>Method <span class='n'>endsWithTermination</span></h1><div class='re'><code>endsWithTermination( self )</code></div><div class='ds'><pre>Returns true if this function ends with a termination operation. This
		is especially useful for back-ends which want to know if they have to
		insert an explicit 'return' at the end (like Java).</pre></div></div><div id='d_Og' class='de'><h1>Method <span class='n'>getContent</span></h1><div class='re'><code>getContent( self )</code></div><div class='ds'><pre>Returns the content of this annotation.</pre></div></div><div id='d_Od' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type for this element</pre></div></div><div id='d_Oe' class='de'><h1>Method <span class='n'>hasAnnotation</span></h1><div class='re'><code>hasAnnotation( self, name )</code></div><div class='ds'><pre>Tells if the given element has an annotation with the given name</pre></div></div><div id='d_Ob' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><pre>Performs a deep clone of this element. Any mutation to the original won't
		change the copy.</pre></div></div><div id='d_Oc' class='de'><h1>Method <span class='n'>setContent</span></h1><div class='re'><code>setContent( self, content )</code></div><div class='ds'><pre>Updates the content of this annotation.</pre></div></div><div id='d_On' class='de'><h1>Method <span class='n'>getImportedModuleNames</span></h1><div class='re'><code>getImportedModuleNames( self )</code></div><div class='ds'><pre>Returns the list of names representing the modules to load</pre></div></div><div id='d_Oo' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><pre>Returns the arguments to this operation.</pre></div></div><div id='d_Ol' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><pre>Returns the arguments to this operation.</pre></div></div><div id='d_Om' class='de'><h1>Method <span class='n'>hasAnnotation</span></h1><div class='re'><code>hasAnnotation( self, name )</code></div><div class='ds'><pre>Tells if the given element has an annotation with the given name</pre></div></div><div id='d_Oj' class='de'><h1>Method <span class='n'>setResultAbstractType</span></h1><div class='re'><code>setResultAbstractType( self, abstractType )</code></div><div class='ds'><pre>Sets the abstract type for this operation result. This is usually
		invoked in the typing phase.</pre></div></div><div id='d_Ok' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><pre>Returns the dataflow accessible/bound to this element</pre></div></div><div id='d_Oh' class='de'><h1>Method <span class='n'>hasExplicitTermination</span></h1><div class='re'><code>hasExplicitTermination( self )</code></div><div class='ds'><pre>Returns true if this function has an operation with a termination,
		otherwise return false.</pre></div></div><div id='d_Oi' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Ov' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><pre>Returns the dataflow accessible/bound to this element</pre></div></div><div id='d_Ow' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.ILiteral at 0x85d205c&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_Ot' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><pre>Returns the ith arguments to this operation.</pre></div></div><div id='d_Ou' class='de'><h1>Method <span class='n'>removeAnnotation</span></h1><div class='re'><code>removeAnnotation( self, name )</code></div><div class='ds'><pre>Removes the annotations with the given name</pre></div></div><div id='d_Or' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><pre>Returns the dataflow accessible/bound to this element</pre></div></div><div id='d_Os' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><pre>Tells if this element has a parent or not</pre></div></div><div id='d_Op' class='de'><h1>Method <span class='n'>getSlots</span></h1><div class='re'><code>getSlots( self )</code></div><div class='ds'><pre>Returns (key, evaluable) pairs representing the slots within this
		context. In the case of context that may inherits slots, this only
		returns the slots that are owned by the context (ie. it does not
		include inherited slots)</pre></div></div><div id='d_Oq' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><pre>Returns the arguments to this operation.</pre></div></div><div id='d_Oz' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><pre>Returns the arguments to this operation.</pre></div></div><div id='d_Ox' class='de'><h1>Method <span class='n'>removeAnnotation</span></h1><div class='re'><code>removeAnnotation( self, name )</code></div><div class='ds'><pre>Removes the annotations with the given name</pre></div></div><div id='d_Oy' class='de'><h1>Method <span class='n'>addAnnotation</span></h1><div class='re'><code>addAnnotation( self, annotation )</code></div><div class='ds'><pre>Adds an annotation to this element</pre></div></div><div id='b' class='cr'><div class='n'><a href='javascript:dS("b");'>Constants</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("b","c");'><span class='special __bases__'><i>Base class</i></span></a></div></div><div class='t'>Values</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&sdot;</span><a href='javascript:dO("b","d");'>Constructor</a></div><div class='slot documented'><span
					class='prefix'>&sdot;</span><a href='javascript:dO("b","e");'>CurrentModule</a></div><div class='slot documented'><span
					class='prefix'>&sdot;</span><a href='javascript:dO("b","f");'>CurrentValue</a></div><div class='slot documented'><span
					class='prefix'>&sdot;</span><a href='javascript:dO("b","g");'>Destructor</a></div><div class='slot documented'><span
					class='prefix'>&sdot;</span><a href='javascript:dO("b","h");'>MainFunction</a></div><div class='slot documented'><span
					class='prefix'>&sdot;</span><a href='javascript:dO("b","i");'>ModuleInit</a></div><div class='slot documented'><span
					class='prefix'>&bull;</span><a href='javascript:dO("b","j");'>PARENS_PRIORITY</a></div></div></div><div id='JB' class='cr'><div class='n'><a href='javascript:dS("JB");'>ISubsetOperation</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("JB","KB");'><span class='special __bases__'>IOperation</span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("JB","LB");'>getTarget</a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("JB","MB");'>addAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("JB","NB");'>addOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("JB","OB");'>copy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("JB","PB");'>detach</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("JB","QB");'>getAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("JB","RB");'>getAnnotations</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("JB","SB");'>getDataFlow</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("JB","TB");'>getOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("JB","UB");'>getOpArguments</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("JB","VB");'>getOpArgumentsInternalTypes</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("JB","WB");'>getParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("JB","XB");'>hasAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("JB","YB");'>hasParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("JB","ZB");'>removeAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("JB","aC");'>setAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("JB","bC");'>setOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("JB","cC");'>setParent</a></div></div></div><div id='d_jM' class='de'><h1>Method <span class='n'>setEnvironment</span></h1><div class='re'><code>setEnvironment( self, environment )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_jL' class='de'><h1>Method <span class='n'>getCurrentProcess</span></h1><div class='re'><code>getCurrentProcess( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_jN' class='de'><h1>Method <span class='n'>getCurrentElement</span></h1><div class='re'><code>getCurrentElement( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_jI' class='de'><h1>Method <span class='n'>isLike</span></h1><div class='re'><code>isLike( self, otherType )</code></div><div class='ds'><pre>Generic implementation of isLike. You should always call this method
		in subclasses, as it implements basic type systems rules such as
		isLike(Any).</pre></div></div><div id='d_jH' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.typecast.Type at 0x40315c5c&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_jK' class='de'><h1>Method <span class='n'>getClassAncestors</span></h1><div class='re'><code>getClassAncestors( self, theClass=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_jJ' class='de'><h1>instance</h1><div class='re'></div><div class='ds'><pre>Symbolic types are types that have no physical counter part but play a
	role in the type system. This is for instance the case with Any or Nil.</pre></div></div><div id='d_jE' class='de'><h1>wrapper_descriptor</h1><div class='re'></div><div class='ds'><pre>x.__init__(...) initializes x; see x.__class__.__doc__ for signature</pre></div></div><div id='d_jD' class='de'><h1>Method <span class='n'>access</span></h1><div class='re'><code>access( self, target, _index )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_jG' class='de'><h1>Method <span class='n'>element</span></h1><div class='re'><code>element( self, key )</code></div><div class='ds'><pre>Returns the element associated with the given key, or 'None' if it
		does not exist.</pre></div></div><div id='d_jF' class='de'><h1>Method <span class='n'>elements</span></h1><div class='re'><code>elements( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_jA' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><pre>Returns the ith arguments to this operation.</pre></div></div><div id='d_jC' class='de'><h1>Method <span class='n'>getReturnedEvaluable</span></h1><div class='re'><code>getReturnedEvaluable( self )</code></div><div class='ds'><pre>Returns the termination return evaluable.</pre></div></div><div id='d_jB' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><pre>Sets the abstract type for this element</pre></div></div><div id='d_jy' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><pre>Returns the local name for this referencable element</pre></div></div><div id='d_jx' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><pre>Returns the *internal types* for this operations arguments. This is
		typically the list of interfaces or @protocols that the arguments must
		comply to.</pre></div></div><div id='d_jz' class='de'><h1>Class <span class='n'>IReference</span></h1><div class='re'></div><div class='ds'><pre>A reference is a name that can be converted into a value using a
	resolution operation (for instance).</pre></div></div><div id='d_ju' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type for this element</pre></div></div><div id='d_jt' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><pre>Sets the abstract type for this element</pre></div></div><div id='d_jw' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IAttributeMethod at 0x85d253c&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_jv' class='de'><h1>Method <span class='n'>getReturnTypeDescription</span></h1><div class='re'><code>getReturnTypeDescription( self )</code></div><div class='ds'><pre>Returns the return type description for this closure, if any</pre></div></div><div id='d_jq' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><pre>Detaches the element from its parent (in case it was already attached).
		This should return this element, and set the parent to None.</pre></div></div><div id='d_jp' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><pre>Returns the dataflow accessible/bound to this element</pre></div></div><div id='d_js' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><pre>Detaches the element from its parent (in case it was already attached).
		This should return this element, and set the parent to None.</pre></div></div><div id='d_jr' class='de'><h1>Method <span class='n'>getConstructors</span></h1><div class='re'><code>getConstructors( self )</code></div><div class='ds'><pre>Returns the constructors for this class</pre></div></div><div id='d_jm' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><pre>Returns the ith arguments to this operation.</pre></div></div><div id='d_jl' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><pre>Adds an argument to this operation. This should do checking of
		arguments (by expected internal type and number).</pre></div></div><div id='d_jo' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IOperation at 0x85d268c&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_jn' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><pre>Returns this element parent</pre></div></div><div id='d_ji' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><pre>Performs a deep clone of this element. Any mutation to the original won't
		change the copy.</pre></div></div><div id='d_jh' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><pre>Returns the arguments to this operation.</pre></div></div><div id='d_jk' class='de'><h1>Method <span class='n'>getCode</span></h1><div class='re'><code>getCode( self )</code></div><div class='ds'><pre>Returns the embedded code string.</pre></div></div><div id='d_jj' class='de'><h1>Method <span class='n'>getSlotNames</span></h1><div class='re'><code>getSlotNames( self )</code></div><div class='ds'><pre>Returns the list of slot names (in order) for this context</pre></div></div><div id='d_je' class='de'><h1>Method <span class='n'>setReturnTypeDescription</span></h1><div class='re'><code>setReturnTypeDescription( self, description )</code></div><div class='ds'><pre>Sets the return type description for this closure, if any</pre></div></div><div id='d_jd' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><pre>Performs a deep clone of this element. Any mutation to the original won't
		change the copy.</pre></div></div><div id='d_jg' class='de'><h1>Method <span class='n'>setArguments</span></h1><div class='re'><code>setArguments( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_jf' class='de'><h1>Method <span class='n'>addAnnotation</span></h1><div class='re'><code>addAnnotation( self, annotation )</code></div><div class='ds'><pre>Adds an annotation to this element</pre></div></div><div id='d_jc' class='de'><h1>Method <span class='n'>setAbstract</span></h1><div class='re'><code>setAbstract( self, isAbstract )</code></div><div class='ds'><pre>Sets wether the given abstractable is abstract or not.</pre></div></div><div id='d_jb' class='de'><h1>Method <span class='n'>setParentClasses</span></h1><div class='re'><code>setParentClasses( self )</code></div><div class='ds'><pre>gives the list of parent classes that will</pre></div></div><div id='d_NA' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><pre>Sets the given argument of this operation, by argument index.</pre></div></div><div id='d_NC' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><pre>Tells if this element has a parent or not</pre></div></div><div id='d_NB' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><pre>Adds an argument to this operation. This should do checking of
		arguments (by expected internal type and number).</pre></div></div><div id='d_NE' class='de'><h1>Class <span class='n'>Runtime</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_ND' class='de'><h1>Method <span class='n'>importSymbol</span></h1><div class='re'><code>importSymbol( self, name, origin, alias )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_NG' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self, **kwargs )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_NF' class='de'><h1>Class <span class='n'>Cell</span></h1><div class='re'></div><div class='ds'><pre>A cell type represents a memory unit. It has a size (in bytes) the
	represents the length in memory.</pre></div></div><div id='d_NI' class='de'><h1>Method <span class='n'>clone</span></h1><div class='re'><code>clone( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_NH' class='de'><h1>Method <span class='n'>isSameAs</span></h1><div class='re'><code>isSameAs( self, otherType )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_NK' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.IProgram at 0x85d23ec&gt;, &lt;class lambdafactory.interfaces.IModule at 0x85d23bc&gt;]</code></div><div class='ds'><pre>list() -&gt; new list
list(sequence) -&gt; new list initialized from sequence's items</pre></div></div><div id='d_NJ' class='de'><h1>Method <span class='n'>handle</span></h1><div class='re'><code>handle( self, element )</code></div><div class='ds'><pre>Handles a sungle element, without recursing through its children</pre></div></div><div id='d_NM' class='de'><h1>Method <span class='n'>resolveAbsolute</span></h1><div class='re'><code>resolveAbsolute( self, referenceOrName )</code></div><div class='ds'><pre>Resolves the given reference or string expressed in absolute style
		('.'-separated list of names), starting from the root dataflow (the program
		dataflow).</pre></div></div><div id='d_NL' class='de'><h1>Method <span class='n'>getCurrentClass</span></h1><div class='re'><code>getCurrentClass( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_NN' class='de'><h1>Method <span class='n'>indent</span></h1><div class='re'><code>indent( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Nc' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><pre>Returns the name of this annotation.</pre></div></div><div id='d_Nb' class='de'><h1>Method <span class='n'>addOperation</span></h1><div class='re'><code>addOperation( self, operation )</code></div><div class='ds'><pre>Adds the given operation as a child of this process.</pre></div></div><div id='d_Ne' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><pre>Returns this element parent</pre></div></div><div id='d_Nd' class='de'><h1>Method <span class='n'>getAbsoluteName</span></h1><div class='re'><code>getAbsoluteName( self )</code></div><div class='ds'><pre>Returns the absolute name for this element</pre></div></div><div id='d_Ng' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IAnnotation at 0x85c4d1c&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_Nf' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><pre>Detaches the element from its parent (in case it was already attached).
		This should return this element, and set the parent to None.</pre></div></div><div id='d_Ni' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Nh' class='de'><h1>Method <span class='n'>hasAnnotation</span></h1><div class='re'><code>hasAnnotation( self, name )</code></div><div class='ds'><pre>Tells if the given element has an annotation with the given name</pre></div></div><div id='d_Nk' class='de'><h1>Method <span class='n'>getCode</span></h1><div class='re'><code>getCode( self )</code></div><div class='ds'><pre>Returns the embedded code string.</pre></div></div><div id='d_Nj' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><pre>Sets this element parent</pre></div></div><div id='d_Nm' class='de'><h1>Method <span class='n'>getSlots</span></h1><div class='re'><code>getSlots( self )</code></div><div class='ds'><pre>Returns (key, evaluable) pairs representing the slots within this
		context. In the case of context that may inherits slots, this only
		returns the slots that are owned by the context (ie. it does not
		include inherited slots)</pre></div></div><div id='d_Nl' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><pre>Returns the ith arguments to this operation.</pre></div></div><div id='d_No' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><pre>Returns the ith arguments to this operation.</pre></div></div><div id='d_Nn' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IImportOperation at 0x85d26bc&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_Nq' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><pre>Returns the ith arguments to this operation.</pre></div></div><div id='d_Np' class='de'><h1>Method <span class='n'>getSlotNames</span></h1><div class='re'><code>getSlotNames( self )</code></div><div class='ds'><pre>Returns the list of slot names (in order) for this context</pre></div></div><div id='d_Ns' class='de'><h1>Method <span class='n'>hasAnnotation</span></h1><div class='re'><code>hasAnnotation( self, name )</code></div><div class='ds'><pre>Tells if the given element has an annotation with the given name</pre></div></div><div id='d_Nr' class='de'><h1>Method <span class='n'>getAnnotations</span></h1><div class='re'><code>getAnnotations( self, name=None )</code></div><div class='ds'><pre>Gets all the annotation with the given name associated to this element
		or all annotations if no name is specified.</pre></div></div><div id='d_Nu' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><pre>Tells if this element has a parent or not</pre></div></div><div id='d_Nt' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><pre>Returns the dataflow accessible/bound to this element</pre></div></div><div id='d_Nw' class='de'><h1>Class <span class='n'>INumber</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Nv' class='de'><h1>Method <span class='n'>getAnnotations</span></h1><div class='re'><code>getAnnotations( self, name=None )</code></div><div class='ds'><pre>Gets all the annotation with the given name associated to this element
		or all annotations if no name is specified.</pre></div></div><div id='d_Ny' class='de'><h1>Method <span class='n'>setFactory</span></h1><div class='re'><code>setFactory( self, factory )</code></div><div class='ds'><pre>Sets the factory that was used to create this program</pre></div></div><div id='d_Nx' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><pre>Tells if this element has a parent or not</pre></div></div><div id='d_Nz' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><pre>Returns the ith arguments to this operation.</pre></div></div><div id='pc' class='cr'><div class='n'><a href='javascript:dS("pc");'>IAllocation</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("pc","qc");'><span class='special __bases__'>IOperation</span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("pc","rc");'>getDefaultValue</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("pc","sc");'>getSlotToAllocate</a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("pc","tc");'>addAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("pc","uc");'>addOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("pc","vc");'>copy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("pc","wc");'>detach</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("pc","xc");'>getAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("pc","yc");'>getAnnotations</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("pc","zc");'>getDataFlow</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("pc","Ac");'>getOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("pc","Bc");'>getOpArguments</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("pc","Cc");'>getOpArgumentsInternalTypes</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("pc","Dc");'>getParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("pc","Ec");'>hasAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("pc","Fc");'>hasParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("pc","Gc");'>removeAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("pc","Hc");'>setAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("pc","Ic");'>setOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("pc","Jc");'>setParent</a></div></div><div class='t'>Values</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&bull;</span><a href='javascript:dO("pc","Kc");'>ARGS</a></div></div></div><div id='pn' class='cr'><div class='n'><a href='javascript:dS("pn");'>IImportModuleOperation</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("pn","qn");'><span class='special __bases__'>IImportOperation</span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("pn","rn");'>getAlias</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("pn","sn");'>getImportedModuleName</a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("pn","tn");'>addAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("pn","un");'>addOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("pn","vn");'>copy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("pn","wn");'>detach</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("pn","xn");'>getAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("pn","yn");'>getAnnotations</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("pn","zn");'>getDataFlow</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("pn","An");'>getOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("pn","Bn");'>getOpArguments</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("pn","Cn");'>getOpArgumentsInternalTypes</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("pn","Dn");'>getParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("pn","En");'>hasAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("pn","Fn");'>hasParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("pn","Gn");'>removeAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("pn","Hn");'>setAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("pn","In");'>setOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("pn","Jn");'>setParent</a></div></div><div class='t'>Values</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&bull;</span><a href='javascript:dO("pn","Kn");'>ARGS</a></div><div class='slot documented'><span
					class='prefix'>&bull;</span><a href='javascript:dO("pn","Ln");'>ARG_NAMES</a></div></div></div><div id='d_PN' class='de'><h1>Method <span class='n'>isDone</span></h1><div class='re'><code>isDone( self, message, element, update=True )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_PM' class='de'><h1>Method <span class='n'>resolveLocalOrAbsolute</span></h1><div class='re'><code>resolveLocalOrAbsolute( self, referenceOrName, contextOrDataFlow=None )</code></div><div class='ds'><pre>Tries a local resolution first, then will look in the program scope if
		it fails.</pre></div></div><div id='d_PL' class='de'><h1>Method <span class='n'>getCurrentClassParents</span></h1><div class='re'><code>getCurrentClassParents( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_PK' class='de'><h1>Class <span class='n'>Importation</span></h1><div class='re'></div><div class='ds'><pre>The importation pass will look for importation operations ('IImportation'),
	will try to resolve the importations (according to the current environment)
	and will trigger the loading and parsing of each module into the current
	program.</pre></div></div><div id='d_PJ' class='de'><h1>Method <span class='n'>isIn</span></h1><div class='re'><code>isIn( self, interface )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_PI' class='de'><h1>Method <span class='n'>definedBy</span></h1><div class='re'><code>definedBy( self, definition=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_PH' class='de'><h1>Method <span class='n'>length</span></h1><div class='re'><code>length( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_PG' class='de'><h1>Method <span class='n'>asString</span></h1><div class='re'><code>asString( self, fromTypes=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_PF' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self, length, name=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_PE' class='de'><h1>Method <span class='n'>getType</span></h1><div class='re'><code>getType( self, name )</code></div><div class='ds'><pre>Returns the type with the given name, or None if it does not
		exist.</pre></div></div><div id='d_PD' class='de'><h1>Method <span class='n'>instanciate</span></h1><div class='re'><code>instanciate( self, evaluable, *arguments )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_PC' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><pre>Sets the abstract type for this element</pre></div></div><div id='d_PB' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><pre>Detaches the element from its parent (in case it was already attached).
		This should return this element, and set the parent to None.</pre></div></div><div id='d_PA' class='de'><h1>list</h1><div class='re'><code>[[&lt;class lambdafactory.interfaces.IMatchOperation at 0x85d298c&gt;]]</code></div><div class='ds'><pre>list() -&gt; new list
list(sequence) -&gt; new list initialized from sequence's items</pre></div></div><div id='d_Pz' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><pre>Returns the *internal types* for this operations arguments. This is
		typically the list of interfaces or @protocols that the arguments must
		comply to.</pre></div></div><div id='d_Py' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><pre>Performs a deep clone of this element. Any mutation to the original won't
		change the copy.</pre></div></div><div id='d_Px' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><pre>Sets the abstract type for this element</pre></div></div><div id='d_Pw' class='de'><h1>Method <span class='n'>addAnnotation</span></h1><div class='re'><code>addAnnotation( self, annotation )</code></div><div class='ds'><pre>Adds an annotation to this element</pre></div></div><div id='d_Pv' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><pre>Returns the local name for this referencable element</pre></div></div><div id='d_Pu' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><pre>Sets the abstract type for this element</pre></div></div><div id='d_Pt' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><pre>Returns the arguments to this operation.</pre></div></div><div id='d_Ps' class='de'><h1>Method <span class='n'>removeAnnotation</span></h1><div class='re'><code>removeAnnotation( self, name )</code></div><div class='ds'><pre>Removes the annotations with the given name</pre></div></div><div id='d_Pr' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><pre>Returns the ith arguments to this operation.</pre></div></div><div id='d_Pq' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><pre>Returns the *internal types* for this operations arguments. This is
		typically the list of interfaces or @protocols that the arguments must
		comply to.</pre></div></div><div id='d_Pp' class='de'><h1>Method <span class='n'>hasAnnotation</span></h1><div class='re'><code>hasAnnotation( self, name )</code></div><div class='ds'><pre>Tells if the given element has an annotation with the given name</pre></div></div><div id='d_Po' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><pre>Returns the *internal types* for this operations arguments. This is
		typically the list of interfaces or @protocols that the arguments must
		comply to.</pre></div></div><div id='d_Pn' class='de'><h1>Method <span class='n'>addAnnotation</span></h1><div class='re'><code>addAnnotation( self, annotation )</code></div><div class='ds'><pre>Adds an annotation to this element</pre></div></div><div id='d_Pm' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><pre>Tells if this element has a parent or not</pre></div></div><div id='d_Pl' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><pre>Returns the *internal types* for this operations arguments. This is
		typically the list of interfaces or @protocols that the arguments must
		comply to.</pre></div></div><div id='d_Pk' class='de'><h1>Method <span class='n'>getLanguage</span></h1><div class='re'><code>getLanguage( self )</code></div><div class='ds'><pre>Returns the language in which the emebedded code is written.</pre></div></div><div id='d_Pj' class='de'><h1>Class <span class='n'>IDocumentation</span></h1><div class='re'></div><div class='ds'><pre>Documentation is often attached to various language elements.
	Documentation can be found in coments (as in Java), or be directly embedded
	as values (as in Python).</pre></div></div><div id='d_Pi' class='de'><h1>Method <span class='n'>getOperations</span></h1><div class='re'><code>getOperations( self )</code></div><div class='ds'><pre>Returns the (ordered) list of operations that affected the slot.
		Operations usually constrain the dataflow abstract type, and
		exception/warnings/errors may be raised by the type system
		when a type constraint fails.</pre></div></div><div id='d_Ph' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><pre>Tells if this element has a parent or not</pre></div></div><div id='d_Pg' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><pre>Returns the name of this annotation.</pre></div></div><div id='d_Pf' class='de'><h1>Method <span class='n'>getAbsoluteName</span></h1><div class='re'><code>getAbsoluteName( self )</code></div><div class='ds'><pre>Returns the absolute name for this element</pre></div></div><div id='d_Pe' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><pre>Tells if this element has a parent or not</pre></div></div><div id='d_Pd' class='de'><h1>Method <span class='n'>getAnnotations</span></h1><div class='re'><code>getAnnotations( self, name=None )</code></div><div class='ds'><pre>Gets all the annotation with the given name associated to this element
		or all annotations if no name is specified.</pre></div></div><div id='d_Pc' class='de'><h1>Class <span class='n'>IArgument</span></h1><div class='re'></div><div class='ds'><pre>Arguments are slots which can be interpreted in different ways.<br />	When an argument is _optional_, it does not need to be defined in the
	invocation. When an argument is _variable_, it means it references the
	rest of the arguments lists. When an argument is _keywords_, it will reference
	the named arguments of the rest of the arguments list.</pre></div></div><div id='d_Pb' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><pre>Detaches the element from its parent (in case it was already attached).
		This should return this element, and set the parent to None.</pre></div></div><div id='d_mH' class='de'><h1>Method <span class='n'>add</span></h1><div class='re'><code>add( self, theType )</code></div><div class='ds'><pre>Adds the given type as an element to this process. The last added
		type becomes the result if one type was already added, the argument
		otherwise.</pre></div></div><div id='d_mI' class='de'><h1>Method <span class='n'>name</span></h1><div class='re'><code>name( self, name=None )</code></div><div class='ds'><pre>Returns/sets the name for this type. By defaults, types are unnamed.</pre></div></div><div id='d_mJ' class='de'><h1>Class <span class='n'>DocumentationPass</span></h1><div class='re'></div><div class='ds'><pre>The documentation pass will run SDoc on all the modules declared in this
	program, creating an HTML file.</pre></div></div><div id='d_mK' class='de'><h1>Method <span class='n'>getCurrentClassAncestors</span></h1><div class='re'><code>getCurrentClassAncestors( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_mL' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><pre>Returns the name of this pass</pre></div></div><div id='d_mM' class='de'><h1>list</h1><div class='re'><code>[]</code></div><div class='ds'><pre>list() -&gt; new list
list(sequence) -&gt; new list initialized from sequence's items</pre></div></div><div id='d_mN' class='de'><h1>Method <span class='n'>getCurrentModule</span></h1><div class='re'><code>getCurrentModule( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_mA' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><pre>Returns this element parent</pre></div></div><div id='d_mB' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.IEvaluable at 0x85c4f2c&gt;, &lt;class lambdafactory.interfaces.IEvaluable at 0x85c4f2c&gt;, &lt;class lambdafactory.interfaces.IEvaluable at 0x85c4f2c&gt;]</code></div><div class='ds'><pre>list() -&gt; new list
list(sequence) -&gt; new list initialized from sequence's items</pre></div></div><div id='d_mC' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><pre>Performs a deep clone of this element. Any mutation to the original won't
		change the copy.</pre></div></div><div id='d_mD' class='de'><h1>Method <span class='n'>assign</span></h1><div class='re'><code>assign( self, name, evaluable )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_mE' class='de'><h1>Class <span class='n'>AbstractWriter</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_mF' class='de'><h1>Method <span class='n'>isSameAs</span></h1><div class='re'><code>isSameAs( self, otherType )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_mG' class='de'><h1>Method <span class='n'>fullName</span></h1><div class='re'><code>fullName( self )</code></div><div class='ds'><pre>Returns the fully qualified name for this context, by
		concateniating the chain of parents name with '.'</pre></div></div><div id='d_mx' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><pre>Performs a deep clone of this element. Any mutation to the original won't
		change the copy.</pre></div></div><div id='d_my' class='de'><h1>Method <span class='n'>hasAnnotation</span></h1><div class='re'><code>hasAnnotation( self, name )</code></div><div class='ds'><pre>Tells if the given element has an annotation with the given name</pre></div></div><div id='d_mz' class='de'><h1>Method <span class='n'>addAnnotation</span></h1><div class='re'><code>addAnnotation( self, annotation )</code></div><div class='ds'><pre>Adds an annotation to this element</pre></div></div><div id='d_mp' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><pre>Returns the *internal types* for this operations arguments. This is
		typically the list of interfaces or @protocols that the arguments must
		comply to.</pre></div></div><div id='d_mq' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><pre>Returns the dataflow accessible/bound to this element</pre></div></div><div id='d_mr' class='de'><h1>Method <span class='n'>getInheritedSlots</span></h1><div class='re'><code>getInheritedSlots( self )</code></div><div class='ds'><pre>gives the list of inherited slots</pre></div></div><div id='d_ms' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><pre>Returns the dataflow accessible/bound to this element</pre></div></div><div id='d_mt' class='de'><h1>Class <span class='n'>ILiteral</span></h1><div class='re'></div><div class='ds'><pre>A literal is a value that does not need a context to be evaluated. The
	evaluation is direct.</pre></div></div><div id='d_mu' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><pre>Returns the ith arguments to this operation.</pre></div></div><div id='d_mv' class='de'><h1>Method <span class='n'>getSlots</span></h1><div class='re'><code>getSlots( self )</code></div><div class='ds'><pre>Returns (key, evaluable) pairs representing the slots within this
		context. In the case of context that may inherits slots, this only
		returns the slots that are owned by the context (ie. it does not
		include inherited slots)</pre></div></div><div id='d_mw' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><pre>Performs a deep clone of this element. Any mutation to the original won't
		change the copy.</pre></div></div><div id='d_mh' class='de'><h1>Method <span class='n'>hasAnnotation</span></h1><div class='re'><code>hasAnnotation( self, name )</code></div><div class='ds'><pre>Tells if the given element has an annotation with the given name</pre></div></div><div id='d_mi' class='de'><h1>Method <span class='n'>getAnnotations</span></h1><div class='re'><code>getAnnotations( self, name=None )</code></div><div class='ds'><pre>Gets all the annotation with the given name associated to this element
		or all annotations if no name is specified.</pre></div></div><div id='d_mj' class='de'><h1>Method <span class='n'>hasExplicitTermination</span></h1><div class='re'><code>hasExplicitTermination( self )</code></div><div class='ds'><pre>Returns true if this function has an operation with a termination,
		otherwise return false.</pre></div></div><div id='d_mk' class='de'><h1>Method <span class='n'>setLanguage</span></h1><div class='re'><code>setLanguage( self, language )</code></div><div class='ds'><pre>Sets the language in which the emebedded code is written.</pre></div></div><div id='d_ml' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type for this element</pre></div></div><div id='d_mm' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><pre>Returns this element parent</pre></div></div><div id='d_mn' class='de'><h1>Method <span class='n'>removeAnnotation</span></h1><div class='re'><code>removeAnnotation( self, name )</code></div><div class='ds'><pre>Removes the annotations with the given name</pre></div></div><div id='d_mo' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><pre>Performs a deep clone of this element. Any mutation to the original won't
		change the copy.</pre></div></div><div id='d_mb' class='de'><h1>Method <span class='n'>isAbstract</span></h1><div class='re'><code>isAbstract( self )</code></div><div class='ds'><pre>Tells wether the given abstractable is abstract or not.</pre></div></div><div id='d_mc' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><pre>Sets this element parent</pre></div></div><div id='d_md' class='de'><h1>Method <span class='n'>getAnnotations</span></h1><div class='re'><code>getAnnotations( self, name=None )</code></div><div class='ds'><pre>Gets all the annotation with the given name associated to this element
		or all annotations if no name is specified.</pre></div></div><div id='d_me' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IGroup at 0x85d244c&gt;, &lt;class lambdafactory.interfaces.IAssignable at 0x85c4ecc&gt;)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_mf' class='de'><h1>Method <span class='n'>getAbsoluteName</span></h1><div class='re'><code>getAbsoluteName( self )</code></div><div class='ds'><pre>Returns the absolute name for this element</pre></div></div><div id='d_mg' class='de'><h1>Method <span class='n'>setSlot</span></h1><div class='re'><code>setSlot( self, name, evaluable )</code></div><div class='ds'><pre>Binds the given evaluable to the named slot. If there is already a slot
		with the same name, then 'getSlot(name)' should return the evaluable
		given as parameter.<br />		In the default implementation, setSlot preserves the ''history'' of
		added slots, and will always return the latest one.</pre></div></div><div id='bu' class='cr'><div class='n'><a href='javascript:dS("bu");'>IMatchOperation</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("bu","cu");'><span class='special __bases__'>IOperation</span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("bu","du");'>getPredicate</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("bu","eu");'>setPredicate</a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("bu","fu");'>addAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("bu","gu");'>addOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("bu","hu");'>copy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("bu","iu");'>detach</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("bu","ju");'>getAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("bu","ku");'>getAnnotations</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("bu","lu");'>getDataFlow</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("bu","mu");'>getOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("bu","nu");'>getOpArguments</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("bu","ou");'>getOpArgumentsInternalTypes</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("bu","pu");'>getParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("bu","qu");'>hasAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("bu","ru");'>hasParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("bu","su");'>removeAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("bu","tu");'>setAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("bu","uu");'>setOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("bu","vu");'>setParent</a></div></div></div><div id='bw' class='cr'><div class='n'><a href='javascript:dS("bw");'>IModuleAttribute</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("bw","cw");'><span class='special __bases__'>IAttribute</span></a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("bw","dw");'>getAbsoluteName</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("bw","ew");'>getDefaultValue</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("bw","fw");'>getName</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("bw","gw");'>getTypeDescription</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("bw","hw");'>setDefaultValue</a></div></div></div><div id='bq' class='cr'><div class='n'><a href='javascript:dS("bq");'>IInstanciable</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("bq","c");'><span class='special __bases__'><i>Base class</i></span></a></div></div></div><div id='bs' class='cr'><div class='n'><a href='javascript:dS("bs");'>IInvocation</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("bs","cs");'><span class='special __bases__'>IOperation</span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("bs","ds");'>getArguments</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("bs","es");'>getTarget</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("bs","fs");'>isByPositionOnly</a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("bs","gs");'>addAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("bs","hs");'>addOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("bs","is");'>copy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("bs","js");'>detach</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("bs","ks");'>getAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("bs","ls");'>getAnnotations</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("bs","ms");'>getDataFlow</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("bs","ns");'>getOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("bs","os");'>getOpArguments</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("bs","ps");'>getOpArgumentsInternalTypes</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("bs","qs");'>getParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("bs","rs");'>hasAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("bs","ss");'>hasParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("bs","ts");'>removeAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("bs","us");'>setAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("bs","vs");'>setOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("bs","ws");'>setParent</a></div></div><div class='t'>Values</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&bull;</span><a href='javascript:dO("bs","xs");'>ARGS</a></div></div></div><div id='bE' class='cr'><div class='n'><a href='javascript:dS("bE");'>ModelBadArgument</a></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("bE","cE");'><span class='special __init__'>constructor</span></a></div></div><div class='t'>Inhertied Values</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("bE","dE");'><span class='special __getitem__'>get item</span></a></div><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("bE","eE");'><span class='special __repr__'>string repr</span></a></div><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("bE","fE");'><span class='special __str__'>string conversion</span></a></div><div class='slot documented'><span
					class='prefix'>&sdot;</span><a href='javascript:dO("bE","gE");'>args</a></div><div class='slot documented'><span
					class='prefix'>&sdot;</span><a href='javascript:dO("bE","hE");'>message</a></div></div></div><div id='d_SJ' class='de'><h1>Method <span class='n'>resolveAbsoluteOrLocal</span></h1><div class='re'><code>resolveAbsoluteOrLocal( self, referenceOrName, contextOrDataFlow=None )</code></div><div class='ds'><pre>Tries an absolute resolution first, then will look in the local scope if
		it fails.</pre></div></div><div id='d_SK' class='de'><h1>Method <span class='n'>onModule</span></h1><div class='re'><code>onModule( self, module )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_SH' class='de'><h1>Method <span class='n'>clone</span></h1><div class='re'><code>clone( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_SI' class='de'><h1>Method <span class='n'>isSubtypeOf</span></h1><div class='re'><code>isSubtypeOf( self, otherType )</code></div><div class='ds'><pre>Generic implementation of isSubtypeOf. You should always call this method
		in subclasses, as it implements basic type systems rules such as
		isSubtypeOf(Any).</pre></div></div><div id='d_SN' class='de'><h1>Method <span class='n'>warning</span></h1><div class='re'><code>warning( self, message, element=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_SL' class='de'><h1>Method <span class='n'>getCurrentDataFlow</span></h1><div class='re'><code>getCurrentDataFlow( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_SM' class='de'><h1>Method <span class='n'>setPass</span></h1><div class='re'><code>setPass( self, programPass )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_SB' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><pre>Returns the dataflow accessible/bound to this element</pre></div></div><div id='d_SC' class='de'><h1>Module <span class='n'>lambdafactory.modelbase</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_SA' class='de'><h1>Method <span class='n'>getSliceEnd</span></h1><div class='re'><code>getSliceEnd( self )</code></div><div class='ds'><pre>Returns evaluable that will return the slice end</pre></div></div><div id='d_SF' class='de'><h1>Method <span class='n'>isLike</span></h1><div class='re'><code>isLike( self, otherType )</code></div><div class='ds'><pre>The other type is like this Cell if the other type is a cell of the
		same length as this one.</pre></div></div><div id='d_SG' class='de'><h1>Method <span class='n'>elementNames</span></h1><div class='re'><code>elementNames( self )</code></div><div class='ds'><pre>Returns the list of slots/elements defined in this map.</pre></div></div><div id='d_SD' class='de'><h1>Method <span class='n'>iterate</span></h1><div class='re'><code>iterate( self, evaluable, process )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_SE' class='de'><h1>Method <span class='n'>getType</span></h1><div class='re'><code>getType( self, name )</code></div><div class='ds'><pre>Returns the type with the given name, or None if it does not
		exist.</pre></div></div><div id='d_Sz' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><pre>Tells if this element has a parent or not</pre></div></div><div id='d_Sx' class='de'><h1>Class <span class='n'>IParameter</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Sy' class='de'><h1>Method <span class='n'>getAnnotations</span></h1><div class='re'><code>getAnnotations( self, name=None )</code></div><div class='ds'><pre>Gets all the annotation with the given name associated to this element
		or all annotations if no name is specified.</pre></div></div><div id='d_Sr' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><pre>Returns this element parent</pre></div></div><div id='d_Ss' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><pre>Sets this element parent</pre></div></div><div id='d_Sp' class='de'><h1>Method <span class='n'>hasSlot</span></h1><div class='re'><code>hasSlot( self, name )</code></div><div class='ds'><pre>Tells if the context has a slot with the given name.</pre></div></div><div id='d_Sq' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><pre>Tells if this element has a parent or not</pre></div></div><div id='d_Sv' class='de'><h1>Method <span class='n'>getSlotNames</span></h1><div class='re'><code>getSlotNames( self )</code></div><div class='ds'><pre>Returns the list of slot names (in order) for this context</pre></div></div><div id='d_Sw' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type for this element</pre></div></div><div id='d_St' class='de'><h1>Method <span class='n'>getPredicate</span></h1><div class='re'><code>getPredicate( self )</code></div><div class='ds'><pre>Returns the evaluable that acts as a predicate for this operation.</pre></div></div><div id='d_Su' class='de'><h1>Method <span class='n'>setPredicate</span></h1><div class='re'><code>setPredicate( self, v )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Sj' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><pre>Returns the name of this annotation.</pre></div></div><div id='d_Sk' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><pre>Returns the *internal types* for this operations arguments. This is
		typically the list of interfaces or @protocols that the arguments must
		comply to.</pre></div></div><div id='d_Sh' class='de'><h1>Method <span class='n'>removeAnnotation</span></h1><div class='re'><code>removeAnnotation( self, name )</code></div><div class='ds'><pre>Removes the annotations with the given name</pre></div></div><div id='d_Si' class='de'><h1>Class <span class='n'>IDestructor</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Sn' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><pre>Detaches the element from its parent (in case it was already attached).
		This should return this element, and set the parent to None.</pre></div></div><div id='d_So' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><pre>Tells if this element has a parent or not</pre></div></div><div id='d_Sl' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><pre>Tells if this element has a parent or not</pre></div></div><div id='d_Sm' class='de'><h1>Method <span class='n'>removeAnnotation</span></h1><div class='re'><code>removeAnnotation( self, name )</code></div><div class='ds'><pre>Removes the annotations with the given name</pre></div></div><div id='d_Sb' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type for this element</pre></div></div><div id='d_Sc' class='de'><h1>Method <span class='n'>isKeywordsRest</span></h1><div class='re'><code>isKeywordsRest( self )</code></div><div class='ds'><pre>Tells if this arguments represents ''the rest'' of the keyword argument in
		the invocation</pre></div></div><div id='d_Sf' class='de'><h1>Method <span class='n'>getArguments</span></h1><div class='re'><code>getArguments( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Sg' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IOperation at 0x85d268c&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_Sd' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><pre>Returns this @protocol name. It can be `None` if the @protocol is anonymous.</pre></div></div><div id='d_Se' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><pre>Sets the given argument of this operation, by argument index.</pre></div></div><div id='d_AL' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.IModule at 0x85d23bc&gt;]</code></div><div class='ds'><pre>list() -&gt; new list
list(sequence) -&gt; new list initialized from sequence's items</pre></div></div><div id='d_AM' class='de'><h1>Method <span class='n'>getCurrentDataFlow</span></h1><div class='re'><code>getCurrentDataFlow( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_AN' class='de'><h1>Method <span class='n'>run</span></h1><div class='re'><code>run( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_AH' class='de'><h1>Method <span class='n'>name</span></h1><div class='re'><code>name( self, name=None )</code></div><div class='ds'><pre>Returns/sets the name for this type. By defaults, types are unnamed.</pre></div></div><div id='d_AI' class='de'><h1>Method <span class='n'>isSameAs</span></h1><div class='re'><code>isSameAs( self, otherType )</code></div><div class='ds'><pre>Generic implementation of isSameAs. You should always call this method
		in subclasses.</pre></div></div><div id='d_AJ' class='de'><h1>Method <span class='n'>getCurrentClosure</span></h1><div class='re'><code>getCurrentClosure( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_AK' class='de'><h1>Method <span class='n'>getProgram</span></h1><div class='re'><code>getProgram( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_AD' class='de'><h1>Method <span class='n'>createInterface</span></h1><div class='re'><code>createInterface( self, name, inherited=() )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_AE' class='de'><h1>Function <span class='n'>notEmpty</span></h1><div class='re'><code>notEmpty( p )</code></div><div class='ds'><pre>Returns None if the given parameter is empty.</pre></div></div><div id='d_AF' class='de'><h1>Method <span class='n'>isSameAs</span></h1><div class='re'><code>isSameAs( self, otherType )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_AG' class='de'><h1>Method <span class='n'>name</span></h1><div class='re'><code>name( self, name=None )</code></div><div class='ds'><pre>Returns/sets the name for this type. By defaults, types are unnamed.</pre></div></div><div id='d_AA' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><pre>Performs a deep clone of this element. Any mutation to the original won't
		change the copy.</pre></div></div><div id='d_AB' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><pre>Returns the dataflow accessible/bound to this element</pre></div></div><div id='d_AC' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><pre>Sets this element parent</pre></div></div><div id='uF' class='cr'><div class='n'><a href='javascript:dS("uF");'>Array</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("uF","vF");'><span class='special __bases__'>Type</span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("uF","wF");'><span class='special __init__'>constructor</span></a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("uF","xF");'>asString</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("uF","yF");'>content</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("uF","zF");'>isLike</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("uF","AF");'>isSameAs</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("uF","BF");'>isSubtypeOf</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("uF","CF");'>setContentType</a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("uF","DF");'><span class='special __call__'>when invoked</span></a></div><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("uF","EF");'><span class='special __str__'>string conversion</span></a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("uF","FF");'>clone</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("uF","GF");'>concreteType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("uF","HF");'>definedBy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("uF","IF");'>name</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("uF","JF");'>result</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("uF","KF");'>setConcreteType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("uF","LF");'>setName</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("uF","MF");'>subtype</a></div></div></div><div id='uA' class='cr'><div class='n'><a href='javascript:dS("uA");'>ISelection</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("uA","vA");'><span class='special __bases__'>IOperation</span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("uA","wA");'>addRule</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("uA","xA");'>getRules</a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("uA","yA");'>addAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("uA","zA");'>addOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("uA","AA");'>copy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("uA","BA");'>detach</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("uA","CA");'>getAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("uA","DA");'>getAnnotations</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("uA","EA");'>getDataFlow</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("uA","FA");'>getOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("uA","GA");'>getOpArguments</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("uA","HA");'>getOpArgumentsInternalTypes</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("uA","IA");'>getParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("uA","JA");'>hasAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("uA","KA");'>hasParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("uA","LA");'>removeAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("uA","MA");'>setAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("uA","NA");'>setOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("uA","OA");'>setParent</a></div></div><div class='t'>Values</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&bull;</span><a href='javascript:dO("uA","PA");'>ARGS</a></div></div></div><div id='d_Al' class='de'><h1>Class <span class='n'>IEvaluable</span></h1><div class='re'></div><div class='ds'><pre>An evaluable is an element that can produce a value. Evaluable elements
	then have associated type information.</pre></div></div><div id='d_Am' class='de'><h1>Method <span class='n'>addOperation</span></h1><div class='re'><code>addOperation( self, operation )</code></div><div class='ds'><pre>Adds the given operation as a child of this process.</pre></div></div><div id='d_An' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><pre>Returns the ith arguments to this operation.</pre></div></div><div id='d_Ao' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><pre>Sets this element parent</pre></div></div><div id='d_Ah' class='de'><h1>Method <span class='n'>endsWithTermination</span></h1><div class='re'><code>endsWithTermination( self )</code></div><div class='ds'><pre>Returns true if this function ends with a termination operation. This
		is especially useful for back-ends which want to know if they have to
		insert an explicit 'return' at the end (like Java).</pre></div></div><div id='d_Ai' class='de'><h1>Method <span class='n'>getChildren</span></h1><div class='re'><code>getChildren( self )</code></div><div class='ds'><pre>Returns a list of the child dataflows for this dataflow.</pre></div></div><div id='d_Aj' class='de'><h1>Method <span class='n'>setValue</span></h1><div class='re'><code>setValue( self, key, value )</code></div><div class='ds'><pre>Sets the value to be associated to the given key (which must be an
		evaluable).</pre></div></div><div id='d_Ak' class='de'><h1>Method <span class='n'>removeAnnotation</span></h1><div class='re'><code>removeAnnotation( self, name )</code></div><div class='ds'><pre>Removes the annotations with the given name</pre></div></div><div id='d_Ad' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.ISlot at 0x85d21dc&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_Ae' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><pre>Sets this element parent</pre></div></div><div id='d_Af' class='de'><h1>Method <span class='n'>setSlot</span></h1><div class='re'><code>setSlot( self, name, evaluable )</code></div><div class='ds'><pre>Binds the given evaluable to the named slot. If there is already a slot
		with the same name, then 'getSlot(name)' should return the evaluable
		given as parameter.<br />		In the default implementation, setSlot preserves the ''history'' of
		added slots, and will always return the latest one.</pre></div></div><div id='d_Ag' class='de'><h1>Method <span class='n'>getOperations</span></h1><div class='re'><code>getOperations( self )</code></div><div class='ds'><pre>Returns the list of operations in this process.</pre></div></div><div id='d_Ab' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><pre>Returns the *internal types* for this operations arguments. This is
		typically the list of interfaces or @protocols that the arguments must
		comply to.</pre></div></div><div id='d_Ac' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><pre>Returns the ith arguments to this operation.</pre></div></div><div id='um' class='cr'><div class='n'><a href='javascript:dS("um");'>IFunction</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("um","vm");'><span class='special __bases__'>IClosure, IReferencable, IAbstractable, IConstruct</span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("um","wm");'>endsWithTermination</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("um","xm");'>getName</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("um","ym");'>hasExplicitTermination</a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("um","zm");'>addAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("um","Am");'>addOperation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("um","Bm");'>copy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("um","Cm");'>detach</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("um","Dm");'>getAbsoluteName</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("um","Em");'>getAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("um","Fm");'>getAnnotations</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("um","Gm");'>getArguments</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("um","Hm");'>getDataFlow</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("um","Im");'>getOperations</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("um","Jm");'>getParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("um","Km");'>getReturnTypeDescription</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("um","Lm");'>getSlot</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("um","Mm");'>getSlotNames</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("um","Nm");'>getSlots</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("um","Om");'>hasAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("um","Pm");'>hasParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("um","Qm");'>hasSlot</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("um","Rm");'>isAbstract</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("um","Sm");'>removeAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("um","Tm");'>setAbstract</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("um","Um");'>setAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("um","Vm");'>setArguments</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("um","Wm");'>setParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("um","Xm");'>setReturnTypeDescription</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("um","Ym");'>setSlot</a></div></div></div><div id='d_Ax' class='de'><h1>Method <span class='n'>setPriority</span></h1><div class='re'><code>setPriority( self, priority )</code></div><div class='ds'><pre>Sets the priority for this operator</pre></div></div><div id='d_Ay' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><pre>Returns the dataflow accessible/bound to this element</pre></div></div><div id='d_Az' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><pre>Sets this element parent</pre></div></div><div id='d_At' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><pre>Sets the abstract type for this element</pre></div></div><div id='d_Au' class='de'><h1>Method <span class='n'>addAnnotation</span></h1><div class='re'><code>addAnnotation( self, annotation )</code></div><div class='ds'><pre>Adds an annotation to this element</pre></div></div><div id='d_Av' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IContext at 0x85d22fc&gt;, &lt;class lambdafactory.interfaces.IReferencable at 0x85c4efc&gt;, &lt;class lambdafactory.interfaces.IConstruct at 0x85c4e9c&gt;)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_Aw' class='de'><h1>Method <span class='n'>getSlots</span></h1><div class='re'><code>getSlots( self )</code></div><div class='ds'><pre>Returns (key, evaluable) pairs representing the slots within this
		context. In the case of context that may inherits slots, this only
		returns the slots that are owned by the context (ie. it does not
		include inherited slots)</pre></div></div><div id='d_Ap' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><pre>Performs a deep clone of this element. Any mutation to the original won't
		change the copy.</pre></div></div><div id='d_Aq' class='de'><h1>Method <span class='n'>getConclusion</span></h1><div class='re'><code>getConclusion( self )</code></div><div class='ds'><pre>Returns the process that will conclude the interception (finally)</pre></div></div><div id='d_Ar' class='de'><h1>Method <span class='n'>removeAnnotation</span></h1><div class='re'><code>removeAnnotation( self, name )</code></div><div class='ds'><pre>Removes the annotations with the given name</pre></div></div><div id='d_As' class='de'><h1>Method <span class='n'>getClosure</span></h1><div class='re'><code>getClosure( self )</code></div><div class='ds'><pre>Returns the closure that will be applied to the iterator.</pre></div></div><div id='TE' class='cr'><div class='n'><a href='javascript:dS("TE");'>TypeCollection</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("TE","c");'><span class='special __bases__'><i>Base class</i></span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("TE","UE");'>getType</a></div></div></div><div id='TC' class='cr'><div class='n'><a href='javascript:dS("TC");'>Factory</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("TC","c");'><span class='special __bases__'><i>Base class</i></span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("TC","UC");'><span class='special __init__'>constructor</span></a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("TC","VC");'><span class='protected'>_arg</span></a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("TC","WC");'><span class='protected'>_attr</span></a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("TC","XC");'><span class='protected'>_classattr</span></a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("TC","YC");'><span class='protected'>_dict</span></a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("TC","ZC");'><span class='protected'>_ensureParam</span></a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("TC","aD");'><span class='protected'>_getImplementation</span></a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("TC","bD");'><span class='protected'>_list</span></a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("TC","cD");'><span class='protected'>_moduleattr</span></a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("TC","dD");'><span class='protected'>_number</span></a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("TC","eD");'><span class='protected'>_op</span></a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("TC","fD");'><span class='protected'>_param</span></a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("TC","gD");'><span class='protected'>_ref</span></a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("TC","hD");'><span class='protected'>_slot</span></a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("TC","iD");'><span class='protected'>_string</span></a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("TC","jD");'>access</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("TC","kD");'>allocate</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("TC","lD");'>annotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("TC","mD");'>assign</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("TC","nD");'>breaks</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("TC","oD");'>comment</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("TC","pD");'>compute</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("TC","qD");'>createAccessor</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("TC","rD");'>createBlock</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("TC","sD");'>createClass</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("TC","tD");'>createClassMethod</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("TC","uD");'>createClosure</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("TC","vD");'>createConstructor</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("TC","wD");'>createDataFlow</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("TC","xD");'>createDataFlowSlot</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("TC","yD");'>createDestructor</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("TC","zD");'>createFunction</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("TC","AD");'>createInterface</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("TC","BD");'>createMethod</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("TC","CD");'>createModule</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("TC","DD");'>createMutator</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("TC","ED");'>createProgram</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("TC","FD");'>doc</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("TC","GD");'>embed</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("TC","HD");'>embedTemplate</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("TC","ID");'>enumerate</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("TC","JD");'>evaluate</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("TC","KD");'>exception</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("TC","LD");'>importModule</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("TC","MD");'>importModules</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("TC","ND");'>importSymbol</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("TC","OD");'>importSymbols</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("TC","PD");'>instanciate</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("TC","QD");'>intercept</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("TC","RD");'>invoke</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("TC","SD");'>iterate</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("TC","TD");'>matchExpression</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("TC","UD");'>matchProcess</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("TC","VD");'>repeat</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("TC","WD");'>resolve</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("TC","XD");'>returns</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("TC","YD");'>rule</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("TC","ZD");'>select</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("TC","aE");'>slice</a></div></div></div><div id='Al' class='cr'><div class='n'><a href='javascript:dS("Al");'>IEvaluable</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("Al","c");'><span class='special __bases__'><i>Base class</i></span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Al","Bl");'>getResultAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Al","Cl");'>setResultAbstractType</a></div></div></div><div id='zd' class='cr'><div class='n'><a href='javascript:dS("zd");'>IAttribute</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("zd","Ad");'><span class='special __bases__'>ISlot</span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("zd","Bd");'>getDefaultValue</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("zd","Cd");'>setDefaultValue</a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("zd","Dd");'>getAbsoluteName</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("zd","Ed");'>getName</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("zd","Fd");'>getTypeDescription</a></div></div></div><div id='zv' class='cr'><div class='n'><a href='javascript:dS("zv");'>IModule</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("zv","Av");'><span class='special __bases__'>IContext, IReferencable, IConstruct</span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("zv","Bv");'>addImportOperation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("zv","Cv");'>getClasses</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("zv","Dv");'>getImportOperations</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("zv","Ev");'>getParentName</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("zv","Fv");'>isImported</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("zv","Gv");'>mergeWith</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("zv","Hv");'>setImported</a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("zv","Iv");'>addAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("zv","Jv");'>copy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("zv","Kv");'>detach</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("zv","Lv");'>getAbsoluteName</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("zv","Mv");'>getAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("zv","Nv");'>getAnnotations</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("zv","Ov");'>getDataFlow</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("zv","Pv");'>getName</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("zv","Qv");'>getParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("zv","Rv");'>getSlot</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("zv","Sv");'>getSlotNames</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("zv","Tv");'>getSlots</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("zv","Uv");'>hasAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("zv","Vv");'>hasParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("zv","Wv");'>hasSlot</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("zv","Xv");'>removeAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("zv","Yv");'>setAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("zv","Zv");'>setParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("zv","aw");'>setSlot</a></div></div></div><div id='d_lK' class='de'><h1>Method <span class='n'>getCurrentClass</span></h1><div class='re'><code>getCurrentClass( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_lJ' class='de'><h1>Module <span class='n'>lambdafactory.passes</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_lI' class='de'><h1>Method <span class='n'>isSubtypeOf</span></h1><div class='re'><code>isSubtypeOf( self, otherType )</code></div><div class='ds'><pre>Generic implementation of isSubtypeOf. You should always call this method
		in subclasses, as it implements basic type systems rules such as
		isSubtypeOf(Any).</pre></div></div><div id='d_lH' class='de'><h1>Method <span class='n'>_ensureIntegrity</span></h1><div class='re'><code>_ensureIntegrity( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_lN' class='de'><h1>Method <span class='n'>getCurrentMethod</span></h1><div class='re'><code>getCurrentMethod( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_lM' class='de'><h1>Method <span class='n'>walk</span></h1><div class='re'><code>walk( self, element )</code></div><div class='ds'><pre>Walks the given element, recursively walking the child elements when the
		handler does not return False</pre></div></div><div id='d_lL' class='de'><h1>Method <span class='n'>getHandler</span></h1><div class='re'><code>getHandler( self, element )</code></div><div class='ds'><pre>Tells if the pass handles the given element. This basically iterates
		on the 'handles' property values (which are interfaces), when one
		interface matches the given 'element', then the corresponding 'onXXX'
		method is invoked, where 'XXX' is the interface
		name (without the leading 'I').</pre></div></div><div id='d_lC' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><pre>Adds an argument to this operation. This should do checking of
		arguments (by expected internal type and number).</pre></div></div><div id='d_lB' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><pre>Sets this element parent</pre></div></div><div id='d_lA' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><pre>Returns the *internal types* for this operations arguments. This is
		typically the list of interfaces or @protocols that the arguments must
		comply to.</pre></div></div><div id='d_lG' class='de'><h1>Method <span class='n'>extends</span></h1><div class='re'><code>extends( self, parent )</code></div><div class='ds'><pre>Add a new parent from which this Context inherits.</pre></div></div><div id='d_lF' class='de'><h1>Method <span class='n'>isLike</span></h1><div class='re'><code>isLike( self, otherType )</code></div><div class='ds'><pre>The other type is like this one if the other is a sequence with the
		same length and that all elements are like the corresponding elements of
		this sequence.</pre></div></div><div id='d_lE' class='de'><h1>Module <span class='n'>lambdafactory.modelwriter</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_lD' class='de'><h1>Method <span class='n'>annotation</span></h1><div class='re'><code>annotation( self, name, content=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_lz' class='de'><h1>Method <span class='n'>getReferenceName</span></h1><div class='re'><code>getReferenceName( self )</code></div><div class='ds'><pre>Returns the name which this reference contains. The name is used by
		the resolution operation to actually resolve a value from the name.</pre></div></div><div id='d_ly' class='de'><h1>Method <span class='n'>getTypeDescription</span></h1><div class='re'><code>getTypeDescription( self )</code></div><div class='ds'><pre>Returns type information (constraints) that are associated to this
		argument.</pre></div></div><div id='d_lx' class='de'><h1>Method <span class='n'>addAnnotation</span></h1><div class='re'><code>addAnnotation( self, annotation )</code></div><div class='ds'><pre>Adds an annotation to this element</pre></div></div><div id='d_ls' class='de'><h1>Method <span class='n'>getAnnotations</span></h1><div class='re'><code>getAnnotations( self, name=None )</code></div><div class='ds'><pre>Gets all the annotation with the given name associated to this element
		or all annotations if no name is specified.</pre></div></div><div id='d_lr' class='de'><h1>Method <span class='n'>getDestructors</span></h1><div class='re'><code>getDestructors( self )</code></div><div class='ds'><pre>Returns the destructors for this class</pre></div></div><div id='d_lq' class='de'><h1>Method <span class='n'>getAnnotations</span></h1><div class='re'><code>getAnnotations( self, name=None )</code></div><div class='ds'><pre>Gets all the annotation with the given name associated to this element
		or all annotations if no name is specified.</pre></div></div><div id='d_lp' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><pre>Returns the arguments to this operation.</pre></div></div><div id='d_lw' class='de'><h1>Method <span class='n'>addOperation</span></h1><div class='re'><code>addOperation( self, operation )</code></div><div class='ds'><pre>Adds the given operation as a child of this process.</pre></div></div><div id='d_lv' class='de'><h1>Method <span class='n'>getSlotNames</span></h1><div class='re'><code>getSlotNames( self )</code></div><div class='ds'><pre>Returns the list of slot names (in order) for this context</pre></div></div><div id='d_lu' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><pre>Returns the dataflow accessible/bound to this element</pre></div></div><div id='d_lt' class='de'><h1>Method <span class='n'>setResultAbstractType</span></h1><div class='re'><code>setResultAbstractType( self, abstractType )</code></div><div class='ds'><pre>Sets the abstract type for this operation result. This is usually
		invoked in the typing phase.</pre></div></div><div id='d_lk' class='de'><h1>Method <span class='n'>setCode</span></h1><div class='re'><code>setCode( self, code )</code></div><div class='ds'><pre>Sets the code of this embed operation.</pre></div></div><div id='d_lj' class='de'><h1>Method <span class='n'>hasAnnotation</span></h1><div class='re'><code>hasAnnotation( self, name )</code></div><div class='ds'><pre>Tells if the given element has an annotation with the given name</pre></div></div><div id='d_li' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type for this element</pre></div></div><div id='d_lh' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><pre>Returns this element parent</pre></div></div><div id='d_lo' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><pre>Adds an argument to this operation. This should do checking of
		arguments (by expected internal type and number).</pre></div></div><div id='d_ln' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><pre>Tells if this element has a parent or not</pre></div></div><div id='d_lm' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><pre>Returns the *internal types* for this operations arguments. This is
		typically the list of interfaces or @protocols that the arguments must
		comply to.</pre></div></div><div id='d_ll' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><pre>Detaches the element from its parent (in case it was already attached).
		This should return this element, and set the parent to None.</pre></div></div><div id='d_lc' class='de'><h1>Method <span class='n'>setArguments</span></h1><div class='re'><code>setArguments( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_lb' class='de'><h1>Class <span class='n'>IAbstractable</span></h1><div class='re'></div><div class='ds'><pre>An abstractable element is an element that is allow to have
	no underlying implementation.  Abstract element are typically interfaces,
	methods, functions, operations, and sometimes modules and @protocoles.</pre></div></div><div id='d_lg' class='de'><h1>Method <span class='n'>setReturnTypeDescription</span></h1><div class='re'><code>setReturnTypeDescription( self, description )</code></div><div class='ds'><pre>Sets the return type description for this closure, if any</pre></div></div><div id='d_lf' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><pre>Detaches the element from its parent (in case it was already attached).
		This should return this element, and set the parent to None.</pre></div></div><div id='d_le' class='de'><h1>Class <span class='n'>IBlock</span></h1><div class='re'></div><div class='ds'><pre>A block is a specific type of (sub) process.</pre></div></div><div id='d_ld' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type for this element</pre></div></div><div id='FH' class='cr'><div class='n'><a href='javascript:dS("FH");'>Sequence</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("FH","GH");'><span class='special __bases__'>Type</span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("FH","HH");'><span class='special __init__'>constructor</span></a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("FH","IH");'>add</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("FH","JH");'>asString</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("FH","KH");'>elements</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("FH","LH");'>extend</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("FH","MH");'>isLike</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("FH","NH");'>isSameAs</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("FH","OH");'>isSubtypeOf</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("FH","PH");'>length</a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("FH","QH");'><span class='special __call__'>when invoked</span></a></div><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("FH","RH");'><span class='special __str__'>string conversion</span></a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("FH","SH");'>clone</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("FH","TH");'>concreteType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("FH","UH");'>definedBy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("FH","VH");'>name</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("FH","WH");'>result</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("FH","XH");'>setConcreteType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("FH","YH");'>setName</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("FH","ZH");'>subtype</a></div></div></div><div id='Fk' class='cr'><div class='n'><a href='javascript:dS("Fk");'>IEmbedTemplate</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("Fk","Gk");'><span class='special __bases__'>IEmbed</span></a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Fk","Hk");'>addAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Fk","Ik");'>addOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Fk","Jk");'>copy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Fk","Kk");'>detach</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Fk","Lk");'>getAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Fk","Mk");'>getAnnotations</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Fk","Nk");'>getCode</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Fk","Ok");'>getDataFlow</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Fk","Pk");'>getLanguage</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Fk","Qk");'>getOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Fk","Rk");'>getOpArguments</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Fk","Sk");'>getOpArgumentsInternalTypes</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Fk","Tk");'>getParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Fk","Uk");'>hasAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Fk","Vk");'>hasParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Fk","Wk");'>removeAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Fk","Xk");'>setAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Fk","Yk");'>setCode</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Fk","Zk");'>setLanguage</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Fk","al");'>setOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Fk","bl");'>setParent</a></div></div><div class='t'>Inhertied Values</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&bull;</span><a href='javascript:dO("Fk","Ek");'>ARGS</a></div></div></div><div id='YE' class='ro'><div class='n'><a href='javascript:dS("YE");'>lambdafactory.typecast</a></div><div class='t'>Classes</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("YE","ZE");'>Arguments</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("YE","uF");'>Array</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("YE","NF");'>Cell</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("YE","fG");'>Context</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("YE","GG");'>Environment</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("YE","KG");'>InvalidArgument</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("YE","LG");'>Map</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("YE","iH");'>Process</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("YE","EH");'>SemanticError</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("YE","FH");'>Sequence</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("YE","aI");'>Symbolic</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("YE","rI");'>Type</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("YE","HI");'>Unresolved</a></div></div><div class='t'>Functions</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&lambda;</span><a href='javascript:dO("YE","YI");'>Class</a></div><div class='slot documented'><span
					class='prefix'>&lambda;</span><a href='javascript:dO("YE","ZI");'>Interface</a></div><div class='slot documented'><span
					class='prefix'>&lambda;</span><a href='javascript:dO("YE","aJ");'>Sequence_combine</a></div><div class='slot documented'><span
					class='prefix'>&lambda;</span><a href='javascript:dO("YE","bJ");'>Sequence_make</a></div><div class='slot documented'><span
					class='prefix'>&lambda;</span><a href='javascript:dO("YE","cJ");'>bits</a></div><div class='slot documented'><span
					class='prefix'>&lambda;</span><a href='javascript:dO("YE","dJ");'>isLike</a></div><div class='slot documented'><span
					class='prefix'>&lambda;</span><a href='javascript:dO("YE","eJ");'>isSame</a></div><div class='slot documented'><span
					class='prefix'>&lambda;</span><a href='javascript:dO("YE","fJ");'>isSubtype</a></div><div class='slot documented'><span
					class='prefix'>&lambda;</span><a href='javascript:dO("YE","gJ");'>isType</a></div></div><div class='t'>Values</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&sdot;</span><a href='javascript:dO("YE","hJ");'>Any</a></div><div class='slot documented'><span
					class='prefix'>&sdot;</span><a href='javascript:dO("YE","iJ");'>Nil</a></div><div class='slot documented'><span
					class='prefix'>&sdot;</span><a href='javascript:dO("YE","jJ");'>Nothing</a></div><div class='slot documented'><span
					class='prefix'>&sdot;</span><a href='javascript:dO("YE","kJ");'>Rest</a></div></div></div><div id='Yz' class='cr'><div class='n'><a href='javascript:dS("Yz");'>IResolution</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("Yz","Zz");'><span class='special __bases__'>IOperation</span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Yz","aA");'>getContext</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Yz","bA");'>getReference</a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Yz","cA");'>addAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Yz","dA");'>addOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Yz","eA");'>copy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Yz","fA");'>detach</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Yz","gA");'>getAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Yz","hA");'>getAnnotations</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Yz","iA");'>getDataFlow</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Yz","jA");'>getOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Yz","kA");'>getOpArguments</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Yz","lA");'>getOpArgumentsInternalTypes</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Yz","mA");'>getParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Yz","nA");'>hasAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Yz","oA");'>hasParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Yz","pA");'>removeAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Yz","qA");'>setAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Yz","rA");'>setOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Yz","sA");'>setParent</a></div></div><div class='t'>Values</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&bull;</span><a href='javascript:dO("Yz","tA");'>ARGS</a></div></div></div><div id='Yq' class='cr'><div class='n'><a href='javascript:dS("Yq");'>IInterface</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("Yq","Zq");'><span class='special __bases__'>IAbstractClass</span></a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Yq","ar");'>addAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Yq","br");'>copy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Yq","cr");'>detach</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Yq","dr");'>getAbsoluteName</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Yq","er");'>getAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Yq","fr");'>getAnnotations</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Yq","gr");'>getAttributes</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Yq","hr");'>getClassAttributes</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Yq","ir");'>getClassMethods</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Yq","jr");'>getConstructors</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Yq","kr");'>getDataFlow</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Yq","lr");'>getDestructors</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Yq","mr");'>getInheritedSlots</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Yq","nr");'>getInstanceMethods</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Yq","or");'>getMethods</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Yq","pr");'>getName</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Yq","qr");'>getOperations</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Yq","rr");'>getParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Yq","sr");'>getParentClassesRefs</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Yq","tr");'>getSlot</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Yq","ur");'>getSlotNames</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Yq","vr");'>getSlots</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Yq","wr");'>hasAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Yq","xr");'>hasParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Yq","yr");'>hasSlot</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Yq","zr");'>isAbstract</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Yq","Ar");'>removeAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Yq","Br");'>setAbstract</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Yq","Cr");'>setAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Yq","Dr");'>setParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Yq","Er");'>setParentClasses</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Yq","Fr");'>setSlot</a></div></div></div><div id='d_Re' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><pre>Sets the abstract type for this element</pre></div></div><div id='d_Rd' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><pre>Returns the dataflow accessible/bound to this element</pre></div></div><div id='d_Rg' class='de'><h1>Class <span class='n'>IComputation</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Rf' class='de'><h1>Method <span class='n'>getAnnotations</span></h1><div class='re'><code>getAnnotations( self, name=None )</code></div><div class='ds'><pre>Gets all the annotation with the given name associated to this element
		or all annotations if no name is specified.</pre></div></div><div id='d_Rc' class='de'><h1>Method <span class='n'>getDefaultValue</span></h1><div class='re'><code>getDefaultValue( self )</code></div><div class='ds'><pre>Returns the @methodault value for this slot.</pre></div></div><div id='d_Rb' class='de'><h1>Method <span class='n'>getAbsoluteName</span></h1><div class='re'><code>getAbsoluteName( self )</code></div><div class='ds'><pre>Returns the absolute name for this element</pre></div></div><div id='d_Rm' class='de'><h1>Method <span class='n'>isAbstract</span></h1><div class='re'><code>isAbstract( self )</code></div><div class='ds'><pre>Tells wether the given abstractable is abstract or not.</pre></div></div><div id='d_Rl' class='de'><h1>Method <span class='n'>hasAnnotation</span></h1><div class='re'><code>hasAnnotation( self, name )</code></div><div class='ds'><pre>Tells if the given element has an annotation with the given name</pre></div></div><div id='d_Ro' class='de'><h1>Method <span class='n'>hasAnnotation</span></h1><div class='re'><code>hasAnnotation( self, name )</code></div><div class='ds'><pre>Tells if the given element has an annotation with the given name</pre></div></div><div id='d_Rn' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><pre>Performs a deep clone of this element. Any mutation to the original won't
		change the copy.</pre></div></div><div id='d_Ri' class='de'><h1>Method <span class='n'>getOriginalValue</span></h1><div class='re'><code>getOriginalValue( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Rh' class='de'><h1>Method <span class='n'>isAbstract</span></h1><div class='re'><code>isAbstract( self )</code></div><div class='ds'><pre>Tells wether the given abstractable is abstract or not.</pre></div></div><div id='d_Rk' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><pre>Returns the arguments to this operation.</pre></div></div><div id='d_Rj' class='de'><h1>Method <span class='n'>getContent</span></h1><div class='re'><code>getContent( self )</code></div><div class='ds'><pre>Returns the content of this annotation.</pre></div></div><div id='d_Ru' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><pre>Sets this element parent</pre></div></div><div id='d_Rt' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><pre>Returns this element parent</pre></div></div><div id='d_Rw' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><pre>Detaches the element from its parent (in case it was already attached).
		This should return this element, and set the parent to None.</pre></div></div><div id='d_Rv' class='de'><h1>Method <span class='n'>getSlot</span></h1><div class='re'><code>getSlot( self, name )</code></div><div class='ds'><pre>Returns the given evaluable bound to named slot.</pre></div></div><div id='d_Rq' class='de'><h1>Method <span class='n'>hasAnnotation</span></h1><div class='re'><code>hasAnnotation( self, name )</code></div><div class='ds'><pre>Tells if the given element has an annotation with the given name</pre></div></div><div id='d_Rp' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><pre>Tells if this element has a parent or not</pre></div></div><div id='d_Rs' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><pre>Sets the given argument of this operation, by argument index.</pre></div></div><div id='d_Rr' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><pre>Returns the *internal types* for this operations arguments. This is
		typically the list of interfaces or @protocols that the arguments must
		comply to.</pre></div></div><div id='d_Ry' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type for this element</pre></div></div><div id='d_Rx' class='de'><h1>Method <span class='n'>setResultAbstractType</span></h1><div class='re'><code>setResultAbstractType( self, abstractType )</code></div><div class='ds'><pre>Sets the abstract type for this operation result. This is usually
		invoked in the typing phase.</pre></div></div><div id='d_Rz' class='de'><h1>Method <span class='n'>hasAnnotation</span></h1><div class='re'><code>hasAnnotation( self, name )</code></div><div class='ds'><pre>Tells if the given element has an annotation with the given name</pre></div></div><div id='d_RE' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.modeltypes.TypeCollection at 0x40315adc&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_RD' class='de'><h1>Method <span class='n'>invoke</span></h1><div class='re'><code>invoke( self, evaluable, *arguments )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_RG' class='de'><h1>Method <span class='n'>element</span></h1><div class='re'><code>element( self, key )</code></div><div class='ds'><pre>Returns the element associated to the given key.</pre></div></div><div id='d_RF' class='de'><h1>Method <span class='n'>clone</span></h1><div class='re'><code>clone( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_RA' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.ISubsetOperation at 0x85d28fc&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_RC' class='de'><h1>Method <span class='n'>setResultAbstractType</span></h1><div class='re'><code>setResultAbstractType( self, abstractType )</code></div><div class='ds'><pre>Sets the abstract type for this operation result. This is usually
		invoked in the typing phase.</pre></div></div><div id='d_RB' class='de'><h1>Method <span class='n'>getAnnotations</span></h1><div class='re'><code>getAnnotations( self, name=None )</code></div><div class='ds'><pre>Gets all the annotation with the given name associated to this element
		or all annotations if no name is specified.</pre></div></div><div id='d_RM' class='de'><h1>Method <span class='n'>setEnvironment</span></h1><div class='re'><code>setEnvironment( self, environment )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_RL' class='de'><h1>Method <span class='n'>getCurrentContext</span></h1><div class='re'><code>getCurrentContext( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_RN' class='de'><h1>Method <span class='n'>onWarning</span></h1><div class='re'><code>onWarning( self, callback )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_RI' class='de'><h1>Method <span class='n'>isSameAs</span></h1><div class='re'><code>isSameAs( self, otherType )</code></div><div class='ds'><pre>Generic implementation of isSameAs. You should always call this method
		in subclasses.</pre></div></div><div id='d_RH' class='de'><h1>Method <span class='n'>__str__</span></h1><div class='re'><code>__str__( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_RK' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_RJ' class='de'><h1>Method <span class='n'>resolveAbsolute</span></h1><div class='re'><code>resolveAbsolute( self, referenceOrName )</code></div><div class='ds'><pre>Resolves the given reference or string expressed in absolute style
		('.'-separated list of names), starting from the root dataflow (the program
		dataflow).</pre></div></div><div id='lE' class='ro'><div class='n'><a href='javascript:dS("lE");'>lambdafactory.modelwriter</a></div><div class='t'>Classes</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("lE","mE");'>AbstractWriter</a></div></div><div class='t'>Functions</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&lambda;</span><a href='javascript:dO("lE","wE");'><span class='protected'>_flatten</span></a></div><div class='slot documented'><span
					class='prefix'>&lambda;</span><a href='javascript:dO("lE","xE");'><span class='protected'>_format</span></a></div><div class='slot documented'><span
					class='prefix'>&lambda;</span><a href='javascript:dO("lE","yE");'>flatten</a></div><div class='slot documented'><span
					class='prefix'>&lambda;</span><a href='javascript:dO("lE","zE");'>format</a></div><div class='slot documented'><span
					class='prefix'>&lambda;</span><a href='javascript:dO("lE","AE");'>notEmpty</a></div></div><div class='t'>Values</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&bull;</span><a href='javascript:dO("lE","BE");'>PREFIX</a></div><div class='slot documented'><span
					class='prefix'>&bull;</span><a href='javascript:dO("lE","CE");'>SNIP</a></div></div></div><div id='lJ' class='ro'><div class='n'><a href='javascript:dS("lJ");'>lambdafactory.passes</a></div><div class='t'>Classes</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("lJ","mJ");'>DocumentationPass</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("lJ","aK");'>ExtendJSRuntime</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("lJ","PK");'>Importation</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("lJ","CL");'>Pass</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("lJ","nM");'>PassContext</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("lJ","UM");'>TransformAsynchronousInvocations</a></div></div></div><div id='le' class='cr'><div class='n'><a href='javascript:dS("le");'>IBlock</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("le","me");'><span class='special __bases__'>IGroup, IAssignable</span></a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("le","ne");'>addAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("le","oe");'>addOperation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("le","pe");'>copy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("le","qe");'>detach</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("le","re");'>getAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("le","se");'>getAnnotations</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("le","te");'>getDataFlow</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("le","ue");'>getOperations</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("le","ve");'>getParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("le","we");'>hasAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("le","xe");'>hasParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("le","ye");'>removeAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("le","ze");'>setAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("le","Ae");'>setParent</a></div></div></div><div id='lb' class='cr'><div class='n'><a href='javascript:dS("lb");'>IAbstractable</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("lb","c");'><span class='special __bases__'><i>Base class</i></span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("lb","mb");'>isAbstract</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("lb","nb");'>setAbstract</a></div></div></div><div id='d_of' class='de'><h1>Method <span class='n'>getAnnotations</span></h1><div class='re'><code>getAnnotations( self, name=None )</code></div><div class='ds'><pre>Gets all the annotation with the given name associated to this element
		or all annotations if no name is specified.</pre></div></div><div id='d_og' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IProcess at 0x85d241c&gt;, &lt;class lambdafactory.interfaces.IContext at 0x85d22fc&gt;)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_od' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><pre>Returns the ith arguments to this operation.</pre></div></div><div id='d_oe' class='de'><h1>Method <span class='n'>addOperation</span></h1><div class='re'><code>addOperation( self, operation )</code></div><div class='ds'><pre>Adds the given operation as a child of this process.</pre></div></div><div id='d_ob' class='de'><h1>Class <span class='n'>IAccessOperation</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_oc' class='de'><h1>Method <span class='n'>setSlot</span></h1><div class='re'><code>setSlot( self, name, evaluable )</code></div><div class='ds'><pre>Binds the given evaluable to the named slot. If there is already a slot
		with the same name, then 'getSlot(name)' should return the evaluable
		given as parameter.<br />		In the default implementation, setSlot preserves the ''history'' of
		added slots, and will always return the latest one.</pre></div></div><div id='d_on' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><pre>Sets this element parent</pre></div></div><div id='d_oo' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type for this element</pre></div></div><div id='d_ol' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><pre>Returns the dataflow accessible/bound to this element</pre></div></div><div id='d_om' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><pre>Tells if this element has a parent or not</pre></div></div><div id='d_oj' class='de'><h1>Method <span class='n'>hasSlot</span></h1><div class='re'><code>hasSlot( self, name )</code></div><div class='ds'><pre>Tells if the context has a slot with the given name.</pre></div></div><div id='d_ok' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><pre>Adds an argument to this operation. This should do checking of
		arguments (by expected internal type and number).</pre></div></div><div id='d_oh' class='de'><h1>Method <span class='n'>removeAnnotation</span></h1><div class='re'><code>removeAnnotation( self, name )</code></div><div class='ds'><pre>Removes the annotations with the given name</pre></div></div><div id='d_oi' class='de'><h1>Method <span class='n'>hasAnnotation</span></h1><div class='re'><code>hasAnnotation( self, name )</code></div><div class='ds'><pre>Tells if the given element has an annotation with the given name</pre></div></div><div id='d_ov' class='de'><h1>Method <span class='n'>hasExplicitTermination</span></h1><div class='re'><code>hasExplicitTermination( self )</code></div><div class='ds'><pre>Returns true if this function has an operation with a termination,
		otherwise return false.</pre></div></div><div id='d_ow' class='de'><h1>Method <span class='n'>endsWithTermination</span></h1><div class='re'><code>endsWithTermination( self )</code></div><div class='ds'><pre>Returns true if this function ends with a termination operation. This
		is especially useful for back-ends which want to know if they have to
		insert an explicit 'return' at the end (like Java).</pre></div></div><div id='d_ot' class='de'><h1>Method <span class='n'>getActualValue</span></h1><div class='re'><code>getActualValue( self )</code></div><div class='ds'><pre>Returns the (implementation language) value for this literal</pre></div></div><div id='d_ou' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><pre>Returns the *internal types* for this operations arguments. This is
		typically the list of interfaces or @protocols that the arguments must
		comply to.</pre></div></div><div id='d_or' class='de'><h1>Method <span class='n'>getMethods</span></h1><div class='re'><code>getMethods( self )</code></div><div class='ds'><pre>Returns the methods defined within this class.</pre></div></div><div id='d_os' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><pre>Returns the arguments to this operation.</pre></div></div><div id='d_op' class='de'><h1>Method <span class='n'>hasAnnotation</span></h1><div class='re'><code>hasAnnotation( self, name )</code></div><div class='ds'><pre>Tells if the given element has an annotation with the given name</pre></div></div><div id='d_oq' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><pre>Returns the arguments to this operation.</pre></div></div><div id='d_oz' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><pre>Detaches the element from its parent (in case it was already attached).
		This should return this element, and set the parent to None.</pre></div></div><div id='d_ox' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type for this element</pre></div></div><div id='d_oy' class='de'><h1>Method <span class='n'>removeAnnotation</span></h1><div class='re'><code>removeAnnotation( self, name )</code></div><div class='ds'><pre>Removes the annotations with the given name</pre></div></div><div id='d_oF' class='de'><h1>Method <span class='n'>length</span></h1><div class='re'><code>length( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_oG' class='de'><h1>Method <span class='n'>parents</span></h1><div class='re'><code>parents( self )</code></div><div class='ds'><pre>Returns a context parents, as a mutable list.</pre></div></div><div id='d_oD' class='de'><h1>Method <span class='n'>comment</span></h1><div class='re'><code>comment( self, content )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_oE' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_oB' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IReferencable at 0x85c4efc&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_oC' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type for this element</pre></div></div><div id='d_oA' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><pre>Tells if this element has a parent or not</pre></div></div><div id='d_oN' class='de'><h1>Method <span class='n'>getFactory</span></h1><div class='re'><code>getFactory( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_oL' class='de'><h1>Method <span class='n'>getProgram</span></h1><div class='re'><code>getProgram( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_oM' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self, environment=None, programPass=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_oJ' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self, args=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_oK' class='de'><h1>Method <span class='n'>getCurrentClosure</span></h1><div class='re'><code>getCurrentClosure( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_oH' class='de'><h1>Method <span class='n'>asString</span></h1><div class='re'><code>asString( self, fromTypes=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_oI' class='de'><h1>Method <span class='n'>setConcreteType</span></h1><div class='re'><code>setConcreteType( self, value )</code></div><div class='ds'><pre>Sets the _concrete type_ for this abstract type. The concrete type
		is a value which represents the type. For instance, if this type
		represents a class, then the concrete type would be the class instance.</pre></div></div><div id='Kb' class='cr'><div class='n'><a href='javascript:dS("Kb");'>IAccessor</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("Kb","Lb");'><span class='special __bases__'>IAttributeMethod</span></a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Kb","Mb");'>addAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Kb","Nb");'>addOperation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Kb","Ob");'>copy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Kb","Pb");'>detach</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Kb","Qb");'>endsWithTermination</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Kb","Rb");'>getAbsoluteName</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Kb","Sb");'>getAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Kb","Tb");'>getAnnotations</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Kb","Ub");'>getArguments</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Kb","Vb");'>getDataFlow</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Kb","Wb");'>getName</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Kb","Xb");'>getOperations</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Kb","Yb");'>getParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Kb","Zb");'>getReturnTypeDescription</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Kb","ac");'>getSlot</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Kb","bc");'>getSlotNames</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Kb","cc");'>getSlots</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Kb","dc");'>hasAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Kb","ec");'>hasExplicitTermination</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Kb","fc");'>hasParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Kb","gc");'>hasSlot</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Kb","hc");'>isAbstract</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Kb","ic");'>removeAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Kb","jc");'>setAbstract</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Kb","kc");'>setAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Kb","lc");'>setArguments</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Kb","mc");'>setParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Kb","nc");'>setReturnTypeDescription</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Kb","oc");'>setSlot</a></div></div></div><div id='d_qx' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><pre>Returns the dataflow accessible/bound to this element</pre></div></div><div id='d_qy' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><pre>Sets this element parent</pre></div></div><div id='d_qz' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type for this element</pre></div></div><div id='d_qt' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><pre>Performs a deep clone of this element. Any mutation to the original won't
		change the copy.</pre></div></div><div id='d_qu' class='de'><h1>Method <span class='n'>hasAnnotation</span></h1><div class='re'><code>hasAnnotation( self, name )</code></div><div class='ds'><pre>Tells if the given element has an annotation with the given name</pre></div></div><div id='Ki' class='cr'><div class='n'><a href='javascript:dS("Ki");'>IDataFlowOwner</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("Ki","c");'><span class='special __bases__'><i>Base class</i></span></a></div></div></div><div id='d_qw' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type for this element</pre></div></div><div id='d_qp' class='de'><h1>Method <span class='n'>removeAnnotation</span></h1><div class='re'><code>removeAnnotation( self, name )</code></div><div class='ds'><pre>Removes the annotations with the given name</pre></div></div><div id='d_qq' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><pre>Returns this element parent</pre></div></div><div id='d_qr' class='de'><h1>Method <span class='n'>getOperations</span></h1><div class='re'><code>getOperations( self )</code></div><div class='ds'><pre>Returns the operations (methods and class methods) defined within this class.</pre></div></div><div id='d_qs' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><pre>Returns this element parent</pre></div></div><div id='d_ql' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><pre>Returns the arguments to this operation.</pre></div></div><div id='d_qm' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><pre>Sets the abstract type for this element</pre></div></div><div id='d_qn' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IImportOperation at 0x85d26bc&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_qo' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><pre>Returns the dataflow accessible/bound to this element</pre></div></div><div id='d_qh' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><pre>Sets the given argument of this operation, by argument index.</pre></div></div><div id='d_qi' class='de'><h1>Method <span class='n'>removeAnnotation</span></h1><div class='re'><code>removeAnnotation( self, name )</code></div><div class='ds'><pre>Removes the annotations with the given name</pre></div></div><div id='d_qj' class='de'><h1>Method <span class='n'>removeAnnotation</span></h1><div class='re'><code>removeAnnotation( self, name )</code></div><div class='ds'><pre>Removes the annotations with the given name</pre></div></div><div id='d_qk' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><pre>Detaches the element from its parent (in case it was already attached).
		This should return this element, and set the parent to None.</pre></div></div><div id='d_qd' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><pre>Returns the *internal types* for this operations arguments. This is
		typically the list of interfaces or @protocols that the arguments must
		comply to.</pre></div></div><div id='d_qe' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><pre>Detaches the element from its parent (in case it was already attached).
		This should return this element, and set the parent to None.</pre></div></div><div id='d_qf' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><pre>Returns the parent context for this context (if any)</pre></div></div><div id='d_qg' class='de'><h1>Method <span class='n'>getReturnTypeDescription</span></h1><div class='re'><code>getReturnTypeDescription( self )</code></div><div class='ds'><pre>Returns the return type description for this closure, if any</pre></div></div><div id='d_qb' class='de'><h1>Method <span class='n'>getIndex</span></h1><div class='re'><code>getIndex( self )</code></div><div class='ds'><pre>Returns evaluable that will return the access index</pre></div></div><div id='d_qc' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IOperation at 0x85d268c&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='KG' class='cr'><div class='n'><a href='javascript:dS("KG");'>InvalidArgument</a></div><div class='t'>Inhertied Values</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("KG","dE");'><span class='special __getitem__'>get item</span></a></div><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("KG","jE");'><span class='special __init__'>constructor</span></a></div><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("KG","eE");'><span class='special __repr__'>string repr</span></a></div><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("KG","fE");'><span class='special __str__'>string conversion</span></a></div><div class='slot documented'><span
					class='prefix'>&sdot;</span><a href='javascript:dO("KG","gE");'>args</a></div><div class='slot documented'><span
					class='prefix'>&sdot;</span><a href='javascript:dO("KG","hE");'>message</a></div></div></div><div id='KE' class='cr'><div class='n'><a href='javascript:dS("KE");'>Operations</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("KE","LE");'><span class='special __bases__'>TypeCollection</span></a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("KE","ME");'>getType</a></div></div></div><div id='d_qL' class='de'><h1>Method <span class='n'>hasParentElement</span></h1><div class='re'><code>hasParentElement( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_qM' class='de'><h1>Method <span class='n'>filter</span></h1><div class='re'><code>filter( self, list, interface )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_qN' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><pre>Returns the name of this pass</pre></div></div><div id='d_qH' class='de'><h1>Method <span class='n'>elements</span></h1><div class='re'><code>elements( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_qI' class='de'><h1>Method <span class='n'>subtype</span></h1><div class='re'><code>subtype( self, name )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_qJ' class='de'><h1>Method <span class='n'>onModule</span></h1><div class='re'><code>onModule( self, module )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_qK' class='de'><h1>Method <span class='n'>getCurrentDataFlow</span></h1><div class='re'><code>getCurrentDataFlow( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_qD' class='de'><h1>Method <span class='n'>createAccessor</span></h1><div class='re'><code>createAccessor( self, name, arguments=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_qE' class='de'><h1>Method <span class='n'>_unique</span></h1><div class='re'><code>_unique( self, name )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_qF' class='de'><h1>Method <span class='n'>result</span></h1><div class='re'><code>result( self )</code></div><div class='ds'><pre>Returns the result for this type. This is usually just the type
		itself, except for processes types.</pre></div></div><div id='d_qG' class='de'><h1>Method <span class='n'>__str__</span></h1><div class='re'><code>__str__( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_qA' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><pre>Sets the abstract type for this element</pre></div></div><div id='d_qB' class='de'><h1>Method <span class='n'>getAbsoluteName</span></h1><div class='re'><code>getAbsoluteName( self )</code></div><div class='ds'><pre>Returns the absolute name for this element</pre></div></div><div id='d_qC' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><pre>Returns the dataflow accessible/bound to this element</pre></div></div><div id='d_Ub' class='de'><h1>Method <span class='n'>getArguments</span></h1><div class='re'><code>getArguments( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Uc' class='de'><h1>Method <span class='n'>isRest</span></h1><div class='re'><code>isRest( self )</code></div><div class='ds'><pre>Tells if this argument represents ''the rest'' of arguments in the
		invocation</pre></div></div><div id='d_Ud' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><pre>Returns this element parent</pre></div></div><div id='d_Ue' class='de'><h1>list</h1><div class='re'><code>[]</code></div><div class='ds'><pre>list() -&gt; new list
list(sequence) -&gt; new list initialized from sequence's items</pre></div></div><div id='d_Uf' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><pre>Returns this @protocol name. It can be `None` if the @protocol is anonymous.</pre></div></div><div id='d_Ug' class='de'><h1>Method <span class='n'>getOperand</span></h1><div class='re'><code>getOperand( self )</code></div><div class='ds'><pre>Returns the left operand of this computation.</pre></div></div><div id='d_Uh' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><pre>Sets the abstract type for this element</pre></div></div><div id='d_Ui' class='de'><h1>Method <span class='n'>addAnnotation</span></h1><div class='re'><code>addAnnotation( self, annotation )</code></div><div class='ds'><pre>Adds an annotation to this element</pre></div></div><div id='d_Uj' class='de'><h1>Class <span class='n'>IElement</span></h1><div class='re'></div><div class='ds'><pre>The core @protocol for every element.</pre></div></div><div id='d_Uk' class='de'><h1>Method <span class='n'>hasAnnotation</span></h1><div class='re'><code>hasAnnotation( self, name )</code></div><div class='ds'><pre>Tells if the given element has an annotation with the given name</pre></div></div><div id='d_Ul' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><pre>Sets the abstract type for this element</pre></div></div><div id='d_Um' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><pre>Sets the abstract type for this element</pre></div></div><div id='d_Un' class='de'><h1>Method <span class='n'>getAnnotations</span></h1><div class='re'><code>getAnnotations( self, name=None )</code></div><div class='ds'><pre>Gets all the annotation with the given name associated to this element
		or all annotations if no name is specified.</pre></div></div><div id='d_Uo' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><pre>Sets the abstract type for this element</pre></div></div><div id='d_Up' class='de'><h1>Method <span class='n'>removeAnnotation</span></h1><div class='re'><code>removeAnnotation( self, name )</code></div><div class='ds'><pre>Removes the annotations with the given name</pre></div></div><div id='d_Uq' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><pre>Sets the abstract type for this element</pre></div></div><div id='d_Ur' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><pre>Tells if this element has a parent or not</pre></div></div><div id='d_Us' class='de'><h1>Class <span class='n'>IList</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Ut' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><pre>Tells if this element has a parent or not</pre></div></div><div id='d_Uu' class='de'><h1>Class <span class='n'>IMethod</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Uv' class='de'><h1>Method <span class='n'>hasAnnotation</span></h1><div class='re'><code>hasAnnotation( self, name )</code></div><div class='ds'><pre>Tells if the given element has an annotation with the given name</pre></div></div><div id='d_Uw' class='de'><h1>Method <span class='n'>getAnnotations</span></h1><div class='re'><code>getAnnotations( self, name=None )</code></div><div class='ds'><pre>Gets all the annotation with the given name associated to this element
		or all annotations if no name is specified.</pre></div></div><div id='d_Ux' class='de'><h1>Method <span class='n'>getValue</span></h1><div class='re'><code>getValue( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Uy' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><pre>Returns the parent context for this context (if any)</pre></div></div><div id='d_Uz' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><pre>Sets the abstract type for this element</pre></div></div><div id='d_UA' class='de'><h1>Method <span class='n'>addAnnotation</span></h1><div class='re'><code>addAnnotation( self, annotation )</code></div><div class='ds'><pre>Adds an annotation to this element</pre></div></div><div id='d_UB' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><pre>Returns the arguments to this operation.</pre></div></div><div id='d_UC' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self, module=<module 'lambdafactory.model' from '/home/sebastien/Projects/Local/lib/python/lambdafactory/model.py'> )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_UD' class='de'><h1>Method <span class='n'>matchProcess</span></h1><div class='re'><code>matchProcess( self, evaluable, process )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_UE' class='de'><h1>Method <span class='n'>getType</span></h1><div class='re'><code>getType( self, name )</code></div><div class='ds'><pre>Returns the type with the given name, or None if it does not
		exist.</pre></div></div><div id='d_UF' class='de'><h1>Method <span class='n'>isSubtypeOf</span></h1><div class='re'><code>isSubtypeOf( self, otherType )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_UG' class='de'><h1>Method <span class='n'>get</span></h1><div class='re'><code>get( self, name )</code></div><div class='ds'><pre>Returns the type for the slot with the given name.</pre></div></div><div id='d_UH' class='de'><h1>Method <span class='n'>definedBy</span></h1><div class='re'><code>definedBy( self, definition=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_UI' class='de'><h1>Method <span class='n'>result</span></h1><div class='re'><code>result( self )</code></div><div class='ds'><pre>Returns the result for this type. This is usually just the type
		itself, except for processes types.</pre></div></div><div id='d_UJ' class='de'><h1>Method <span class='n'>run</span></h1><div class='re'><code>run( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_UK' class='de'><h1>Method <span class='n'>filter</span></h1><div class='re'><code>filter( self, list, interface )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_UL' class='de'><h1>Method <span class='n'>getCurrentFunction</span></h1><div class='re'><code>getCurrentFunction( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_UM' class='de'><h1>Class <span class='n'>TransformAsynchronousInvocations</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_CJ' class='de'><h1>Method <span class='n'>getCurrentDataFlow</span></h1><div class='re'><code>getCurrentDataFlow( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_CK' class='de'><h1>Method <span class='n'>hasParentElement</span></h1><div class='re'><code>hasParentElement( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_CH' class='de'><h1>Method <span class='n'>setName</span></h1><div class='re'><code>setName( self, name )</code></div><div class='ds'><pre>Sets the name of this type</pre></div></div><div id='d_CI' class='de'><h1>Method <span class='n'>name</span></h1><div class='re'><code>name( self, name=None )</code></div><div class='ds'><pre>Returns/sets the name for this type. By defaults, types are unnamed.</pre></div></div><div id='d_CN' class='de'><h1>Method <span class='n'>setPass</span></h1><div class='re'><code>setPass( self, programPass )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_CL' class='de'><h1>Class <span class='n'>Pass</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_CM' class='de'><h1>Method <span class='n'>getCurrentFunction</span></h1><div class='re'><code>getCurrentFunction( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_CB' class='de'><h1>Method <span class='n'>getResultAbstractType</span></h1><div class='re'><code>getResultAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type of the result of the evaluation of this
		evaluable</pre></div></div><div id='d_CC' class='de'><h1>Class <span class='n'>IValue</span></h1><div class='re'></div><div class='ds'><pre>A value represents an atomic element of the language, like a number, a
	string, or a name (that can resolved by the language, acts as key for data
	structures, etc.).</pre></div></div><div id='d_CA' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type for this element</pre></div></div><div id='d_CF' class='de'><h1>Method <span class='n'>setContentType</span></h1><div class='re'><code>setContentType( self, theType )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_CG' class='de'><h1>Method <span class='n'>set</span></h1><div class='re'><code>set( self, name, theType )</code></div><div class='ds'><pre>Sets the slot with the given 'name' to have a value of the given
		type ('theType').</pre></div></div><div id='d_CD' class='de'><h1>Method <span class='n'>createModule</span></h1><div class='re'><code>createModule( self, name )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_CE' class='de'><h1>str</h1><div class='re'><code>'8&lt; ---[%s]---'</code></div><div class='ds'><pre>str(object) -&gt; string<br />Return a nice string representation of the object.
If the argument is a string, the return value is the same object.</pre></div></div><div id='d_Cj' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><pre>Performs a deep clone of this element. Any mutation to the original won't
		change the copy.</pre></div></div><div id='d_Ck' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><pre>Sets the given argument of this operation, by argument index.</pre></div></div><div id='d_Ch' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type for this element</pre></div></div><div id='d_Ci' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><pre>Returns the list of parent dataflows for this dataflow.</pre></div></div><div id='d_Cn' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><pre>Returns the *internal types* for this operations arguments. This is
		typically the list of interfaces or @protocols that the arguments must
		comply to.</pre></div></div><div id='d_Co' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IImportOperation at 0x85d26bc&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_Cl' class='de'><h1>Method <span class='n'>setResultAbstractType</span></h1><div class='re'><code>setResultAbstractType( self, abstractType )</code></div><div class='ds'><pre>Sets the abstract type for this operation result. This is usually
		invoked in the typing phase.</pre></div></div><div id='d_Cm' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><pre>Detaches the element from its parent (in case it was already attached).
		This should return this element, and set the parent to None.</pre></div></div><div id='d_Cb' class='de'><h1>Method <span class='n'>getTarget</span></h1><div class='re'><code>getTarget( self )</code></div><div class='ds'><pre>Returns the operation target.</pre></div></div><div id='d_Cc' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><pre>Returns the *internal types* for this operations arguments. This is
		typically the list of interfaces or @protocols that the arguments must
		comply to.</pre></div></div><div id='d_Cf' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IAttribute at 0x85d226c&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_Cg' class='de'><h1>Method <span class='n'>getSlot</span></h1><div class='re'><code>getSlot( self, name )</code></div><div class='ds'><pre>Returns the given evaluable bound to named slot.</pre></div></div><div id='d_Cd' class='de'><h1>Method <span class='n'>setDefaultValue</span></h1><div class='re'><code>setDefaultValue( self )</code></div><div class='ds'><pre>Sets the @methodault value for this attribute</pre></div></div><div id='d_Ce' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IInterruption at 0x85d2b0c&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_Cz' class='de'><h1>Class <span class='n'>IRepetition</span></h1><div class='re'></div><div class='ds'><pre>A repetition is the repetitive execution of a process according to a
	predicate expression which can be modified by the process.</pre></div></div><div id='d_Cx' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><pre>Performs a deep clone of this element. Any mutation to the original won't
		change the copy.</pre></div></div><div id='d_Cy' class='de'><h1>Method <span class='n'>hasAnnotation</span></h1><div class='re'><code>hasAnnotation( self, name )</code></div><div class='ds'><pre>Tells if the given element has an annotation with the given name</pre></div></div><div id='d_Cr' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><pre>Sets the abstract type for this element</pre></div></div><div id='d_Cs' class='de'><h1>Method <span class='n'>addAnnotation</span></h1><div class='re'><code>addAnnotation( self, annotation )</code></div><div class='ds'><pre>Adds an annotation to this element</pre></div></div><div id='d_Cp' class='de'><h1>Method <span class='n'>endsWithTermination</span></h1><div class='re'><code>endsWithTermination( self )</code></div><div class='ds'><pre>Returns true if this function ends with a termination operation. This
		is especially useful for back-ends which want to know if they have to
		insert an explicit 'return' at the end (like Java).</pre></div></div><div id='d_Cq' class='de'><h1>Method <span class='n'>getProcess</span></h1><div class='re'><code>getProcess( self )</code></div><div class='ds'><pre>Returns the process that we will intercept interruptions from.</pre></div></div><div id='d_Cv' class='de'><h1>Method <span class='n'>getClasses</span></h1><div class='re'><code>getClasses( self )</code></div><div class='ds'><pre>Returns the list of classes defined in this module. This is mainly a
		convenience function.</pre></div></div><div id='d_Cw' class='de'><h1>Method <span class='n'>hasExplicitTermination</span></h1><div class='re'><code>hasExplicitTermination( self )</code></div><div class='ds'><pre>Returns true if this function has an operation with a termination,
		otherwise return false.</pre></div></div><div id='d_Ct' class='de'><h1>Method <span class='n'>setResultAbstractType</span></h1><div class='re'><code>setResultAbstractType( self, abstractType )</code></div><div class='ds'><pre>Sets the abstract type for this operation result. This is usually
		invoked in the typing phase.</pre></div></div><div id='d_Cu' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><pre>Performs a deep clone of this element. Any mutation to the original won't
		change the copy.</pre></div></div><div id='d_GI' class='de'><h1>Method <span class='n'>subtype</span></h1><div class='re'><code>subtype( self, name )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='Pc' class='cr'><div class='n'><a href='javascript:dS("Pc");'>IArgument</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("Pc","Qc");'><span class='special __bases__'>ISlot</span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Pc","Rc");'>getDefaultValue</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Pc","Sc");'>isKeywordsRest</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Pc","Tc");'>isOptional</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Pc","Uc");'>isRest</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Pc","Vc");'>setDefaultValue</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Pc","Wc");'>setKeywordsRest</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Pc","Xc");'>setOptional</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Pc","Yc");'>setRest</a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Pc","Zc");'>getAbsoluteName</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Pc","ad");'>getName</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Pc","bd");'>getTypeDescription</a></div></div></div><div id='Pj' class='cr'><div class='n'><a href='javascript:dS("Pj");'>IDocumentation</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("Pj","Qj");'><span class='special __bases__'>IAnnotation</span></a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Pj","Rj");'>getContent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Pj","Sj");'>getName</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Pj","Tj");'>setContent</a></div></div></div><div id='PK' class='cr'><div class='n'><a href='javascript:dS("PK");'>Importation</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("PK","QK");'><span class='special __bases__'>Pass</span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("PK","RK");'><span class='special __init__'>constructor</span></a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("PK","SK");'>onModule</a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("PK","TK");'>annotate</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("PK","UK");'>filter</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("PK","VK");'>filterContext</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("PK","WK");'>findInContext</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("PK","XK");'>getClassAncestors</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("PK","YK");'>getClassParents</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("PK","ZK");'>getCurrentClass</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("PK","aL");'>getCurrentClassAncestors</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("PK","bL");'>getCurrentClassParents</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("PK","cL");'>getCurrentClosure</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("PK","dL");'>getCurrentContext</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("PK","eL");'>getCurrentDataFlow</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("PK","fL");'>getCurrentElement</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("PK","gL");'>getCurrentFunction</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("PK","hL");'>getCurrentMethod</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("PK","iL");'>getCurrentModule</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("PK","jL");'>getCurrentProcess</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("PK","kL");'>getFactory</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("PK","lL");'>getHandler</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("PK","mL");'>getName</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("PK","nL");'>getParentElement</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("PK","oL");'>getProgram</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("PK","pL");'>handle</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("PK","qL");'>hasParentElement</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("PK","rL");'>isIn</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("PK","sL");'>resolve</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("PK","tL");'>resolveAbsolute</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("PK","uL");'>resolveAbsoluteOrLocal</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("PK","vL");'>resolveLocalOrAbsolute</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("PK","wL");'>run</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("PK","xL");'>setEnvironment</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("PK","yL");'>setPass</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("PK","zL");'>walk</a></div></div><div class='t'>Values</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&bull;</span><a href='javascript:dO("PK","AL");'>HANDLES</a></div><div class='slot documented'><span
					class='prefix'>&bull;</span><a href='javascript:dO("PK","BL");'>NAME</a></div></div></div><div id='d_fB' class='de'><h1>Method <span class='n'>getTarget</span></h1><div class='re'><code>getTarget( self )</code></div><div class='ds'><pre>Returns the operation target.</pre></div></div><div id='d_GL' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><pre>Returns the name of this pass</pre></div></div><div id='d_pz' class='de'><h1>Method <span class='n'>getAbsoluteName</span></h1><div class='re'><code>getAbsoluteName( self )</code></div><div class='ds'><pre>Returns the absolute name for this element</pre></div></div><div id='d_py' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><pre>Sets the abstract type for this element</pre></div></div><div id='d_px' class='de'><h1>Method <span class='n'>getAnnotations</span></h1><div class='re'><code>getAnnotations( self, name=None )</code></div><div class='ds'><pre>Gets all the annotation with the given name associated to this element
		or all annotations if no name is specified.</pre></div></div><div id='d_pw' class='de'><h1>Method <span class='n'>getAbsoluteName</span></h1><div class='re'><code>getAbsoluteName( self )</code></div><div class='ds'><pre>Returns the absolute name for this element</pre></div></div><div id='d_pv' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><pre>Tells if this element has a parent or not</pre></div></div><div id='d_pu' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><pre>Returns this element parent</pre></div></div><div id='d_pt' class='de'><h1>Method <span class='n'>addAnnotation</span></h1><div class='re'><code>addAnnotation( self, annotation )</code></div><div class='ds'><pre>Adds an annotation to this element</pre></div></div><div id='d_ps' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><pre>Returns the *internal types* for this operations arguments. This is
		typically the list of interfaces or @protocols that the arguments must
		comply to.</pre></div></div><div id='d_pr' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><pre>Returns this class name. It can be `None` if the class is anonymous.</pre></div></div><div id='d_pq' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><pre>Returns the *internal types* for this operations arguments. This is
		typically the list of interfaces or @protocols that the arguments must
		comply to.</pre></div></div><div id='d_pp' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><pre>Tells if this element has a parent or not</pre></div></div><div id='d_po' class='de'><h1>Method <span class='n'>getAnnotations</span></h1><div class='re'><code>getAnnotations( self, name=None )</code></div><div class='ds'><pre>Gets all the annotation with the given name associated to this element
		or all annotations if no name is specified.</pre></div></div><div id='d_pn' class='de'><h1>Class <span class='n'>IImportModuleOperation</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_pm' class='de'><h1>Method <span class='n'>removeAnnotation</span></h1><div class='re'><code>removeAnnotation( self, name )</code></div><div class='ds'><pre>Removes the annotations with the given name</pre></div></div><div id='d_pl' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><pre>Returns the ith arguments to this operation.</pre></div></div><div id='d_pk' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><pre>Performs a deep clone of this element. Any mutation to the original won't
		change the copy.</pre></div></div><div id='d_pj' class='de'><h1>Method <span class='n'>isAbstract</span></h1><div class='re'><code>isAbstract( self )</code></div><div class='ds'><pre>Tells wether the given abstractable is abstract or not.</pre></div></div><div id='d_pi' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><pre>Tells if this element has a parent or not</pre></div></div><div id='d_ph' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><pre>Sets the abstract type for this element</pre></div></div><div id='d_pg' class='de'><h1>Method <span class='n'>getArguments</span></h1><div class='re'><code>getArguments( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_pf' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><pre>Returns the dataflow accessible/bound to this element</pre></div></div><div id='d_pe' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><pre>Performs a deep clone of this element. Any mutation to the original won't
		change the copy.</pre></div></div><div id='d_pd' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><pre>Returns the arguments to this operation.</pre></div></div><div id='d_pc' class='de'><h1>Class <span class='n'>IAllocation</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_pb' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.ISubsetOperation at 0x85d28fc&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_pN' class='de'><h1>Method <span class='n'>getHandler</span></h1><div class='re'><code>getHandler( self, element )</code></div><div class='ds'><pre>Tells if the pass handles the given element. This basically iterates
		on the 'handles' property values (which are interfaces), when one
		interface matches the given 'element', then the corresponding 'onXXX'
		method is invoked, where 'XXX' is the interface
		name (without the leading 'I').</pre></div></div><div id='d_pM' class='de'><h1>Method <span class='n'>annotate</span></h1><div class='re'><code>annotate( self, value, name, content=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_pL' class='de'><h1>Method <span class='n'>handle</span></h1><div class='re'><code>handle( self, element )</code></div><div class='ds'><pre>Handles a sungle element, without recursing through its children</pre></div></div><div id='d_pK' class='de'><h1>Method <span class='n'>getCurrentContext</span></h1><div class='re'><code>getCurrentContext( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_pJ' class='de'><h1>Method <span class='n'>asHTML</span></h1><div class='re'><code>asHTML( self, title=None )</code></div><div class='ds'><pre>Returns the HTML document generated by this pass</pre></div></div><div id='d_pI' class='de'><h1>Method <span class='n'>setName</span></h1><div class='re'><code>setName( self, name )</code></div><div class='ds'><pre>Sets the name of this type</pre></div></div><div id='d_pH' class='de'><h1>Method <span class='n'>clone</span></h1><div class='re'><code>clone( self, clone=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_pG' class='de'><h1>Method <span class='n'>__call__</span></h1><div class='re'><code>__call__( self )</code></div><div class='ds'><pre>A type instance can be used as a class to construct a new type, which
		will be cloned from the current type.</pre></div></div><div id='d_pF' class='de'><h1>Method <span class='n'>name</span></h1><div class='re'><code>name( self, name=None )</code></div><div class='ds'><pre>Returns/sets the name for this type. By defaults, types are unnamed.</pre></div></div><div id='d_pE' class='de'><h1>Method <span class='n'>_format</span></h1><div class='re'><code>_format( self, *values )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_pD' class='de'><h1>Method <span class='n'>compute</span></h1><div class='re'><code>compute( self, operatorName, leftOperand, rightOperand=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_pC' class='de'><h1>Method <span class='n'>getAnnotations</span></h1><div class='re'><code>getAnnotations( self, name=None )</code></div><div class='ds'><pre>Gets all the annotation with the given name associated to this element
		or all annotations if no name is specified.</pre></div></div><div id='d_pB' class='de'><h1>Method <span class='n'>getTypeDescription</span></h1><div class='re'><code>getTypeDescription( self )</code></div><div class='ds'><pre>Returns type information (constraints) that are associated to this
		argument.</pre></div></div><div id='d_pA' class='de'><h1>Method <span class='n'>removeAnnotation</span></h1><div class='re'><code>removeAnnotation( self, name )</code></div><div class='ds'><pre>Removes the annotations with the given name</pre></div></div><div id='d_nc' class='de'><h1>Method <span class='n'>setReturnTypeDescription</span></h1><div class='re'><code>setReturnTypeDescription( self, description )</code></div><div class='ds'><pre>Sets the return type description for this closure, if any</pre></div></div><div id='d_nb' class='de'><h1>Method <span class='n'>setAbstract</span></h1><div class='re'><code>setAbstract( self, isAbstract )</code></div><div class='ds'><pre>Sets wether the given abstractable is abstract or not.</pre></div></div><div id='d_ne' class='de'><h1>Method <span class='n'>addAnnotation</span></h1><div class='re'><code>addAnnotation( self, annotation )</code></div><div class='ds'><pre>Adds an annotation to this element</pre></div></div><div id='d_nd' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><pre>Returns the dataflow accessible/bound to this element</pre></div></div><div id='d_ng' class='de'><h1>Class <span class='n'>IClosure</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_nf' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type for this element</pre></div></div><div id='d_ni' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><pre>Returns the dataflow accessible/bound to this element</pre></div></div><div id='d_nh' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><pre>Tells if this element has a parent or not</pre></div></div><div id='d_nk' class='de'><h1>Method <span class='n'>addAnnotation</span></h1><div class='re'><code>addAnnotation( self, annotation )</code></div><div class='ds'><pre>Adds an annotation to this element</pre></div></div><div id='d_nj' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><pre>Tells if this element has a parent or not</pre></div></div><div id='d_nm' class='de'><h1>Method <span class='n'>hasAnnotation</span></h1><div class='re'><code>hasAnnotation( self, name )</code></div><div class='ds'><pre>Tells if the given element has an annotation with the given name</pre></div></div><div id='d_nl' class='de'><h1>Method <span class='n'>getAnnotations</span></h1><div class='re'><code>getAnnotations( self, name=None )</code></div><div class='ds'><pre>Gets all the annotation with the given name associated to this element
		or all annotations if no name is specified.</pre></div></div><div id='d_no' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><pre>Detaches the element from its parent (in case it was already attached).
		This should return this element, and set the parent to None.</pre></div></div><div id='d_nn' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><pre>Sets the abstract type for this element</pre></div></div><div id='d_nq' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><pre>Returns the ith arguments to this operation.</pre></div></div><div id='d_np' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><pre>Returns this element parent</pre></div></div><div id='d_ns' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><pre>Returns the ith arguments to this operation.</pre></div></div><div id='d_nr' class='de'><h1>Method <span class='n'>getInstanceMethods</span></h1><div class='re'><code>getInstanceMethods( self )</code></div><div class='ds'><pre>Returns the instance methods defined within this class.</pre></div></div><div id='d_nu' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><pre>Returns the arguments to this operation.</pre></div></div><div id='d_nt' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IValue at 0x85d202c&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_nw' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><pre>Detaches the element from its parent (in case it was already attached).
		This should return this element, and set the parent to None.</pre></div></div><div id='d_nv' class='de'><h1>Method <span class='n'>hasAnnotation</span></h1><div class='re'><code>hasAnnotation( self, name )</code></div><div class='ds'><pre>Tells if the given element has an annotation with the given name</pre></div></div><div id='d_ny' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><pre>Tells if this element has a parent or not</pre></div></div><div id='d_nx' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><pre>Detaches the element from its parent (in case it was already attached).
		This should return this element, and set the parent to None.</pre></div></div><div id='d_nz' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><pre>Performs a deep clone of this element. Any mutation to the original won't
		change the copy.</pre></div></div><div id='d_nA' class='de'><h1>Method <span class='n'>hasAnnotation</span></h1><div class='re'><code>hasAnnotation( self, name )</code></div><div class='ds'><pre>Tells if the given element has an annotation with the given name</pre></div></div><div id='d_nC' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><pre>Detaches the element from its parent (in case it was already attached).
		This should return this element, and set the parent to None.</pre></div></div><div id='d_nB' class='de'><h1>Class <span class='n'>ISlot</span></h1><div class='re'></div><div class='ds'><pre>An argument is a reference with additional type information.</pre></div></div><div id='d_nE' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.passes.Pass at 0x857b20c&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_nD' class='de'><h1>Method <span class='n'>breaks</span></h1><div class='re'><code>breaks( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_nG' class='de'><h1>Method <span class='n'>parent</span></h1><div class='re'><code>parent( self, parent=None )</code></div><div class='ds'><pre>Returns the main parent for this context.</pre></div></div><div id='d_nF' class='de'><h1>Method <span class='n'>isSubtypeOf</span></h1><div class='re'><code>isSubtypeOf( self, otherType )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_nI' class='de'><h1>Method <span class='n'>result</span></h1><div class='re'><code>result( self )</code></div><div class='ds'><pre>Returns the result for this type. This is usually just the type
		itself, except for processes types.</pre></div></div><div id='d_nH' class='de'><h1>Method <span class='n'>arguments</span></h1><div class='re'><code>arguments( self, args=None )</code></div><div class='ds'><pre>Returns the arguments of this process encapsulated in a sequence
		if there is more than one argument.</pre></div></div><div id='d_nK' class='de'><h1>Method <span class='n'>getCurrentClassParents</span></h1><div class='re'><code>getCurrentClassParents( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_nJ' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.passes.Pass at 0x857b20c&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_nM' class='de'><h1>Class <span class='n'>PassContext</span></h1><div class='re'></div><div class='ds'><pre>The 'PassContext' represents the current state of one or more passes when
	walking the program. It offers access to the 'environment' (gives access
	to the program and various passes) but more importantly gives access
	to _dataflow-related primitives_ which allow you to resolve symbols
	an interrogate contexts.<br />	NOTE that a single pass context can be shared among various passes.</pre></div></div><div id='d_nL' class='de'><h1>Method <span class='n'>getParentElement</span></h1><div class='re'><code>getParentElement( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_nN' class='de'><h1>Method <span class='n'>getCurrentProcess</span></h1><div class='re'><code>getCurrentProcess( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_BE' class='de'><h1>str</h1><div class='re'><code>'\t'</code></div><div class='ds'><pre>str(object) -&gt; string<br />Return a nice string representation of the object.
If the argument is a string, the return value is the same object.</pre></div></div><div id='d_BD' class='de'><h1>Method <span class='n'>createMethod</span></h1><div class='re'><code>createMethod( self, name, arguments=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_BG' class='de'><h1>Method <span class='n'>result</span></h1><div class='re'><code>result( self )</code></div><div class='ds'><pre>Returns the result for this type. This is usually just the type
		itself, except for processes types.</pre></div></div><div id='d_BF' class='de'><h1>Method <span class='n'>isSubtypeOf</span></h1><div class='re'><code>isSubtypeOf( self, otherType )</code></div><div class='ds'><pre>Othertype must be an Array with a content type that is a subtype of
		this content type.</pre></div></div><div id='d_BA' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><pre>Detaches the element from its parent (in case it was already attached).
		This should return this element, and set the parent to None.</pre></div></div><div id='d_BC' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.IEvaluable at 0x85c4f2c&gt;]</code></div><div class='ds'><pre>list() -&gt; new list
list(sequence) -&gt; new list initialized from sequence's items</pre></div></div><div id='d_BB' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><pre>Returns this element parent</pre></div></div><div id='d_BM' class='de'><h1>Method <span class='n'>getCurrentElement</span></h1><div class='re'><code>getCurrentElement( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_BL' class='de'><h1>str</h1><div class='re'><code>'Importation'</code></div><div class='ds'><pre>str(object) -&gt; string<br />Return a nice string representation of the object.
If the argument is a string, the return value is the same object.</pre></div></div><div id='d_BN' class='de'><h1>Method <span class='n'>setEnvironment</span></h1><div class='re'><code>setEnvironment( self, environment )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_BI' class='de'><h1>Method <span class='n'>isSubtypeOf</span></h1><div class='re'><code>isSubtypeOf( self, otherType )</code></div><div class='ds'><pre>Generic implementation of isSubtypeOf. You should always call this method
		in subclasses, as it implements basic type systems rules such as
		isSubtypeOf(Any).</pre></div></div><div id='d_BH' class='de'><h1>Method <span class='n'>setConcreteType</span></h1><div class='re'><code>setConcreteType( self, value )</code></div><div class='ds'><pre>Sets the _concrete type_ for this abstract type. The concrete type
		is a value which represents the type. For instance, if this type
		represents a class, then the concrete type would be the class instance.</pre></div></div><div id='d_BK' class='de'><h1>Method <span class='n'>handle</span></h1><div class='re'><code>handle( self, element )</code></div><div class='ds'><pre>Handles a sungle element, without recursing through its children</pre></div></div><div id='d_BJ' class='de'><h1>Method <span class='n'>getCurrentContext</span></h1><div class='re'><code>getCurrentContext( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Bu' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><pre>Adds an argument to this operation. This should do checking of
		arguments (by expected internal type and number).</pre></div></div><div id='d_Bt' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><pre>Sets this element parent</pre></div></div><div id='d_Bw' class='de'><h1>Method <span class='n'>hasAnnotation</span></h1><div class='re'><code>hasAnnotation( self, name )</code></div><div class='ds'><pre>Tells if the given element has an annotation with the given name</pre></div></div><div id='d_Bv' class='de'><h1>Method <span class='n'>addImportOperation</span></h1><div class='re'><code>addImportOperation( self, operation )</code></div><div class='ds'><pre>Returns the list of import operations declared in this module
		</pre></div></div><div id='d_Bq' class='de'><h1>Method <span class='n'>getIntercept</span></h1><div class='re'><code>getIntercept( self )</code></div><div class='ds'><pre>Returns the process that will do the interception</pre></div></div><div id='d_Bp' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><pre>Detaches the element from its parent (in case it was already attached).
		This should return this element, and set the parent to None.</pre></div></div><div id='d_Bs' class='de'><h1>Method <span class='n'>getIterator</span></h1><div class='re'><code>getIterator( self )</code></div><div class='ds'><pre>Returns this iteration iterator.</pre></div></div><div id='d_Br' class='de'><h1>Method <span class='n'>setAbstract</span></h1><div class='re'><code>setAbstract( self, isAbstract )</code></div><div class='ds'><pre>Sets wether the given abstractable is abstract or not.</pre></div></div><div id='d_By' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><pre>Returns this element parent</pre></div></div><div id='d_Bx' class='de'><h1>Method <span class='n'>addAnnotation</span></h1><div class='re'><code>addAnnotation( self, annotation )</code></div><div class='ds'><pre>Adds an annotation to this element</pre></div></div><div id='d_Bz' class='de'><h1>Method <span class='n'>setResultAbstractType</span></h1><div class='re'><code>setResultAbstractType( self, abstractType )</code></div><div class='ds'><pre>Sets the abstract type for this operation result. This is usually
		invoked in the typing phase.</pre></div></div><div id='d_Be' class='de'><h1>Class <span class='n'>IBreaking</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Bd' class='de'><h1>Method <span class='n'>getDefaultValue</span></h1><div class='re'><code>getDefaultValue( self )</code></div><div class='ds'><pre>Gets the @methodault value for this attribute</pre></div></div><div id='d_Bg' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><pre>Returns this element parent</pre></div></div><div id='d_Bf' class='de'><h1>Class <span class='n'>IClassAttribute</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Bc' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><pre>Returns the arguments to this operation.</pre></div></div><div id='d_Bb' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><pre>Returns this element parent</pre></div></div><div id='d_Bm' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><pre>Performs a deep clone of this element. Any mutation to the original won't
		change the copy.</pre></div></div><div id='d_Bl' class='de'><h1>Method <span class='n'>getResultAbstractType</span></h1><div class='re'><code>getResultAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type of the result of the evaluation of this
		evaluable</pre></div></div><div id='d_Bo' class='de'><h1>Class <span class='n'>IImportSymbolOperation</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Bn' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><pre>Returns the arguments to this operation.</pre></div></div><div id='d_Bi' class='de'><h1>Method <span class='n'>getDestinations</span></h1><div class='re'><code>getDestinations( self )</code></div><div class='ds'><pre>Returns the dataflows that are _destinations_, meaning that these
		dataflows will resolve if this dataflow if resolution fails, according tot
		the resolution scheme used.</pre></div></div><div id='d_Bh' class='de'><h1>Method <span class='n'>getAbsoluteName</span></h1><div class='re'><code>getAbsoluteName( self )</code></div><div class='ds'><pre>Returns the absolute name for this element</pre></div></div><div id='d_Bk' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><pre>Sets the abstract type for this element</pre></div></div><div id='d_Bj' class='de'><h1>Method <span class='n'>addAnnotation</span></h1><div class='re'><code>addAnnotation( self, annotation )</code></div><div class='ds'><pre>Adds an annotation to this element</pre></div></div><div id='aI' class='cr'><div class='n'><a href='javascript:dS("aI");'>Symbolic</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("aI","bI");'><span class='special __bases__'>Type</span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("aI","cI");'><span class='special __init__'>constructor</span></a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("aI","dI");'>asString</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("aI","eI");'>clone</a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("aI","fI");'><span class='special __call__'>when invoked</span></a></div><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("aI","gI");'><span class='special __str__'>string conversion</span></a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("aI","hI");'>concreteType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("aI","iI");'>definedBy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("aI","jI");'>isLike</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("aI","kI");'>isSameAs</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("aI","lI");'>isSubtypeOf</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("aI","mI");'>name</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("aI","nI");'>result</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("aI","oI");'>setConcreteType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("aI","pI");'>setName</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("aI","qI");'>subtype</a></div></div></div><div id='aK' class='cr'><div class='n'><a href='javascript:dS("aK");'>ExtendJSRuntime</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("aK","bK");'><span class='special __bases__'>Pass</span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("aK","cK");'><span class='special __init__'>constructor</span></a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("aK","dK");'>onModule</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("aK","eK");'>onProgram</a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("aK","fK");'>annotate</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("aK","gK");'>filter</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("aK","hK");'>filterContext</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("aK","iK");'>findInContext</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("aK","jK");'>getClassAncestors</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("aK","kK");'>getClassParents</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("aK","lK");'>getCurrentClass</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("aK","mK");'>getCurrentClassAncestors</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("aK","nK");'>getCurrentClassParents</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("aK","oK");'>getCurrentClosure</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("aK","pK");'>getCurrentContext</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("aK","qK");'>getCurrentDataFlow</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("aK","rK");'>getCurrentElement</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("aK","sK");'>getCurrentFunction</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("aK","tK");'>getCurrentMethod</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("aK","uK");'>getCurrentModule</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("aK","vK");'>getCurrentProcess</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("aK","wK");'>getFactory</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("aK","xK");'>getHandler</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("aK","yK");'>getName</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("aK","zK");'>getParentElement</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("aK","AK");'>getProgram</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("aK","BK");'>handle</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("aK","CK");'>hasParentElement</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("aK","DK");'>isIn</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("aK","EK");'>resolve</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("aK","FK");'>resolveAbsolute</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("aK","GK");'>resolveAbsoluteOrLocal</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("aK","HK");'>resolveLocalOrAbsolute</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("aK","IK");'>run</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("aK","JK");'>setEnvironment</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("aK","KK");'>setPass</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("aK","LK");'>walk</a></div></div><div class='t'>Values</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&bull;</span><a href='javascript:dO("aK","MK");'>FUNCTIONS</a></div><div class='slot documented'><span
					class='prefix'>&bull;</span><a href='javascript:dO("aK","NK");'>HANDLES</a></div><div class='slot documented'><span
					class='prefix'>&bull;</span><a href='javascript:dO("aK","OK");'>NAME</a></div></div></div><div id='Be' class='cr'><div class='n'><a href='javascript:dS("Be");'>IBreaking</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("Be","Ce");'><span class='special __bases__'>IInterruption</span></a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Be","De");'>addAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Be","Ee");'>addOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Be","Fe");'>copy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Be","Ge");'>detach</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Be","He");'>getAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Be","Ie");'>getAnnotations</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Be","Je");'>getDataFlow</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Be","Ke");'>getOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Be","Le");'>getOpArguments</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Be","Me");'>getOpArgumentsInternalTypes</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Be","Ne");'>getParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Be","Oe");'>hasAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Be","Pe");'>hasParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Be","Qe");'>removeAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Be","Re");'>setAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Be","Se");'>setOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Be","Te");'>setParent</a></div></div><div class='t'>Values</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&bull;</span><a href='javascript:dO("Be","Ue");'>ARGS</a></div></div></div><div id='Bf' class='cr'><div class='n'><a href='javascript:dS("Bf");'>IClassAttribute</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("Bf","Cf");'><span class='special __bases__'>IAttribute</span></a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Bf","Df");'>getAbsoluteName</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Bf","Ef");'>getDefaultValue</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Bf","Ff");'>getName</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Bf","Gf");'>getTypeDescription</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Bf","Hf");'>setDefaultValue</a></div></div></div><div id='Bo' class='cr'><div class='n'><a href='javascript:dS("Bo");'>IImportSymbolOperation</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("Bo","Co");'><span class='special __bases__'>IImportOperation</span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Bo","Do");'>getAlias</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Bo","Eo");'>getImportOrigin</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Bo","Fo");'>getImportedElement</a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Bo","Go");'>addAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Bo","Ho");'>addOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Bo","Io");'>copy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Bo","Jo");'>detach</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Bo","Ko");'>getAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Bo","Lo");'>getAnnotations</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Bo","Mo");'>getDataFlow</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Bo","No");'>getOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Bo","Oo");'>getOpArguments</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Bo","Po");'>getOpArgumentsInternalTypes</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Bo","Qo");'>getParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Bo","Ro");'>hasAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Bo","So");'>hasParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Bo","To");'>removeAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Bo","Uo");'>setAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Bo","Vo");'>setOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Bo","Wo");'>setParent</a></div></div><div class='t'>Values</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&bull;</span><a href='javascript:dO("Bo","Xo");'>ARGS</a></div><div class='slot documented'><span
					class='prefix'>&bull;</span><a href='javascript:dO("Bo","Yo");'>ARG_NAMES</a></div></div></div><div id='d_Tc' class='de'><h1>Method <span class='n'>isOptional</span></h1><div class='re'><code>isOptional( self )</code></div><div class='ds'><pre>Tells if the argument is optional or not.</pre></div></div><div id='d_Tb' class='de'><h1>Method <span class='n'>getAnnotations</span></h1><div class='re'><code>getAnnotations( self, name=None )</code></div><div class='ds'><pre>Gets all the annotation with the given name associated to this element
		or all annotations if no name is specified.</pre></div></div><div id='d_Tg' class='de'><h1>Method <span class='n'>getLeftOperand</span></h1><div class='re'><code>getLeftOperand( self )</code></div><div class='ds'><pre>Returns the left operand of this computation.</pre></div></div><div id='d_Tf' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><pre>Returns the dataflow accessible/bound to this element</pre></div></div><div id='d_Te' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><pre>Sets this element parent</pre></div></div><div id='d_Td' class='de'><h1>Method <span class='n'>getOperations</span></h1><div class='re'><code>getOperations( self )</code></div><div class='ds'><pre>Returns the list of operations in this process.</pre></div></div><div id='d_Tk' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><pre>Returns this element parent</pre></div></div><div id='d_Tj' class='de'><h1>Method <span class='n'>setContent</span></h1><div class='re'><code>setContent( self, content )</code></div><div class='ds'><pre>Updates the content of this annotation.</pre></div></div><div id='d_Ti' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IMethod at 0x85d250c&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_Th' class='de'><h1>Method <span class='n'>setAbstract</span></h1><div class='re'><code>setAbstract( self, isAbstract )</code></div><div class='ds'><pre>Sets wether the given abstractable is abstract or not.</pre></div></div><div id='d_To' class='de'><h1>Method <span class='n'>removeAnnotation</span></h1><div class='re'><code>removeAnnotation( self, name )</code></div><div class='ds'><pre>Removes the annotations with the given name</pre></div></div><div id='d_Tn' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type for this element</pre></div></div><div id='d_Tm' class='de'><h1>Method <span class='n'>setAbstract</span></h1><div class='re'><code>setAbstract( self, isAbstract )</code></div><div class='ds'><pre>Sets wether the given abstractable is abstract or not.</pre></div></div><div id='d_Tl' class='de'><h1>Method <span class='n'>removeAnnotation</span></h1><div class='re'><code>removeAnnotation( self, name )</code></div><div class='ds'><pre>Removes the annotations with the given name</pre></div></div><div id='d_Ts' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.IEvaluable at 0x85c4f2c&gt;, &lt;class lambdafactory.interfaces.IEvaluable at 0x85c4f2c&gt;]</code></div><div class='ds'><pre>list() -&gt; new list
list(sequence) -&gt; new list initialized from sequence's items</pre></div></div><div id='d_Tr' class='de'><h1>Method <span class='n'>hasAnnotation</span></h1><div class='re'><code>hasAnnotation( self, name )</code></div><div class='ds'><pre>Tells if the given element has an annotation with the given name</pre></div></div><div id='d_Tq' class='de'><h1>Method <span class='n'>removeAnnotation</span></h1><div class='re'><code>removeAnnotation( self, name )</code></div><div class='ds'><pre>Removes the annotations with the given name</pre></div></div><div id='d_Tp' class='de'><h1>Method <span class='n'>isAbstract</span></h1><div class='re'><code>isAbstract( self )</code></div><div class='ds'><pre>Tells wether the given abstractable is abstract or not.</pre></div></div><div id='d_Tw' class='de'><h1>Method <span class='n'>getActualValue</span></h1><div class='re'><code>getActualValue( self )</code></div><div class='ds'><pre>Returns the (implementation language) value for this literal</pre></div></div><div id='d_Tv' class='de'><h1>Method <span class='n'>getSlots</span></h1><div class='re'><code>getSlots( self )</code></div><div class='ds'><pre>Returns (key, evaluable) pairs representing the slots within this
		context. In the case of context that may inherits slots, this only
		returns the slots that are owned by the context (ie. it does not
		include inherited slots)</pre></div></div><div id='d_Tu' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.IEvaluable at 0x85c4f2c&gt;, &lt;class lambdafactory.interfaces.IProcess at 0x85d241c&gt;]</code></div><div class='ds'><pre>list() -&gt; new list
list(sequence) -&gt; new list initialized from sequence's items</pre></div></div><div id='d_Tt' class='de'><h1>Method <span class='n'>hasAnnotation</span></h1><div class='re'><code>hasAnnotation( self, name )</code></div><div class='ds'><pre>Tells if the given element has an annotation with the given name</pre></div></div><div id='d_Tz' class='de'><h1>Method <span class='n'>removeAnnotation</span></h1><div class='re'><code>removeAnnotation( self, name )</code></div><div class='ds'><pre>Removes the annotations with the given name</pre></div></div><div id='d_Ty' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><pre>Returns the dataflow accessible/bound to this element</pre></div></div><div id='d_Tx' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IElement at 0x85c4e6c&gt;, &lt;class lambdafactory.interfaces.ISlot at 0x85d21dc&gt;)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_TC' class='de'><h1>Class <span class='n'>Factory</span></h1><div class='re'></div><div class='ds'><pre>This class takes a module and look for classes with the same name as the
	`createXXX` methods and instanciates them.<br />	For instance, if you define a module with classes like `Value`, `Literal`,
	`Invocation`, `Function`, etc. you just have to give this module to the
	factory constructor and it will be used to generate the given element.</pre></div></div><div id='d_TB' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><pre>Returns the ith arguments to this operation.</pre></div></div><div id='d_TA' class='de'><h1>Method <span class='n'>getSliceStart</span></h1><div class='re'><code>getSliceStart( self )</code></div><div class='ds'><pre>Returns evaluable that will return the slice start</pre></div></div><div id='d_TG' class='de'><h1>Method <span class='n'>elements</span></h1><div class='re'><code>elements( self )</code></div><div class='ds'><pre>Returns a dict of the elements in this map. Do not modify it.</pre></div></div><div id='d_TF' class='de'><h1>Method <span class='n'>isSameAs</span></h1><div class='re'><code>isSameAs( self, otherType )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_TE' class='de'><h1>Class <span class='n'>TypeCollection</span></h1><div class='re'></div><div class='ds'><pre>A type collection is a class that contains type definitions which can be
	easily retrieved using the @getType method.</pre></div></div><div id='d_TD' class='de'><h1>Method <span class='n'>matchExpression</span></h1><div class='re'><code>matchExpression( self, evaluable, expression )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_TK' class='de'><h1>Method <span class='n'>annotate</span></h1><div class='re'><code>annotate( self, value, name, content=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_TJ' class='de'><h1>Method <span class='n'>resolveLocalOrAbsolute</span></h1><div class='re'><code>resolveLocalOrAbsolute( self, referenceOrName, contextOrDataFlow=None )</code></div><div class='ds'><pre>Tries a local resolution first, then will look in the program scope if
		it fails.</pre></div></div><div id='d_TI' class='de'><h1>Method <span class='n'>name</span></h1><div class='re'><code>name( self, name=None )</code></div><div class='ds'><pre>Returns/sets the name for this type. By defaults, types are unnamed.</pre></div></div><div id='d_TH' class='de'><h1>Method <span class='n'>concreteType</span></h1><div class='re'><code>concreteType( self )</code></div><div class='ds'><pre>Returns the _concrete type_ for this abstract type.</pre></div></div><div id='d_TN' class='de'><h1>instance</h1><div class='re'></div><div class='ds'><pre>The reporter aggregates error reports that may happen during model
	construction and the different phases (dataflowing, typing, writing,
	etc).</pre></div></div><div id='d_TM' class='de'><h1>Method <span class='n'>walk</span></h1><div class='re'><code>walk( self, element )</code></div><div class='ds'><pre>Walks the given element, recursively walking the child elements when the
		handler does not return False</pre></div></div><div id='d_TL' class='de'><h1>Method <span class='n'>getCurrentElement</span></h1><div class='re'><code>getCurrentElement( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='Uu' class='cr'><div class='n'><a href='javascript:dS("Uu");'>IMethod</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("Uu","Vu");'><span class='special __bases__'>IFunction</span></a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Uu","Wu");'>addAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Uu","Xu");'>addOperation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Uu","Yu");'>copy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Uu","Zu");'>detach</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Uu","av");'>endsWithTermination</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Uu","bv");'>getAbsoluteName</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Uu","cv");'>getAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Uu","dv");'>getAnnotations</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Uu","ev");'>getArguments</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Uu","fv");'>getDataFlow</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Uu","gv");'>getName</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Uu","hv");'>getOperations</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Uu","iv");'>getParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Uu","jv");'>getReturnTypeDescription</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Uu","kv");'>getSlot</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Uu","lv");'>getSlotNames</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Uu","mv");'>getSlots</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Uu","nv");'>hasAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Uu","ov");'>hasExplicitTermination</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Uu","pv");'>hasParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Uu","qv");'>hasSlot</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Uu","rv");'>isAbstract</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Uu","sv");'>removeAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Uu","tv");'>setAbstract</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Uu","uv");'>setAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Uu","vv");'>setArguments</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Uu","wv");'>setParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Uu","xv");'>setReturnTypeDescription</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Uu","yv");'>setSlot</a></div></div></div><div id='Us' class='cr'><div class='n'><a href='javascript:dS("Us");'>IList</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("Us","Vs");'><span class='special __bases__'>IValue</span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Us","Ws");'>addValue</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Us","Xs");'>getValues</a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Us","Ys");'>addAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Us","Zs");'>copy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Us","at");'>detach</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Us","bt");'>getAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Us","ct");'>getAnnotations</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Us","dt");'>getDataFlow</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Us","et");'>getParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Us","ft");'>getResultAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Us","gt");'>hasAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Us","ht");'>hasParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Us","it");'>removeAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Us","jt");'>setAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Us","kt");'>setParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Us","lt");'>setResultAbstractType</a></div></div></div><div id='Uj' class='cr'><div class='n'><a href='javascript:dS("Uj");'>IElement</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("Uj","c");'><span class='special __bases__'><i>Base class</i></span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Uj","Vj");'>addAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Uj","Wj");'>copy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Uj","Xj");'>detach</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Uj","Yj");'>getAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Uj","Zj");'>getAnnotations</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Uj","ak");'>getDataFlow</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Uj","bk");'>getParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Uj","ck");'>hasAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Uj","dk");'>hasParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Uj","ek");'>removeAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Uj","fk");'>setAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Uj","gk");'>setParent</a></div></div></div><div id='UM' class='cr'><div class='n'><a href='javascript:dS("UM");'>TransformAsynchronousInvocations</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("UM","VM");'><span class='special __bases__'>Pass</span></a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("UM","WM");'><span class='special __init__'>constructor</span></a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("UM","XM");'>annotate</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("UM","YM");'>filter</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("UM","ZM");'>filterContext</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("UM","aN");'>findInContext</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("UM","bN");'>getClassAncestors</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("UM","cN");'>getClassParents</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("UM","dN");'>getCurrentClass</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("UM","eN");'>getCurrentClassAncestors</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("UM","fN");'>getCurrentClassParents</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("UM","gN");'>getCurrentClosure</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("UM","hN");'>getCurrentContext</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("UM","iN");'>getCurrentDataFlow</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("UM","jN");'>getCurrentElement</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("UM","kN");'>getCurrentFunction</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("UM","lN");'>getCurrentMethod</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("UM","mN");'>getCurrentModule</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("UM","nN");'>getCurrentProcess</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("UM","oN");'>getFactory</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("UM","pN");'>getHandler</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("UM","qN");'>getName</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("UM","rN");'>getParentElement</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("UM","sN");'>getProgram</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("UM","tN");'>handle</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("UM","uN");'>hasParentElement</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("UM","vN");'>isIn</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("UM","wN");'>resolve</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("UM","xN");'>resolveAbsolute</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("UM","yN");'>resolveAbsoluteOrLocal</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("UM","zN");'>resolveLocalOrAbsolute</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("UM","AN");'>run</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("UM","BN");'>setEnvironment</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("UM","CN");'>setPass</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("UM","DN");'>walk</a></div></div><div class='t'>Values</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&bull;</span><a href='javascript:dO("UM","EN");'>HANDLES</a></div><div class='slot documented'><span
					class='prefix'>&bull;</span><a href='javascript:dO("UM","FN");'>NAME</a></div></div></div><div id='d_al' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><pre>Sets the given argument of this operation, by argument index.</pre></div></div><div id='d_am' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IInterruption at 0x85d2b0c&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_an' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IProcess at 0x85d241c&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_ao' class='de'><h1>Method <span class='n'>hasAnnotation</span></h1><div class='re'><code>hasAnnotation( self, name )</code></div><div class='ds'><pre>Tells if the given element has an annotation with the given name</pre></div></div><div id='d_ah' class='de'><h1>Method <span class='n'>setRightOperand</span></h1><div class='re'><code>setRightOperand( self, operand )</code></div><div class='ds'><pre>Sets the right operand of this computation</pre></div></div><div id='d_ai' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IElement at 0x85c4e6c&gt;, &lt;class lambdafactory.interfaces.IDataFlowOwner at 0x85c4e3c&gt;)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_aj' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type for this element</pre></div></div><div id='d_ak' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><pre>Returns the dataflow accessible/bound to this element</pre></div></div><div id='d_ad' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><pre>Returns the local name for this referencable element</pre></div></div><div id='d_ae' class='de'><h1>Method <span class='n'>hasExplicitTermination</span></h1><div class='re'><code>hasExplicitTermination( self )</code></div><div class='ds'><pre>Returns true if this function has an operation with a termination,
		otherwise return false.</pre></div></div><div id='d_af' class='de'><h1>Method <span class='n'>getConstructors</span></h1><div class='re'><code>getConstructors( self )</code></div><div class='ds'><pre>Returns the constructors for this class</pre></div></div><div id='d_ag' class='de'><h1>Method <span class='n'>getSlots</span></h1><div class='re'><code>getSlots( self )</code></div><div class='ds'><pre>Returns (key, evaluable) pairs representing the slots within this
		context. In the case of context that may inherits slots, this only
		returns the slots that are owned by the context (ie. it does not
		include inherited slots)</pre></div></div><div id='d_ab' class='de'><h1>Method <span class='n'>getSlots</span></h1><div class='re'><code>getSlots( self )</code></div><div class='ds'><pre>Returns (key, evaluable) pairs representing the slots within this
		context. In the case of context that may inherits slots, this only
		returns the slots that are owned by the context (ie. it does not
		include inherited slots)</pre></div></div><div id='d_ac' class='de'><h1>Method <span class='n'>getSlot</span></h1><div class='re'><code>getSlot( self, name )</code></div><div class='ds'><pre>Returns the given evaluable bound to named slot.</pre></div></div><div id='d_ax' class='de'><h1>Method <span class='n'>removeAnnotation</span></h1><div class='re'><code>removeAnnotation( self, name )</code></div><div class='ds'><pre>Removes the annotations with the given name</pre></div></div><div id='d_ay' class='de'><h1>Method <span class='n'>setByName</span></h1><div class='re'><code>setByName( self, n )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_az' class='de'><h1>Method <span class='n'>hasSlot</span></h1><div class='re'><code>hasSlot( self, name )</code></div><div class='ds'><pre>Tells if the context has a slot with the given name.</pre></div></div><div id='d_at' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><pre>Detaches the element from its parent (in case it was already attached).
		This should return this element, and set the parent to None.</pre></div></div><div id='d_au' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.IEvaluable at 0x85c4f2c&gt;, &lt;class lambdafactory.interfaces.IEvaluable at 0x85c4f2c&gt;]</code></div><div class='ds'><pre>list() -&gt; new list
list(sequence) -&gt; new list initialized from sequence's items</pre></div></div><div id='d_av' class='de'><h1>Method <span class='n'>endsWithTermination</span></h1><div class='re'><code>endsWithTermination( self )</code></div><div class='ds'><pre>Returns true if this function ends with a termination operation. This
		is especially useful for back-ends which want to know if they have to
		insert an explicit 'return' at the end (like Java).</pre></div></div><div id='d_aw' class='de'><h1>Method <span class='n'>setSlot</span></h1><div class='re'><code>setSlot( self, name, evaluable )</code></div><div class='ds'><pre>Binds the given evaluable to the named slot. If there is already a slot
		with the same name, then 'getSlot(name)' should return the evaluable
		given as parameter.<br />		In the default implementation, setSlot preserves the ''history'' of
		added slots, and will always return the latest one.</pre></div></div><div id='d_ap' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IImportOperation at 0x85d26bc&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_aq' class='de'><h1>Method <span class='n'>setSlot</span></h1><div class='re'><code>setSlot( self, name, evaluable )</code></div><div class='ds'><pre>Binds the given evaluable to the named slot. If there is already a slot
		with the same name, then 'getSlot(name)' should return the evaluable
		given as parameter.<br />		In the default implementation, setSlot preserves the ''history'' of
		added slots, and will always return the latest one.</pre></div></div><div id='d_ar' class='de'><h1>Method <span class='n'>addAnnotation</span></h1><div class='re'><code>addAnnotation( self, annotation )</code></div><div class='ds'><pre>Adds an annotation to this element</pre></div></div><div id='d_as' class='de'><h1>Method <span class='n'>getArguments</span></h1><div class='re'><code>getArguments( self )</code></div><div class='ds'><pre>Returns a list of arguments (which are names associated with optional
		type information.</pre></div></div><div id='d_aL' class='de'><h1>Method <span class='n'>getCurrentClassAncestors</span></h1><div class='re'><code>getCurrentClassAncestors( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_aM' class='de'><h1>Method <span class='n'>getProgram</span></h1><div class='re'><code>getProgram( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_aN' class='de'><h1>Method <span class='n'>findInContext</span></h1><div class='re'><code>findInContext( self, interface )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_aH' class='de'><h1>Method <span class='n'>__str__</span></h1><div class='re'><code>__str__( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_aI' class='de'><h1>Class <span class='n'>Symbolic</span></h1><div class='re'></div><div class='ds'><pre>Symbolic types are types that have no physical counter part but play a
	role in the type system. This is for instance the case with Any or Nil.</pre></div></div><div id='d_aJ' class='de'><h1>Function <span class='n'>Sequence_combine</span></h1><div class='re'><code>Sequence_combine( a, b, sequenceclass=<class lambdafactory.typecast.Sequence at 0x40315d4c> )</code></div><div class='ds'><pre>Combines the given arguments into a sequence. This follows the following
	rules:
		Nothing, Nothing     -&gt; Nothing
		Nothing, A           -&gt; A
		A,       B           -&gt; (A, B)
		(A, B),  C           -&gt; (A, B, C)   ( type = type(a) )
		(A, B),  (C, D)      -&gt; (A, B, C, D) ( type = type(a) )
		A     ,  (C, D)      -&gt; (A, B, C)   ( type = sequenceclass)
	</pre></div></div><div id='d_aK' class='de'><h1>Class <span class='n'>ExtendJSRuntime</span></h1><div class='re'></div><div class='ds'><pre>This pass is like an importation and will simply bind the symbols</pre></div></div><div id='d_aD' class='de'><h1>Method <span class='n'>_getImplementation</span></h1><div class='re'><code>_getImplementation( self, name )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_aE' class='de'><h1>Method <span class='n'>slice</span></h1><div class='re'><code>slice( self, target, _start, _end=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_aF' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.typecast.Sequence at 0x40315d4c&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_aG' class='de'><h1>Method <span class='n'>name</span></h1><div class='re'><code>name( self, name=None )</code></div><div class='ds'><pre>Returns/sets the name for this type. By defaults, types are unnamed.</pre></div></div><div id='d_aA' class='de'><h1>Method <span class='n'>getContext</span></h1><div class='re'><code>getContext( self )</code></div><div class='ds'><pre>Returns the (optional) context in which the resolution should occur.</pre></div></div><div id='d_aB' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><pre>Returns the dataflow accessible/bound to this element</pre></div></div><div id='d_aC' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><pre>Sets the abstract type for this element</pre></div></div><div id='hk' class='cr'><div class='n'><a href='javascript:dS("hk");'>IEmbed</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("hk","ik");'><span class='special __bases__'>IOperation</span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("hk","jk");'>getCode</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("hk","kk");'>getLanguage</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("hk","lk");'>setCode</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("hk","mk");'>setLanguage</a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("hk","nk");'>addAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("hk","ok");'>addOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("hk","pk");'>copy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("hk","qk");'>detach</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("hk","rk");'>getAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("hk","sk");'>getAnnotations</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("hk","tk");'>getDataFlow</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("hk","uk");'>getOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("hk","vk");'>getOpArguments</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("hk","wk");'>getOpArgumentsInternalTypes</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("hk","xk");'>getParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("hk","yk");'>hasAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("hk","zk");'>hasParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("hk","Ak");'>removeAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("hk","Bk");'>setAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("hk","Ck");'>setOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("hk","Dk");'>setParent</a></div></div><div class='t'>Values</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&bull;</span><a href='javascript:dO("hk","Ek");'>ARGS</a></div></div></div><div id='hC' class='cr'><div class='n'><a href='javascript:dS("hC");'>ITermination</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("hC","iC");'><span class='special __bases__'>IOperation</span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("hC","jC");'>getReturnedEvaluable</a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("hC","kC");'>addAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("hC","lC");'>addOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("hC","mC");'>copy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("hC","nC");'>detach</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("hC","oC");'>getAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("hC","pC");'>getAnnotations</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("hC","qC");'>getDataFlow</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("hC","rC");'>getOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("hC","sC");'>getOpArguments</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("hC","tC");'>getOpArgumentsInternalTypes</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("hC","uC");'>getParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("hC","vC");'>hasAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("hC","wC");'>hasParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("hC","xC");'>removeAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("hC","yC");'>setAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("hC","zC");'>setOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("hC","AC");'>setParent</a></div></div><div class='t'>Values</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&bull;</span><a href='javascript:dO("hC","BC");'>ARGS</a></div></div></div><div id='d_sz' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><pre>Returns the dataflow accessible/bound to this element</pre></div></div><div id='d_sx' class='de'><h1>Method <span class='n'>hasAnnotation</span></h1><div class='re'><code>hasAnnotation( self, name )</code></div><div class='ds'><pre>Tells if the given element has an annotation with the given name</pre></div></div><div id='d_sy' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IElement at 0x85c4e6c&gt;,)</code></div><div class='ds'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_sr' class='de'><h1>Method <span class='n'>getParentClassesRefs</span></h1><div class='re'><code>getParentClassesRefs( self )</code></div><div class='ds'><pre>Returns the list of inherited classes references. Note that they
		have to be interpreted in the class parent (a module)</pre></div></div><div id='d_ss' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><pre>Tells if this element has a parent or not</pre></div></div><div id='d_sp' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><pre>Sets the given argument of this operation, by argument index.</pre></div></div><div id='d_sq' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><pre>Tells if this element has a parent or not</pre></div></div><div id='d_sv' class='de'><h1>Method <span class='n'>removeAnnotation</span></h1><div class='re'><code>removeAnnotation( self, name )</code></div><div class='ds'><pre>Removes the annotations with the given name</pre></div></div><div id='d_sw' class='de'><h1>Method <span class='n'>getArguments</span></h1><div class='re'><code>getArguments( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_st' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><pre>Returns the abstract type for this element</pre></div></div><div id='d_su' class='de'><h1>Method <span class='n'>removeAnnotation</span></h1><div class='re'><code>removeAnnotation( self, name )</code></div><div class='ds'><pre>Removes the annotations with the given name</pre></div></div><div id='d_sj' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><pre>Sets the abstract type for this element</pre></div></div><div id='d_sk' class='de'><h1>Method <span class='n'>getAnnotations</span></h1><div class='re'><code>getAnnotations( self, name=None )</code></div><div class='ds'><pre>Gets all the annotation with the given name associated to this element
		or all annotations if no name is specified.</pre></div></div><div id='d_sh' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.IOperator at 0x85d21ac&gt;, &lt;class lambdafactory.interfaces.IEvaluable at 0x85c4f2c&gt;, &lt;class lambdafactory.interfaces.IEvaluable at 0x85c4f2c&gt;]</code></div><div class='ds'><pre>list() -&gt; new list
list(sequence) -&gt; new list initialized from sequence's items</pre></div></div><div id='d_si' class='de'><h1>Class <span class='n'>IDataFlow</span></h1><div class='re'></div><div class='ds'><pre>The DataFlow are ''dynamic contexts'' bound to the various program model
	elements. DataFlows are typically owned by elements which implement
	'IContext', and are linked together by rules defined in the 'Resolver'
	@protocol.<br />	The dataflow bound to most expressions is the one of the enclosing closure
	(whether it is a function, or method. The dataflow of a method is bound to
	its parent @protocol, which dataflow is also bound to the parent @protocol dataflow.<br />	While 'DataFlow' and 'Context' may appear very similar, they are not the
	same: contexts are elements that keep track of declared slots, while the
	dataflow make use of the context to weave the elements togeher.</pre></div></div><div id='d_sn' class='de'><h1>Method <span class='n'>getImportedModuleName</span></h1><div class='re'><code>getImportedModuleName( self )</code></div><div class='ds'><pre>Returns the list of names representing the modules to load</pre></div></div><div id='d_so' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><pre>Returns the arguments to this operation.</pre></div></div><div id='d_sl' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><pre>Returns this element parent</pre></div></div><div id='d_sm' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><pre>Sets this element parent</pre></div></div><div id='d_sb' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><pre>Adds an argument to this operation. This should do checking of
		arguments (by expected internal type and number).</pre></div></div><div id='d_sc' class='de'><h1>Method <span class='n'>getSlotToAllocate</span></h1><div class='re'><code>getSlotToAllocate( self )</code></div><div class='ds'><pre>Returns slot to be allocated by this operation.</pre></div></div><div id='d_sf' class='de'><h1>Method <span class='n'>getSlotNames</span></h1><div class='re'><code>getSlotNames( self )</code></div><div class='ds'><pre>Returns the list of slot names (in order) for this context</pre></div></div><div id='d_sg' class='de'><h1>Method <span class='n'>setReturnTypeDescription</span></h1><div class='re'><code>setReturnTypeDescription( self, description )</code></div><div class='ds'><pre>Sets the return type description for this closure, if any</pre></div></div><div id='d_sd' class='de'><h1>Method <span class='n'>hasAnnotation</span></h1><div class='re'><code>hasAnnotation( self, name )</code></div><div class='ds'><pre>Tells if the given element has an annotation with the given name</pre></div></div><div id='d_se' class='de'><h1>Method <span class='n'>getAnnotations</span></h1><div class='re'><code>getAnnotations( self, name=None )</code></div><div class='ds'><pre>Gets all the annotation with the given name associated to this element
		or all annotations if no name is specified.</pre></div></div><div id='d_sJ' class='de'><h1>Method <span class='n'>filter</span></h1><div class='re'><code>filter( self, list, interface )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_sK' class='de'><h1>Method <span class='n'>getCurrentFunction</span></h1><div class='re'><code>getCurrentFunction( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_sH' class='de'><h1>Method <span class='n'>isSameAs</span></h1><div class='re'><code>isSameAs( self, otherType )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_sI' class='de'><h1>Method <span class='n'>__call__</span></h1><div class='re'><code>__call__( self )</code></div><div class='ds'><pre>A type instance can be used as a class to construct a new type, which
		will be cloned from the current type.</pre></div></div><div id='d_sN' class='de'><h1>Method <span class='n'>getProgram</span></h1><div class='re'><code>getProgram( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_sL' class='de'><h1>Method <span class='n'>resolve</span></h1><div class='re'><code>resolve( self, referenceOrName, contextOrDataFlow=None )</code></div><div class='ds'><pre>Resolves the given 'IReference' or String sing the given context
		('IContext') or dataflow ('IDataFlow'). This usually requires that
		you've applied a pass to create the dataflow (see the
		'lambdafactory.resolution.BasicDataFlow' pass).</pre></div></div><div id='d_sM' class='de'><h1>Method <span class='n'>findInContext</span></h1><div class='re'><code>findInContext( self, interface )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_sB' class='de'><h1>Class <span class='n'>IString</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_sC' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><pre>Returns the arguments to this operation.</pre></div></div><div id='d_sA' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><pre>Sets this element parent</pre></div></div><div id='d_sF' class='de'><h1>Method <span class='n'>setName</span></h1><div class='re'><code>setName( self, name )</code></div><div class='ds'><pre>Sets the name of this type</pre></div></div><div id='d_sG' class='de'><h1>Method <span class='n'>asString</span></h1><div class='re'><code>asString( self, fromTypes=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_sD' class='de'><h1>Method <span class='n'>createClass</span></h1><div class='re'><code>createClass( self, name, inherited=() )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_sE' class='de'><h1>Method <span class='n'>run</span></h1><div class='re'><code>run( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div>
	<!-- hidden-snip -->
	<!-- hidden nodes will be moved here -->
</div>
</div>
<!-- body -->
</body>
</html>
