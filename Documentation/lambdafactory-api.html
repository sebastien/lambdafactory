<html>
<!-- Document generated by SDoc <http://www.ivy.fr/sdoc> -->
<head>
<title>Python API documentation (SDoc)</title>

<style type="text/css" media="screen">
/* css-main-snip */
html, body {
	background : #fcfcf6;
	color: #000000;
	font: 8pt/14pt "Lucida Grande", "Lucida", Helvetica, sans-serif;
	padding: 0;
	margin: 0;
}


a, a:active, a:link, a:visited, a:hover {
	color: #404040;
	text-decoration: none;
}

a:active, a:focus {
	background-color: #eae08c;
	color: white;
	border: 0;
	padding: 2px;
}

a:hover {
	color: #8fb216;
}

code {
	color: #8fb216;
}

pre {
	padding-top: 5pt;
	padding-bottom: 5pt;
	background: #f0f0f0;
	color: #8fb216;
}

/* css-main-snip */
/* css-classes-snip */
#descriptions {
	padding: 0;
	margin: 0;
	margin-left: 380px;
}

#modules {
	padding: 0;
	padding: 1pt;
	padding-left: 5pt;
	font-size: 7pt;
	color: #A0A0A0;
	background: #404040;
	border-bottom: 2px solid #f0f0f0;
}

#modules a {
	color: white;
}

#options {
	text-align: right;
}

#options label {
	font-weight: bold;
	padding-left: 10px;
}

#api {
	display: block;
	width: 360px;
	float: left;
	padding:0;
	padding-left: 5pt;
	padding-right: 10pt;
	background: white;
	border-right: 1px solid #f0f0f0;
	overflow: auto;
	height: 100%;

}

#hidden {
	padding: 0;
	margin: 0;
	display: none;
}

#sdoc .de {
	display: none;
	padding: 5pt;
}

#sdoc .re {
	padding-bottom: 5pt;
}


#sdoc .t {
	padding-top: 10pt;
	font-weight: bold;
	border-bottom: 1px solid #f0f0f0;
	color: #505050;
}

#sdoc .prefix {
	color: #D0C0C0;
	font-style: italic;
	padding-right: 5px;
}

#sdoc .noattributes {
	color: #D0C0C0;
	font-style: italic;
}

#sdoc .n, #sdoc .n a {
	color: #cdb425;
}

#sdoc .term {
	font-weight:bold;
	color: #cdb425;
	background: #F9FFDE;
	padding-left: 2px;
	padding-right: 2px;
}

#sdoc .n {
	font-weight: bold;
	margin-top: 1em;
}

#sdoc .special {
	font-weight: bold;
}

#sdoc .special.__bases__ {
	font-weight: normal;
	color: #cdb425;
}

#sdoc .u, #sdoc .u a {
	color: #b0c0c0;
	font-style: italic;
}
#sdoc .ds {
	border-top: 1px solid #f0f0f0;
	border-bottom: 1px solid #f0f0f0;
	background: white;
	padding: 5pt;
	color: #808080;
}

#sdoc table caption {
	font: 8pt/14pt "Lucida Grande", "Lucida", Helvetica, sans-serif;
	font-weight: bold;
}

#sdoc table tr td {
	font: 8pt/14pt "Lucida Grande", "Lucida", Helvetica, sans-serif;
	color: #808080;
}

#sdoc .ro, #sdoc .cr {
	padding-left: 10pt;
	padding-top: 8pt;
	color: #404040;
	width: 150px;
	border-left: 1px solid #f0f0f0;
	float: left;
}

#sdoc .cr {
	margin-left: 10pt;
	display: none;
}


/* css-classes-snip */
</style>

<script type="text/javascript" src="http://jqueryjs.googlecode.com/files/jquery-1.2.2.pack.js" > </script>
<script type="text/javascript">
/* <![CDATA[ */
// javascript-snip

var displays    = [];
var selected    = undefined;
var description = undefined;
var hidden      = undefined;
var content     = undefined;

function dO( from_id, to_id )
{
	if ( to_id == undefined ) { to_id = from_id ; from_id = undefined; }
	if ( hidden  == undefined ) hidden  = document.getElementById("hidden");
	if ( content == undefined ) content = document.getElementById("api");
	// We get the target element and the associated description element
	var element  = document.getElementById(to_id);
	var felement = document.getElementById(from_id);
	var level    = 0;
	if ( felement != undefined )
	{
		level        = felement.getAttribute("level");
		if ( !level ) { level = 0; }
		else { level = parseInt(level); }
	}
	else
	{
		level = 0;
	}
	// We show the element description
	dS(to_id);
	// We show the element
	if (element)
	{
		if ( element == selected ) return;
		// We re-order the content nodes anyway
		element.parentNode.removeChild(element);
		element.setAttribute("level", level + 1);
		content.appendChild(element);
		// Ensure that the node is visible
		element.style.display  = "block";
		// And its description
		// We hide the old ones
		while ( displays.length > 0 && displays.length > level )
		{
			var hiding_id = displays.pop()
			var hiding_el = document.getElementById(hiding_id);
			if ( hiding_el != element )
			{
				hiding_el.parentNode.removeChild(hiding_el);
				hidden.appendChild(hiding_el);
			}
		}
		// And update the state
		displays.push(to_id);
		selected = element;
	}
}

function dS( eid )
{
	var delement = document.getElementById("d_" + eid);
	if ( delement != undefined && delement != description )
	{
		delement.style.display = "block";
		if ( description != undefined ) description.style.display = "none";
		description = delement;
	}
	else if ( delement == undefined )
	{
		alert("ERROR: Description not found for id 'd_" + eid + "'");
	}
}

var J = jQuery

function updatePrivateVisibility () {
	/* FIXME: Use proper class instead */
	if ( J(".do-togglePrivate").attr("checked") ) {
		J(".private").parent().parent().fadeIn()
	} else {
		J(".private").parent().parent().fadeOut()
	}
}

function updateProtectedVisibility () {
	if ( J(".do-toggleProtected").attr("checked") ) {
		J(".protected").parent().parent().fadeIn()
	} else {
		J(".protected").parent().parent().fadeOut()
	}
}

jQuery(document).ready(function(){
	J(".do-togglePrivate").click(updatePrivateVisibility)
	J(".do-toggleProtected").click(updateProtectedVisibility)
	updatePrivateVisibility()
	updateProtectedVisibility()
})

// javascript-snip
/* ]]> */

</script>
</head>
<body onLoad="javascript:dO('a');">
<!-- body -->
<div id="sdoc">
<div id='modules'>
<!-- modules-snip -->
API : <a href='javascript:dO("a");'>lambdafactory.interfaces</a> &bull; <a href='javascript:dO("Bx");'>lambdafactory.modelbase</a> &bull; <a href='javascript:dO("Qy");'>lambdafactory.modelwriter</a> &bull; <a href='javascript:dO("iz");'>lambdafactory.modeltypes</a> &bull; <a href='javascript:dO("Dz");'>lambdafactory.typecast</a> &bull; <a href='javascript:dO("QD");'>lambdafactory.passes</a> &bull; <a href='javascript:dO("hH");'>lambdafactory.reporter</a>
<div id='options'>
	<label>Show:</label>
	<input type="checkbox" class="do-togglePrivate"> private
	<input type="checkbox" class="do-toggleProtected"> protected
</div>
<!-- modules-snip -->
</div>
<div id='api'><!-- main element will be displayed here --></div>
<div id='descriptions'>
	<!-- descriptions-snip -->
	<div id='d_c' class='de'><h1>tuple</h1><div class='re'><code>()</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_d' class='de'><h1>str</h1><div class='re'><code>'__init__'</code></div><div class='ds'><p>str(object) -&gt; string</p><p>Return a nice string representation of the object. If the argument is a string, the return value is the same object.</p></div></div><div id='d_e' class='de'><h1>str</h1><div class='re'><code>'__current__'</code></div><div class='ds'><p>str(object) -&gt; string</p><p>Return a nice string representation of the object. If the argument is a string, the return value is the same object.</p></div></div><div id='d_f' class='de'><h1>str</h1><div class='re'><code>'__currentvalue__'</code></div><div class='ds'><p>str(object) -&gt; string</p><p>Return a nice string representation of the object. If the argument is a string, the return value is the same object.</p></div></div><div id='d_g' class='de'><h1>str</h1><div class='re'><code>'__destroy__'</code></div><div class='ds'><p>str(object) -&gt; string</p><p>Return a nice string representation of the object. If the argument is a string, the return value is the same object.</p></div></div><div id='d_h' class='de'><h1>str</h1><div class='re'><code>'__main__'</code></div><div class='ds'><p>str(object) -&gt; string</p><p>Return a nice string representation of the object. If the argument is a string, the return value is the same object.</p></div></div><div id='d_i' class='de'><h1>str</h1><div class='re'><code>'__moduleinit__'</code></div><div class='ds'><p>str(object) -&gt; string</p><p>Return a nice string representation of the object. If the argument is a string, the return value is the same object.</p></div></div><div id='d_j' class='de'><h1>int</h1><div class='re'></div><div class='ds'><p>int(x<a href="#,-BASE" class="internal">, base</a>) -&gt; integer</p><p>Convert a string or number to an integer, if possible. A floating point argument will be truncated towards zero (this does not include a string representation of a floating point number!) When converting a string, use the optional base. It is an error to supply a base when converting a non-string. If the argument is outside the integer range a long object will be returned instead.</p></div></div><div id='d_b' class='de'><h1>Class <span class='n'>Constants</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_l' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IReference at 0x7bf630&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_m' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><p>Performs a deep clone of this element. Any mutation to the original won't change the copy.</p></div></div><div id='d_n' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><p>Detaches the element from its parent (in case it was already attached). This should return this element, and set the parent to None.</p></div></div><div id='d_o' class='de'><h1>Method <span class='n'>getAbsoluteName</span></h1><div class='re'><code>getAbsoluteName( self )</code></div><div class='ds'><p>Returns the absolute name for this element</p></div></div><div id='d_p' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_q' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_r' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_s' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><p>Returns the local name for this referencable element</p></div></div><div id='d_t' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns this element parent</p></div></div><div id='d_u' class='de'><h1>Method <span class='n'>getReferenceName</span></h1><div class='re'><code>getReferenceName( self )</code></div><div class='ds'><p>Returns the name which this reference contains. The name is used by the resolution operation to actually resolve a value from the name.</p></div></div><div id='d_v' class='de'><h1>Method <span class='n'>getResultAbstractType</span></h1><div class='re'><code>getResultAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type of the result of the evaluation of this evaluable</p></div></div><div id='d_w' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><p>Tells if this element has a parent or not</p></div></div><div id='d_x' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_y' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_z' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><p>Sets this element parent</p></div></div><div id='d_A' class='de'><h1>Method <span class='n'>setResultAbstractType</span></h1><div class='re'><code>setResultAbstractType( self, abstractType )</code></div><div class='ds'><p>Sets the abstract type for this operation result. This is usually invoked in the typing phase.</p></div></div><div id='d_k' class='de'><h1>Class <span class='n'>IAbsoluteReference</span></h1><div class='re'></div><div class='ds'><p>An absolute reference is a specific kind of reference that does not necessarily resolve in the current context, but will rather use the program root context as a starting point.</p></div></div><div id='d_C' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IClass at 0x7bf810&gt;, &lt;class lambdafactory.interfaces.IAbstractable at 0x7bf4e0&gt;)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_D' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><p>Performs a deep clone of this element. Any mutation to the original won't change the copy.</p></div></div><div id='d_E' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><p>Detaches the element from its parent (in case it was already attached). This should return this element, and set the parent to None.</p></div></div><div id='d_F' class='de'><h1>Method <span class='n'>getAbsoluteName</span></h1><div class='re'><code>getAbsoluteName( self )</code></div><div class='ds'><p>Returns the absolute name for this element</p></div></div><div id='d_G' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_H' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_I' class='de'><h1>Method <span class='n'>getAttributes</span></h1><div class='re'><code>getAttributes( self )</code></div><div class='ds'><p>Returns the (non-class) attributes defined within this class.</p></div></div><div id='d_J' class='de'><h1>Method <span class='n'>getClassAttributes</span></h1><div class='re'><code>getClassAttributes( self )</code></div><div class='ds'><p>Returns the class attributes defined within this class.</p></div></div><div id='d_K' class='de'><h1>Method <span class='n'>getClassMethods</span></h1><div class='re'><code>getClassMethods( self )</code></div><div class='ds'><p>Returns the class method defined within this class.</p></div></div><div id='d_L' class='de'><h1>Method <span class='n'>getConstructors</span></h1><div class='re'><code>getConstructors( self )</code></div><div class='ds'><p>Returns the constructors for this class</p></div></div><div id='d_M' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_N' class='de'><h1>Method <span class='n'>getDestructors</span></h1><div class='re'><code>getDestructors( self )</code></div><div class='ds'><p>Returns the destructors for this class</p></div></div><div id='d_O' class='de'><h1>Method <span class='n'>getInstanceMethods</span></h1><div class='re'><code>getInstanceMethods( self )</code></div><div class='ds'><p>Returns the instance methods defined within this class.</p></div></div><div id='d_P' class='de'><h1>Method <span class='n'>getMethods</span></h1><div class='re'><code>getMethods( self )</code></div><div class='ds'><p>Returns the methods defined within this class.</p></div></div><div id='d_Q' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><p>Returns this class name. It can be <code>None</code> if the class is anonymous.</p></div></div><div id='d_R' class='de'><h1>Method <span class='n'>getOperations</span></h1><div class='re'><code>getOperations( self )</code></div><div class='ds'><p>Returns the operations (methods and class methods) defined within this class.</p></div></div><div id='d_S' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns the parent context for this context (if any)</p></div></div><div id='d_T' class='de'><h1>Method <span class='n'>getParentClasses</span></h1><div class='re'><code>getParentClasses( self )</code></div><div class='ds'><p>Returns the list of inherited classes references.</p></div></div><div id='d_U' class='de'><h1>Method <span class='n'>getSlot</span></h1><div class='re'><code>getSlot( self, name )</code></div><div class='ds'><p>Returns the given evaluable bound to named slot.</p></div></div><div id='d_V' class='de'><h1>Method <span class='n'>getSlots</span></h1><div class='re'><code>getSlots( self )</code></div><div class='ds'><p>Returns (key, evaluable) pairs representing the slots within this context.</p></div></div><div id='d_W' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><p>Tells if this element has a parent or not</p></div></div><div id='d_X' class='de'><h1>Method <span class='n'>hasSlot</span></h1><div class='re'><code>hasSlot( self, name )</code></div><div class='ds'><p>Tells if the context has a slot with the given name.</p></div></div><div id='d_Y' class='de'><h1>Method <span class='n'>isAbstract</span></h1><div class='re'><code>isAbstract( self )</code></div><div class='ds'><p>Tells wether the given abstractable is abstract or not.</p></div></div><div id='d_Z' class='de'><h1>Method <span class='n'>setAbstract</span></h1><div class='re'><code>setAbstract( self, isAbstract )</code></div><div class='ds'><p>Sets wether the given abstractable is abstract or not.</p></div></div><div id='d_ab' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_bb' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_cb' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, context )</code></div><div class='ds'><p>Sets the parent context for this context.</p></div></div><div id='d_db' class='de'><h1>Method <span class='n'>setParentClasses</span></h1><div class='re'><code>setParentClasses( self )</code></div><div class='ds'><p>gives the list of parent classes that will</p></div></div><div id='d_eb' class='de'><h1>Method <span class='n'>setSlot</span></h1><div class='re'><code>setSlot( self, name, evaluable )</code></div><div class='ds'><p>Binds the given evaluable to the named slot.</p></div></div><div id='d_B' class='de'><h1>Class <span class='n'>IAbstractClass</span></h1><div class='re'></div><div class='ds'><p>An abstract @protocol is a @protocol that has at least one abstract element.</p></div></div><div id='d_gb' class='de'><h1>Method <span class='n'>isAbstract</span></h1><div class='re'><code>isAbstract( self )</code></div><div class='ds'><p>Tells wether the given abstractable is abstract or not.</p></div></div><div id='d_hb' class='de'><h1>Method <span class='n'>setAbstract</span></h1><div class='re'><code>setAbstract( self, isAbstract )</code></div><div class='ds'><p>Sets wether the given abstractable is abstract or not.</p></div></div><div id='d_fb' class='de'><h1>Class <span class='n'>IAbstractable</span></h1><div class='re'></div><div class='ds'><p>An abstractable element is an element that is allow to have no underlying implementation. Abstract element are typically interfaces, methods, functions, operations, and sometimes modules and @protocoles.</p></div></div><div id='d_jb' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.ISubsetOperation at 0x7bfd50&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_kb' class='de'><h1>Method <span class='n'>getIndex</span></h1><div class='re'><code>getIndex( self )</code></div><div class='ds'><p>Returns evaluable that will return the access index</p></div></div><div id='d_lb' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><p>Adds an argument to this operation. This should do checking of arguments (by expected internal type and number).</p></div></div><div id='d_mb' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><p>Performs a deep clone of this element. Any mutation to the original won't change the copy.</p></div></div><div id='d_nb' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><p>Detaches the element from its parent (in case it was already attached). This should return this element, and set the parent to None.</p></div></div><div id='d_ob' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_pb' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_qb' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_rb' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><p>Returns the ith arguments to this operation.</p></div></div><div id='d_sb' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><p>Returns the arguments to this operation.</p></div></div><div id='d_tb' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><p>Returns the <em>internal types</em> for this operations arguments. This is typically the list of interfaces or @protocols that the arguments must comply to.</p></div></div><div id='d_ub' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns this element parent</p></div></div><div id='d_vb' class='de'><h1>Method <span class='n'>getTarget</span></h1><div class='re'><code>getTarget( self )</code></div><div class='ds'><p>Returns the operation target.</p></div></div><div id='d_wb' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><p>Tells if this element has a parent or not</p></div></div><div id='d_xb' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_yb' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_zb' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><p>Sets the given argument of this operation, by argument index.</p></div></div><div id='d_Ab' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><p>Sets this element parent</p></div></div><div id='d_Bb' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.IEvaluable at 0x7bf450&gt;, &lt;class lambdafactory.interfaces.IEvaluable at 0x7bf450&gt;]</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='d_ib' class='de'><h1>Class <span class='n'>IAccessOperation</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Db' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IOperation at 0x7bfae0&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Eb' class='de'><h1>Method <span class='n'>getDefaultValue</span></h1><div class='re'><code>getDefaultValue( self )</code></div><div class='ds'><p>Returns the expression that assigns the @methodault value.</p></div></div><div id='d_Fb' class='de'><h1>Method <span class='n'>getSlotToAllocate</span></h1><div class='re'><code>getSlotToAllocate( self )</code></div><div class='ds'><p>Returns slot to be allocated by this operation.</p></div></div><div id='d_Gb' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><p>Adds an argument to this operation. This should do checking of arguments (by expected internal type and number).</p></div></div><div id='d_Hb' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><p>Performs a deep clone of this element. Any mutation to the original won't change the copy.</p></div></div><div id='d_Ib' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><p>Detaches the element from its parent (in case it was already attached). This should return this element, and set the parent to None.</p></div></div><div id='d_Jb' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_Kb' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_Lb' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_Mb' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><p>Returns the ith arguments to this operation.</p></div></div><div id='d_Nb' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><p>Returns the arguments to this operation.</p></div></div><div id='d_Ob' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><p>Returns the <em>internal types</em> for this operations arguments. This is typically the list of interfaces or @protocols that the arguments must comply to.</p></div></div><div id='d_Pb' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns this element parent</p></div></div><div id='d_Qb' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><p>Tells if this element has a parent or not</p></div></div><div id='d_Rb' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_Sb' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_Tb' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><p>Sets the given argument of this operation, by argument index.</p></div></div><div id='d_Ub' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><p>Sets this element parent</p></div></div><div id='d_Vb' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.ISlot at 0x7bf6c0&gt;, &lt;class lambdafactory.interfaces.IEvaluable at 0x7bf450&gt;]</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='d_Cb' class='de'><h1>Class <span class='n'>IAllocation</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Xb' class='de'><h1>Method <span class='n'>getContent</span></h1><div class='re'><code>getContent( self )</code></div><div class='ds'><p>Returns the content of this annotation.</p></div></div><div id='d_Yb' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><p>Returns the name of this annotation.</p></div></div><div id='d_Wb' class='de'><h1>Class <span class='n'>IAnnotation</span></h1><div class='re'></div><div class='ds'><p>An annotation is some information that is not used for the actual program, but annotates/gives meta-information about is elements.</p></div></div><div id='d_ac' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.ISlot at 0x7bf6c0&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_bc' class='de'><h1>Method <span class='n'>getDefaultValue</span></h1><div class='re'><code>getDefaultValue( self )</code></div><div class='ds'><p>Returns the @methodault value for this slot.</p></div></div><div id='d_cc' class='de'><h1>Method <span class='n'>isKeywordsRest</span></h1><div class='re'><code>isKeywordsRest( self )</code></div><div class='ds'><p>Tells if this arguments represents &ldquo;<span class='quote'>the rest</span>&rdquo; of the keyword argument in the invocation</p></div></div><div id='d_dc' class='de'><h1>Method <span class='n'>isOptional</span></h1><div class='re'><code>isOptional( self )</code></div><div class='ds'><p>Tells if the argument is optional or not.</p></div></div><div id='d_ec' class='de'><h1>Method <span class='n'>isRest</span></h1><div class='re'><code>isRest( self )</code></div><div class='ds'><p>Tells if this argument represents &ldquo;<span class='quote'>the rest</span>&rdquo; of arguments in the invocation</p></div></div><div id='d_fc' class='de'><h1>Method <span class='n'>setDefaultValue</span></h1><div class='re'><code>setDefaultValue( self, value )</code></div><div class='ds'><p>Sets the @methodault value for this argument.</p></div></div><div id='d_gc' class='de'><h1>Method <span class='n'>setKeywordsRest</span></h1><div class='re'><code>setKeywordsRest( self, value )</code></div><div class='ds'><p>Tells this arguments represents &ldquo;<span class='quote'>the rest</span>&rdquo; of the keyword argument in the invocation</p></div></div><div id='d_hc' class='de'><h1>Method <span class='n'>setOptional</span></h1><div class='re'><code>setOptional( self, value )</code></div><div class='ds'><p>Sets this argument as optional or not.</p></div></div><div id='d_ic' class='de'><h1>Method <span class='n'>setRest</span></h1><div class='re'><code>setRest( self, value )</code></div><div class='ds'><p>Tells this argument represents &ldquo;<span class='quote'>the rest</span>&rdquo; of arguments in the invocation</p></div></div><div id='d_jc' class='de'><h1>Method <span class='n'>getAbsoluteName</span></h1><div class='re'><code>getAbsoluteName( self )</code></div><div class='ds'><p>Returns the absolute name for this element</p></div></div><div id='d_kc' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><p>Returns the local name for this referencable element</p></div></div><div id='d_lc' class='de'><h1>Method <span class='n'>getTypeDescription</span></h1><div class='re'><code>getTypeDescription( self )</code></div><div class='ds'><p>Returns type information (constraints) that are associated to this argument.</p></div></div><div id='d_Zb' class='de'><h1>Class <span class='n'>IArgument</span></h1><div class='re'></div><div class='ds'><p>Arguments are slots which can be interpreted in different ways.</p><p>When an argument is <span class='term'>optional</span>, it does not need to be defined in the invocation. When an argument is <span class='term'>variable</span>, it means it references the rest of the arguments lists. When an argument is <span class='term'>keywords</span>, it will reference the named arguments of the rest of the arguments list.</p></div></div><div id='d_mc' class='de'><h1>Class <span class='n'>IAssignable</span></h1><div class='re'></div><div class='ds'><p>Assignable elements are elements that can be bound to slots. In many languages, only a subset of elements can be assigned. For instance, in Java, you cannot assign a package to something:</p><pre>  Object my_package = java.lang.Object</pre><p>while in some other languages (like JavaScript), you could do that.</p></div></div><div id='d_oc' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IOperation at 0x7bfae0&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_pc' class='de'><h1>Method <span class='n'>getAssignedValue</span></h1><div class='re'><code>getAssignedValue( self )</code></div><div class='ds'><p>Returns this assigned evaluable.</p></div></div><div id='d_qc' class='de'><h1>Method <span class='n'>getTarget</span></h1><div class='re'><code>getTarget( self )</code></div><div class='ds'><p>Returns this assignation target reference, which can be an evaluable (in case you assign to self.something, or a reference)</p></div></div><div id='d_rc' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><p>Adds an argument to this operation. This should do checking of arguments (by expected internal type and number).</p></div></div><div id='d_sc' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><p>Performs a deep clone of this element. Any mutation to the original won't change the copy.</p></div></div><div id='d_tc' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><p>Detaches the element from its parent (in case it was already attached). This should return this element, and set the parent to None.</p></div></div><div id='d_uc' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_vc' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_wc' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_xc' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><p>Returns the ith arguments to this operation.</p></div></div><div id='d_yc' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><p>Returns the arguments to this operation.</p></div></div><div id='d_zc' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><p>Returns the <em>internal types</em> for this operations arguments. This is typically the list of interfaces or @protocols that the arguments must comply to.</p></div></div><div id='d_Ac' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns this element parent</p></div></div><div id='d_Bc' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><p>Tells if this element has a parent or not</p></div></div><div id='d_Cc' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_Dc' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_Ec' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><p>Sets the given argument of this operation, by argument index.</p></div></div><div id='d_Fc' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><p>Sets this element parent</p></div></div><div id='d_Gc' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.IEvaluable at 0x7bf450&gt;, &lt;class lambdafactory.interfaces.IEvaluable at 0x7bf450&gt;]</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='d_nc' class='de'><h1>Class <span class='n'>IAssignation</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Ic' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.ISlot at 0x7bf6c0&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Jc' class='de'><h1>Method <span class='n'>getDefaultValue</span></h1><div class='re'><code>getDefaultValue( self )</code></div><div class='ds'><p>Gets the @methodault value for this attribute</p></div></div><div id='d_Kc' class='de'><h1>Method <span class='n'>setDefaultValue</span></h1><div class='re'><code>setDefaultValue( self )</code></div><div class='ds'><p>Sets the @methodault value for this attribute</p></div></div><div id='d_Lc' class='de'><h1>Method <span class='n'>getAbsoluteName</span></h1><div class='re'><code>getAbsoluteName( self )</code></div><div class='ds'><p>Returns the absolute name for this element</p></div></div><div id='d_Mc' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><p>Returns the local name for this referencable element</p></div></div><div id='d_Nc' class='de'><h1>Method <span class='n'>getTypeDescription</span></h1><div class='re'><code>getTypeDescription( self )</code></div><div class='ds'><p>Returns type information (constraints) that are associated to this argument.</p></div></div><div id='d_Hc' class='de'><h1>Class <span class='n'>IAttribute</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Pc' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IGroup at 0x7bf930&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Qc' class='de'><h1>Method <span class='n'>addOperation</span></h1><div class='re'><code>addOperation( self, operation )</code></div><div class='ds'><p>Adds the given operation as a child of this process.</p></div></div><div id='d_Rc' class='de'><h1>Method <span class='n'>getOperations</span></h1><div class='re'><code>getOperations( self )</code></div><div class='ds'><p>Returns the list of operations in this process.</p></div></div><div id='d_Oc' class='de'><h1>Class <span class='n'>IBlock</span></h1><div class='re'></div><div class='ds'><p>A block is a specific type of (sub) process.</p></div></div><div id='d_Tc' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IInterruption at 0x7bff60&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Uc' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><p>Adds an argument to this operation. This should do checking of arguments (by expected internal type and number).</p></div></div><div id='d_Vc' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><p>Performs a deep clone of this element. Any mutation to the original won't change the copy.</p></div></div><div id='d_Wc' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><p>Detaches the element from its parent (in case it was already attached). This should return this element, and set the parent to None.</p></div></div><div id='d_Xc' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_Yc' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_Zc' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_ad' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><p>Returns the ith arguments to this operation.</p></div></div><div id='d_bd' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><p>Returns the arguments to this operation.</p></div></div><div id='d_cd' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><p>Returns the <em>internal types</em> for this operations arguments. This is typically the list of interfaces or @protocols that the arguments must comply to.</p></div></div><div id='d_dd' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns this element parent</p></div></div><div id='d_ed' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><p>Tells if this element has a parent or not</p></div></div><div id='d_fd' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_gd' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_hd' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><p>Sets the given argument of this operation, by argument index.</p></div></div><div id='d_id' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><p>Sets this element parent</p></div></div><div id='d_jd' class='de'><h1>list</h1><div class='re'><code>[]</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='d_Sc' class='de'><h1>Class <span class='n'>IBreaking</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_ld' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IContext at 0x7bf7e0&gt;, &lt;class lambdafactory.interfaces.IReferencable at 0x7bf420&gt;)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_md' class='de'><h1>Method <span class='n'>getAttributes</span></h1><div class='re'><code>getAttributes( self )</code></div><div class='ds'><p>Returns the (non-class) attributes defined within this class.</p></div></div><div id='d_nd' class='de'><h1>Method <span class='n'>getClassAttributes</span></h1><div class='re'><code>getClassAttributes( self )</code></div><div class='ds'><p>Returns the class attributes defined within this class.</p></div></div><div id='d_od' class='de'><h1>Method <span class='n'>getClassMethods</span></h1><div class='re'><code>getClassMethods( self )</code></div><div class='ds'><p>Returns the class method defined within this class.</p></div></div><div id='d_pd' class='de'><h1>Method <span class='n'>getConstructors</span></h1><div class='re'><code>getConstructors( self )</code></div><div class='ds'><p>Returns the constructors for this class</p></div></div><div id='d_qd' class='de'><h1>Method <span class='n'>getDestructors</span></h1><div class='re'><code>getDestructors( self )</code></div><div class='ds'><p>Returns the destructors for this class</p></div></div><div id='d_rd' class='de'><h1>Method <span class='n'>getInstanceMethods</span></h1><div class='re'><code>getInstanceMethods( self )</code></div><div class='ds'><p>Returns the instance methods defined within this class.</p></div></div><div id='d_sd' class='de'><h1>Method <span class='n'>getMethods</span></h1><div class='re'><code>getMethods( self )</code></div><div class='ds'><p>Returns the methods defined within this class.</p></div></div><div id='d_td' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><p>Returns this class name. It can be <code>None</code> if the class is anonymous.</p></div></div><div id='d_ud' class='de'><h1>Method <span class='n'>getOperations</span></h1><div class='re'><code>getOperations( self )</code></div><div class='ds'><p>Returns the operations (methods and class methods) defined within this class.</p></div></div><div id='d_vd' class='de'><h1>Method <span class='n'>getParentClasses</span></h1><div class='re'><code>getParentClasses( self )</code></div><div class='ds'><p>Returns the list of inherited classes references.</p></div></div><div id='d_wd' class='de'><h1>Method <span class='n'>setParentClasses</span></h1><div class='re'><code>setParentClasses( self )</code></div><div class='ds'><p>gives the list of parent classes that will</p></div></div><div id='d_xd' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><p>Performs a deep clone of this element. Any mutation to the original won't change the copy.</p></div></div><div id='d_yd' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><p>Detaches the element from its parent (in case it was already attached). This should return this element, and set the parent to None.</p></div></div><div id='d_zd' class='de'><h1>Method <span class='n'>getAbsoluteName</span></h1><div class='re'><code>getAbsoluteName( self )</code></div><div class='ds'><p>Returns the absolute name for this element</p></div></div><div id='d_Ad' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_Bd' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_Cd' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_Dd' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns the parent context for this context (if any)</p></div></div><div id='d_Ed' class='de'><h1>Method <span class='n'>getSlot</span></h1><div class='re'><code>getSlot( self, name )</code></div><div class='ds'><p>Returns the given evaluable bound to named slot.</p></div></div><div id='d_Fd' class='de'><h1>Method <span class='n'>getSlots</span></h1><div class='re'><code>getSlots( self )</code></div><div class='ds'><p>Returns (key, evaluable) pairs representing the slots within this context.</p></div></div><div id='d_Gd' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><p>Tells if this element has a parent or not</p></div></div><div id='d_Hd' class='de'><h1>Method <span class='n'>hasSlot</span></h1><div class='re'><code>hasSlot( self, name )</code></div><div class='ds'><p>Tells if the context has a slot with the given name.</p></div></div><div id='d_Id' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_Jd' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_Kd' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, context )</code></div><div class='ds'><p>Sets the parent context for this context.</p></div></div><div id='d_Ld' class='de'><h1>Method <span class='n'>setSlot</span></h1><div class='re'><code>setSlot( self, name, evaluable )</code></div><div class='ds'><p>Binds the given evaluable to the named slot.</p></div></div><div id='d_kd' class='de'><h1>Class <span class='n'>IClass</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Nd' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IAttribute at 0x7bf750&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Od' class='de'><h1>Method <span class='n'>getAbsoluteName</span></h1><div class='re'><code>getAbsoluteName( self )</code></div><div class='ds'><p>Returns the absolute name for this element</p></div></div><div id='d_Pd' class='de'><h1>Method <span class='n'>getDefaultValue</span></h1><div class='re'><code>getDefaultValue( self )</code></div><div class='ds'><p>Gets the @methodault value for this attribute</p></div></div><div id='d_Qd' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><p>Returns the local name for this referencable element</p></div></div><div id='d_Rd' class='de'><h1>Method <span class='n'>getTypeDescription</span></h1><div class='re'><code>getTypeDescription( self )</code></div><div class='ds'><p>Returns type information (constraints) that are associated to this argument.</p></div></div><div id='d_Sd' class='de'><h1>Method <span class='n'>setDefaultValue</span></h1><div class='re'><code>setDefaultValue( self )</code></div><div class='ds'><p>Sets the @methodault value for this attribute</p></div></div><div id='d_Md' class='de'><h1>Class <span class='n'>IClassAttribute</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Ud' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IMethod at 0x7bf9f0&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Vd' class='de'><h1>Method <span class='n'>addOperation</span></h1><div class='re'><code>addOperation( self, operation )</code></div><div class='ds'><p>Adds the given operation as a child of this process.</p></div></div><div id='d_Wd' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><p>Performs a deep clone of this element. Any mutation to the original won't change the copy.</p></div></div><div id='d_Xd' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><p>Detaches the element from its parent (in case it was already attached). This should return this element, and set the parent to None.</p></div></div><div id='d_Yd' class='de'><h1>Method <span class='n'>endsWithTermination</span></h1><div class='re'><code>endsWithTermination( self )</code></div><div class='ds'><p>Returns true if this function ends with a termination operation. This is especially useful for back-ends which want to know if they have to insert an explicit <code>return</code> at the end (like Java).</p></div></div><div id='d_Zd' class='de'><h1>Method <span class='n'>getAbsoluteName</span></h1><div class='re'><code>getAbsoluteName( self )</code></div><div class='ds'><p>Returns the absolute name for this element</p></div></div><div id='d_ae' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_be' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_ce' class='de'><h1>Method <span class='n'>getArguments</span></h1><div class='re'><code>getArguments( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_de' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_ee' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><p>Returns this @protocol name. It can be <code>None</code> if the @protocol is anonymous.</p></div></div><div id='d_fe' class='de'><h1>Method <span class='n'>getOperations</span></h1><div class='re'><code>getOperations( self )</code></div><div class='ds'><p>Returns the list of operations in this process.</p></div></div><div id='d_ge' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns the parent context for this context (if any)</p></div></div><div id='d_he' class='de'><h1>Method <span class='n'>getSlot</span></h1><div class='re'><code>getSlot( self, name )</code></div><div class='ds'><p>Returns the given evaluable bound to named slot.</p></div></div><div id='d_ie' class='de'><h1>Method <span class='n'>getSlots</span></h1><div class='re'><code>getSlots( self )</code></div><div class='ds'><p>Returns (key, evaluable) pairs representing the slots within this context.</p></div></div><div id='d_je' class='de'><h1>Method <span class='n'>hasExplicitTermination</span></h1><div class='re'><code>hasExplicitTermination( self )</code></div><div class='ds'><p>Returns true if this function has an operation with a termination, otherwise return false.</p></div></div><div id='d_ke' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><p>Tells if this element has a parent or not</p></div></div><div id='d_le' class='de'><h1>Method <span class='n'>hasSlot</span></h1><div class='re'><code>hasSlot( self, name )</code></div><div class='ds'><p>Tells if the context has a slot with the given name.</p></div></div><div id='d_me' class='de'><h1>Method <span class='n'>isAbstract</span></h1><div class='re'><code>isAbstract( self )</code></div><div class='ds'><p>Tells wether the given abstractable is abstract or not.</p></div></div><div id='d_ne' class='de'><h1>Method <span class='n'>setAbstract</span></h1><div class='re'><code>setAbstract( self, isAbstract )</code></div><div class='ds'><p>Sets wether the given abstractable is abstract or not.</p></div></div><div id='d_oe' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_pe' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_qe' class='de'><h1>Method <span class='n'>setArguments</span></h1><div class='re'><code>setArguments( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_re' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, context )</code></div><div class='ds'><p>Sets the parent context for this context.</p></div></div><div id='d_se' class='de'><h1>Method <span class='n'>setSlot</span></h1><div class='re'><code>setSlot( self, name, evaluable )</code></div><div class='ds'><p>Binds the given evaluable to the named slot.</p></div></div><div id='d_Td' class='de'><h1>Class <span class='n'>IClassMethod</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_ue' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IProcess at 0x7bf900&gt;, &lt;class lambdafactory.interfaces.IContext at 0x7bf7e0&gt;)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_ve' class='de'><h1>Method <span class='n'>getArguments</span></h1><div class='re'><code>getArguments( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_we' class='de'><h1>Method <span class='n'>setArguments</span></h1><div class='re'><code>setArguments( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_xe' class='de'><h1>Method <span class='n'>addOperation</span></h1><div class='re'><code>addOperation( self, operation )</code></div><div class='ds'><p>Adds the given operation as a child of this process.</p></div></div><div id='d_ye' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><p>Performs a deep clone of this element. Any mutation to the original won't change the copy.</p></div></div><div id='d_ze' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><p>Detaches the element from its parent (in case it was already attached). This should return this element, and set the parent to None.</p></div></div><div id='d_Ae' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_Be' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_Ce' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_De' class='de'><h1>Method <span class='n'>getOperations</span></h1><div class='re'><code>getOperations( self )</code></div><div class='ds'><p>Returns the list of operations in this process.</p></div></div><div id='d_Ee' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns the parent context for this context (if any)</p></div></div><div id='d_Fe' class='de'><h1>Method <span class='n'>getSlot</span></h1><div class='re'><code>getSlot( self, name )</code></div><div class='ds'><p>Returns the given evaluable bound to named slot.</p></div></div><div id='d_Ge' class='de'><h1>Method <span class='n'>getSlots</span></h1><div class='re'><code>getSlots( self )</code></div><div class='ds'><p>Returns (key, evaluable) pairs representing the slots within this context.</p></div></div><div id='d_He' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><p>Tells if this element has a parent or not</p></div></div><div id='d_Ie' class='de'><h1>Method <span class='n'>hasSlot</span></h1><div class='re'><code>hasSlot( self, name )</code></div><div class='ds'><p>Tells if the context has a slot with the given name.</p></div></div><div id='d_Je' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_Ke' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_Le' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, context )</code></div><div class='ds'><p>Sets the parent context for this context.</p></div></div><div id='d_Me' class='de'><h1>Method <span class='n'>setSlot</span></h1><div class='re'><code>setSlot( self, name, evaluable )</code></div><div class='ds'><p>Binds the given evaluable to the named slot.</p></div></div><div id='d_te' class='de'><h1>Class <span class='n'>IClosure</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Oe' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IAnnotation at 0x7bf270&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Pe' class='de'><h1>Method <span class='n'>getContent</span></h1><div class='re'><code>getContent( self )</code></div><div class='ds'><p>Returns the content of this annotation.</p></div></div><div id='d_Qe' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><p>Returns the name of this annotation.</p></div></div><div id='d_Ne' class='de'><h1>Class <span class='n'>IComment</span></h1><div class='re'></div><div class='ds'><p>A comment is an annotation that can occur anywhere in a source file.</p></div></div><div id='d_Se' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IOperation at 0x7bfae0&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Te' class='de'><h1>Method <span class='n'>getLeftOperand</span></h1><div class='re'><code>getLeftOperand( self )</code></div><div class='ds'><p>Returns the left operand of this computation.</p></div></div><div id='d_Ue' class='de'><h1>Method <span class='n'>getOperand</span></h1><div class='re'><code>getOperand( self )</code></div><div class='ds'><p>Returns the left operand of this computation.</p></div></div><div id='d_Ve' class='de'><h1>Method <span class='n'>getOperands</span></h1><div class='re'><code>getOperands( self )</code></div><div class='ds'><p>Returns the left (and right, if any) operands of this computation.</p></div></div><div id='d_We' class='de'><h1>Method <span class='n'>getOperator</span></h1><div class='re'><code>getOperator( self )</code></div><div class='ds'><p>Gets the operator for this computation</p></div></div><div id='d_Xe' class='de'><h1>Method <span class='n'>getRightOperand</span></h1><div class='re'><code>getRightOperand( self )</code></div><div class='ds'><p>Returns the right operand of this computation (if any)</p></div></div><div id='d_Ye' class='de'><h1>Method <span class='n'>setLeftOperand</span></h1><div class='re'><code>setLeftOperand( self, operand )</code></div><div class='ds'><p>Sets the left operand of this computation.</p></div></div><div id='d_Ze' class='de'><h1>Method <span class='n'>setOperator</span></h1><div class='re'><code>setOperator( self, operator )</code></div><div class='ds'><p>Sets the operator for this computation</p></div></div><div id='d_af' class='de'><h1>Method <span class='n'>setRightOperand</span></h1><div class='re'><code>setRightOperand( self, operand )</code></div><div class='ds'><p>Sets the right operand of this computation</p></div></div><div id='d_bf' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><p>Adds an argument to this operation. This should do checking of arguments (by expected internal type and number).</p></div></div><div id='d_cf' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><p>Performs a deep clone of this element. Any mutation to the original won't change the copy.</p></div></div><div id='d_df' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><p>Detaches the element from its parent (in case it was already attached). This should return this element, and set the parent to None.</p></div></div><div id='d_ef' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_ff' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_gf' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_hf' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><p>Returns the ith arguments to this operation.</p></div></div><div id='d_if' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><p>Returns the arguments to this operation.</p></div></div><div id='d_jf' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><p>Returns the <em>internal types</em> for this operations arguments. This is typically the list of interfaces or @protocols that the arguments must comply to.</p></div></div><div id='d_kf' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns this element parent</p></div></div><div id='d_lf' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><p>Tells if this element has a parent or not</p></div></div><div id='d_mf' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_nf' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_of' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><p>Sets the given argument of this operation, by argument index.</p></div></div><div id='d_pf' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><p>Sets this element parent</p></div></div><div id='d_qf' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.IOperator at 0x7bf690&gt;, &lt;class lambdafactory.interfaces.IEvaluable at 0x7bf450&gt;, &lt;class lambdafactory.interfaces.IEvaluable at 0x7bf450&gt;]</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='d_Re' class='de'><h1>Class <span class='n'>IComputation</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_sf' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IMethod at 0x7bf9f0&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_tf' class='de'><h1>Method <span class='n'>addOperation</span></h1><div class='re'><code>addOperation( self, operation )</code></div><div class='ds'><p>Adds the given operation as a child of this process.</p></div></div><div id='d_uf' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><p>Performs a deep clone of this element. Any mutation to the original won't change the copy.</p></div></div><div id='d_vf' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><p>Detaches the element from its parent (in case it was already attached). This should return this element, and set the parent to None.</p></div></div><div id='d_wf' class='de'><h1>Method <span class='n'>endsWithTermination</span></h1><div class='re'><code>endsWithTermination( self )</code></div><div class='ds'><p>Returns true if this function ends with a termination operation. This is especially useful for back-ends which want to know if they have to insert an explicit <code>return</code> at the end (like Java).</p></div></div><div id='d_xf' class='de'><h1>Method <span class='n'>getAbsoluteName</span></h1><div class='re'><code>getAbsoluteName( self )</code></div><div class='ds'><p>Returns the absolute name for this element</p></div></div><div id='d_yf' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_zf' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_Af' class='de'><h1>Method <span class='n'>getArguments</span></h1><div class='re'><code>getArguments( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Bf' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_Cf' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><p>Returns this @protocol name. It can be <code>None</code> if the @protocol is anonymous.</p></div></div><div id='d_Df' class='de'><h1>Method <span class='n'>getOperations</span></h1><div class='re'><code>getOperations( self )</code></div><div class='ds'><p>Returns the list of operations in this process.</p></div></div><div id='d_Ef' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns the parent context for this context (if any)</p></div></div><div id='d_Ff' class='de'><h1>Method <span class='n'>getSlot</span></h1><div class='re'><code>getSlot( self, name )</code></div><div class='ds'><p>Returns the given evaluable bound to named slot.</p></div></div><div id='d_Gf' class='de'><h1>Method <span class='n'>getSlots</span></h1><div class='re'><code>getSlots( self )</code></div><div class='ds'><p>Returns (key, evaluable) pairs representing the slots within this context.</p></div></div><div id='d_Hf' class='de'><h1>Method <span class='n'>hasExplicitTermination</span></h1><div class='re'><code>hasExplicitTermination( self )</code></div><div class='ds'><p>Returns true if this function has an operation with a termination, otherwise return false.</p></div></div><div id='d_If' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><p>Tells if this element has a parent or not</p></div></div><div id='d_Jf' class='de'><h1>Method <span class='n'>hasSlot</span></h1><div class='re'><code>hasSlot( self, name )</code></div><div class='ds'><p>Tells if the context has a slot with the given name.</p></div></div><div id='d_Kf' class='de'><h1>Method <span class='n'>isAbstract</span></h1><div class='re'><code>isAbstract( self )</code></div><div class='ds'><p>Tells wether the given abstractable is abstract or not.</p></div></div><div id='d_Lf' class='de'><h1>Method <span class='n'>setAbstract</span></h1><div class='re'><code>setAbstract( self, isAbstract )</code></div><div class='ds'><p>Sets wether the given abstractable is abstract or not.</p></div></div><div id='d_Mf' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_Nf' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_Of' class='de'><h1>Method <span class='n'>setArguments</span></h1><div class='re'><code>setArguments( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Pf' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, context )</code></div><div class='ds'><p>Sets the parent context for this context.</p></div></div><div id='d_Qf' class='de'><h1>Method <span class='n'>setSlot</span></h1><div class='re'><code>setSlot( self, name, evaluable )</code></div><div class='ds'><p>Binds the given evaluable to the named slot.</p></div></div><div id='d_rf' class='de'><h1>Class <span class='n'>IConstructor</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Sf' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IElement at 0x7bf3c0&gt;, &lt;class lambdafactory.interfaces.IDataFlowOwner at 0x7bf390&gt;)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Tf' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns the parent context for this context (if any)</p></div></div><div id='d_Uf' class='de'><h1>Method <span class='n'>getSlot</span></h1><div class='re'><code>getSlot( self, name )</code></div><div class='ds'><p>Returns the given evaluable bound to named slot.</p></div></div><div id='d_Vf' class='de'><h1>Method <span class='n'>getSlots</span></h1><div class='re'><code>getSlots( self )</code></div><div class='ds'><p>Returns (key, evaluable) pairs representing the slots within this context.</p></div></div><div id='d_Wf' class='de'><h1>Method <span class='n'>hasSlot</span></h1><div class='re'><code>hasSlot( self, name )</code></div><div class='ds'><p>Tells if the context has a slot with the given name.</p></div></div><div id='d_Xf' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, context )</code></div><div class='ds'><p>Sets the parent context for this context.</p></div></div><div id='d_Yf' class='de'><h1>Method <span class='n'>setSlot</span></h1><div class='re'><code>setSlot( self, name, evaluable )</code></div><div class='ds'><p>Binds the given evaluable to the named slot.</p></div></div><div id='d_Zf' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><p>Performs a deep clone of this element. Any mutation to the original won't change the copy.</p></div></div><div id='d_ag' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><p>Detaches the element from its parent (in case it was already attached). This should return this element, and set the parent to None.</p></div></div><div id='d_bg' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_cg' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_dg' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_eg' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><p>Tells if this element has a parent or not</p></div></div><div id='d_fg' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_gg' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_Rf' class='de'><h1>Class <span class='n'>IContext</span></h1><div class='re'></div><div class='ds'><p>A context is an element that has slots, which bind evaluable elements (aka values) to names.</p></div></div><div id='d_ig' class='de'><h1>Method <span class='n'>addChild</span></h1><div class='re'><code>addChild( self, child )</code></div><div class='ds'><p>Adds the given dataflow as a child of this dataflow.</p></div></div><div id='d_jg' class='de'><h1>Method <span class='n'>addDestination</span></h1><div class='re'><code>addDestination( self, dataflow )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_kg' class='de'><h1>Method <span class='n'>addSource</span></h1><div class='re'><code>addSource( self, dataflow )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_lg' class='de'><h1>Method <span class='n'>declareArgument</span></h1><div class='re'><code>declareArgument( self, name, value )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_mg' class='de'><h1>Method <span class='n'>declareEnvironment</span></h1><div class='re'><code>declareEnvironment( self, name, value )</code></div><div class='ds'><p>Declares an environment variable with the given name, value and origin.</p></div></div><div id='d_ng' class='de'><h1>Method <span class='n'>declareVariable</span></h1><div class='re'><code>declareVariable( self, name, value, origin=None )</code></div><div class='ds'><p>Declares a (local) variable with the given name, value and origin</p></div></div><div id='d_og' class='de'><h1>Method <span class='n'>defines</span></h1><div class='re'><code>defines( self, name )</code></div><div class='ds'><p>Tells if this dataflow, or any of its child dataflows defines the given name (symbol)</p></div></div><div id='d_pg' class='de'><h1>Method <span class='n'>getChildren</span></h1><div class='re'><code>getChildren( self )</code></div><div class='ds'><p>Returns a list of the child dataflows for this dataflow.</p></div></div><div id='d_qg' class='de'><h1>Method <span class='n'>getDestinations</span></h1><div class='re'><code>getDestinations( self )</code></div><div class='ds'><p>Returns the dataflows that are <span class='term'>destinations</span>, meaning that these dataflows will resolve if this dataflow if resolution fails, according tot the resolution scheme used.</p></div></div><div id='d_rg' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns the list of parent dataflows for this dataflow.</p></div></div><div id='d_sg' class='de'><h1>Method <span class='n'>getRoot</span></h1><div class='re'><code>getRoot( self )</code></div><div class='ds'><p>Returns the root of this dataflow (the root of the parent or this dataflow if it has no parent)</p></div></div><div id='d_tg' class='de'><h1>Method <span class='n'>getSlot</span></h1><div class='re'><code>getSlot( self, name )</code></div><div class='ds'><p>Returns the slot with the given name, if any.</p></div></div><div id='d_ug' class='de'><h1>Method <span class='n'>getSlots</span></h1><div class='re'><code>getSlots( self )</code></div><div class='ds'><p>Returns the lsit of slots @methodiend for this dataflow.</p></div></div><div id='d_vg' class='de'><h1>Method <span class='n'>getSources</span></h1><div class='re'><code>getSources( self )</code></div><div class='ds'><p>Returns the dataflows that are <span class='term'>sources</span>, meaning that if a slot is not resolved by this dataflow, it will look in the parent and then in the sources (depending on the resolution scheme, but this is the default)</p></div></div><div id='d_wg' class='de'><h1>Method <span class='n'>hasSlot</span></h1><div class='re'><code>hasSlot( self, name )</code></div><div class='ds'><p>Tells if this dataflow @methodines a slot with the given name.</p></div></div><div id='d_xg' class='de'><h1>Method <span class='n'>resolve</span></h1><div class='re'><code>resolve( self, name )</code></div><div class='ds'><p>Returns a couple <code>(DataFlow slot, IElement)</code> or <code>(None,None)</code> corresponding to the resolution of the given <code>name</code> in this dataflow.</p></div></div><div id='d_yg' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, parent )</code></div><div class='ds'><p>Add the given dataflow as a parent of this dataflow.</p></div></div><div id='d_hg' class='de'><h1>Class <span class='n'>IDataFlow</span></h1><div class='re'></div><div class='ds'><p>The DataFlow are &ldquo;<span class='quote'>dynamic contexts</span>&rdquo; bound to the various program model elements. DataFlows are typically owned by elements which implement <code>IContext</code>, and are linked together by rules defined in the <code>Resolver</code> @protocol.</p><p>The dataflow bound to most expressions is the one of the enclosing closure (whether it is a function, or method. The dataflow of a method is bound to its parent @protocol, which dataflow is also bound to the parent @protocol dataflow.</p><p>While <code>DataFlow</code> and <code>Context</code> may appear very similar, they are not the same: contexts are elements that keep track of declared slots, while the dataflow make use of the context to weave the elements togeher.</p></div></div><div id='d_zg' class='de'><h1>Class <span class='n'>IDataFlowOwner</span></h1><div class='re'></div><div class='ds'><p>DataFlow owners are elements that have their own dataflow. IContext are typical examples of elements that are dataflow owners</p></div></div><div id='d_Bg' class='de'><h1>Method <span class='n'>addOperation</span></h1><div class='re'><code>addOperation( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Cg' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Dg' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Eg' class='de'><h1>Method <span class='n'>getOperations</span></h1><div class='re'><code>getOperations( self )</code></div><div class='ds'><p>Returns the (ordered) list of operations that affected the slot. Operations usually constrain the dataflow abstract type, and exception/warnings/errors may be raised by the type system when a type constraint fails.</p></div></div><div id='d_Fg' class='de'><h1>Method <span class='n'>getOrigin</span></h1><div class='re'><code>getOrigin( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Gg' class='de'><h1>Method <span class='n'>getOriginalValue</span></h1><div class='re'><code>getOriginalValue( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Ag' class='de'><h1>Class <span class='n'>IDataFlowSlot</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Ig' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IMethod at 0x7bf9f0&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Jg' class='de'><h1>Method <span class='n'>addOperation</span></h1><div class='re'><code>addOperation( self, operation )</code></div><div class='ds'><p>Adds the given operation as a child of this process.</p></div></div><div id='d_Kg' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><p>Performs a deep clone of this element. Any mutation to the original won't change the copy.</p></div></div><div id='d_Lg' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><p>Detaches the element from its parent (in case it was already attached). This should return this element, and set the parent to None.</p></div></div><div id='d_Mg' class='de'><h1>Method <span class='n'>endsWithTermination</span></h1><div class='re'><code>endsWithTermination( self )</code></div><div class='ds'><p>Returns true if this function ends with a termination operation. This is especially useful for back-ends which want to know if they have to insert an explicit <code>return</code> at the end (like Java).</p></div></div><div id='d_Ng' class='de'><h1>Method <span class='n'>getAbsoluteName</span></h1><div class='re'><code>getAbsoluteName( self )</code></div><div class='ds'><p>Returns the absolute name for this element</p></div></div><div id='d_Og' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_Pg' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_Qg' class='de'><h1>Method <span class='n'>getArguments</span></h1><div class='re'><code>getArguments( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Rg' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_Sg' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><p>Returns this @protocol name. It can be <code>None</code> if the @protocol is anonymous.</p></div></div><div id='d_Tg' class='de'><h1>Method <span class='n'>getOperations</span></h1><div class='re'><code>getOperations( self )</code></div><div class='ds'><p>Returns the list of operations in this process.</p></div></div><div id='d_Ug' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns the parent context for this context (if any)</p></div></div><div id='d_Vg' class='de'><h1>Method <span class='n'>getSlot</span></h1><div class='re'><code>getSlot( self, name )</code></div><div class='ds'><p>Returns the given evaluable bound to named slot.</p></div></div><div id='d_Wg' class='de'><h1>Method <span class='n'>getSlots</span></h1><div class='re'><code>getSlots( self )</code></div><div class='ds'><p>Returns (key, evaluable) pairs representing the slots within this context.</p></div></div><div id='d_Xg' class='de'><h1>Method <span class='n'>hasExplicitTermination</span></h1><div class='re'><code>hasExplicitTermination( self )</code></div><div class='ds'><p>Returns true if this function has an operation with a termination, otherwise return false.</p></div></div><div id='d_Yg' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><p>Tells if this element has a parent or not</p></div></div><div id='d_Zg' class='de'><h1>Method <span class='n'>hasSlot</span></h1><div class='re'><code>hasSlot( self, name )</code></div><div class='ds'><p>Tells if the context has a slot with the given name.</p></div></div><div id='d_ah' class='de'><h1>Method <span class='n'>isAbstract</span></h1><div class='re'><code>isAbstract( self )</code></div><div class='ds'><p>Tells wether the given abstractable is abstract or not.</p></div></div><div id='d_bh' class='de'><h1>Method <span class='n'>setAbstract</span></h1><div class='re'><code>setAbstract( self, isAbstract )</code></div><div class='ds'><p>Sets wether the given abstractable is abstract or not.</p></div></div><div id='d_ch' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_dh' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_eh' class='de'><h1>Method <span class='n'>setArguments</span></h1><div class='re'><code>setArguments( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_fh' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, context )</code></div><div class='ds'><p>Sets the parent context for this context.</p></div></div><div id='d_gh' class='de'><h1>Method <span class='n'>setSlot</span></h1><div class='re'><code>setSlot( self, name, evaluable )</code></div><div class='ds'><p>Binds the given evaluable to the named slot.</p></div></div><div id='d_Hg' class='de'><h1>Class <span class='n'>IDestructor</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_ih' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IValue at 0x7bf510&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_jh' class='de'><h1>Method <span class='n'>getItems</span></h1><div class='re'><code>getItems( self )</code></div><div class='ds'><p>Returns the items contained in this dict</p></div></div><div id='d_kh' class='de'><h1>Method <span class='n'>setValue</span></h1><div class='re'><code>setValue( self, key, value )</code></div><div class='ds'><p>Sets the value to be associated to the given key (which must be an evaluable).</p></div></div><div id='d_lh' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><p>Performs a deep clone of this element. Any mutation to the original won't change the copy.</p></div></div><div id='d_mh' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><p>Detaches the element from its parent (in case it was already attached). This should return this element, and set the parent to None.</p></div></div><div id='d_nh' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_oh' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_ph' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_qh' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns this element parent</p></div></div><div id='d_rh' class='de'><h1>Method <span class='n'>getResultAbstractType</span></h1><div class='re'><code>getResultAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type of the result of the evaluation of this evaluable</p></div></div><div id='d_sh' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><p>Tells if this element has a parent or not</p></div></div><div id='d_th' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_uh' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_vh' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><p>Sets this element parent</p></div></div><div id='d_wh' class='de'><h1>Method <span class='n'>setResultAbstractType</span></h1><div class='re'><code>setResultAbstractType( self, abstractType )</code></div><div class='ds'><p>Sets the abstract type for this operation result. This is usually invoked in the typing phase.</p></div></div><div id='d_hh' class='de'><h1>Class <span class='n'>IDict</span></h1><div class='re'></div><div class='ds'><p>A dictionary is a binding of key to values. It may or may not be ordered, depending on the implementation/model semantics.</p></div></div><div id='d_yh' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IAnnotation at 0x7bf270&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_zh' class='de'><h1>Method <span class='n'>getContent</span></h1><div class='re'><code>getContent( self )</code></div><div class='ds'><p>Returns the content of this annotation.</p></div></div><div id='d_Ah' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><p>Returns the name of this annotation.</p></div></div><div id='d_xh' class='de'><h1>Class <span class='n'>IDocumentation</span></h1><div class='re'></div><div class='ds'><p>Documentation is often attached to various language elements. Documentation can be found in coments (as in Java), or be directly embedded as values (as in Python).</p></div></div><div id='d_Ch' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><p>Performs a deep clone of this element. Any mutation to the original won't change the copy.</p></div></div><div id='d_Dh' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><p>Detaches the element from its parent (in case it was already attached). This should return this element, and set the parent to None.</p></div></div><div id='d_Eh' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_Fh' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_Gh' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_Hh' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns this element parent</p></div></div><div id='d_Ih' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><p>Tells if this element has a parent or not</p></div></div><div id='d_Jh' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_Kh' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_Lh' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><p>Sets this element parent</p></div></div><div id='d_Bh' class='de'><h1>Class <span class='n'>IElement</span></h1><div class='re'></div><div class='ds'><p>The core @protocol for every element.</p></div></div><div id='d_Nh' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IOperation at 0x7bfae0&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Oh' class='de'><h1>Method <span class='n'>getCode</span></h1><div class='re'><code>getCode( self )</code></div><div class='ds'><p>Returns the embedded code string.</p></div></div><div id='d_Ph' class='de'><h1>Method <span class='n'>getLanguage</span></h1><div class='re'><code>getLanguage( self )</code></div><div class='ds'><p>Returns the language in which the emebedded code is written.</p></div></div><div id='d_Qh' class='de'><h1>Method <span class='n'>setCode</span></h1><div class='re'><code>setCode( self, code )</code></div><div class='ds'><p>Sets the code of this embed operation.</p></div></div><div id='d_Rh' class='de'><h1>Method <span class='n'>setLanguage</span></h1><div class='re'><code>setLanguage( self, language )</code></div><div class='ds'><p>Sets the language in which the emebedded code is written.</p></div></div><div id='d_Sh' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><p>Adds an argument to this operation. This should do checking of arguments (by expected internal type and number).</p></div></div><div id='d_Th' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><p>Performs a deep clone of this element. Any mutation to the original won't change the copy.</p></div></div><div id='d_Uh' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><p>Detaches the element from its parent (in case it was already attached). This should return this element, and set the parent to None.</p></div></div><div id='d_Vh' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_Wh' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_Xh' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_Yh' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><p>Returns the ith arguments to this operation.</p></div></div><div id='d_Zh' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><p>Returns the arguments to this operation.</p></div></div><div id='d_ai' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><p>Returns the <em>internal types</em> for this operations arguments. This is typically the list of interfaces or @protocols that the arguments must comply to.</p></div></div><div id='d_bi' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns this element parent</p></div></div><div id='d_ci' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><p>Tells if this element has a parent or not</p></div></div><div id='d_di' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_ei' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_fi' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><p>Sets the given argument of this operation, by argument index.</p></div></div><div id='d_gi' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><p>Sets this element parent</p></div></div><div id='d_hi' class='de'><h1>list</h1><div class='re'><code>[]</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='d_Mh' class='de'><h1>Class <span class='n'>IEmbed</span></h1><div class='re'></div><div class='ds'><p>An embedded operation represents a bit of verbatim code written in a different language. This allows for embedding code written specifically in a target language (which may happen for optimizing stuff, for instance).</p></div></div><div id='d_ji' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IEmbed at 0x1174060&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_ki' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><p>Adds an argument to this operation. This should do checking of arguments (by expected internal type and number).</p></div></div><div id='d_li' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><p>Performs a deep clone of this element. Any mutation to the original won't change the copy.</p></div></div><div id='d_mi' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><p>Detaches the element from its parent (in case it was already attached). This should return this element, and set the parent to None.</p></div></div><div id='d_ni' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_oi' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_pi' class='de'><h1>Method <span class='n'>getCode</span></h1><div class='re'><code>getCode( self )</code></div><div class='ds'><p>Returns the embedded code string.</p></div></div><div id='d_qi' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_ri' class='de'><h1>Method <span class='n'>getLanguage</span></h1><div class='re'><code>getLanguage( self )</code></div><div class='ds'><p>Returns the language in which the emebedded code is written.</p></div></div><div id='d_si' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><p>Returns the ith arguments to this operation.</p></div></div><div id='d_ti' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><p>Returns the arguments to this operation.</p></div></div><div id='d_ui' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><p>Returns the <em>internal types</em> for this operations arguments. This is typically the list of interfaces or @protocols that the arguments must comply to.</p></div></div><div id='d_vi' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns this element parent</p></div></div><div id='d_wi' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><p>Tells if this element has a parent or not</p></div></div><div id='d_xi' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_yi' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_zi' class='de'><h1>Method <span class='n'>setCode</span></h1><div class='re'><code>setCode( self, code )</code></div><div class='ds'><p>Sets the code of this embed operation.</p></div></div><div id='d_Ai' class='de'><h1>Method <span class='n'>setLanguage</span></h1><div class='re'><code>setLanguage( self, language )</code></div><div class='ds'><p>Sets the language in which the emebedded code is written.</p></div></div><div id='d_Bi' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><p>Sets the given argument of this operation, by argument index.</p></div></div><div id='d_Ci' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><p>Sets this element parent</p></div></div><div id='d_ii' class='de'><h1>Class <span class='n'>IEmbedTemplate</span></h1><div class='re'></div><div class='ds'><p>The <code>EmbedTemplate</code> is embedded (<code>Embed</code>) that contains template expressions. It's up to the model writer to know how to expand the template to convert it to the target language.</p></div></div><div id='d_Ei' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IOperation at 0x7bfae0&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Fi' class='de'><h1>Method <span class='n'>getEnd</span></h1><div class='re'><code>getEnd( self )</code></div><div class='ds'><p>Returns this enumeration end.</p></div></div><div id='d_Gi' class='de'><h1>Method <span class='n'>getStart</span></h1><div class='re'><code>getStart( self )</code></div><div class='ds'><p>Returns this enumeration start.</p></div></div><div id='d_Hi' class='de'><h1>Method <span class='n'>getStep</span></h1><div class='re'><code>getStep( self )</code></div><div class='ds'><p>Returns this enumeration step.</p></div></div><div id='d_Ii' class='de'><h1>Method <span class='n'>setStep</span></h1><div class='re'><code>setStep( self, value )</code></div><div class='ds'><p>Sets this enumeration step</p></div></div><div id='d_Ji' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><p>Adds an argument to this operation. This should do checking of arguments (by expected internal type and number).</p></div></div><div id='d_Ki' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><p>Performs a deep clone of this element. Any mutation to the original won't change the copy.</p></div></div><div id='d_Li' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><p>Detaches the element from its parent (in case it was already attached). This should return this element, and set the parent to None.</p></div></div><div id='d_Mi' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_Ni' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_Oi' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_Pi' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><p>Returns the ith arguments to this operation.</p></div></div><div id='d_Qi' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><p>Returns the arguments to this operation.</p></div></div><div id='d_Ri' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><p>Returns the <em>internal types</em> for this operations arguments. This is typically the list of interfaces or @protocols that the arguments must comply to.</p></div></div><div id='d_Si' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns this element parent</p></div></div><div id='d_Ti' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><p>Tells if this element has a parent or not</p></div></div><div id='d_Ui' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_Vi' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_Wi' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><p>Sets the given argument of this operation, by argument index.</p></div></div><div id='d_Xi' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><p>Sets this element parent</p></div></div><div id='d_Yi' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.IEvaluable at 0x7bf450&gt;, &lt;class lambdafactory.interfaces.IEvaluable at 0x7bf450&gt;, &lt;class lambdafactory.interfaces.IEvaluable at 0x7bf450&gt;]</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='d_Di' class='de'><h1>Class <span class='n'>IEnumeration</span></h1><div class='re'></div><div class='ds'><p>An enumeration produces values between a start and an end value, with the given step.</p></div></div><div id='d_aj' class='de'><h1>Method <span class='n'>getResultAbstractType</span></h1><div class='re'><code>getResultAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type of the result of the evaluation of this evaluable</p></div></div><div id='d_bj' class='de'><h1>Method <span class='n'>setResultAbstractType</span></h1><div class='re'><code>setResultAbstractType( self, abstractType )</code></div><div class='ds'><p>Sets the abstract type for this operation result. This is usually invoked in the typing phase.</p></div></div><div id='d_Zi' class='de'><h1>Class <span class='n'>IEvaluable</span></h1><div class='re'></div><div class='ds'><p>An evaluable is an element that can produce a value. Evaluable elements then have associated type information.</p></div></div><div id='d_dj' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IOperation at 0x7bfae0&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_ej' class='de'><h1>Method <span class='n'>getEvaluable</span></h1><div class='re'><code>getEvaluable( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_fj' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><p>Adds an argument to this operation. This should do checking of arguments (by expected internal type and number).</p></div></div><div id='d_gj' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><p>Performs a deep clone of this element. Any mutation to the original won't change the copy.</p></div></div><div id='d_hj' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><p>Detaches the element from its parent (in case it was already attached). This should return this element, and set the parent to None.</p></div></div><div id='d_ij' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_jj' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_kj' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_lj' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><p>Returns the ith arguments to this operation.</p></div></div><div id='d_mj' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><p>Returns the arguments to this operation.</p></div></div><div id='d_nj' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><p>Returns the <em>internal types</em> for this operations arguments. This is typically the list of interfaces or @protocols that the arguments must comply to.</p></div></div><div id='d_oj' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns this element parent</p></div></div><div id='d_pj' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><p>Tells if this element has a parent or not</p></div></div><div id='d_qj' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_rj' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_sj' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><p>Sets the given argument of this operation, by argument index.</p></div></div><div id='d_tj' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><p>Sets this element parent</p></div></div><div id='d_uj' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.IEvaluable at 0x7bf450&gt;, &lt;class lambdafactory.interfaces.IEvaluable at 0x7bf450&gt;]</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='d_vj' class='de'><h1>list</h1><div class='re'><code>['Evaluable']</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='d_cj' class='de'><h1>Class <span class='n'>IEvaluation</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_xj' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IInterruption at 0x7bff60&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_yj' class='de'><h1>Method <span class='n'>getValue</span></h1><div class='re'><code>getValue( self )</code></div><div class='ds'><p>Returns the termination return evaluable.</p></div></div><div id='d_zj' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><p>Adds an argument to this operation. This should do checking of arguments (by expected internal type and number).</p></div></div><div id='d_Aj' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><p>Performs a deep clone of this element. Any mutation to the original won't change the copy.</p></div></div><div id='d_Bj' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><p>Detaches the element from its parent (in case it was already attached). This should return this element, and set the parent to None.</p></div></div><div id='d_Cj' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_Dj' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_Ej' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_Fj' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><p>Returns the ith arguments to this operation.</p></div></div><div id='d_Gj' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><p>Returns the arguments to this operation.</p></div></div><div id='d_Hj' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><p>Returns the <em>internal types</em> for this operations arguments. This is typically the list of interfaces or @protocols that the arguments must comply to.</p></div></div><div id='d_Ij' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns this element parent</p></div></div><div id='d_Jj' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><p>Tells if this element has a parent or not</p></div></div><div id='d_Kj' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_Lj' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_Mj' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><p>Sets the given argument of this operation, by argument index.</p></div></div><div id='d_Nj' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><p>Sets this element parent</p></div></div><div id='d_Oj' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.IEvaluable at 0x7bf450&gt;]</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='d_wj' class='de'><h1>Class <span class='n'>IExcept</span></h1><div class='re'></div><div class='ds'><p>An interruption that raises some value</p></div></div><div id='d_Qj' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IClosure at 0x7bf990&gt;, &lt;class lambdafactory.interfaces.IReferencable at 0x7bf420&gt;, &lt;class lambdafactory.interfaces.IAbstractable at 0x7bf4e0&gt;)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Rj' class='de'><h1>Method <span class='n'>endsWithTermination</span></h1><div class='re'><code>endsWithTermination( self )</code></div><div class='ds'><p>Returns true if this function ends with a termination operation. This is especially useful for back-ends which want to know if they have to insert an explicit <code>return</code> at the end (like Java).</p></div></div><div id='d_Sj' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><p>Returns this @protocol name. It can be <code>None</code> if the @protocol is anonymous.</p></div></div><div id='d_Tj' class='de'><h1>Method <span class='n'>hasExplicitTermination</span></h1><div class='re'><code>hasExplicitTermination( self )</code></div><div class='ds'><p>Returns true if this function has an operation with a termination, otherwise return false.</p></div></div><div id='d_Uj' class='de'><h1>Method <span class='n'>addOperation</span></h1><div class='re'><code>addOperation( self, operation )</code></div><div class='ds'><p>Adds the given operation as a child of this process.</p></div></div><div id='d_Vj' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><p>Performs a deep clone of this element. Any mutation to the original won't change the copy.</p></div></div><div id='d_Wj' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><p>Detaches the element from its parent (in case it was already attached). This should return this element, and set the parent to None.</p></div></div><div id='d_Xj' class='de'><h1>Method <span class='n'>getAbsoluteName</span></h1><div class='re'><code>getAbsoluteName( self )</code></div><div class='ds'><p>Returns the absolute name for this element</p></div></div><div id='d_Yj' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_Zj' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_ak' class='de'><h1>Method <span class='n'>getArguments</span></h1><div class='re'><code>getArguments( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_bk' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_ck' class='de'><h1>Method <span class='n'>getOperations</span></h1><div class='re'><code>getOperations( self )</code></div><div class='ds'><p>Returns the list of operations in this process.</p></div></div><div id='d_dk' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns the parent context for this context (if any)</p></div></div><div id='d_ek' class='de'><h1>Method <span class='n'>getSlot</span></h1><div class='re'><code>getSlot( self, name )</code></div><div class='ds'><p>Returns the given evaluable bound to named slot.</p></div></div><div id='d_fk' class='de'><h1>Method <span class='n'>getSlots</span></h1><div class='re'><code>getSlots( self )</code></div><div class='ds'><p>Returns (key, evaluable) pairs representing the slots within this context.</p></div></div><div id='d_gk' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><p>Tells if this element has a parent or not</p></div></div><div id='d_hk' class='de'><h1>Method <span class='n'>hasSlot</span></h1><div class='re'><code>hasSlot( self, name )</code></div><div class='ds'><p>Tells if the context has a slot with the given name.</p></div></div><div id='d_ik' class='de'><h1>Method <span class='n'>isAbstract</span></h1><div class='re'><code>isAbstract( self )</code></div><div class='ds'><p>Tells wether the given abstractable is abstract or not.</p></div></div><div id='d_jk' class='de'><h1>Method <span class='n'>setAbstract</span></h1><div class='re'><code>setAbstract( self, isAbstract )</code></div><div class='ds'><p>Sets wether the given abstractable is abstract or not.</p></div></div><div id='d_kk' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_lk' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_mk' class='de'><h1>Method <span class='n'>setArguments</span></h1><div class='re'><code>setArguments( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_nk' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, context )</code></div><div class='ds'><p>Sets the parent context for this context.</p></div></div><div id='d_ok' class='de'><h1>Method <span class='n'>setSlot</span></h1><div class='re'><code>setSlot( self, name, evaluable )</code></div><div class='ds'><p>Binds the given evaluable to the named slot.</p></div></div><div id='d_Pj' class='de'><h1>Class <span class='n'>IFunction</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_qk' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IProcess at 0x7bf900&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_rk' class='de'><h1>Method <span class='n'>addOperation</span></h1><div class='re'><code>addOperation( self, operation )</code></div><div class='ds'><p>Adds the given operation as a child of this process.</p></div></div><div id='d_sk' class='de'><h1>Method <span class='n'>getOperations</span></h1><div class='re'><code>getOperations( self )</code></div><div class='ds'><p>Returns the list of operations in this process.</p></div></div><div id='d_pk' class='de'><h1>Class <span class='n'>IGroup</span></h1><div class='re'></div><div class='ds'><p>A block is a group of operations that share a common aspect. Groups are more likely to be used by program passes to further structure the program.</p><p>Groups should generally not have their own context, as opposed to blocks which generally have a context of their own.</p></div></div><div id='d_uk' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IImportOperation at 0x7bfb10&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_vk' class='de'><h1>Method <span class='n'>getAlias</span></h1><div class='re'><code>getAlias( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_wk' class='de'><h1>Method <span class='n'>getImportedModuleName</span></h1><div class='re'><code>getImportedModuleName( self )</code></div><div class='ds'><p>Returns the list of names representing the modules to load</p></div></div><div id='d_xk' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><p>Adds an argument to this operation. This should do checking of arguments (by expected internal type and number).</p></div></div><div id='d_yk' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><p>Performs a deep clone of this element. Any mutation to the original won't change the copy.</p></div></div><div id='d_zk' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><p>Detaches the element from its parent (in case it was already attached). This should return this element, and set the parent to None.</p></div></div><div id='d_Ak' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_Bk' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_Ck' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_Dk' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><p>Returns the ith arguments to this operation.</p></div></div><div id='d_Ek' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><p>Returns the arguments to this operation.</p></div></div><div id='d_Fk' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><p>Returns the <em>internal types</em> for this operations arguments. This is typically the list of interfaces or @protocols that the arguments must comply to.</p></div></div><div id='d_Gk' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns this element parent</p></div></div><div id='d_Hk' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><p>Tells if this element has a parent or not</p></div></div><div id='d_Ik' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_Jk' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_Kk' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><p>Sets the given argument of this operation, by argument index.</p></div></div><div id='d_Lk' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><p>Sets this element parent</p></div></div><div id='d_Mk' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.IEvaluable at 0x7bf450&gt;, &lt;class lambdafactory.interfaces.IEvaluable at 0x7bf450&gt;]</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='d_Nk' class='de'><h1>list</h1><div class='re'><code>['ImportedModuleName', 'Alias']</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='d_tk' class='de'><h1>Class <span class='n'>IImportModuleOperation</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Pk' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IImportOperation at 0x7bfb10&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Qk' class='de'><h1>Method <span class='n'>getImportedModuleNames</span></h1><div class='re'><code>getImportedModuleNames( self )</code></div><div class='ds'><p>Returns the list of names representing the modules to load</p></div></div><div id='d_Rk' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><p>Adds an argument to this operation. This should do checking of arguments (by expected internal type and number).</p></div></div><div id='d_Sk' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><p>Performs a deep clone of this element. Any mutation to the original won't change the copy.</p></div></div><div id='d_Tk' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><p>Detaches the element from its parent (in case it was already attached). This should return this element, and set the parent to None.</p></div></div><div id='d_Uk' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_Vk' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_Wk' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_Xk' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><p>Returns the ith arguments to this operation.</p></div></div><div id='d_Yk' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><p>Returns the arguments to this operation.</p></div></div><div id='d_Zk' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><p>Returns the <em>internal types</em> for this operations arguments. This is typically the list of interfaces or @protocols that the arguments must comply to.</p></div></div><div id='d_al' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns this element parent</p></div></div><div id='d_bl' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><p>Tells if this element has a parent or not</p></div></div><div id='d_cl' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_dl' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_el' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><p>Sets the given argument of this operation, by argument index.</p></div></div><div id='d_fl' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><p>Sets this element parent</p></div></div><div id='d_gl' class='de'><h1>list</h1><div class='re'><code>[[&lt;class lambdafactory.interfaces.IEvaluable at 0x7bf450&gt;]]</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='d_hl' class='de'><h1>list</h1><div class='re'><code>['ImportedModuleNames']</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='d_Ok' class='de'><h1>Class <span class='n'>IImportModulesOperation</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_jl' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IOperation at 0x7bfae0&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_kl' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><p>Adds an argument to this operation. This should do checking of arguments (by expected internal type and number).</p></div></div><div id='d_ll' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><p>Performs a deep clone of this element. Any mutation to the original won't change the copy.</p></div></div><div id='d_ml' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><p>Detaches the element from its parent (in case it was already attached). This should return this element, and set the parent to None.</p></div></div><div id='d_nl' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_ol' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_pl' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_ql' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><p>Returns the ith arguments to this operation.</p></div></div><div id='d_rl' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><p>Returns the arguments to this operation.</p></div></div><div id='d_sl' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><p>Returns the <em>internal types</em> for this operations arguments. This is typically the list of interfaces or @protocols that the arguments must comply to.</p></div></div><div id='d_tl' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns this element parent</p></div></div><div id='d_ul' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><p>Tells if this element has a parent or not</p></div></div><div id='d_vl' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_wl' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_xl' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><p>Sets the given argument of this operation, by argument index.</p></div></div><div id='d_yl' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><p>Sets this element parent</p></div></div><div id='d_il' class='de'><h1>Class <span class='n'>IImportOperation</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Al' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IImportOperation at 0x7bfb10&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Bl' class='de'><h1>Method <span class='n'>getAlias</span></h1><div class='re'><code>getAlias( self )</code></div><div class='ds'><p>Returns the (optional) alias which will allow to reference the element.</p></div></div><div id='d_Cl' class='de'><h1>Method <span class='n'>getImportOrigin</span></h1><div class='re'><code>getImportOrigin( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Dl' class='de'><h1>Method <span class='n'>getImportedElement</span></h1><div class='re'><code>getImportedElement( self )</code></div><div class='ds'><p>Returns a reference or a resolution that will allow to get the imported element.</p></div></div><div id='d_El' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><p>Adds an argument to this operation. This should do checking of arguments (by expected internal type and number).</p></div></div><div id='d_Fl' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><p>Performs a deep clone of this element. Any mutation to the original won't change the copy.</p></div></div><div id='d_Gl' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><p>Detaches the element from its parent (in case it was already attached). This should return this element, and set the parent to None.</p></div></div><div id='d_Hl' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_Il' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_Jl' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_Kl' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><p>Returns the ith arguments to this operation.</p></div></div><div id='d_Ll' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><p>Returns the arguments to this operation.</p></div></div><div id='d_Ml' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><p>Returns the <em>internal types</em> for this operations arguments. This is typically the list of interfaces or @protocols that the arguments must comply to.</p></div></div><div id='d_Nl' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns this element parent</p></div></div><div id='d_Ol' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><p>Tells if this element has a parent or not</p></div></div><div id='d_Pl' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_Ql' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_Rl' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><p>Sets the given argument of this operation, by argument index.</p></div></div><div id='d_Sl' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><p>Sets this element parent</p></div></div><div id='d_Tl' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.IEvaluable at 0x7bf450&gt;, &lt;class lambdafactory.interfaces.IEvaluable at 0x7bf450&gt;, &lt;class lambdafactory.interfaces.IEvaluable at 0x7bf450&gt;]</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='d_Ul' class='de'><h1>list</h1><div class='re'><code>['ImportedElement', 'ImportOrigin', 'Alias']</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='d_zl' class='de'><h1>Class <span class='n'>IImportSymbolOperation</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Wl' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IImportOperation at 0x7bfb10&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Xl' class='de'><h1>Method <span class='n'>getImportOrigin</span></h1><div class='re'><code>getImportOrigin( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Yl' class='de'><h1>Method <span class='n'>getImportedElements</span></h1><div class='re'><code>getImportedElements( self )</code></div><div class='ds'><p>Returns a reference or a resolution that will allow to get the imported element.</p></div></div><div id='d_Zl' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><p>Adds an argument to this operation. This should do checking of arguments (by expected internal type and number).</p></div></div><div id='d_am' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><p>Performs a deep clone of this element. Any mutation to the original won't change the copy.</p></div></div><div id='d_bm' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><p>Detaches the element from its parent (in case it was already attached). This should return this element, and set the parent to None.</p></div></div><div id='d_cm' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_dm' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_em' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_fm' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><p>Returns the ith arguments to this operation.</p></div></div><div id='d_gm' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><p>Returns the arguments to this operation.</p></div></div><div id='d_hm' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><p>Returns the <em>internal types</em> for this operations arguments. This is typically the list of interfaces or @protocols that the arguments must comply to.</p></div></div><div id='d_im' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns this element parent</p></div></div><div id='d_jm' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><p>Tells if this element has a parent or not</p></div></div><div id='d_km' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_lm' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_mm' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><p>Sets the given argument of this operation, by argument index.</p></div></div><div id='d_nm' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><p>Sets this element parent</p></div></div><div id='d_om' class='de'><h1>list</h1><div class='re'><code>[[&lt;class lambdafactory.interfaces.IEvaluable at 0x7bf450&gt;], &lt;class lambdafactory.interfaces.IEvaluable at 0x7bf450&gt;]</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='d_pm' class='de'><h1>list</h1><div class='re'><code>['ImportedElements', 'ImportOrigin']</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='d_Vl' class='de'><h1>Class <span class='n'>IImportSymbolsOperation</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_rm' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IMethod at 0x7bf9f0&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_sm' class='de'><h1>Method <span class='n'>addOperation</span></h1><div class='re'><code>addOperation( self, operation )</code></div><div class='ds'><p>Adds the given operation as a child of this process.</p></div></div><div id='d_tm' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><p>Performs a deep clone of this element. Any mutation to the original won't change the copy.</p></div></div><div id='d_um' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><p>Detaches the element from its parent (in case it was already attached). This should return this element, and set the parent to None.</p></div></div><div id='d_vm' class='de'><h1>Method <span class='n'>endsWithTermination</span></h1><div class='re'><code>endsWithTermination( self )</code></div><div class='ds'><p>Returns true if this function ends with a termination operation. This is especially useful for back-ends which want to know if they have to insert an explicit <code>return</code> at the end (like Java).</p></div></div><div id='d_wm' class='de'><h1>Method <span class='n'>getAbsoluteName</span></h1><div class='re'><code>getAbsoluteName( self )</code></div><div class='ds'><p>Returns the absolute name for this element</p></div></div><div id='d_xm' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_ym' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_zm' class='de'><h1>Method <span class='n'>getArguments</span></h1><div class='re'><code>getArguments( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Am' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_Bm' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><p>Returns this @protocol name. It can be <code>None</code> if the @protocol is anonymous.</p></div></div><div id='d_Cm' class='de'><h1>Method <span class='n'>getOperations</span></h1><div class='re'><code>getOperations( self )</code></div><div class='ds'><p>Returns the list of operations in this process.</p></div></div><div id='d_Dm' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns the parent context for this context (if any)</p></div></div><div id='d_Em' class='de'><h1>Method <span class='n'>getSlot</span></h1><div class='re'><code>getSlot( self, name )</code></div><div class='ds'><p>Returns the given evaluable bound to named slot.</p></div></div><div id='d_Fm' class='de'><h1>Method <span class='n'>getSlots</span></h1><div class='re'><code>getSlots( self )</code></div><div class='ds'><p>Returns (key, evaluable) pairs representing the slots within this context.</p></div></div><div id='d_Gm' class='de'><h1>Method <span class='n'>hasExplicitTermination</span></h1><div class='re'><code>hasExplicitTermination( self )</code></div><div class='ds'><p>Returns true if this function has an operation with a termination, otherwise return false.</p></div></div><div id='d_Hm' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><p>Tells if this element has a parent or not</p></div></div><div id='d_Im' class='de'><h1>Method <span class='n'>hasSlot</span></h1><div class='re'><code>hasSlot( self, name )</code></div><div class='ds'><p>Tells if the context has a slot with the given name.</p></div></div><div id='d_Jm' class='de'><h1>Method <span class='n'>isAbstract</span></h1><div class='re'><code>isAbstract( self )</code></div><div class='ds'><p>Tells wether the given abstractable is abstract or not.</p></div></div><div id='d_Km' class='de'><h1>Method <span class='n'>setAbstract</span></h1><div class='re'><code>setAbstract( self, isAbstract )</code></div><div class='ds'><p>Sets wether the given abstractable is abstract or not.</p></div></div><div id='d_Lm' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_Mm' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_Nm' class='de'><h1>Method <span class='n'>setArguments</span></h1><div class='re'><code>setArguments( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Om' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, context )</code></div><div class='ds'><p>Sets the parent context for this context.</p></div></div><div id='d_Pm' class='de'><h1>Method <span class='n'>setSlot</span></h1><div class='re'><code>setSlot( self, name, evaluable )</code></div><div class='ds'><p>Binds the given evaluable to the named slot.</p></div></div><div id='d_qm' class='de'><h1>Class <span class='n'>IInstanceMethod</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Qm' class='de'><h1>Class <span class='n'>IInstanciable</span></h1><div class='re'></div><div class='ds'><p>Instanciable is a property of some elements that allows them to be instanciated. Conceptually, an instanciation could be considered as a specific kind of invocation.</p></div></div><div id='d_Sm' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IOperation at 0x7bfae0&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Tm' class='de'><h1>Method <span class='n'>getArguments</span></h1><div class='re'><code>getArguments( self )</code></div><div class='ds'><p>Returns evaluable arguments.</p></div></div><div id='d_Um' class='de'><h1>Method <span class='n'>getInstanciable</span></h1><div class='re'><code>getInstanciable( self )</code></div><div class='ds'><p>Returns the instanciable used in this operation.</p></div></div><div id='d_Vm' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><p>Adds an argument to this operation. This should do checking of arguments (by expected internal type and number).</p></div></div><div id='d_Wm' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><p>Performs a deep clone of this element. Any mutation to the original won't change the copy.</p></div></div><div id='d_Xm' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><p>Detaches the element from its parent (in case it was already attached). This should return this element, and set the parent to None.</p></div></div><div id='d_Ym' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_Zm' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_an' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_bn' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><p>Returns the ith arguments to this operation.</p></div></div><div id='d_cn' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><p>Returns the arguments to this operation.</p></div></div><div id='d_dn' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><p>Returns the <em>internal types</em> for this operations arguments. This is typically the list of interfaces or @protocols that the arguments must comply to.</p></div></div><div id='d_en' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns this element parent</p></div></div><div id='d_fn' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><p>Tells if this element has a parent or not</p></div></div><div id='d_gn' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_hn' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_in' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><p>Sets the given argument of this operation, by argument index.</p></div></div><div id='d_jn' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><p>Sets this element parent</p></div></div><div id='d_kn' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.IEvaluable at 0x7bf450&gt;, [&lt;class lambdafactory.interfaces.IEvaluable at 0x7bf450&gt;]]</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='d_Rm' class='de'><h1>Class <span class='n'>IInstanciation</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_mn' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IOperation at 0x7bfae0&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_nn' class='de'><h1>Method <span class='n'>getConclusion</span></h1><div class='re'><code>getConclusion( self )</code></div><div class='ds'><p>Returns the process that will conclude the interception (finally)</p></div></div><div id='d_on' class='de'><h1>Method <span class='n'>getIntercept</span></h1><div class='re'><code>getIntercept( self )</code></div><div class='ds'><p>Returns the process that will do the interception</p></div></div><div id='d_pn' class='de'><h1>Method <span class='n'>getProcess</span></h1><div class='re'><code>getProcess( self )</code></div><div class='ds'><p>Returns the process that we will intercept interruptions from.</p></div></div><div id='d_qn' class='de'><h1>Method <span class='n'>setConclusion</span></h1><div class='re'><code>setConclusion( self, process )</code></div><div class='ds'><p>Sets the process that will conclude the interception (finally)</p></div></div><div id='d_rn' class='de'><h1>Method <span class='n'>setIntercept</span></h1><div class='re'><code>setIntercept( self, process )</code></div><div class='ds'><p>Sets the process that will do the interception</p></div></div><div id='d_sn' class='de'><h1>Method <span class='n'>setProcess</span></h1><div class='re'><code>setProcess( self, process )</code></div><div class='ds'><p>Sets the process from which interruptions will be intercepted.</p></div></div><div id='d_tn' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><p>Adds an argument to this operation. This should do checking of arguments (by expected internal type and number).</p></div></div><div id='d_un' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><p>Performs a deep clone of this element. Any mutation to the original won't change the copy.</p></div></div><div id='d_vn' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><p>Detaches the element from its parent (in case it was already attached). This should return this element, and set the parent to None.</p></div></div><div id='d_wn' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_xn' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_yn' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_zn' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><p>Returns the ith arguments to this operation.</p></div></div><div id='d_An' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><p>Returns the arguments to this operation.</p></div></div><div id='d_Bn' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><p>Returns the <em>internal types</em> for this operations arguments. This is typically the list of interfaces or @protocols that the arguments must comply to.</p></div></div><div id='d_Cn' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns this element parent</p></div></div><div id='d_Dn' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><p>Tells if this element has a parent or not</p></div></div><div id='d_En' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_Fn' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_Gn' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><p>Sets the given argument of this operation, by argument index.</p></div></div><div id='d_Hn' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><p>Sets this element parent</p></div></div><div id='d_In' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.IProcess at 0x7bf900&gt;, &lt;class lambdafactory.interfaces.IProcess at 0x7bf900&gt;, &lt;class lambdafactory.interfaces.IProcess at 0x7bf900&gt;]</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='d_ln' class='de'><h1>Class <span class='n'>IInterception</span></h1><div class='re'></div><div class='ds'><p>An interception allows to intercept interruptions that propagage from an enclosed process to parent contexts.</p></div></div><div id='d_Kn' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IAbstractClass at 0x7bf840&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Ln' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><p>Performs a deep clone of this element. Any mutation to the original won't change the copy.</p></div></div><div id='d_Mn' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><p>Detaches the element from its parent (in case it was already attached). This should return this element, and set the parent to None.</p></div></div><div id='d_Nn' class='de'><h1>Method <span class='n'>getAbsoluteName</span></h1><div class='re'><code>getAbsoluteName( self )</code></div><div class='ds'><p>Returns the absolute name for this element</p></div></div><div id='d_On' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_Pn' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_Qn' class='de'><h1>Method <span class='n'>getAttributes</span></h1><div class='re'><code>getAttributes( self )</code></div><div class='ds'><p>Returns the (non-class) attributes defined within this class.</p></div></div><div id='d_Rn' class='de'><h1>Method <span class='n'>getClassAttributes</span></h1><div class='re'><code>getClassAttributes( self )</code></div><div class='ds'><p>Returns the class attributes defined within this class.</p></div></div><div id='d_Sn' class='de'><h1>Method <span class='n'>getClassMethods</span></h1><div class='re'><code>getClassMethods( self )</code></div><div class='ds'><p>Returns the class method defined within this class.</p></div></div><div id='d_Tn' class='de'><h1>Method <span class='n'>getConstructors</span></h1><div class='re'><code>getConstructors( self )</code></div><div class='ds'><p>Returns the constructors for this class</p></div></div><div id='d_Un' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_Vn' class='de'><h1>Method <span class='n'>getDestructors</span></h1><div class='re'><code>getDestructors( self )</code></div><div class='ds'><p>Returns the destructors for this class</p></div></div><div id='d_Wn' class='de'><h1>Method <span class='n'>getInstanceMethods</span></h1><div class='re'><code>getInstanceMethods( self )</code></div><div class='ds'><p>Returns the instance methods defined within this class.</p></div></div><div id='d_Xn' class='de'><h1>Method <span class='n'>getMethods</span></h1><div class='re'><code>getMethods( self )</code></div><div class='ds'><p>Returns the methods defined within this class.</p></div></div><div id='d_Yn' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><p>Returns this class name. It can be <code>None</code> if the class is anonymous.</p></div></div><div id='d_Zn' class='de'><h1>Method <span class='n'>getOperations</span></h1><div class='re'><code>getOperations( self )</code></div><div class='ds'><p>Returns the operations (methods and class methods) defined within this class.</p></div></div><div id='d_ao' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns the parent context for this context (if any)</p></div></div><div id='d_bo' class='de'><h1>Method <span class='n'>getParentClasses</span></h1><div class='re'><code>getParentClasses( self )</code></div><div class='ds'><p>Returns the list of inherited classes references.</p></div></div><div id='d_co' class='de'><h1>Method <span class='n'>getSlot</span></h1><div class='re'><code>getSlot( self, name )</code></div><div class='ds'><p>Returns the given evaluable bound to named slot.</p></div></div><div id='d_do' class='de'><h1>Method <span class='n'>getSlots</span></h1><div class='re'><code>getSlots( self )</code></div><div class='ds'><p>Returns (key, evaluable) pairs representing the slots within this context.</p></div></div><div id='d_eo' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><p>Tells if this element has a parent or not</p></div></div><div id='d_fo' class='de'><h1>Method <span class='n'>hasSlot</span></h1><div class='re'><code>hasSlot( self, name )</code></div><div class='ds'><p>Tells if the context has a slot with the given name.</p></div></div><div id='d_go' class='de'><h1>Method <span class='n'>isAbstract</span></h1><div class='re'><code>isAbstract( self )</code></div><div class='ds'><p>Tells wether the given abstractable is abstract or not.</p></div></div><div id='d_ho' class='de'><h1>Method <span class='n'>setAbstract</span></h1><div class='re'><code>setAbstract( self, isAbstract )</code></div><div class='ds'><p>Sets wether the given abstractable is abstract or not.</p></div></div><div id='d_io' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_jo' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_ko' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, context )</code></div><div class='ds'><p>Sets the parent context for this context.</p></div></div><div id='d_lo' class='de'><h1>Method <span class='n'>setParentClasses</span></h1><div class='re'><code>setParentClasses( self )</code></div><div class='ds'><p>gives the list of parent classes that will</p></div></div><div id='d_mo' class='de'><h1>Method <span class='n'>setSlot</span></h1><div class='re'><code>setSlot( self, name, evaluable )</code></div><div class='ds'><p>Binds the given evaluable to the named slot.</p></div></div><div id='d_Jn' class='de'><h1>Class <span class='n'>IInterface</span></h1><div class='re'></div><div class='ds'><p>An interface is an abstract @protocol that only has abstract elements.</p></div></div><div id='d_oo' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IOperation at 0x7bfae0&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_po' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><p>Adds an argument to this operation. This should do checking of arguments (by expected internal type and number).</p></div></div><div id='d_qo' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><p>Performs a deep clone of this element. Any mutation to the original won't change the copy.</p></div></div><div id='d_ro' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><p>Detaches the element from its parent (in case it was already attached). This should return this element, and set the parent to None.</p></div></div><div id='d_so' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_to' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_uo' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_vo' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><p>Returns the ith arguments to this operation.</p></div></div><div id='d_wo' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><p>Returns the arguments to this operation.</p></div></div><div id='d_xo' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><p>Returns the <em>internal types</em> for this operations arguments. This is typically the list of interfaces or @protocols that the arguments must comply to.</p></div></div><div id='d_yo' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns this element parent</p></div></div><div id='d_zo' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><p>Tells if this element has a parent or not</p></div></div><div id='d_Ao' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_Bo' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_Co' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><p>Sets the given argument of this operation, by argument index.</p></div></div><div id='d_Do' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><p>Sets this element parent</p></div></div><div id='d_no' class='de'><h1>Class <span class='n'>IInterruption</span></h1><div class='re'></div><div class='ds'><p>An interruption can be be used to halt the process.</p></div></div><div id='d_Fo' class='de'><h1>Method <span class='n'>getArguments</span></h1><div class='re'><code>getArguments( self )</code></div><div class='ds'><p>Returns a list of arguments (which are names associated with optional type information.</p></div></div><div id='d_Eo' class='de'><h1>Class <span class='n'>IInvocable</span></h1><div class='re'></div><div class='ds'><p>An invocable can be used in an invocation operation.</p></div></div><div id='d_Ho' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IOperation at 0x7bfae0&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Io' class='de'><h1>Method <span class='n'>getArguments</span></h1><div class='re'><code>getArguments( self )</code></div><div class='ds'><p>Returns evaluable arguments.</p></div></div><div id='d_Jo' class='de'><h1>Method <span class='n'>getTarget</span></h1><div class='re'><code>getTarget( self )</code></div><div class='ds'><p>Returns the invocation target reference.</p></div></div><div id='d_Ko' class='de'><h1>Method <span class='n'>isByPositionOnly</span></h1><div class='re'><code>isByPositionOnly( self )</code></div><div class='ds'><p>Tells if this invocation is only by position. Otherwise, some arguments are given by name, as list or as a map (and they should be handled in a specific way)</p></div></div><div id='d_Lo' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><p>Adds an argument to this operation. This should do checking of arguments (by expected internal type and number).</p></div></div><div id='d_Mo' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><p>Performs a deep clone of this element. Any mutation to the original won't change the copy.</p></div></div><div id='d_No' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><p>Detaches the element from its parent (in case it was already attached). This should return this element, and set the parent to None.</p></div></div><div id='d_Oo' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_Po' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_Qo' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_Ro' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><p>Returns the ith arguments to this operation.</p></div></div><div id='d_So' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><p>Returns the arguments to this operation.</p></div></div><div id='d_To' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><p>Returns the <em>internal types</em> for this operations arguments. This is typically the list of interfaces or @protocols that the arguments must comply to.</p></div></div><div id='d_Uo' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns this element parent</p></div></div><div id='d_Vo' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><p>Tells if this element has a parent or not</p></div></div><div id='d_Wo' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_Xo' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_Yo' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><p>Sets the given argument of this operation, by argument index.</p></div></div><div id='d_Zo' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><p>Sets this element parent</p></div></div><div id='d_ap' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.IEvaluable at 0x7bf450&gt;, [&lt;class lambdafactory.interfaces.IEvaluable at 0x7bf450&gt;]]</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='d_Go' class='de'><h1>Class <span class='n'>IInvocation</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_cp' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IOperation at 0x7bfae0&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_dp' class='de'><h1>Method <span class='n'>getClosure</span></h1><div class='re'><code>getClosure( self )</code></div><div class='ds'><p>Returns the closure that will be applied to the iterator.</p></div></div><div id='d_ep' class='de'><h1>Method <span class='n'>getIterator</span></h1><div class='re'><code>getIterator( self )</code></div><div class='ds'><p>Returns this iteration iterator.</p></div></div><div id='d_fp' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><p>Adds an argument to this operation. This should do checking of arguments (by expected internal type and number).</p></div></div><div id='d_gp' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><p>Performs a deep clone of this element. Any mutation to the original won't change the copy.</p></div></div><div id='d_hp' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><p>Detaches the element from its parent (in case it was already attached). This should return this element, and set the parent to None.</p></div></div><div id='d_ip' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_jp' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_kp' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_lp' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><p>Returns the ith arguments to this operation.</p></div></div><div id='d_mp' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><p>Returns the arguments to this operation.</p></div></div><div id='d_np' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><p>Returns the <em>internal types</em> for this operations arguments. This is typically the list of interfaces or @protocols that the arguments must comply to.</p></div></div><div id='d_op' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns this element parent</p></div></div><div id='d_pp' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><p>Tells if this element has a parent or not</p></div></div><div id='d_qp' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_rp' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_sp' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><p>Sets the given argument of this operation, by argument index.</p></div></div><div id='d_tp' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><p>Sets this element parent</p></div></div><div id='d_up' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.IEvaluable at 0x7bf450&gt;, &lt;class lambdafactory.interfaces.IEvaluable at 0x7bf450&gt;]</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='d_bp' class='de'><h1>Class <span class='n'>IIteration</span></h1><div class='re'></div><div class='ds'><p>An iteration is the multiple application of a process given a set of values produced by an iterator.</p></div></div><div id='d_wp' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IValue at 0x7bf510&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_xp' class='de'><h1>Method <span class='n'>addValue</span></h1><div class='re'><code>addValue( self, value )</code></div><div class='ds'><p>Adds a value to this list.</p></div></div><div id='d_yp' class='de'><h1>Method <span class='n'>getValues</span></h1><div class='re'><code>getValues( self )</code></div><div class='ds'><p>Returns the values within this list.</p></div></div><div id='d_zp' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><p>Performs a deep clone of this element. Any mutation to the original won't change the copy.</p></div></div><div id='d_Ap' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><p>Detaches the element from its parent (in case it was already attached). This should return this element, and set the parent to None.</p></div></div><div id='d_Bp' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_Cp' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_Dp' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_Ep' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns this element parent</p></div></div><div id='d_Fp' class='de'><h1>Method <span class='n'>getResultAbstractType</span></h1><div class='re'><code>getResultAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type of the result of the evaluation of this evaluable</p></div></div><div id='d_Gp' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><p>Tells if this element has a parent or not</p></div></div><div id='d_Hp' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_Ip' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_Jp' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><p>Sets this element parent</p></div></div><div id='d_Kp' class='de'><h1>Method <span class='n'>setResultAbstractType</span></h1><div class='re'><code>setResultAbstractType( self, abstractType )</code></div><div class='ds'><p>Sets the abstract type for this operation result. This is usually invoked in the typing phase.</p></div></div><div id='d_vp' class='de'><h1>Class <span class='n'>IList</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Mp' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IValue at 0x7bf510&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Np' class='de'><h1>Method <span class='n'>getActualValue</span></h1><div class='re'><code>getActualValue( self )</code></div><div class='ds'><p>Returns the (implementation language) value for this literal</p></div></div><div id='d_Op' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><p>Performs a deep clone of this element. Any mutation to the original won't change the copy.</p></div></div><div id='d_Pp' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><p>Detaches the element from its parent (in case it was already attached). This should return this element, and set the parent to None.</p></div></div><div id='d_Qp' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_Rp' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_Sp' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_Tp' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns this element parent</p></div></div><div id='d_Up' class='de'><h1>Method <span class='n'>getResultAbstractType</span></h1><div class='re'><code>getResultAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type of the result of the evaluation of this evaluable</p></div></div><div id='d_Vp' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><p>Tells if this element has a parent or not</p></div></div><div id='d_Wp' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_Xp' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_Yp' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><p>Sets this element parent</p></div></div><div id='d_Zp' class='de'><h1>Method <span class='n'>setResultAbstractType</span></h1><div class='re'><code>setResultAbstractType( self, abstractType )</code></div><div class='ds'><p>Sets the abstract type for this operation result. This is usually invoked in the typing phase.</p></div></div><div id='d_Lp' class='de'><h1>Class <span class='n'>ILiteral</span></h1><div class='re'></div><div class='ds'><p>A literal is a value that does not need a context to be evaluated. The evaluation is direct.</p></div></div><div id='d_bq' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IMatchOperation at 0x7bfde0&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_cq' class='de'><h1>Method <span class='n'>getExpression</span></h1><div class='re'><code>getExpression( self )</code></div><div class='ds'><p>Returns the process that will be executed if the rule matches.</p></div></div><div id='d_dq' class='de'><h1>Method <span class='n'>setExpression</span></h1><div class='re'><code>setExpression( self, v )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_eq' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><p>Adds an argument to this operation. This should do checking of arguments (by expected internal type and number).</p></div></div><div id='d_fq' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><p>Performs a deep clone of this element. Any mutation to the original won't change the copy.</p></div></div><div id='d_gq' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><p>Detaches the element from its parent (in case it was already attached). This should return this element, and set the parent to None.</p></div></div><div id='d_hq' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_iq' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_jq' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_kq' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><p>Returns the ith arguments to this operation.</p></div></div><div id='d_lq' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><p>Returns the arguments to this operation.</p></div></div><div id='d_mq' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><p>Returns the <em>internal types</em> for this operations arguments. This is typically the list of interfaces or @protocols that the arguments must comply to.</p></div></div><div id='d_nq' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns this element parent</p></div></div><div id='d_oq' class='de'><h1>Method <span class='n'>getPredicate</span></h1><div class='re'><code>getPredicate( self )</code></div><div class='ds'><p>Returns the evaluable that acts as a predicate for this operation.</p></div></div><div id='d_pq' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><p>Tells if this element has a parent or not</p></div></div><div id='d_qq' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_rq' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_sq' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><p>Sets the given argument of this operation, by argument index.</p></div></div><div id='d_tq' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><p>Sets this element parent</p></div></div><div id='d_uq' class='de'><h1>Method <span class='n'>setPredicate</span></h1><div class='re'><code>setPredicate( self, v )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_vq' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.IEvaluable at 0x7bf450&gt;, &lt;class lambdafactory.interfaces.IEvaluable at 0x7bf450&gt;]</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='d_aq' class='de'><h1>Class <span class='n'>IMatchExpressionOperation</span></h1><div class='re'></div><div class='ds'><p>A match expression is a predicate that is associated to an expression. This is typically used in conditional expressions like in C:</p><pre>int a = ( b==2 ? 1 : 2 )</pre></div></div><div id='d_xq' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IOperation at 0x7bfae0&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_yq' class='de'><h1>Method <span class='n'>getPredicate</span></h1><div class='re'><code>getPredicate( self )</code></div><div class='ds'><p>Returns the evaluable that acts as a predicate for this operation.</p></div></div><div id='d_zq' class='de'><h1>Method <span class='n'>setPredicate</span></h1><div class='re'><code>setPredicate( self, v )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Aq' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><p>Adds an argument to this operation. This should do checking of arguments (by expected internal type and number).</p></div></div><div id='d_Bq' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><p>Performs a deep clone of this element. Any mutation to the original won't change the copy.</p></div></div><div id='d_Cq' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><p>Detaches the element from its parent (in case it was already attached). This should return this element, and set the parent to None.</p></div></div><div id='d_Dq' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_Eq' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_Fq' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_Gq' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><p>Returns the ith arguments to this operation.</p></div></div><div id='d_Hq' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><p>Returns the arguments to this operation.</p></div></div><div id='d_Iq' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><p>Returns the <em>internal types</em> for this operations arguments. This is typically the list of interfaces or @protocols that the arguments must comply to.</p></div></div><div id='d_Jq' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns this element parent</p></div></div><div id='d_Kq' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><p>Tells if this element has a parent or not</p></div></div><div id='d_Lq' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_Mq' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_Nq' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><p>Sets the given argument of this operation, by argument index.</p></div></div><div id='d_Oq' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><p>Sets this element parent</p></div></div><div id='d_wq' class='de'><h1>Class <span class='n'>IMatchOperation</span></h1><div class='re'></div><div class='ds'><p>A match operation is the binding of an expression and a process.</p></div></div><div id='d_Qq' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IMatchOperation at 0x7bfde0&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Rq' class='de'><h1>Method <span class='n'>getProcess</span></h1><div class='re'><code>getProcess( self )</code></div><div class='ds'><p>Returns the process that will be executed if the rule matches.</p></div></div><div id='d_Sq' class='de'><h1>Method <span class='n'>setProcess</span></h1><div class='re'><code>setProcess( self, v )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Tq' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><p>Adds an argument to this operation. This should do checking of arguments (by expected internal type and number).</p></div></div><div id='d_Uq' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><p>Performs a deep clone of this element. Any mutation to the original won't change the copy.</p></div></div><div id='d_Vq' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><p>Detaches the element from its parent (in case it was already attached). This should return this element, and set the parent to None.</p></div></div><div id='d_Wq' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_Xq' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_Yq' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_Zq' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><p>Returns the ith arguments to this operation.</p></div></div><div id='d_ar' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><p>Returns the arguments to this operation.</p></div></div><div id='d_br' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><p>Returns the <em>internal types</em> for this operations arguments. This is typically the list of interfaces or @protocols that the arguments must comply to.</p></div></div><div id='d_cr' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns this element parent</p></div></div><div id='d_dr' class='de'><h1>Method <span class='n'>getPredicate</span></h1><div class='re'><code>getPredicate( self )</code></div><div class='ds'><p>Returns the evaluable that acts as a predicate for this operation.</p></div></div><div id='d_er' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><p>Tells if this element has a parent or not</p></div></div><div id='d_fr' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_gr' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_hr' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><p>Sets the given argument of this operation, by argument index.</p></div></div><div id='d_ir' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><p>Sets this element parent</p></div></div><div id='d_jr' class='de'><h1>Method <span class='n'>setPredicate</span></h1><div class='re'><code>setPredicate( self, v )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_kr' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.IEvaluable at 0x7bf450&gt;, &lt;class lambdafactory.interfaces.IProcess at 0x7bf900&gt;]</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='d_Pq' class='de'><h1>Class <span class='n'>IMatchProcessOperation</span></h1><div class='re'></div><div class='ds'><p>A match process is a predicate associate to a process, which is typically used for implementing <code>if</code>, <code>else</code>, etc.</p></div></div><div id='d_mr' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IFunction at 0x7bf9c0&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_nr' class='de'><h1>Method <span class='n'>addOperation</span></h1><div class='re'><code>addOperation( self, operation )</code></div><div class='ds'><p>Adds the given operation as a child of this process.</p></div></div><div id='d_or' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><p>Performs a deep clone of this element. Any mutation to the original won't change the copy.</p></div></div><div id='d_pr' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><p>Detaches the element from its parent (in case it was already attached). This should return this element, and set the parent to None.</p></div></div><div id='d_qr' class='de'><h1>Method <span class='n'>endsWithTermination</span></h1><div class='re'><code>endsWithTermination( self )</code></div><div class='ds'><p>Returns true if this function ends with a termination operation. This is especially useful for back-ends which want to know if they have to insert an explicit <code>return</code> at the end (like Java).</p></div></div><div id='d_rr' class='de'><h1>Method <span class='n'>getAbsoluteName</span></h1><div class='re'><code>getAbsoluteName( self )</code></div><div class='ds'><p>Returns the absolute name for this element</p></div></div><div id='d_sr' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_tr' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_ur' class='de'><h1>Method <span class='n'>getArguments</span></h1><div class='re'><code>getArguments( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_vr' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_wr' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><p>Returns this @protocol name. It can be <code>None</code> if the @protocol is anonymous.</p></div></div><div id='d_xr' class='de'><h1>Method <span class='n'>getOperations</span></h1><div class='re'><code>getOperations( self )</code></div><div class='ds'><p>Returns the list of operations in this process.</p></div></div><div id='d_yr' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns the parent context for this context (if any)</p></div></div><div id='d_zr' class='de'><h1>Method <span class='n'>getSlot</span></h1><div class='re'><code>getSlot( self, name )</code></div><div class='ds'><p>Returns the given evaluable bound to named slot.</p></div></div><div id='d_Ar' class='de'><h1>Method <span class='n'>getSlots</span></h1><div class='re'><code>getSlots( self )</code></div><div class='ds'><p>Returns (key, evaluable) pairs representing the slots within this context.</p></div></div><div id='d_Br' class='de'><h1>Method <span class='n'>hasExplicitTermination</span></h1><div class='re'><code>hasExplicitTermination( self )</code></div><div class='ds'><p>Returns true if this function has an operation with a termination, otherwise return false.</p></div></div><div id='d_Cr' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><p>Tells if this element has a parent or not</p></div></div><div id='d_Dr' class='de'><h1>Method <span class='n'>hasSlot</span></h1><div class='re'><code>hasSlot( self, name )</code></div><div class='ds'><p>Tells if the context has a slot with the given name.</p></div></div><div id='d_Er' class='de'><h1>Method <span class='n'>isAbstract</span></h1><div class='re'><code>isAbstract( self )</code></div><div class='ds'><p>Tells wether the given abstractable is abstract or not.</p></div></div><div id='d_Fr' class='de'><h1>Method <span class='n'>setAbstract</span></h1><div class='re'><code>setAbstract( self, isAbstract )</code></div><div class='ds'><p>Sets wether the given abstractable is abstract or not.</p></div></div><div id='d_Gr' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_Hr' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_Ir' class='de'><h1>Method <span class='n'>setArguments</span></h1><div class='re'><code>setArguments( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Jr' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, context )</code></div><div class='ds'><p>Sets the parent context for this context.</p></div></div><div id='d_Kr' class='de'><h1>Method <span class='n'>setSlot</span></h1><div class='re'><code>setSlot( self, name, evaluable )</code></div><div class='ds'><p>Binds the given evaluable to the named slot.</p></div></div><div id='d_lr' class='de'><h1>Class <span class='n'>IMethod</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Mr' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IContext at 0x7bf7e0&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Nr' class='de'><h1>Method <span class='n'>addImportOperation</span></h1><div class='re'><code>addImportOperation( self, operation )</code></div><div class='ds'><p>Returns the list of import operations declared in this module</p></div></div><div id='d_Or' class='de'><h1>Method <span class='n'>getClasses</span></h1><div class='re'><code>getClasses( self )</code></div><div class='ds'><p>Returns the list of classes defined in this module. This is mainly a convenience function.</p></div></div><div id='d_Pr' class='de'><h1>Method <span class='n'>getImportOperations</span></h1><div class='re'><code>getImportOperations( self )</code></div><div class='ds'><p>Returns the list of import operations declared in this module</p></div></div><div id='d_Qr' class='de'><h1>Method <span class='n'>getParentName</span></h1><div class='re'><code>getParentName( self )</code></div><div class='ds'><p>Returns the parent name of this module (if any)</p></div></div><div id='d_Rr' class='de'><h1>Method <span class='n'>isImported</span></h1><div class='re'><code>isImported( self )</code></div><div class='ds'><p>A stub module is a module that does not have any bound implementation. Stub modules are typically used by Programs when adding a module such as <code>a.b.c</code> where <code>a</code> and <code>a.b</code> will be stub modules unless they were or will be imported.</p></div></div><div id='d_Sr' class='de'><h1>Method <span class='n'>setImported</span></h1><div class='re'><code>setImported( self, value=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Tr' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><p>Performs a deep clone of this element. Any mutation to the original won't change the copy.</p></div></div><div id='d_Ur' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><p>Detaches the element from its parent (in case it was already attached). This should return this element, and set the parent to None.</p></div></div><div id='d_Vr' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_Wr' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_Xr' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_Yr' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns the parent context for this context (if any)</p></div></div><div id='d_Zr' class='de'><h1>Method <span class='n'>getSlot</span></h1><div class='re'><code>getSlot( self, name )</code></div><div class='ds'><p>Returns the given evaluable bound to named slot.</p></div></div><div id='d_as' class='de'><h1>Method <span class='n'>getSlots</span></h1><div class='re'><code>getSlots( self )</code></div><div class='ds'><p>Returns (key, evaluable) pairs representing the slots within this context.</p></div></div><div id='d_bs' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><p>Tells if this element has a parent or not</p></div></div><div id='d_cs' class='de'><h1>Method <span class='n'>hasSlot</span></h1><div class='re'><code>hasSlot( self, name )</code></div><div class='ds'><p>Tells if the context has a slot with the given name.</p></div></div><div id='d_ds' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_es' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_fs' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, context )</code></div><div class='ds'><p>Sets the parent context for this context.</p></div></div><div id='d_gs' class='de'><h1>Method <span class='n'>setSlot</span></h1><div class='re'><code>setSlot( self, name, evaluable )</code></div><div class='ds'><p>Binds the given evaluable to the named slot.</p></div></div><div id='d_Lr' class='de'><h1>Class <span class='n'>IModule</span></h1><div class='re'></div><div class='ds'><p>Note that a module <code>getName</code> function returns the module absolute name</p></div></div><div id='d_is' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IAttribute at 0x7bf750&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_js' class='de'><h1>Method <span class='n'>getAbsoluteName</span></h1><div class='re'><code>getAbsoluteName( self )</code></div><div class='ds'><p>Returns the absolute name for this element</p></div></div><div id='d_ks' class='de'><h1>Method <span class='n'>getDefaultValue</span></h1><div class='re'><code>getDefaultValue( self )</code></div><div class='ds'><p>Gets the @methodault value for this attribute</p></div></div><div id='d_ls' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><p>Returns the local name for this referencable element</p></div></div><div id='d_ms' class='de'><h1>Method <span class='n'>getTypeDescription</span></h1><div class='re'><code>getTypeDescription( self )</code></div><div class='ds'><p>Returns type information (constraints) that are associated to this argument.</p></div></div><div id='d_ns' class='de'><h1>Method <span class='n'>setDefaultValue</span></h1><div class='re'><code>setDefaultValue( self )</code></div><div class='ds'><p>Sets the @methodault value for this attribute</p></div></div><div id='d_hs' class='de'><h1>Class <span class='n'>IModuleAttribute</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_ps' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.ILiteral at 0x7bf540&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_qs' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><p>Performs a deep clone of this element. Any mutation to the original won't change the copy.</p></div></div><div id='d_rs' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><p>Detaches the element from its parent (in case it was already attached). This should return this element, and set the parent to None.</p></div></div><div id='d_ss' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_ts' class='de'><h1>Method <span class='n'>getActualValue</span></h1><div class='re'><code>getActualValue( self )</code></div><div class='ds'><p>Returns the (implementation language) value for this literal</p></div></div><div id='d_us' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_vs' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_ws' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns this element parent</p></div></div><div id='d_xs' class='de'><h1>Method <span class='n'>getResultAbstractType</span></h1><div class='re'><code>getResultAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type of the result of the evaluation of this evaluable</p></div></div><div id='d_ys' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><p>Tells if this element has a parent or not</p></div></div><div id='d_zs' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_As' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_Bs' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><p>Sets this element parent</p></div></div><div id='d_Cs' class='de'><h1>Method <span class='n'>setResultAbstractType</span></h1><div class='re'><code>setResultAbstractType( self, abstractType )</code></div><div class='ds'><p>Sets the abstract type for this operation result. This is usually invoked in the typing phase.</p></div></div><div id='d_os' class='de'><h1>Class <span class='n'>INumber</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Es' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IElement at 0x7bf3c0&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Fs' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><p>Adds an argument to this operation. This should do checking of arguments (by expected internal type and number).</p></div></div><div id='d_Gs' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><p>Returns the ith arguments to this operation.</p></div></div><div id='d_Hs' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><p>Returns the arguments to this operation.</p></div></div><div id='d_Is' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><p>Returns the <em>internal types</em> for this operations arguments. This is typically the list of interfaces or @protocols that the arguments must comply to.</p></div></div><div id='d_Js' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><p>Sets the given argument of this operation, by argument index.</p></div></div><div id='d_Ks' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><p>Performs a deep clone of this element. Any mutation to the original won't change the copy.</p></div></div><div id='d_Ls' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><p>Detaches the element from its parent (in case it was already attached). This should return this element, and set the parent to None.</p></div></div><div id='d_Ms' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_Ns' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_Os' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_Ps' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns this element parent</p></div></div><div id='d_Qs' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><p>Tells if this element has a parent or not</p></div></div><div id='d_Rs' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_Ss' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_Ts' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><p>Sets this element parent</p></div></div><div id='d_Ds' class='de'><h1>Class <span class='n'>IOperation</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Vs' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IReference at 0x7bf630&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Ws' class='de'><h1>Method <span class='n'>getPriority</span></h1><div class='re'><code>getPriority( self )</code></div><div class='ds'><p>Gets the priority for this operator</p></div></div><div id='d_Xs' class='de'><h1>Method <span class='n'>setPriority</span></h1><div class='re'><code>setPriority( self, priority )</code></div><div class='ds'><p>Sets the priority for this operator</p></div></div><div id='d_Ys' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><p>Performs a deep clone of this element. Any mutation to the original won't change the copy.</p></div></div><div id='d_Zs' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><p>Detaches the element from its parent (in case it was already attached). This should return this element, and set the parent to None.</p></div></div><div id='d_at' class='de'><h1>Method <span class='n'>getAbsoluteName</span></h1><div class='re'><code>getAbsoluteName( self )</code></div><div class='ds'><p>Returns the absolute name for this element</p></div></div><div id='d_bt' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_ct' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_dt' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_et' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><p>Returns the local name for this referencable element</p></div></div><div id='d_ft' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns this element parent</p></div></div><div id='d_gt' class='de'><h1>Method <span class='n'>getReferenceName</span></h1><div class='re'><code>getReferenceName( self )</code></div><div class='ds'><p>Returns the name which this reference contains. The name is used by the resolution operation to actually resolve a value from the name.</p></div></div><div id='d_ht' class='de'><h1>Method <span class='n'>getResultAbstractType</span></h1><div class='re'><code>getResultAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type of the result of the evaluation of this evaluable</p></div></div><div id='d_it' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><p>Tells if this element has a parent or not</p></div></div><div id='d_jt' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_kt' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_lt' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><p>Sets this element parent</p></div></div><div id='d_mt' class='de'><h1>Method <span class='n'>setResultAbstractType</span></h1><div class='re'><code>setResultAbstractType( self, abstractType )</code></div><div class='ds'><p>Sets the abstract type for this operation result. This is usually invoked in the typing phase.</p></div></div><div id='d_Us' class='de'><h1>Class <span class='n'>IOperator</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_ot' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IElement at 0x7bf3c0&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_pt' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_qt' class='de'><h1>Method <span class='n'>getValue</span></h1><div class='re'><code>getValue( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_rt' class='de'><h1>Method <span class='n'>isAsList</span></h1><div class='re'><code>isAsList( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_st' class='de'><h1>Method <span class='n'>isAsMap</span></h1><div class='re'><code>isAsMap( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_tt' class='de'><h1>Method <span class='n'>isByName</span></h1><div class='re'><code>isByName( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_ut' class='de'><h1>Method <span class='n'>setAsList</span></h1><div class='re'><code>setAsList( self, v=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_vt' class='de'><h1>Method <span class='n'>setAsMap</span></h1><div class='re'><code>setAsMap( self, v=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_wt' class='de'><h1>Method <span class='n'>setByName</span></h1><div class='re'><code>setByName( self, n )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_xt' class='de'><h1>Method <span class='n'>setValue</span></h1><div class='re'><code>setValue( self, v )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_yt' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><p>Performs a deep clone of this element. Any mutation to the original won't change the copy.</p></div></div><div id='d_zt' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><p>Detaches the element from its parent (in case it was already attached). This should return this element, and set the parent to None.</p></div></div><div id='d_At' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_Bt' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_Ct' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_Dt' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns this element parent</p></div></div><div id='d_Et' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><p>Tells if this element has a parent or not</p></div></div><div id='d_Ft' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_Gt' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_Ht' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><p>Sets this element parent</p></div></div><div id='d_nt' class='de'><h1>Class <span class='n'>IParameter</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Jt' class='de'><h1>Method <span class='n'>addOperation</span></h1><div class='re'><code>addOperation( self, operation )</code></div><div class='ds'><p>Adds the given operation as a child of this process.</p></div></div><div id='d_Kt' class='de'><h1>Method <span class='n'>getOperations</span></h1><div class='re'><code>getOperations( self )</code></div><div class='ds'><p>Returns the list of operations in this process.</p></div></div><div id='d_It' class='de'><h1>Class <span class='n'>IProcess</span></h1><div class='re'></div><div class='ds'><p>A process is a sequence of operations.</p></div></div><div id='d_Mt' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IContext at 0x7bf7e0&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Nt' class='de'><h1>Method <span class='n'>addModule</span></h1><div class='re'><code>addModule( self, module )</code></div><div class='ds'><p>Adds a module to this program. The module will be registered in the global module catalogue.</p></div></div><div id='d_Ot' class='de'><h1>Method <span class='n'>getFactory</span></h1><div class='re'><code>getFactory( self )</code></div><div class='ds'><p>Gets the factory that was used to create this program. It can be used to create more elements in the program.</p></div></div><div id='d_Pt' class='de'><h1>Method <span class='n'>getModule</span></h1><div class='re'><code>getModule( self, moduleAbsoluteName )</code></div><div class='ds'><p>Returns the module (if any) with the given absolute name</p></div></div><div id='d_Qt' class='de'><h1>Method <span class='n'>getModules</span></h1><div class='re'><code>getModules( self )</code></div><div class='ds'><p>Returns the list of modules declared/imported in this program</p></div></div><div id='d_Rt' class='de'><h1>Method <span class='n'>setFactory</span></h1><div class='re'><code>setFactory( self, factory )</code></div><div class='ds'><p>Sets the factory that was used to create this program</p></div></div><div id='d_St' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><p>Performs a deep clone of this element. Any mutation to the original won't change the copy.</p></div></div><div id='d_Tt' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><p>Detaches the element from its parent (in case it was already attached). This should return this element, and set the parent to None.</p></div></div><div id='d_Ut' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_Vt' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_Wt' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_Xt' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns the parent context for this context (if any)</p></div></div><div id='d_Yt' class='de'><h1>Method <span class='n'>getSlot</span></h1><div class='re'><code>getSlot( self, name )</code></div><div class='ds'><p>Returns the given evaluable bound to named slot.</p></div></div><div id='d_Zt' class='de'><h1>Method <span class='n'>getSlots</span></h1><div class='re'><code>getSlots( self )</code></div><div class='ds'><p>Returns (key, evaluable) pairs representing the slots within this context.</p></div></div><div id='d_au' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><p>Tells if this element has a parent or not</p></div></div><div id='d_bu' class='de'><h1>Method <span class='n'>hasSlot</span></h1><div class='re'><code>hasSlot( self, name )</code></div><div class='ds'><p>Tells if the context has a slot with the given name.</p></div></div><div id='d_cu' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_du' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_eu' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, context )</code></div><div class='ds'><p>Sets the parent context for this context.</p></div></div><div id='d_fu' class='de'><h1>Method <span class='n'>setSlot</span></h1><div class='re'><code>setSlot( self, name, evaluable )</code></div><div class='ds'><p>Binds the given evaluable to the named slot.</p></div></div><div id='d_Lt' class='de'><h1>Class <span class='n'>IProgram</span></h1><div class='re'></div><div class='ds'><p>The program is the core context and entry point for almost every operation offered by LambdaFactory.</p></div></div><div id='d_hu' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IAssignable at 0x7bf3f0&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_iu' class='de'><h1>Method <span class='n'>getAbsoluteName</span></h1><div class='re'><code>getAbsoluteName( self )</code></div><div class='ds'><p>Returns the absolute name for this element</p></div></div><div id='d_ju' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><p>Returns the local name for this referencable element</p></div></div><div id='d_gu' class='de'><h1>Class <span class='n'>IReferencable</span></h1><div class='re'></div><div class='ds'><p>A referencable is an element that can be referenced either by id (it is unique and stable), or by a name (which is also not supposed to change).</p><p>Types are good examples of referencables: they have an <em>absolute name</em> (like <code>Data.List</code>), but can also be bound to slots within contexts which give them "local names" (like <code>List := Data.List</code>)</p></div></div><div id='d_lu' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IValue at 0x7bf510&gt;, &lt;class lambdafactory.interfaces.IReferencable at 0x7bf420&gt;)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_mu' class='de'><h1>Method <span class='n'>getReferenceName</span></h1><div class='re'><code>getReferenceName( self )</code></div><div class='ds'><p>Returns the name which this reference contains. The name is used by the resolution operation to actually resolve a value from the name.</p></div></div><div id='d_nu' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><p>Performs a deep clone of this element. Any mutation to the original won't change the copy.</p></div></div><div id='d_ou' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><p>Detaches the element from its parent (in case it was already attached). This should return this element, and set the parent to None.</p></div></div><div id='d_pu' class='de'><h1>Method <span class='n'>getAbsoluteName</span></h1><div class='re'><code>getAbsoluteName( self )</code></div><div class='ds'><p>Returns the absolute name for this element</p></div></div><div id='d_qu' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_ru' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_su' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_tu' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><p>Returns the local name for this referencable element</p></div></div><div id='d_uu' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns this element parent</p></div></div><div id='d_vu' class='de'><h1>Method <span class='n'>getResultAbstractType</span></h1><div class='re'><code>getResultAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type of the result of the evaluation of this evaluable</p></div></div><div id='d_wu' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><p>Tells if this element has a parent or not</p></div></div><div id='d_xu' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_yu' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_zu' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><p>Sets this element parent</p></div></div><div id='d_Au' class='de'><h1>Method <span class='n'>setResultAbstractType</span></h1><div class='re'><code>setResultAbstractType( self, abstractType )</code></div><div class='ds'><p>Sets the abstract type for this operation result. This is usually invoked in the typing phase.</p></div></div><div id='d_ku' class='de'><h1>Class <span class='n'>IReference</span></h1><div class='re'></div><div class='ds'><p>A reference is a name that can be converted into a value using a resolution operation (for instance).</p></div></div><div id='d_Cu' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IOperation at 0x7bfae0&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Du' class='de'><h1>Method <span class='n'>getCondition</span></h1><div class='re'><code>getCondition( self )</code></div><div class='ds'><p>Gets the expression that is the condition for this repetition.</p></div></div><div id='d_Eu' class='de'><h1>Method <span class='n'>getProcess</span></h1><div class='re'><code>getProcess( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Fu' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><p>Adds an argument to this operation. This should do checking of arguments (by expected internal type and number).</p></div></div><div id='d_Gu' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><p>Performs a deep clone of this element. Any mutation to the original won't change the copy.</p></div></div><div id='d_Hu' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><p>Detaches the element from its parent (in case it was already attached). This should return this element, and set the parent to None.</p></div></div><div id='d_Iu' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_Ju' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_Ku' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_Lu' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><p>Returns the ith arguments to this operation.</p></div></div><div id='d_Mu' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><p>Returns the arguments to this operation.</p></div></div><div id='d_Nu' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><p>Returns the <em>internal types</em> for this operations arguments. This is typically the list of interfaces or @protocols that the arguments must comply to.</p></div></div><div id='d_Ou' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns this element parent</p></div></div><div id='d_Pu' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><p>Tells if this element has a parent or not</p></div></div><div id='d_Qu' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_Ru' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_Su' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><p>Sets the given argument of this operation, by argument index.</p></div></div><div id='d_Tu' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><p>Sets this element parent</p></div></div><div id='d_Uu' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.IEvaluable at 0x7bf450&gt;, &lt;class lambdafactory.interfaces.IProcess at 0x7bf900&gt;]</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='d_Bu' class='de'><h1>Class <span class='n'>IRepetition</span></h1><div class='re'></div><div class='ds'><p>A repetition is the repetitive execution of a process according to a predicate expression which can be modified by the process.</p></div></div><div id='d_Wu' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IOperation at 0x7bfae0&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Xu' class='de'><h1>Method <span class='n'>getContext</span></h1><div class='re'><code>getContext( self )</code></div><div class='ds'><p>Returns the (optional) context in which the resolution should occur.</p></div></div><div id='d_Yu' class='de'><h1>Method <span class='n'>getReference</span></h1><div class='re'><code>getReference( self )</code></div><div class='ds'><p>Returns the reference to be resolved.</p></div></div><div id='d_Zu' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><p>Adds an argument to this operation. This should do checking of arguments (by expected internal type and number).</p></div></div><div id='d_av' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><p>Performs a deep clone of this element. Any mutation to the original won't change the copy.</p></div></div><div id='d_bv' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><p>Detaches the element from its parent (in case it was already attached). This should return this element, and set the parent to None.</p></div></div><div id='d_cv' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_dv' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_ev' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_fv' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><p>Returns the ith arguments to this operation.</p></div></div><div id='d_gv' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><p>Returns the arguments to this operation.</p></div></div><div id='d_hv' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><p>Returns the <em>internal types</em> for this operations arguments. This is typically the list of interfaces or @protocols that the arguments must comply to.</p></div></div><div id='d_iv' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns this element parent</p></div></div><div id='d_jv' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><p>Tells if this element has a parent or not</p></div></div><div id='d_kv' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_lv' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_mv' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><p>Sets the given argument of this operation, by argument index.</p></div></div><div id='d_nv' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><p>Sets this element parent</p></div></div><div id='d_ov' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.IReferencable at 0x7bf420&gt;, &lt;class lambdafactory.interfaces.IEvaluable at 0x7bf450&gt;]</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='d_Vu' class='de'><h1>Class <span class='n'>IResolution</span></h1><div class='re'></div><div class='ds'><p>A resolution resolves a reference into a value.</p></div></div><div id='d_qv' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IOperation at 0x7bfae0&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_rv' class='de'><h1>Method <span class='n'>addRule</span></h1><div class='re'><code>addRule( self, evaluable )</code></div><div class='ds'><p>Adds a rule to this operation.</p></div></div><div id='d_sv' class='de'><h1>Method <span class='n'>getRules</span></h1><div class='re'><code>getRules( self )</code></div><div class='ds'><p>Returns the ordered set of rule for this selection.</p></div></div><div id='d_tv' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><p>Adds an argument to this operation. This should do checking of arguments (by expected internal type and number).</p></div></div><div id='d_uv' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><p>Performs a deep clone of this element. Any mutation to the original won't change the copy.</p></div></div><div id='d_vv' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><p>Detaches the element from its parent (in case it was already attached). This should return this element, and set the parent to None.</p></div></div><div id='d_wv' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_xv' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_yv' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_zv' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><p>Returns the ith arguments to this operation.</p></div></div><div id='d_Av' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><p>Returns the arguments to this operation.</p></div></div><div id='d_Bv' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><p>Returns the <em>internal types</em> for this operations arguments. This is typically the list of interfaces or @protocols that the arguments must comply to.</p></div></div><div id='d_Cv' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns this element parent</p></div></div><div id='d_Dv' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><p>Tells if this element has a parent or not</p></div></div><div id='d_Ev' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_Fv' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_Gv' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><p>Sets the given argument of this operation, by argument index.</p></div></div><div id='d_Hv' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><p>Sets this element parent</p></div></div><div id='d_Iv' class='de'><h1>list</h1><div class='re'><code>[[&lt;class lambdafactory.interfaces.IMatchOperation at 0x7bfde0&gt;]]</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='d_pv' class='de'><h1>Class <span class='n'>ISelection</span></h1><div class='re'></div><div class='ds'><p>Selections are the abstract objects behind <code>if</code>, <code>select</code> or pattern-matching operations. Each selection has match operations as arguments, which bind a subprocess to a predicate expression.</p></div></div><div id='d_Kv' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.ISubsetOperation at 0x7bfd50&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Lv' class='de'><h1>Method <span class='n'>getSliceEnd</span></h1><div class='re'><code>getSliceEnd( self )</code></div><div class='ds'><p>Returns evaluable that will return the slice end</p></div></div><div id='d_Mv' class='de'><h1>Method <span class='n'>getSliceStart</span></h1><div class='re'><code>getSliceStart( self )</code></div><div class='ds'><p>Returns evaluable that will return the slice start</p></div></div><div id='d_Nv' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><p>Adds an argument to this operation. This should do checking of arguments (by expected internal type and number).</p></div></div><div id='d_Ov' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><p>Performs a deep clone of this element. Any mutation to the original won't change the copy.</p></div></div><div id='d_Pv' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><p>Detaches the element from its parent (in case it was already attached). This should return this element, and set the parent to None.</p></div></div><div id='d_Qv' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_Rv' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_Sv' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_Tv' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><p>Returns the ith arguments to this operation.</p></div></div><div id='d_Uv' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><p>Returns the arguments to this operation.</p></div></div><div id='d_Vv' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><p>Returns the <em>internal types</em> for this operations arguments. This is typically the list of interfaces or @protocols that the arguments must comply to.</p></div></div><div id='d_Wv' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns this element parent</p></div></div><div id='d_Xv' class='de'><h1>Method <span class='n'>getTarget</span></h1><div class='re'><code>getTarget( self )</code></div><div class='ds'><p>Returns the operation target.</p></div></div><div id='d_Yv' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><p>Tells if this element has a parent or not</p></div></div><div id='d_Zv' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_aw' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_bw' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><p>Sets the given argument of this operation, by argument index.</p></div></div><div id='d_cw' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><p>Sets this element parent</p></div></div><div id='d_dw' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.IEvaluable at 0x7bf450&gt;, &lt;class lambdafactory.interfaces.IEvaluable at 0x7bf450&gt;, &lt;class lambdafactory.interfaces.IEvaluable at 0x7bf450&gt;]</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='d_Jv' class='de'><h1>Class <span class='n'>ISliceOperation</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_fw' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IReferencable at 0x7bf420&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_gw' class='de'><h1>Method <span class='n'>getTypeDescription</span></h1><div class='re'><code>getTypeDescription( self )</code></div><div class='ds'><p>Returns type information (constraints) that are associated to this argument.</p></div></div><div id='d_hw' class='de'><h1>Method <span class='n'>getAbsoluteName</span></h1><div class='re'><code>getAbsoluteName( self )</code></div><div class='ds'><p>Returns the absolute name for this element</p></div></div><div id='d_iw' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><p>Returns the local name for this referencable element</p></div></div><div id='d_ew' class='de'><h1>Class <span class='n'>ISlot</span></h1><div class='re'></div><div class='ds'><p>An argument is a reference with additional type information.</p></div></div><div id='d_kw' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.ILiteral at 0x7bf540&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_lw' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><p>Performs a deep clone of this element. Any mutation to the original won't change the copy.</p></div></div><div id='d_mw' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><p>Detaches the element from its parent (in case it was already attached). This should return this element, and set the parent to None.</p></div></div><div id='d_nw' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_ow' class='de'><h1>Method <span class='n'>getActualValue</span></h1><div class='re'><code>getActualValue( self )</code></div><div class='ds'><p>Returns the (implementation language) value for this literal</p></div></div><div id='d_pw' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_qw' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_rw' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns this element parent</p></div></div><div id='d_sw' class='de'><h1>Method <span class='n'>getResultAbstractType</span></h1><div class='re'><code>getResultAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type of the result of the evaluation of this evaluable</p></div></div><div id='d_tw' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><p>Tells if this element has a parent or not</p></div></div><div id='d_uw' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_vw' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_ww' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><p>Sets this element parent</p></div></div><div id='d_xw' class='de'><h1>Method <span class='n'>setResultAbstractType</span></h1><div class='re'><code>setResultAbstractType( self, abstractType )</code></div><div class='ds'><p>Sets the abstract type for this operation result. This is usually invoked in the typing phase.</p></div></div><div id='d_jw' class='de'><h1>Class <span class='n'>IString</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_zw' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IOperation at 0x7bfae0&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Aw' class='de'><h1>Method <span class='n'>getTarget</span></h1><div class='re'><code>getTarget( self )</code></div><div class='ds'><p>Returns the operation target.</p></div></div><div id='d_Bw' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><p>Adds an argument to this operation. This should do checking of arguments (by expected internal type and number).</p></div></div><div id='d_Cw' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><p>Performs a deep clone of this element. Any mutation to the original won't change the copy.</p></div></div><div id='d_Dw' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><p>Detaches the element from its parent (in case it was already attached). This should return this element, and set the parent to None.</p></div></div><div id='d_Ew' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_Fw' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_Gw' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_Hw' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><p>Returns the ith arguments to this operation.</p></div></div><div id='d_Iw' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><p>Returns the arguments to this operation.</p></div></div><div id='d_Jw' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><p>Returns the <em>internal types</em> for this operations arguments. This is typically the list of interfaces or @protocols that the arguments must comply to.</p></div></div><div id='d_Kw' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns this element parent</p></div></div><div id='d_Lw' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><p>Tells if this element has a parent or not</p></div></div><div id='d_Mw' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_Nw' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_Ow' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><p>Sets the given argument of this operation, by argument index.</p></div></div><div id='d_Pw' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><p>Sets this element parent</p></div></div><div id='d_yw' class='de'><h1>Class <span class='n'>ISubsetOperation</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Rw' class='de'><h1>Method <span class='n'>getColumn</span></h1><div class='re'><code>getColumn( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Sw' class='de'><h1>Method <span class='n'>getLine</span></h1><div class='re'><code>getLine( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Tw' class='de'><h1>Method <span class='n'>getOffset</span></h1><div class='re'><code>getOffset( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Qw' class='de'><h1>Class <span class='n'>ISyntactic</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Vw' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IOperation at 0x7bfae0&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Ww' class='de'><h1>Method <span class='n'>getReturnedEvaluable</span></h1><div class='re'><code>getReturnedEvaluable( self )</code></div><div class='ds'><p>Returns the termination return evaluable.</p></div></div><div id='d_Xw' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><p>Adds an argument to this operation. This should do checking of arguments (by expected internal type and number).</p></div></div><div id='d_Yw' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><p>Performs a deep clone of this element. Any mutation to the original won't change the copy.</p></div></div><div id='d_Zw' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><p>Detaches the element from its parent (in case it was already attached). This should return this element, and set the parent to None.</p></div></div><div id='d_ax' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_bx' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_cx' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_dx' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><p>Returns the ith arguments to this operation.</p></div></div><div id='d_ex' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><p>Returns the arguments to this operation.</p></div></div><div id='d_fx' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><p>Returns the <em>internal types</em> for this operations arguments. This is typically the list of interfaces or @protocols that the arguments must comply to.</p></div></div><div id='d_gx' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns this element parent</p></div></div><div id='d_hx' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><p>Tells if this element has a parent or not</p></div></div><div id='d_ix' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_jx' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_kx' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><p>Sets the given argument of this operation, by argument index.</p></div></div><div id='d_lx' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><p>Sets this element parent</p></div></div><div id='d_mx' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.IEvaluable at 0x7bf450&gt;]</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='d_Uw' class='de'><h1>Class <span class='n'>ITermination</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_ox' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IElement at 0x7bf3c0&gt;, &lt;class lambdafactory.interfaces.IEvaluable at 0x7bf450&gt;)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_px' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><p>Performs a deep clone of this element. Any mutation to the original won't change the copy.</p></div></div><div id='d_qx' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><p>Detaches the element from its parent (in case it was already attached). This should return this element, and set the parent to None.</p></div></div><div id='d_rx' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_sx' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_tx' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_ux' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns this element parent</p></div></div><div id='d_vx' class='de'><h1>Method <span class='n'>getResultAbstractType</span></h1><div class='re'><code>getResultAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type of the result of the evaluation of this evaluable</p></div></div><div id='d_wx' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><p>Tells if this element has a parent or not</p></div></div><div id='d_xx' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_yx' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_zx' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><p>Sets this element parent</p></div></div><div id='d_Ax' class='de'><h1>Method <span class='n'>setResultAbstractType</span></h1><div class='re'><code>setResultAbstractType( self, abstractType )</code></div><div class='ds'><p>Sets the abstract type for this operation result. This is usually invoked in the typing phase.</p></div></div><div id='d_nx' class='de'><h1>Class <span class='n'>IValue</span></h1><div class='re'></div><div class='ds'><p>A value represents an atomic element of the language, like a number, a string, or a name (that can resolved by the language, acts as key for data structures, etc.).</p></div></div><div id='d_a' class='de'><h1>Module <span class='n'>lambdafactory.interfaces</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Dx' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self, module=<module 'lambdafactory.model' from '/Users/sebastien/Local/Python/lambdafactory/model.pyc'> )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Ex' class='de'><h1>Method <span class='n'>_arg</span></h1><div class='re'><code>_arg( self, name, typeinfo=None, optional=False )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Fx' class='de'><h1>Method <span class='n'>_attr</span></h1><div class='re'><code>_attr( self, name, typeinfo=None, value=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Gx' class='de'><h1>Method <span class='n'>_classattr</span></h1><div class='re'><code>_classattr( self, name, typeinfo=None, value=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Hx' class='de'><h1>Method <span class='n'>_dict</span></h1><div class='re'><code>_dict( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Ix' class='de'><h1>Method <span class='n'>_getImplementation</span></h1><div class='re'><code>_getImplementation( self, name )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Jx' class='de'><h1>Method <span class='n'>_list</span></h1><div class='re'><code>_list( self, *args )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Kx' class='de'><h1>Method <span class='n'>_moduleattr</span></h1><div class='re'><code>_moduleattr( self, name, typeinfo=None, value=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Lx' class='de'><h1>Method <span class='n'>_number</span></h1><div class='re'><code>_number( self, number )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Mx' class='de'><h1>Method <span class='n'>_op</span></h1><div class='re'><code>_op( self, symbol, priority=0 )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Nx' class='de'><h1>Method <span class='n'>_param</span></h1><div class='re'><code>_param( self, name=None, value=None, asList=False, asMap=False )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Ox' class='de'><h1>Method <span class='n'>_ref</span></h1><div class='re'><code>_ref( self, name )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Px' class='de'><h1>Method <span class='n'>_slot</span></h1><div class='re'><code>_slot( self, name, typeinfo=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Qx' class='de'><h1>Method <span class='n'>_string</span></h1><div class='re'><code>_string( self, value )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Rx' class='de'><h1>Method <span class='n'>access</span></h1><div class='re'><code>access( self, target, _index )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Sx' class='de'><h1>Method <span class='n'>allocate</span></h1><div class='re'><code>allocate( self, slot, value=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Tx' class='de'><h1>Method <span class='n'>annotation</span></h1><div class='re'><code>annotation( self, name, content )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Ux' class='de'><h1>Method <span class='n'>assign</span></h1><div class='re'><code>assign( self, name, evaluable )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Vx' class='de'><h1>Method <span class='n'>breaks</span></h1><div class='re'><code>breaks( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Wx' class='de'><h1>Method <span class='n'>comment</span></h1><div class='re'><code>comment( self, content )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Xx' class='de'><h1>Method <span class='n'>compute</span></h1><div class='re'><code>compute( self, operatorName, leftOperand, rightOperand=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Yx' class='de'><h1>Method <span class='n'>createBlock</span></h1><div class='re'><code>createBlock( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Zx' class='de'><h1>Method <span class='n'>createClass</span></h1><div class='re'><code>createClass( self, name, inherited=() )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_ay' class='de'><h1>Method <span class='n'>createClassMethod</span></h1><div class='re'><code>createClassMethod( self, name, arguments=() )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_by' class='de'><h1>Method <span class='n'>createClosure</span></h1><div class='re'><code>createClosure( self, arguments )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_cy' class='de'><h1>Method <span class='n'>createConstructor</span></h1><div class='re'><code>createConstructor( self, arguments=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_dy' class='de'><h1>Method <span class='n'>createDataFlow</span></h1><div class='re'><code>createDataFlow( self, element, parent=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_ey' class='de'><h1>Method <span class='n'>createDataFlowSlot</span></h1><div class='re'><code>createDataFlowSlot( self, name, value, origin, slotType )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_fy' class='de'><h1>Method <span class='n'>createDestructor</span></h1><div class='re'><code>createDestructor( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_gy' class='de'><h1>Method <span class='n'>createFunction</span></h1><div class='re'><code>createFunction( self, name, arguments )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_hy' class='de'><h1>Method <span class='n'>createInterface</span></h1><div class='re'><code>createInterface( self, name, inherited=() )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_iy' class='de'><h1>Method <span class='n'>createMethod</span></h1><div class='re'><code>createMethod( self, name, arguments=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_jy' class='de'><h1>Method <span class='n'>createModule</span></h1><div class='re'><code>createModule( self, name )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_ky' class='de'><h1>Method <span class='n'>createProgram</span></h1><div class='re'><code>createProgram( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_ly' class='de'><h1>Method <span class='n'>doc</span></h1><div class='re'><code>doc( self, content )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_my' class='de'><h1>Method <span class='n'>embed</span></h1><div class='re'><code>embed( self, lang, code )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_ny' class='de'><h1>Method <span class='n'>embedTemplate</span></h1><div class='re'><code>embedTemplate( self, lang, code )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_oy' class='de'><h1>Method <span class='n'>enumerate</span></h1><div class='re'><code>enumerate( self, start, end, step=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_py' class='de'><h1>Method <span class='n'>evaluate</span></h1><div class='re'><code>evaluate( self, evaluable )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_qy' class='de'><h1>Method <span class='n'>exception</span></h1><div class='re'><code>exception( self, exception )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_ry' class='de'><h1>Method <span class='n'>importModule</span></h1><div class='re'><code>importModule( self, name, alias )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_sy' class='de'><h1>Method <span class='n'>importModules</span></h1><div class='re'><code>importModules( self, names )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_ty' class='de'><h1>Method <span class='n'>importSymbol</span></h1><div class='re'><code>importSymbol( self, name, origin, alias )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_uy' class='de'><h1>Method <span class='n'>importSymbols</span></h1><div class='re'><code>importSymbols( self, names, origin )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_vy' class='de'><h1>Method <span class='n'>instanciate</span></h1><div class='re'><code>instanciate( self, evaluable, *arguments )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_wy' class='de'><h1>Method <span class='n'>intercept</span></h1><div class='re'><code>intercept( self, tryProcess, catchProcess=None, finallyProcess=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_xy' class='de'><h1>Method <span class='n'>invoke</span></h1><div class='re'><code>invoke( self, evaluable, *arguments )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_yy' class='de'><h1>Method <span class='n'>iterate</span></h1><div class='re'><code>iterate( self, evaluable, process )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_zy' class='de'><h1>Method <span class='n'>matchExpression</span></h1><div class='re'><code>matchExpression( self, evaluable, expression )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Ay' class='de'><h1>Method <span class='n'>matchProcess</span></h1><div class='re'><code>matchProcess( self, evaluable, process )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_By' class='de'><h1>Method <span class='n'>repeat</span></h1><div class='re'><code>repeat( self, condition, process )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Cy' class='de'><h1>Method <span class='n'>resolve</span></h1><div class='re'><code>resolve( self, reference, context=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Dy' class='de'><h1>Method <span class='n'>returns</span></h1><div class='re'><code>returns( self, evaluable )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Ey' class='de'><h1>Method <span class='n'>select</span></h1><div class='re'><code>select( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Fy' class='de'><h1>Method <span class='n'>slice</span></h1><div class='re'><code>slice( self, target, _start, _end=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Cx' class='de'><h1>Class <span class='n'>Factory</span></h1><div class='re'></div><div class='ds'><p>This class takes a module and look for classes with the same name as the <code>createXXX</code> methods and instanciates them.</p><p>For instance, if you define a module with classes like <code>Value</code>, <code>Literal</code>, <code>Invocation</code>, <code>Function</code>, etc. you just have to give this module to the factory constructor and it will be used to generate the given element.</p></div></div><div id='d_Hy' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self, someClass, expectedClass, argument )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Iy' class='de'><h1>wrapper_descriptor</h1><div class='re'></div><div class='ds'><div class="section" level="1"><h1 class="heading"><span class="number"><span class="level0">1<span class="lastDot dot">.</span></span></span><span class='term'>getitem</span>_(y) &lt;==&gt; x[y]</h1><div class="level1"></div></div></div></div><div id='d_Jy' class='de'><h1>wrapper_descriptor</h1><div class='re'></div><div class='ds'><div class="section" level="1"><h1 class="heading"><span class="number"><span class="level0">1<span class="lastDot dot">.</span></span></span><span class='term'>repr</span>_() &lt;==&gt; repr(x)</h1><div class="level1"></div></div></div></div><div id='d_Ky' class='de'><h1>wrapper_descriptor</h1><div class='re'></div><div class='ds'><div class="section" level="1"><h1 class="heading"><span class="number"><span class="level0">1<span class="lastDot dot">.</span></span></span><span class='term'>str</span>_() &lt;==&gt; str(x)</h1><div class="level1"></div></div></div></div><div id='d_Ly' class='de'><h1>getset_descriptor</h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_My' class='de'><h1>member_descriptor</h1><div class='re'></div><div class='ds'><p>exception message</p></div></div><div id='d_Gy' class='de'><h1>Class <span class='n'>ModelBadArgument</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Oy' class='de'><h1>wrapper_descriptor</h1><div class='re'></div><div class='ds'><div class="section" level="1"><h1 class="heading"><span class="number"><span class="level0">1<span class="lastDot dot">.</span></span></span><span class='term'>init</span><span class='term'>(...) initializes x; see x.</span><span class='term'>class</span><span class='term'>.</span><span class='term'>doc</span>_ for signature</h1><div class="level1"></div></div></div></div><div id='d_Ny' class='de'><h1>Class <span class='n'>ModelException</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Py' class='de'><h1>Function <span class='n'>assertImplements</span></h1><div class='re'><code>assertImplements( v, i )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Bx' class='de'><h1>Module <span class='n'>lambdafactory.modelbase</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Sy' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.passes.Pass at 0x1228030&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Ty' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Uy' class='de'><h1>Method <span class='n'>_format</span></h1><div class='re'><code>_format( self, *values )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Vy' class='de'><h1>Method <span class='n'>_unique</span></h1><div class='re'><code>_unique( self, name )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Wy' class='de'><h1>Method <span class='n'>onProgram</span></h1><div class='re'><code>onProgram( self, element )</code></div><div class='ds'><p>Writes a Program element</p></div></div><div id='d_Xy' class='de'><h1>Method <span class='n'>run</span></h1><div class='re'><code>run( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Yy' class='de'><h1>Method <span class='n'>write</span></h1><div class='re'><code>write( self, element )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Zy' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.IProgram at 0x7bf8d0&gt;, &lt;class lambdafactory.interfaces.IClass at 0x7bf810&gt;, &lt;class lambdafactory.interfaces.IModule at 0x7bf8a0&gt;, &lt;class lambdafactory.interfaces.IDestructor at 0x7bfa50&gt;, &lt;class lambdafactory.interfaces.IConstructor at 0x7bfa20&gt;, &lt;class lambdafactory.interfaces.IClassMethod at 0x7bfab0&gt;, &lt;class lambdafactory.interfaces.IMethod at 0x7bf9f0&gt;, &lt;class lambdafactory.interfaces.IFunction at 0x7bf9c0&gt;, &lt;class lambdafactory.interfaces.IClosure at 0x7bf990&gt;, &lt;class lambdafactory.interfaces.IBlock at 0x7bf960&gt;, &lt;class lambdafactory.interfaces.IModuleAttribute at 0x7bf780&gt;, &lt;class lambdafactory.interfaces.IClassAttribute at 0x7bf7b0&gt;, &lt;class lambdafactory.interfaces.IAttribute at 0x7bf750&gt;, &lt;class lambdafactory.interfaces.IArgument at 0x7bf6f0&gt;, &lt;class lambdafactory.interfaces.IParameter at 0x7bf720&gt;, &lt;class lambdafactory.interfaces.IOperator at 0x7bf690&gt;, &lt;class lambdafactory.interfaces.IReference at 0x7bf630&gt;, &lt;class lambdafactory.interfaces.INumber at 0x7bf570&gt;, &lt;class lambdafactory.interfaces.IString at 0x7bf5a0&gt;, &lt;class lambdafactory.interfaces.IList at 0x7bf5d0&gt;, &lt;class lambdafactory.interfaces.IDict at 0x7bf600&gt;, &lt;class lambdafactory.interfaces.IEnumeration at 0x7bfed0&gt;, &lt;class lambdafactory.interfaces.IAllocation at 0x7bfc60&gt;, &lt;class lambdafactory.interfaces.IAssignation at 0x7bfc30&gt;, &lt;class lambdafactory.interfaces.IComputation at 0x7bfcc0&gt;, &lt;class lambdafactory.interfaces.IInvocation at 0x7bfcf0&gt;, &lt;class lambdafactory.interfaces.IInstanciation at 0x7bfd20&gt;, &lt;class lambdafactory.interfaces.IResolution at 0x7bfc90&gt;, &lt;class lambdafactory.interfaces.ISelection at 0x7bfe70&gt;, &lt;class lambdafactory.interfaces.IRepetition at 0x7bff00&gt;, &lt;class lambdafactory.interfaces.IIteration at 0x7bfea0&gt;, &lt;class lambdafactory.interfaces.IAccessOperation at 0x7bfd80&gt;, &lt;class lambdafactory.interfaces.ISliceOperation at 0x7bfdb0&gt;, &lt;class lambdafactory.interfaces.IEvaluation at 0x7bfc00&gt;, &lt;class lambdafactory.interfaces.ITermination at 0x7bff30&gt;, &lt;class lambdafactory.interfaces.IBreaking at 0x7bff90&gt;, &lt;class lambdafactory.interfaces.IExcept at 0x7bffc0&gt;, &lt;class lambdafactory.interfaces.IInterception at 0x1174030&gt;, &lt;class lambdafactory.interfaces.IImportSymbolOperation at 0x7bfb40&gt;, &lt;class lambdafactory.interfaces.IImportSymbolsOperation at 0x7bfb70&gt;, &lt;class lambdafactory.interfaces.IImportModuleOperation at 0x7bfba0&gt;, &lt;class lambdafactory.interfaces.IImportModulesOperation at 0x7bfbd0&gt;, &lt;class lambdafactory.interfaces.IEmbed at 0x1174060&gt;]</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='d_az' class='de'><h1>str</h1><div class='re'><code>''</code></div><div class='ds'><p>str(object) -&gt; string</p><p>Return a nice string representation of the object. If the argument is a string, the return value is the same object.</p></div></div><div id='d_Ry' class='de'><h1>Class <span class='n'>AbstractWriter</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_bz' class='de'><h1>Function <span class='n'>_flatten</span></h1><div class='re'><code>_flatten( value, res )</code></div><div class='ds'><p>Flatten helper operation. See <code>flatten</code></p></div></div><div id='d_cz' class='de'><h1>Function <span class='n'>_format</span></h1><div class='re'><code>_format( value, level=None )</code></div><div class='ds'><p>Format helper operation. See @format</p></div></div><div id='d_dz' class='de'><h1>Function <span class='n'>flatten</span></h1><div class='re'><code>flatten( *lists )</code></div><div class='ds'><p>Flattens the given lists in a single list</p></div></div><div id='d_ez' class='de'><h1>Function <span class='n'>format</span></h1><div class='re'><code>format( *values )</code></div><div class='ds'><p>Formats a combination of string ang tuples. Strings are joined by newlines, and the content of the inner tuples gets indented</p></div></div><div id='d_fz' class='de'><h1>Function <span class='n'>notEmpty</span></h1><div class='re'><code>notEmpty( p )</code></div><div class='ds'><p>Returns None if the given parameter is empty.</p></div></div><div id='d_gz' class='de'><h1>str</h1><div class='re'><code>'\t'</code></div><div class='ds'><p>str(object) -&gt; string</p><p>Return a nice string representation of the object. If the argument is a string, the return value is the same object.</p></div></div><div id='d_hz' class='de'><h1>str</h1><div class='re'><code>'8&lt; ---[%s]---'</code></div><div class='ds'><p>str(object) -&gt; string</p><p>Return a nice string representation of the object. If the argument is a string, the return value is the same object.</p></div></div><div id='d_Qy' class='de'><h1>Module <span class='n'>lambdafactory.modelwriter</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_kz' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.modeltypes.TypeCollection at 0x120e0f0&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_lz' class='de'><h1>Method <span class='n'>getType</span></h1><div class='re'><code>getType( self, name )</code></div><div class='ds'><p>Returns the type with the given name, or None if it does not exist.</p></div></div><div id='d_jz' class='de'><h1>Class <span class='n'>Behaviour</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_nz' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.modeltypes.TypeCollection at 0x120e0f0&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_oz' class='de'><h1>Method <span class='n'>getType</span></h1><div class='re'><code>getType( self, name )</code></div><div class='ds'><p>Returns the type with the given name, or None if it does not exist.</p></div></div><div id='d_mz' class='de'><h1>Class <span class='n'>Data</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_qz' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.modeltypes.TypeCollection at 0x120e0f0&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_rz' class='de'><h1>Method <span class='n'>getType</span></h1><div class='re'><code>getType( self, name )</code></div><div class='ds'><p>Returns the type with the given name, or None if it does not exist.</p></div></div><div id='d_pz' class='de'><h1>Class <span class='n'>Operations</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_tz' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.modeltypes.TypeCollection at 0x120e0f0&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_uz' class='de'><h1>Method <span class='n'>getType</span></h1><div class='re'><code>getType( self, name )</code></div><div class='ds'><p>Returns the type with the given name, or None if it does not exist.</p></div></div><div id='d_sz' class='de'><h1>Class <span class='n'>Runtime</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_wz' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.modeltypes.TypeCollection at 0x120e0f0&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_xz' class='de'><h1>Method <span class='n'>getType</span></h1><div class='re'><code>getType( self, name )</code></div><div class='ds'><p>Returns the type with the given name, or None if it does not exist.</p></div></div><div id='d_vz' class='de'><h1>Class <span class='n'>Structure</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_zz' class='de'><h1>Method <span class='n'>getType</span></h1><div class='re'><code>getType( self, name )</code></div><div class='ds'><p>Returns the type with the given name, or None if it does not exist.</p></div></div><div id='d_yz' class='de'><h1>Class <span class='n'>TypeCollection</span></h1><div class='re'></div><div class='ds'><p>A type collection is a class that contains type definitions which can be easily retrieved using the @getType method.</p></div></div><div id='d_Az' class='de'><h1>Function <span class='n'>typeForValue</span></h1><div class='re'><code>typeForValue( value, noneIs=<lambdafactory.typecast.Symbolic instance at 0x11f83c8> )</code></div><div class='ds'><p>Associates a type with the given value. This basically creates a typecast instance/subtype, using the types defined in this module, using the given value which is a program element (implements interfaces defined in LF <code>interfaces</code> module).</p></div></div><div id='d_Bz' class='de'><h1>NoneType</h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Cz' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.modeltypes.Data at 0x120e6c0&gt;, &lt;class lambdafactory.modeltypes.Operations at 0x120eb10&gt;, &lt;class lambdafactory.modeltypes.Structure at 0x120eb40&gt;, &lt;class lambdafactory.modeltypes.Behaviour at 0x120eb70&gt;, &lt;class lambdafactory.modeltypes.Runtime at 0x120eba0&gt;)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_iz' class='de'><h1>Module <span class='n'>lambdafactory.modeltypes</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Fz' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.typecast.Sequence at 0x120e9f0&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Gz' class='de'><h1>Method <span class='n'>__call__</span></h1><div class='re'><code>__call__( self )</code></div><div class='ds'><p>A type instance can be used as a class to construct a new type, which will be cloned from the current type.</p></div></div><div id='d_Hz' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self, *args )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Iz' class='de'><h1>Method <span class='n'>__str__</span></h1><div class='re'><code>__str__( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Jz' class='de'><h1>Method <span class='n'>add</span></h1><div class='re'><code>add( self, theType )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Kz' class='de'><h1>Method <span class='n'>asString</span></h1><div class='re'><code>asString( self, fromTypes=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Lz' class='de'><h1>Method <span class='n'>clone</span></h1><div class='re'><code>clone( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Mz' class='de'><h1>Method <span class='n'>concreteType</span></h1><div class='re'><code>concreteType( self )</code></div><div class='ds'><p>Returns the <span class='term'>concrete type</span> for this abstract type.</p></div></div><div id='d_Nz' class='de'><h1>Method <span class='n'>definedBy</span></h1><div class='re'><code>definedBy( self, definition=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Oz' class='de'><h1>Method <span class='n'>elements</span></h1><div class='re'><code>elements( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Pz' class='de'><h1>Method <span class='n'>extend</span></h1><div class='re'><code>extend( self, othertype )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Qz' class='de'><h1>Method <span class='n'>isLike</span></h1><div class='re'><code>isLike( self, otherType )</code></div><div class='ds'><p>The other type is like this one if the other is a sequence with the same length and that all elements are like the corresponding elements of this sequence.</p></div></div><div id='d_Rz' class='de'><h1>Method <span class='n'>isSameAs</span></h1><div class='re'><code>isSameAs( self, otherType )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Sz' class='de'><h1>Method <span class='n'>isSubtypeOf</span></h1><div class='re'><code>isSubtypeOf( self, otherType )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Tz' class='de'><h1>Method <span class='n'>length</span></h1><div class='re'><code>length( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Uz' class='de'><h1>Method <span class='n'>name</span></h1><div class='re'><code>name( self, name=None )</code></div><div class='ds'><p>Returns/sets the name for this type. By defaults, types are unnamed.</p></div></div><div id='d_Vz' class='de'><h1>Method <span class='n'>result</span></h1><div class='re'><code>result( self )</code></div><div class='ds'><p>Returns the result for this type. This is usually just the type itself, except for processes types.</p></div></div><div id='d_Wz' class='de'><h1>Method <span class='n'>setConcreteType</span></h1><div class='re'><code>setConcreteType( self, value )</code></div><div class='ds'><p>Sets the <span class='term'>concrete type</span> for this abstract type. The concrete type is a value which represents the type. For instance, if this type represents a class, then the concrete type would be the class instance.</p></div></div><div id='d_Xz' class='de'><h1>Method <span class='n'>setName</span></h1><div class='re'><code>setName( self, name )</code></div><div class='ds'><p>Sets the name of this type</p></div></div><div id='d_Yz' class='de'><h1>Method <span class='n'>subtype</span></h1><div class='re'><code>subtype( self, name )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Ez' class='de'><h1>Class <span class='n'>Arguments</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_aA' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.typecast.Type at 0x120e900&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_bA' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self, contentType, name=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_cA' class='de'><h1>Method <span class='n'>asString</span></h1><div class='re'><code>asString( self, fromTypes=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_dA' class='de'><h1>Method <span class='n'>content</span></h1><div class='re'><code>content( self )</code></div><div class='ds'><p>Returns the type for the content of this array.</p></div></div><div id='d_eA' class='de'><h1>Method <span class='n'>isLike</span></h1><div class='re'><code>isLike( self, otherType )</code></div><div class='ds'><p>Othertype must be an Array with a content type that is the same type as the content type.</p></div></div><div id='d_fA' class='de'><h1>Method <span class='n'>isSameAs</span></h1><div class='re'><code>isSameAs( self, otherType )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_gA' class='de'><h1>Method <span class='n'>isSubtypeOf</span></h1><div class='re'><code>isSubtypeOf( self, otherType )</code></div><div class='ds'><p>Othertype must be an Array with a content type that is a subtype of this content type.</p></div></div><div id='d_hA' class='de'><h1>Method <span class='n'>setContentType</span></h1><div class='re'><code>setContentType( self, theType )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_iA' class='de'><h1>Method <span class='n'>__call__</span></h1><div class='re'><code>__call__( self )</code></div><div class='ds'><p>A type instance can be used as a class to construct a new type, which will be cloned from the current type.</p></div></div><div id='d_jA' class='de'><h1>Method <span class='n'>__str__</span></h1><div class='re'><code>__str__( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_kA' class='de'><h1>Method <span class='n'>clone</span></h1><div class='re'><code>clone( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_lA' class='de'><h1>Method <span class='n'>concreteType</span></h1><div class='re'><code>concreteType( self )</code></div><div class='ds'><p>Returns the <span class='term'>concrete type</span> for this abstract type.</p></div></div><div id='d_mA' class='de'><h1>Method <span class='n'>definedBy</span></h1><div class='re'><code>definedBy( self, definition=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_nA' class='de'><h1>Method <span class='n'>name</span></h1><div class='re'><code>name( self, name=None )</code></div><div class='ds'><p>Returns/sets the name for this type. By defaults, types are unnamed.</p></div></div><div id='d_oA' class='de'><h1>Method <span class='n'>result</span></h1><div class='re'><code>result( self )</code></div><div class='ds'><p>Returns the result for this type. This is usually just the type itself, except for processes types.</p></div></div><div id='d_pA' class='de'><h1>Method <span class='n'>setConcreteType</span></h1><div class='re'><code>setConcreteType( self, value )</code></div><div class='ds'><p>Sets the <span class='term'>concrete type</span> for this abstract type. The concrete type is a value which represents the type. For instance, if this type represents a class, then the concrete type would be the class instance.</p></div></div><div id='d_qA' class='de'><h1>Method <span class='n'>setName</span></h1><div class='re'><code>setName( self, name )</code></div><div class='ds'><p>Sets the name of this type</p></div></div><div id='d_rA' class='de'><h1>Method <span class='n'>subtype</span></h1><div class='re'><code>subtype( self, name )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Zz' class='de'><h1>Class <span class='n'>Array</span></h1><div class='re'></div><div class='ds'><p>A sequence is simply an ordered set of types.</p></div></div><div id='d_tA' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.typecast.Type at 0x120e900&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_uA' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self, length, name=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_vA' class='de'><h1>Method <span class='n'>asString</span></h1><div class='re'><code>asString( self, fromType=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_wA' class='de'><h1>Method <span class='n'>clone</span></h1><div class='re'><code>clone( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_xA' class='de'><h1>Method <span class='n'>isLike</span></h1><div class='re'><code>isLike( self, otherType )</code></div><div class='ds'><p>The other type is like this Cell if the other type is a cell of the same length as this one.</p></div></div><div id='d_yA' class='de'><h1>Method <span class='n'>isSameAs</span></h1><div class='re'><code>isSameAs( self, otherType )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_zA' class='de'><h1>Method <span class='n'>isSubtypeOf</span></h1><div class='re'><code>isSubtypeOf( self, otherType )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_AA' class='de'><h1>Method <span class='n'>length</span></h1><div class='re'><code>length( self )</code></div><div class='ds'><p>Returns the length (in bytes) for this cell.</p></div></div><div id='d_BA' class='de'><h1>Method <span class='n'>__call__</span></h1><div class='re'><code>__call__( self )</code></div><div class='ds'><p>A type instance can be used as a class to construct a new type, which will be cloned from the current type.</p></div></div><div id='d_CA' class='de'><h1>Method <span class='n'>__str__</span></h1><div class='re'><code>__str__( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_DA' class='de'><h1>Method <span class='n'>concreteType</span></h1><div class='re'><code>concreteType( self )</code></div><div class='ds'><p>Returns the <span class='term'>concrete type</span> for this abstract type.</p></div></div><div id='d_EA' class='de'><h1>Method <span class='n'>definedBy</span></h1><div class='re'><code>definedBy( self, definition=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_FA' class='de'><h1>Method <span class='n'>name</span></h1><div class='re'><code>name( self, name=None )</code></div><div class='ds'><p>Returns/sets the name for this type. By defaults, types are unnamed.</p></div></div><div id='d_GA' class='de'><h1>Method <span class='n'>result</span></h1><div class='re'><code>result( self )</code></div><div class='ds'><p>Returns the result for this type. This is usually just the type itself, except for processes types.</p></div></div><div id='d_HA' class='de'><h1>Method <span class='n'>setConcreteType</span></h1><div class='re'><code>setConcreteType( self, value )</code></div><div class='ds'><p>Sets the <span class='term'>concrete type</span> for this abstract type. The concrete type is a value which represents the type. For instance, if this type represents a class, then the concrete type would be the class instance.</p></div></div><div id='d_IA' class='de'><h1>Method <span class='n'>setName</span></h1><div class='re'><code>setName( self, name )</code></div><div class='ds'><p>Sets the name of this type</p></div></div><div id='d_JA' class='de'><h1>Method <span class='n'>subtype</span></h1><div class='re'><code>subtype( self, name )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_sA' class='de'><h1>Class <span class='n'>Cell</span></h1><div class='re'></div><div class='ds'><p>A cell type represents a memory unit. It has a size (in bytes) the represents the length in memory.</p></div></div><div id='d_LA' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.typecast.Map at 0x120ea80&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_MA' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self, *args, **kwargs )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_NA' class='de'><h1>Method <span class='n'>clone</span></h1><div class='re'><code>clone( self, clone=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_OA' class='de'><h1>Method <span class='n'>element</span></h1><div class='re'><code>element( self, key )</code></div><div class='ds'><p>Returns the element associated with the given key, or <code>None</code> if it does not exist.</p></div></div><div id='d_PA' class='de'><h1>Method <span class='n'>elements</span></h1><div class='re'><code>elements( self )</code></div><div class='ds'><p>Returns a dict of the elements in this map.</p></div></div><div id='d_QA' class='de'><h1>Method <span class='n'>extends</span></h1><div class='re'><code>extends( self, parent )</code></div><div class='ds'><p>Add a new parent from which this Context inherits.</p></div></div><div id='d_RA' class='de'><h1>Method <span class='n'>fullName</span></h1><div class='re'><code>fullName( self )</code></div><div class='ds'><p>Returns the fully qualified name for this context, by concateniating the chain of parents name with <code>.</code></p></div></div><div id='d_SA' class='de'><h1>Method <span class='n'>parent</span></h1><div class='re'><code>parent( self, parent=None )</code></div><div class='ds'><p>Returns the main parent for this context.</p></div></div><div id='d_TA' class='de'><h1>Method <span class='n'>parents</span></h1><div class='re'><code>parents( self )</code></div><div class='ds'><p>Returns a context parents, as a mutable list.</p></div></div><div id='d_UA' class='de'><h1>Method <span class='n'>__call__</span></h1><div class='re'><code>__call__( self )</code></div><div class='ds'><p>A type instance can be used as a class to construct a new type, which will be cloned from the current type.</p></div></div><div id='d_VA' class='de'><h1>Method <span class='n'>__str__</span></h1><div class='re'><code>__str__( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_WA' class='de'><h1>Method <span class='n'>add</span></h1><div class='re'><code>add( self, name, theType )</code></div><div class='ds'><p>This is a <em>deprecated</em> methods that is simply an alias for <code>Map.set</code>.</p></div></div><div id='d_XA' class='de'><h1>Method <span class='n'>asString</span></h1><div class='re'><code>asString( self, fromTypes=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_YA' class='de'><h1>Method <span class='n'>concreteType</span></h1><div class='re'><code>concreteType( self )</code></div><div class='ds'><p>Returns the <span class='term'>concrete type</span> for this abstract type.</p></div></div><div id='d_ZA' class='de'><h1>Method <span class='n'>definedBy</span></h1><div class='re'><code>definedBy( self, definition=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_aB' class='de'><h1>Method <span class='n'>elementNames</span></h1><div class='re'><code>elementNames( self )</code></div><div class='ds'><p>Returns the list of slots/elements defined in this map.</p></div></div><div id='d_bB' class='de'><h1>Method <span class='n'>get</span></h1><div class='re'><code>get( self, name )</code></div><div class='ds'><p>Returns the type for the slot with the given name.</p></div></div><div id='d_cB' class='de'><h1>Method <span class='n'>isLike</span></h1><div class='re'><code>isLike( self, otherType )</code></div><div class='ds'><p>The other type is like this one if the other is a sequence with the same length and that all elements are like the corresponding elements of this sequence.</p></div></div><div id='d_dB' class='de'><h1>Method <span class='n'>isSameAs</span></h1><div class='re'><code>isSameAs( self, otherType )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_eB' class='de'><h1>Method <span class='n'>isSubtypeOf</span></h1><div class='re'><code>isSubtypeOf( self, otherType )</code></div><div class='ds'><p>The other type is a subtype of this one if for each element of this type, we find that the other type has a subtype.</p></div></div><div id='d_fB' class='de'><h1>Method <span class='n'>name</span></h1><div class='re'><code>name( self, name=None )</code></div><div class='ds'><p>Returns/sets the name for this type. By defaults, types are unnamed.</p></div></div><div id='d_gB' class='de'><h1>Method <span class='n'>result</span></h1><div class='re'><code>result( self )</code></div><div class='ds'><p>Returns the result for this type. This is usually just the type itself, except for processes types.</p></div></div><div id='d_hB' class='de'><h1>Method <span class='n'>set</span></h1><div class='re'><code>set( self, name, theType )</code></div><div class='ds'><p>Sets the slot with the given <code>name</code> to have a value of the given type (<code>theType</code>).</p></div></div><div id='d_iB' class='de'><h1>Method <span class='n'>setConcreteType</span></h1><div class='re'><code>setConcreteType( self, value )</code></div><div class='ds'><p>Sets the <span class='term'>concrete type</span> for this abstract type. The concrete type is a value which represents the type. For instance, if this type represents a class, then the concrete type would be the class instance.</p></div></div><div id='d_jB' class='de'><h1>Method <span class='n'>setName</span></h1><div class='re'><code>setName( self, name )</code></div><div class='ds'><p>Sets the name of this type</p></div></div><div id='d_kB' class='de'><h1>Method <span class='n'>subtype</span></h1><div class='re'><code>subtype( self, name )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_KA' class='de'><h1>Class <span class='n'>Context</span></h1><div class='re'></div><div class='ds'><p>The Context type is the type that will probably be the most used in OO languages. A context can inherit from other contexts, in which case there is an explicit subtyping relationship.</p></div></div><div id='d_mB' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_nB' class='de'><h1>Method <span class='n'>register</span></h1><div class='re'><code>register( self, name, _type )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_oB' class='de'><h1>Method <span class='n'>resolve</span></h1><div class='re'><code>resolve( self, typeName )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_lB' class='de'><h1>Class <span class='n'>Environment</span></h1><div class='re'></div><div class='ds'><p>The environment stores types and names them. This allows to easily retrieve types from a given name.</p></div></div><div id='d_pB' class='de'><h1>Class <span class='n'>InvalidArgument</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_rB' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.typecast.Type at 0x120e900&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_sB' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self, **kwargs )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_tB' class='de'><h1>Method <span class='n'>add</span></h1><div class='re'><code>add( self, name, theType )</code></div><div class='ds'><p>This is a <em>deprecated</em> methods that is simply an alias for <code>Map.set</code>.</p></div></div><div id='d_uB' class='de'><h1>Method <span class='n'>asString</span></h1><div class='re'><code>asString( self, fromTypes=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_vB' class='de'><h1>Method <span class='n'>clone</span></h1><div class='re'><code>clone( self, clone=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_wB' class='de'><h1>Method <span class='n'>element</span></h1><div class='re'><code>element( self, key )</code></div><div class='ds'><p>Returns the element associated to the given key.</p></div></div><div id='d_xB' class='de'><h1>Method <span class='n'>elementNames</span></h1><div class='re'><code>elementNames( self )</code></div><div class='ds'><p>Returns the list of slots/elements defined in this map.</p></div></div><div id='d_yB' class='de'><h1>Method <span class='n'>elements</span></h1><div class='re'><code>elements( self )</code></div><div class='ds'><p>Returns a dict of the elements in this map. Do not modify it.</p></div></div><div id='d_zB' class='de'><h1>Method <span class='n'>get</span></h1><div class='re'><code>get( self, name )</code></div><div class='ds'><p>Returns the type for the slot with the given name.</p></div></div><div id='d_AB' class='de'><h1>Method <span class='n'>isLike</span></h1><div class='re'><code>isLike( self, otherType )</code></div><div class='ds'><p>The other type is like this one if the other is a sequence with the same length and that all elements are like the corresponding elements of this sequence.</p></div></div><div id='d_BB' class='de'><h1>Method <span class='n'>isSameAs</span></h1><div class='re'><code>isSameAs( self, otherType )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_CB' class='de'><h1>Method <span class='n'>isSubtypeOf</span></h1><div class='re'><code>isSubtypeOf( self, otherType )</code></div><div class='ds'><p>The other type is a subtype of this one if for each element of this type, we find that the other type has a subtype.</p></div></div><div id='d_DB' class='de'><h1>Method <span class='n'>set</span></h1><div class='re'><code>set( self, name, theType )</code></div><div class='ds'><p>Sets the slot with the given <code>name</code> to have a value of the given type (<code>theType</code>).</p></div></div><div id='d_EB' class='de'><h1>Method <span class='n'>__call__</span></h1><div class='re'><code>__call__( self )</code></div><div class='ds'><p>A type instance can be used as a class to construct a new type, which will be cloned from the current type.</p></div></div><div id='d_FB' class='de'><h1>Method <span class='n'>__str__</span></h1><div class='re'><code>__str__( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_GB' class='de'><h1>Method <span class='n'>concreteType</span></h1><div class='re'><code>concreteType( self )</code></div><div class='ds'><p>Returns the <span class='term'>concrete type</span> for this abstract type.</p></div></div><div id='d_HB' class='de'><h1>Method <span class='n'>definedBy</span></h1><div class='re'><code>definedBy( self, definition=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_IB' class='de'><h1>Method <span class='n'>name</span></h1><div class='re'><code>name( self, name=None )</code></div><div class='ds'><p>Returns/sets the name for this type. By defaults, types are unnamed.</p></div></div><div id='d_JB' class='de'><h1>Method <span class='n'>result</span></h1><div class='re'><code>result( self )</code></div><div class='ds'><p>Returns the result for this type. This is usually just the type itself, except for processes types.</p></div></div><div id='d_KB' class='de'><h1>Method <span class='n'>setConcreteType</span></h1><div class='re'><code>setConcreteType( self, value )</code></div><div class='ds'><p>Sets the <span class='term'>concrete type</span> for this abstract type. The concrete type is a value which represents the type. For instance, if this type represents a class, then the concrete type would be the class instance.</p></div></div><div id='d_LB' class='de'><h1>Method <span class='n'>setName</span></h1><div class='re'><code>setName( self, name )</code></div><div class='ds'><p>Sets the name of this type</p></div></div><div id='d_MB' class='de'><h1>Method <span class='n'>subtype</span></h1><div class='re'><code>subtype( self, name )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_qB' class='de'><h1>Class <span class='n'>Map</span></h1><div class='re'></div><div class='ds'><p>A map is simply an unordered set of types, mapped to names.</p></div></div><div id='d_OB' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.typecast.Type at 0x120e900&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_PB' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self, *args )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_QB' class='de'><h1>Method <span class='n'>_ensureIntegrity</span></h1><div class='re'><code>_ensureIntegrity( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_RB' class='de'><h1>Method <span class='n'>add</span></h1><div class='re'><code>add( self, theType )</code></div><div class='ds'><p>Adds the given type as an element to this process. The last added type becomes the result if one type was already added, the argument otherwise.</p></div></div><div id='d_SB' class='de'><h1>Method <span class='n'>arguments</span></h1><div class='re'><code>arguments( self, args=None )</code></div><div class='ds'><p>Returns the arguments of this process encapsulated in a sequence if there is more than one argument.</p></div></div><div id='d_TB' class='de'><h1>Method <span class='n'>asString</span></h1><div class='re'><code>asString( self, fromTypes=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_UB' class='de'><h1>Method <span class='n'>clone</span></h1><div class='re'><code>clone( self, clone=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_VB' class='de'><h1>Method <span class='n'>elements</span></h1><div class='re'><code>elements( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_WB' class='de'><h1>Method <span class='n'>isLike</span></h1><div class='re'><code>isLike( self, otherType )</code></div><div class='ds'><p>The other type is like this one if the other is a sequence with the same length and that all elements are like the corresponding elements of this sequence.</p></div></div><div id='d_XB' class='de'><h1>Method <span class='n'>isSameAs</span></h1><div class='re'><code>isSameAs( self, otherType )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_YB' class='de'><h1>Method <span class='n'>isSubtypeOf</span></h1><div class='re'><code>isSubtypeOf( self, otherType )</code></div><div class='ds'><p>The other type is like this one if the other is a sequence with the same length and that all elements are like the corresponding elements of this sequence.</p></div></div><div id='d_ZB' class='de'><h1>Method <span class='n'>peel</span></h1><div class='re'><code>peel( self )</code></div><div class='ds'><p>If this process is (A, B)-&gt;C, will return (B)-&gt;C. You cannot peel a process that is (B)-&gt;C.</p></div></div><div id='d_aC' class='de'><h1>Method <span class='n'>result</span></h1><div class='re'><code>result( self, result=None )</code></div><div class='ds'><p>If there is not at least 2 addded types, the result is Nothing.</p></div></div><div id='d_bC' class='de'><h1>Method <span class='n'>__call__</span></h1><div class='re'><code>__call__( self )</code></div><div class='ds'><p>A type instance can be used as a class to construct a new type, which will be cloned from the current type.</p></div></div><div id='d_cC' class='de'><h1>Method <span class='n'>__str__</span></h1><div class='re'><code>__str__( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_dC' class='de'><h1>Method <span class='n'>concreteType</span></h1><div class='re'><code>concreteType( self )</code></div><div class='ds'><p>Returns the <span class='term'>concrete type</span> for this abstract type.</p></div></div><div id='d_eC' class='de'><h1>Method <span class='n'>definedBy</span></h1><div class='re'><code>definedBy( self, definition=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_fC' class='de'><h1>Method <span class='n'>name</span></h1><div class='re'><code>name( self, name=None )</code></div><div class='ds'><p>Returns/sets the name for this type. By defaults, types are unnamed.</p></div></div><div id='d_gC' class='de'><h1>Method <span class='n'>setConcreteType</span></h1><div class='re'><code>setConcreteType( self, value )</code></div><div class='ds'><p>Sets the <span class='term'>concrete type</span> for this abstract type. The concrete type is a value which represents the type. For instance, if this type represents a class, then the concrete type would be the class instance.</p></div></div><div id='d_hC' class='de'><h1>Method <span class='n'>setName</span></h1><div class='re'><code>setName( self, name )</code></div><div class='ds'><p>Sets the name of this type</p></div></div><div id='d_iC' class='de'><h1>Method <span class='n'>subtype</span></h1><div class='re'><code>subtype( self, name )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_NB' class='de'><h1>Class <span class='n'>Process</span></h1><div class='re'></div><div class='ds'><p>A process generates values by processing (optional) arguments.</p></div></div><div id='d_jC' class='de'><h1>Class <span class='n'>SemanticError</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_lC' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.typecast.Type at 0x120e900&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_mC' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self, *args )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_nC' class='de'><h1>Method <span class='n'>add</span></h1><div class='re'><code>add( self, theType )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_oC' class='de'><h1>Method <span class='n'>asString</span></h1><div class='re'><code>asString( self, fromTypes=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_pC' class='de'><h1>Method <span class='n'>elements</span></h1><div class='re'><code>elements( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_qC' class='de'><h1>Method <span class='n'>extend</span></h1><div class='re'><code>extend( self, othertype )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_rC' class='de'><h1>Method <span class='n'>isLike</span></h1><div class='re'><code>isLike( self, otherType )</code></div><div class='ds'><p>The other type is like this one if the other is a sequence with the same length and that all elements are like the corresponding elements of this sequence.</p></div></div><div id='d_sC' class='de'><h1>Method <span class='n'>isSameAs</span></h1><div class='re'><code>isSameAs( self, otherType )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_tC' class='de'><h1>Method <span class='n'>isSubtypeOf</span></h1><div class='re'><code>isSubtypeOf( self, otherType )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_uC' class='de'><h1>Method <span class='n'>length</span></h1><div class='re'><code>length( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_vC' class='de'><h1>Method <span class='n'>__call__</span></h1><div class='re'><code>__call__( self )</code></div><div class='ds'><p>A type instance can be used as a class to construct a new type, which will be cloned from the current type.</p></div></div><div id='d_wC' class='de'><h1>Method <span class='n'>__str__</span></h1><div class='re'><code>__str__( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_xC' class='de'><h1>Method <span class='n'>clone</span></h1><div class='re'><code>clone( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_yC' class='de'><h1>Method <span class='n'>concreteType</span></h1><div class='re'><code>concreteType( self )</code></div><div class='ds'><p>Returns the <span class='term'>concrete type</span> for this abstract type.</p></div></div><div id='d_zC' class='de'><h1>Method <span class='n'>definedBy</span></h1><div class='re'><code>definedBy( self, definition=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_AC' class='de'><h1>Method <span class='n'>name</span></h1><div class='re'><code>name( self, name=None )</code></div><div class='ds'><p>Returns/sets the name for this type. By defaults, types are unnamed.</p></div></div><div id='d_BC' class='de'><h1>Method <span class='n'>result</span></h1><div class='re'><code>result( self )</code></div><div class='ds'><p>Returns the result for this type. This is usually just the type itself, except for processes types.</p></div></div><div id='d_CC' class='de'><h1>Method <span class='n'>setConcreteType</span></h1><div class='re'><code>setConcreteType( self, value )</code></div><div class='ds'><p>Sets the <span class='term'>concrete type</span> for this abstract type. The concrete type is a value which represents the type. For instance, if this type represents a class, then the concrete type would be the class instance.</p></div></div><div id='d_DC' class='de'><h1>Method <span class='n'>setName</span></h1><div class='re'><code>setName( self, name )</code></div><div class='ds'><p>Sets the name of this type</p></div></div><div id='d_EC' class='de'><h1>Method <span class='n'>subtype</span></h1><div class='re'><code>subtype( self, name )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_kC' class='de'><h1>Class <span class='n'>Sequence</span></h1><div class='re'></div><div class='ds'><p>A sequence is simply an ordered set of types.</p></div></div><div id='d_GC' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.typecast.Type at 0x120e900&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_HC' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self, name )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_IC' class='de'><h1>Method <span class='n'>asString</span></h1><div class='re'><code>asString( self, fromType=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_JC' class='de'><h1>Method <span class='n'>clone</span></h1><div class='re'><code>clone( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_KC' class='de'><h1>Method <span class='n'>__call__</span></h1><div class='re'><code>__call__( self )</code></div><div class='ds'><p>A type instance can be used as a class to construct a new type, which will be cloned from the current type.</p></div></div><div id='d_LC' class='de'><h1>Method <span class='n'>__str__</span></h1><div class='re'><code>__str__( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_MC' class='de'><h1>Method <span class='n'>concreteType</span></h1><div class='re'><code>concreteType( self )</code></div><div class='ds'><p>Returns the <span class='term'>concrete type</span> for this abstract type.</p></div></div><div id='d_NC' class='de'><h1>Method <span class='n'>definedBy</span></h1><div class='re'><code>definedBy( self, definition=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_OC' class='de'><h1>Method <span class='n'>isLike</span></h1><div class='re'><code>isLike( self, otherType )</code></div><div class='ds'><p>Generic implementation of isLike. You should always call this method in subclasses, as it implements basic type systems rules such as isLike(Any).</p></div></div><div id='d_PC' class='de'><h1>Method <span class='n'>isSameAs</span></h1><div class='re'><code>isSameAs( self, otherType )</code></div><div class='ds'><p>Generic implementation of isSameAs. You should always call this method in subclasses.</p></div></div><div id='d_QC' class='de'><h1>Method <span class='n'>isSubtypeOf</span></h1><div class='re'><code>isSubtypeOf( self, otherType )</code></div><div class='ds'><p>Generic implementation of isSubtypeOf. You should always call this method in subclasses, as it implements basic type systems rules such as isSubtypeOf(Any).</p></div></div><div id='d_RC' class='de'><h1>Method <span class='n'>name</span></h1><div class='re'><code>name( self, name=None )</code></div><div class='ds'><p>Returns/sets the name for this type. By defaults, types are unnamed.</p></div></div><div id='d_SC' class='de'><h1>Method <span class='n'>result</span></h1><div class='re'><code>result( self )</code></div><div class='ds'><p>Returns the result for this type. This is usually just the type itself, except for processes types.</p></div></div><div id='d_TC' class='de'><h1>Method <span class='n'>setConcreteType</span></h1><div class='re'><code>setConcreteType( self, value )</code></div><div class='ds'><p>Sets the <span class='term'>concrete type</span> for this abstract type. The concrete type is a value which represents the type. For instance, if this type represents a class, then the concrete type would be the class instance.</p></div></div><div id='d_UC' class='de'><h1>Method <span class='n'>setName</span></h1><div class='re'><code>setName( self, name )</code></div><div class='ds'><p>Sets the name of this type</p></div></div><div id='d_VC' class='de'><h1>Method <span class='n'>subtype</span></h1><div class='re'><code>subtype( self, name )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_FC' class='de'><h1>Class <span class='n'>Symbolic</span></h1><div class='re'></div><div class='ds'><p>Symbolic types are types that have no physical counter part but play a role in the type system. This is for instance the case with Any or Nil.</p></div></div><div id='d_XC' class='de'><h1>Method <span class='n'>__call__</span></h1><div class='re'><code>__call__( self )</code></div><div class='ds'><p>A type instance can be used as a class to construct a new type, which will be cloned from the current type.</p></div></div><div id='d_YC' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self, name=None )</code></div><div class='ds'><p>Creates a new anonymous type</p></div></div><div id='d_ZC' class='de'><h1>Method <span class='n'>__str__</span></h1><div class='re'><code>__str__( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_aD' class='de'><h1>Method <span class='n'>asString</span></h1><div class='re'><code>asString( self, fromTypes=None )</code></div><div class='ds'><p>Returns a string representation of this type.</p></div></div><div id='d_bD' class='de'><h1>Method <span class='n'>clone</span></h1><div class='re'><code>clone( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_cD' class='de'><h1>Method <span class='n'>concreteType</span></h1><div class='re'><code>concreteType( self )</code></div><div class='ds'><p>Returns the <span class='term'>concrete type</span> for this abstract type.</p></div></div><div id='d_dD' class='de'><h1>Method <span class='n'>definedBy</span></h1><div class='re'><code>definedBy( self, definition=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_eD' class='de'><h1>Method <span class='n'>isLike</span></h1><div class='re'><code>isLike( self, otherType )</code></div><div class='ds'><p>Generic implementation of isLike. You should always call this method in subclasses, as it implements basic type systems rules such as isLike(Any).</p></div></div><div id='d_fD' class='de'><h1>Method <span class='n'>isSameAs</span></h1><div class='re'><code>isSameAs( self, otherType )</code></div><div class='ds'><p>Generic implementation of isSameAs. You should always call this method in subclasses.</p></div></div><div id='d_gD' class='de'><h1>Method <span class='n'>isSubtypeOf</span></h1><div class='re'><code>isSubtypeOf( self, otherType )</code></div><div class='ds'><p>Generic implementation of isSubtypeOf. You should always call this method in subclasses, as it implements basic type systems rules such as isSubtypeOf(Any).</p></div></div><div id='d_hD' class='de'><h1>Method <span class='n'>name</span></h1><div class='re'><code>name( self, name=None )</code></div><div class='ds'><p>Returns/sets the name for this type. By defaults, types are unnamed.</p></div></div><div id='d_iD' class='de'><h1>Method <span class='n'>result</span></h1><div class='re'><code>result( self )</code></div><div class='ds'><p>Returns the result for this type. This is usually just the type itself, except for processes types.</p></div></div><div id='d_jD' class='de'><h1>Method <span class='n'>setConcreteType</span></h1><div class='re'><code>setConcreteType( self, value )</code></div><div class='ds'><p>Sets the <span class='term'>concrete type</span> for this abstract type. The concrete type is a value which represents the type. For instance, if this type represents a class, then the concrete type would be the class instance.</p></div></div><div id='d_kD' class='de'><h1>Method <span class='n'>setName</span></h1><div class='re'><code>setName( self, name )</code></div><div class='ds'><p>Sets the name of this type</p></div></div><div id='d_lD' class='de'><h1>Method <span class='n'>subtype</span></h1><div class='re'><code>subtype( self, name )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_WC' class='de'><h1>Class <span class='n'>Type</span></h1><div class='re'></div><div class='ds'><p>Abstract class for all types.</p></div></div><div id='d_nD' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.typecast.Symbolic at 0x120e930&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_oD' class='de'><h1>Method <span class='n'>__call__</span></h1><div class='re'><code>__call__( self )</code></div><div class='ds'><p>A type instance can be used as a class to construct a new type, which will be cloned from the current type.</p></div></div><div id='d_pD' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self, name )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_qD' class='de'><h1>Method <span class='n'>__str__</span></h1><div class='re'><code>__str__( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_rD' class='de'><h1>Method <span class='n'>asString</span></h1><div class='re'><code>asString( self, fromType=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_sD' class='de'><h1>Method <span class='n'>clone</span></h1><div class='re'><code>clone( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_tD' class='de'><h1>Method <span class='n'>concreteType</span></h1><div class='re'><code>concreteType( self )</code></div><div class='ds'><p>Returns the <span class='term'>concrete type</span> for this abstract type.</p></div></div><div id='d_uD' class='de'><h1>Method <span class='n'>definedBy</span></h1><div class='re'><code>definedBy( self, definition=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_vD' class='de'><h1>Method <span class='n'>isLike</span></h1><div class='re'><code>isLike( self, otherType )</code></div><div class='ds'><p>Generic implementation of isLike. You should always call this method in subclasses, as it implements basic type systems rules such as isLike(Any).</p></div></div><div id='d_wD' class='de'><h1>Method <span class='n'>isSameAs</span></h1><div class='re'><code>isSameAs( self, otherType )</code></div><div class='ds'><p>Generic implementation of isSameAs. You should always call this method in subclasses.</p></div></div><div id='d_xD' class='de'><h1>Method <span class='n'>isSubtypeOf</span></h1><div class='re'><code>isSubtypeOf( self, otherType )</code></div><div class='ds'><p>Generic implementation of isSubtypeOf. You should always call this method in subclasses, as it implements basic type systems rules such as isSubtypeOf(Any).</p></div></div><div id='d_yD' class='de'><h1>Method <span class='n'>name</span></h1><div class='re'><code>name( self, name=None )</code></div><div class='ds'><p>Returns/sets the name for this type. By defaults, types are unnamed.</p></div></div><div id='d_zD' class='de'><h1>Method <span class='n'>result</span></h1><div class='re'><code>result( self )</code></div><div class='ds'><p>Returns the result for this type. This is usually just the type itself, except for processes types.</p></div></div><div id='d_AD' class='de'><h1>Method <span class='n'>setConcreteType</span></h1><div class='re'><code>setConcreteType( self, value )</code></div><div class='ds'><p>Sets the <span class='term'>concrete type</span> for this abstract type. The concrete type is a value which represents the type. For instance, if this type represents a class, then the concrete type would be the class instance.</p></div></div><div id='d_BD' class='de'><h1>Method <span class='n'>setName</span></h1><div class='re'><code>setName( self, name )</code></div><div class='ds'><p>Sets the name of this type</p></div></div><div id='d_CD' class='de'><h1>Method <span class='n'>subtype</span></h1><div class='re'><code>subtype( self, name )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_mD' class='de'><h1>Class <span class='n'>Unresolved</span></h1><div class='re'></div><div class='ds'><p>Unresolved types are temporary types that can be resolved later when necessary.</p></div></div><div id='d_DD' class='de'><h1>Function <span class='n'>Class</span></h1><div class='re'><code>Class( Context )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_ED' class='de'><h1>Function <span class='n'>Interface</span></h1><div class='re'><code>Interface( Context )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_FD' class='de'><h1>Function <span class='n'>Sequence_combine</span></h1><div class='re'><code>Sequence_combine( a, b, sequenceclass=<class lambdafactory.typecast.Sequence at 0x120e9f0> )</code></div><div class='ds'><p>Combines the given arguments into a sequence. This follows the following rules: Nothing, Nothing -&gt; Nothing Nothing, A -&gt; A A, B -&gt; (A, B) (A, B), C -&gt; (A, B, C) ( type = type(a) ) (A, B), (C, D) -&gt; (A, B, C, D) ( type = type(a) ) A , (C, D) -&gt; (A, B, C) ( type = sequenceclass)</p></div></div><div id='d_GD' class='de'><h1>Function <span class='n'>Sequence_make</span></h1><div class='re'><code>Sequence_make( args, sequenceclass=<class lambdafactory.typecast.Sequence at 0x120e9f0> )</code></div><div class='ds'><p>Tries to make a sequence from the given argumnents. This follows the following rules:</p><blockquote><div class='content'><p>len(args) == 0 -&gt; Nothing len(args) == 1 -&gt; args[1] otherwise -&gt; (args&hellip;.)</p></div></blockquote></div></div><div id='d_HD' class='de'><h1>Function <span class='n'>bits</span></h1><div class='re'><code>bits( size )</code></div><div class='ds'><p>Converts the given number of bits into bytes. This is simply for readibility purprose.</p></div></div><div id='d_ID' class='de'><h1>Function <span class='n'>isLike</span></h1><div class='re'><code>isLike( a, b )</code></div><div class='ds'><p>Type (b) is like type (a) if (b) can be used where (a) can be used. When two types are alike but not the same, this usually means that one type is composed at some level of <code>Any</code> or <code>Rest</code> types.</p><p>Not that isLike(a,b) does not imply isLike(b,a), as (a) may be a "broad" type (such as <code>Any</code>), and (b) a particular type (say <code>String</code>).</p></div></div><div id='d_JD' class='de'><h1>Function <span class='n'>isSame</span></h1><div class='re'><code>isSame( a, b )</code></div><div class='ds'><p>Type (b) is the same as (a) if (a) and (b) are identicial, that means that you can use b where you use a, and this also means that isSame(a,b) == isSame(b,a). Basically, when (b) is same as (a), (b) can be considered as an alias for (a).</p></div></div><div id='d_KD' class='de'><h1>Function <span class='n'>isSubtype</span></h1><div class='re'><code>isSubtype( a, b )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_LD' class='de'><h1>Function <span class='n'>isType</span></h1><div class='re'><code>isType( a )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_MD' class='de'><h1>instance</h1><div class='re'></div><div class='ds'><p>Symbolic types are types that have no physical counter part but play a role in the type system. This is for instance the case with Any or Nil.</p></div></div><div id='d_ND' class='de'><h1>instance</h1><div class='re'></div><div class='ds'><p>Symbolic types are types that have no physical counter part but play a role in the type system. This is for instance the case with Any or Nil.</p></div></div><div id='d_OD' class='de'><h1>instance</h1><div class='re'></div><div class='ds'><p>Symbolic types are types that have no physical counter part but play a role in the type system. This is for instance the case with Any or Nil.</p></div></div><div id='d_PD' class='de'><h1>instance</h1><div class='re'></div><div class='ds'><p>Symbolic types are types that have no physical counter part but play a role in the type system. This is for instance the case with Any or Nil.</p></div></div><div id='d_Dz' class='de'><h1>Module <span class='n'>lambdafactory.typecast</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_SD' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.passes.Pass at 0x1228030&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_TD' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self, args=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_UD' class='de'><h1>Method <span class='n'>asHTML</span></h1><div class='re'><code>asHTML( self, title=None )</code></div><div class='ds'><p>Returns the HTML document generated by this pass</p></div></div><div id='d_VD' class='de'><h1>Method <span class='n'>onModule</span></h1><div class='re'><code>onModule( self, module )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_WD' class='de'><h1>Method <span class='n'>filter</span></h1><div class='re'><code>filter( self, list, interface )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_XD' class='de'><h1>Method <span class='n'>filterContext</span></h1><div class='re'><code>filterContext( self, interface )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_YD' class='de'><h1>Method <span class='n'>findInContext</span></h1><div class='re'><code>findInContext( self, interface )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_ZD' class='de'><h1>Method <span class='n'>getCurrentClass</span></h1><div class='re'><code>getCurrentClass( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_aE' class='de'><h1>Method <span class='n'>getCurrentClassAncestors</span></h1><div class='re'><code>getCurrentClassAncestors( self, theClass=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_bE' class='de'><h1>Method <span class='n'>getCurrentClassParents</span></h1><div class='re'><code>getCurrentClassParents( self, theClass )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_cE' class='de'><h1>Method <span class='n'>getCurrentClosure</span></h1><div class='re'><code>getCurrentClosure( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_dE' class='de'><h1>Method <span class='n'>getCurrentContext</span></h1><div class='re'><code>getCurrentContext( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_eE' class='de'><h1>Method <span class='n'>getCurrentDataFlow</span></h1><div class='re'><code>getCurrentDataFlow( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_fE' class='de'><h1>Method <span class='n'>getCurrentElement</span></h1><div class='re'><code>getCurrentElement( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_gE' class='de'><h1>Method <span class='n'>getCurrentFunction</span></h1><div class='re'><code>getCurrentFunction( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_hE' class='de'><h1>Method <span class='n'>getCurrentMethod</span></h1><div class='re'><code>getCurrentMethod( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_iE' class='de'><h1>Method <span class='n'>getCurrentModule</span></h1><div class='re'><code>getCurrentModule( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_jE' class='de'><h1>Method <span class='n'>getCurrentProcess</span></h1><div class='re'><code>getCurrentProcess( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_kE' class='de'><h1>Method <span class='n'>getFactory</span></h1><div class='re'><code>getFactory( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_lE' class='de'><h1>Method <span class='n'>getHandle</span></h1><div class='re'><code>getHandle( self, element )</code></div><div class='ds'><p>Tells if the pass handles the given element. This basically iterates on the <code>handles</code> property values (which are interfaces), when one interface matches the given <code>element</code>, then the corresponding <code>onXXX</code> method is invoked, where <code>XXX</code> is the interface name (without the leading <code>I</code>).</p></div></div><div id='d_mE' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><p>Returns the name of this pass</p></div></div><div id='d_nE' class='de'><h1>Method <span class='n'>getParentElement</span></h1><div class='re'><code>getParentElement( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_oE' class='de'><h1>Method <span class='n'>getProgram</span></h1><div class='re'><code>getProgram( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_pE' class='de'><h1>Method <span class='n'>handle</span></h1><div class='re'><code>handle( self, element )</code></div><div class='ds'><p>Handles a sungle element, without recursing through its children</p></div></div><div id='d_qE' class='de'><h1>Method <span class='n'>hasParentElement</span></h1><div class='re'><code>hasParentElement( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_rE' class='de'><h1>Method <span class='n'>isIn</span></h1><div class='re'><code>isIn( self, interface )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_sE' class='de'><h1>Method <span class='n'>resolve</span></h1><div class='re'><code>resolve( self, referenceOrName, contextOrDataFlow=None )</code></div><div class='ds'><p>Resolves the given <code>IReference</code> or String sing the given context (<code>IContext</code>) or dataflow (<code>IDataFlow</code>). This usually requires that you've applied a pass to create the dataflow (see the 'lambdafactory.resolution.BasicDataFlow' pass).</p></div></div><div id='d_tE' class='de'><h1>Method <span class='n'>resolveAbsolute</span></h1><div class='re'><code>resolveAbsolute( self, referenceOrName )</code></div><div class='ds'><p>Resolves the given reference or string expressed in absolute style (<code>.</code>-separated list of names), starting from the root dataflow (the program dataflow).</p></div></div><div id='d_uE' class='de'><h1>Method <span class='n'>resolveAbsoluteOrLocal</span></h1><div class='re'><code>resolveAbsoluteOrLocal( self, referenceOrName, contextOrDataFlow=None )</code></div><div class='ds'><p>Tries an absolute resolution first, then will look in the local scope if it fails.</p></div></div><div id='d_vE' class='de'><h1>Method <span class='n'>resolveLocalOrAbsolute</span></h1><div class='re'><code>resolveLocalOrAbsolute( self, referenceOrName, contextOrDataFlow=None )</code></div><div class='ds'><p>Tries a local resolution first, then will look in the program scope if it fails.</p></div></div><div id='d_wE' class='de'><h1>Method <span class='n'>run</span></h1><div class='re'><code>run( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_xE' class='de'><h1>Method <span class='n'>setEnvironment</span></h1><div class='re'><code>setEnvironment( self, environment )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_yE' class='de'><h1>Method <span class='n'>setPass</span></h1><div class='re'><code>setPass( self, programPass )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_zE' class='de'><h1>Method <span class='n'>walk</span></h1><div class='re'><code>walk( self, element )</code></div><div class='ds'><p>Walks the given element, recursively walking the child elements when the handler does not return False</p></div></div><div id='d_AE' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.IModule at 0x7bf8a0&gt;]</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='d_BE' class='de'><h1>str</h1><div class='re'><code>'Documentation'</code></div><div class='ds'><p>str(object) -&gt; string</p><p>Return a nice string representation of the object. If the argument is a string, the return value is the same object.</p></div></div><div id='d_RD' class='de'><h1>Class <span class='n'>DocumentationPass</span></h1><div class='re'></div><div class='ds'><p>The documentation pass will run SDoc on all the modules declared in this program, creating an HTML file.</p></div></div><div id='d_DE' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.passes.Pass at 0x1228030&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_EE' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_FE' class='de'><h1>Method <span class='n'>onModule</span></h1><div class='re'><code>onModule( self, module )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_GE' class='de'><h1>Method <span class='n'>filter</span></h1><div class='re'><code>filter( self, list, interface )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_HE' class='de'><h1>Method <span class='n'>filterContext</span></h1><div class='re'><code>filterContext( self, interface )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_IE' class='de'><h1>Method <span class='n'>findInContext</span></h1><div class='re'><code>findInContext( self, interface )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_JE' class='de'><h1>Method <span class='n'>getCurrentClass</span></h1><div class='re'><code>getCurrentClass( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_KE' class='de'><h1>Method <span class='n'>getCurrentClassAncestors</span></h1><div class='re'><code>getCurrentClassAncestors( self, theClass=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_LE' class='de'><h1>Method <span class='n'>getCurrentClassParents</span></h1><div class='re'><code>getCurrentClassParents( self, theClass )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_ME' class='de'><h1>Method <span class='n'>getCurrentClosure</span></h1><div class='re'><code>getCurrentClosure( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_NE' class='de'><h1>Method <span class='n'>getCurrentContext</span></h1><div class='re'><code>getCurrentContext( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_OE' class='de'><h1>Method <span class='n'>getCurrentDataFlow</span></h1><div class='re'><code>getCurrentDataFlow( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_PE' class='de'><h1>Method <span class='n'>getCurrentElement</span></h1><div class='re'><code>getCurrentElement( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_QE' class='de'><h1>Method <span class='n'>getCurrentFunction</span></h1><div class='re'><code>getCurrentFunction( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_RE' class='de'><h1>Method <span class='n'>getCurrentMethod</span></h1><div class='re'><code>getCurrentMethod( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_SE' class='de'><h1>Method <span class='n'>getCurrentModule</span></h1><div class='re'><code>getCurrentModule( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_TE' class='de'><h1>Method <span class='n'>getCurrentProcess</span></h1><div class='re'><code>getCurrentProcess( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_UE' class='de'><h1>Method <span class='n'>getFactory</span></h1><div class='re'><code>getFactory( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_VE' class='de'><h1>Method <span class='n'>getHandle</span></h1><div class='re'><code>getHandle( self, element )</code></div><div class='ds'><p>Tells if the pass handles the given element. This basically iterates on the <code>handles</code> property values (which are interfaces), when one interface matches the given <code>element</code>, then the corresponding <code>onXXX</code> method is invoked, where <code>XXX</code> is the interface name (without the leading <code>I</code>).</p></div></div><div id='d_WE' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><p>Returns the name of this pass</p></div></div><div id='d_XE' class='de'><h1>Method <span class='n'>getParentElement</span></h1><div class='re'><code>getParentElement( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_YE' class='de'><h1>Method <span class='n'>getProgram</span></h1><div class='re'><code>getProgram( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_ZE' class='de'><h1>Method <span class='n'>handle</span></h1><div class='re'><code>handle( self, element )</code></div><div class='ds'><p>Handles a sungle element, without recursing through its children</p></div></div><div id='d_aF' class='de'><h1>Method <span class='n'>hasParentElement</span></h1><div class='re'><code>hasParentElement( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_bF' class='de'><h1>Method <span class='n'>isIn</span></h1><div class='re'><code>isIn( self, interface )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_cF' class='de'><h1>Method <span class='n'>resolve</span></h1><div class='re'><code>resolve( self, referenceOrName, contextOrDataFlow=None )</code></div><div class='ds'><p>Resolves the given <code>IReference</code> or String sing the given context (<code>IContext</code>) or dataflow (<code>IDataFlow</code>). This usually requires that you've applied a pass to create the dataflow (see the 'lambdafactory.resolution.BasicDataFlow' pass).</p></div></div><div id='d_dF' class='de'><h1>Method <span class='n'>resolveAbsolute</span></h1><div class='re'><code>resolveAbsolute( self, referenceOrName )</code></div><div class='ds'><p>Resolves the given reference or string expressed in absolute style (<code>.</code>-separated list of names), starting from the root dataflow (the program dataflow).</p></div></div><div id='d_eF' class='de'><h1>Method <span class='n'>resolveAbsoluteOrLocal</span></h1><div class='re'><code>resolveAbsoluteOrLocal( self, referenceOrName, contextOrDataFlow=None )</code></div><div class='ds'><p>Tries an absolute resolution first, then will look in the local scope if it fails.</p></div></div><div id='d_fF' class='de'><h1>Method <span class='n'>resolveLocalOrAbsolute</span></h1><div class='re'><code>resolveLocalOrAbsolute( self, referenceOrName, contextOrDataFlow=None )</code></div><div class='ds'><p>Tries a local resolution first, then will look in the program scope if it fails.</p></div></div><div id='d_gF' class='de'><h1>Method <span class='n'>run</span></h1><div class='re'><code>run( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_hF' class='de'><h1>Method <span class='n'>setEnvironment</span></h1><div class='re'><code>setEnvironment( self, environment )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_iF' class='de'><h1>Method <span class='n'>setPass</span></h1><div class='re'><code>setPass( self, programPass )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_jF' class='de'><h1>Method <span class='n'>walk</span></h1><div class='re'><code>walk( self, element )</code></div><div class='ds'><p>Walks the given element, recursively walking the child elements when the handler does not return False</p></div></div><div id='d_kF' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.IModule at 0x7bf8a0&gt;]</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='d_lF' class='de'><h1>str</h1><div class='re'><code>'Importation'</code></div><div class='ds'><p>str(object) -&gt; string</p><p>Return a nice string representation of the object. If the argument is a string, the return value is the same object.</p></div></div><div id='d_CE' class='de'><h1>Class <span class='n'>ImportationPass</span></h1><div class='re'></div><div class='ds'><p>The importation pass will look for importation operations (<code>IImportation</code>), will try to resolve the importations (according to the current environment) and will trigger the loading and parsing of each module into the current program.</p></div></div><div id='d_nF' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.passes.PassContext at 0x1219f30&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_oF' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_pF' class='de'><h1>Method <span class='n'>getHandle</span></h1><div class='re'><code>getHandle( self, element )</code></div><div class='ds'><p>Tells if the pass handles the given element. This basically iterates on the <code>handles</code> property values (which are interfaces), when one interface matches the given <code>element</code>, then the corresponding <code>onXXX</code> method is invoked, where <code>XXX</code> is the interface name (without the leading <code>I</code>).</p></div></div><div id='d_qF' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><p>Returns the name of this pass</p></div></div><div id='d_rF' class='de'><h1>Method <span class='n'>filter</span></h1><div class='re'><code>filter( self, list, interface )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_sF' class='de'><h1>Method <span class='n'>filterContext</span></h1><div class='re'><code>filterContext( self, interface )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_tF' class='de'><h1>Method <span class='n'>findInContext</span></h1><div class='re'><code>findInContext( self, interface )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_uF' class='de'><h1>Method <span class='n'>getCurrentClass</span></h1><div class='re'><code>getCurrentClass( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_vF' class='de'><h1>Method <span class='n'>getCurrentClassAncestors</span></h1><div class='re'><code>getCurrentClassAncestors( self, theClass=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_wF' class='de'><h1>Method <span class='n'>getCurrentClassParents</span></h1><div class='re'><code>getCurrentClassParents( self, theClass )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_xF' class='de'><h1>Method <span class='n'>getCurrentClosure</span></h1><div class='re'><code>getCurrentClosure( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_yF' class='de'><h1>Method <span class='n'>getCurrentContext</span></h1><div class='re'><code>getCurrentContext( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_zF' class='de'><h1>Method <span class='n'>getCurrentDataFlow</span></h1><div class='re'><code>getCurrentDataFlow( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_AF' class='de'><h1>Method <span class='n'>getCurrentElement</span></h1><div class='re'><code>getCurrentElement( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_BF' class='de'><h1>Method <span class='n'>getCurrentFunction</span></h1><div class='re'><code>getCurrentFunction( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_CF' class='de'><h1>Method <span class='n'>getCurrentMethod</span></h1><div class='re'><code>getCurrentMethod( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_DF' class='de'><h1>Method <span class='n'>getCurrentModule</span></h1><div class='re'><code>getCurrentModule( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_EF' class='de'><h1>Method <span class='n'>getCurrentProcess</span></h1><div class='re'><code>getCurrentProcess( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_FF' class='de'><h1>Method <span class='n'>getFactory</span></h1><div class='re'><code>getFactory( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_GF' class='de'><h1>Method <span class='n'>getParentElement</span></h1><div class='re'><code>getParentElement( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_HF' class='de'><h1>Method <span class='n'>getProgram</span></h1><div class='re'><code>getProgram( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_IF' class='de'><h1>Method <span class='n'>handle</span></h1><div class='re'><code>handle( self, element )</code></div><div class='ds'><p>Handles a sungle element, without recursing through its children</p></div></div><div id='d_JF' class='de'><h1>Method <span class='n'>hasParentElement</span></h1><div class='re'><code>hasParentElement( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_KF' class='de'><h1>Method <span class='n'>isIn</span></h1><div class='re'><code>isIn( self, interface )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_LF' class='de'><h1>Method <span class='n'>resolve</span></h1><div class='re'><code>resolve( self, referenceOrName, contextOrDataFlow=None )</code></div><div class='ds'><p>Resolves the given <code>IReference</code> or String sing the given context (<code>IContext</code>) or dataflow (<code>IDataFlow</code>). This usually requires that you've applied a pass to create the dataflow (see the 'lambdafactory.resolution.BasicDataFlow' pass).</p></div></div><div id='d_MF' class='de'><h1>Method <span class='n'>resolveAbsolute</span></h1><div class='re'><code>resolveAbsolute( self, referenceOrName )</code></div><div class='ds'><p>Resolves the given reference or string expressed in absolute style (<code>.</code>-separated list of names), starting from the root dataflow (the program dataflow).</p></div></div><div id='d_NF' class='de'><h1>Method <span class='n'>resolveAbsoluteOrLocal</span></h1><div class='re'><code>resolveAbsoluteOrLocal( self, referenceOrName, contextOrDataFlow=None )</code></div><div class='ds'><p>Tries an absolute resolution first, then will look in the local scope if it fails.</p></div></div><div id='d_OF' class='de'><h1>Method <span class='n'>resolveLocalOrAbsolute</span></h1><div class='re'><code>resolveLocalOrAbsolute( self, referenceOrName, contextOrDataFlow=None )</code></div><div class='ds'><p>Tries a local resolution first, then will look in the program scope if it fails.</p></div></div><div id='d_PF' class='de'><h1>Method <span class='n'>run</span></h1><div class='re'><code>run( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_QF' class='de'><h1>Method <span class='n'>setEnvironment</span></h1><div class='re'><code>setEnvironment( self, environment )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_RF' class='de'><h1>Method <span class='n'>setPass</span></h1><div class='re'><code>setPass( self, programPass )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_SF' class='de'><h1>Method <span class='n'>walk</span></h1><div class='re'><code>walk( self, element )</code></div><div class='ds'><p>Walks the given element, recursively walking the child elements when the handler does not return False</p></div></div><div id='d_TF' class='de'><h1>list</h1><div class='re'><code>[]</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='d_mF' class='de'><h1>Class <span class='n'>Pass</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_VF' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self, environment=None, programPass=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_WF' class='de'><h1>Method <span class='n'>filter</span></h1><div class='re'><code>filter( self, list, interface )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_XF' class='de'><h1>Method <span class='n'>filterContext</span></h1><div class='re'><code>filterContext( self, interface )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_YF' class='de'><h1>Method <span class='n'>findInContext</span></h1><div class='re'><code>findInContext( self, interface )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_ZF' class='de'><h1>Method <span class='n'>getCurrentClass</span></h1><div class='re'><code>getCurrentClass( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_aG' class='de'><h1>Method <span class='n'>getCurrentClassAncestors</span></h1><div class='re'><code>getCurrentClassAncestors( self, theClass=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_bG' class='de'><h1>Method <span class='n'>getCurrentClassParents</span></h1><div class='re'><code>getCurrentClassParents( self, theClass )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_cG' class='de'><h1>Method <span class='n'>getCurrentClosure</span></h1><div class='re'><code>getCurrentClosure( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_dG' class='de'><h1>Method <span class='n'>getCurrentContext</span></h1><div class='re'><code>getCurrentContext( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_eG' class='de'><h1>Method <span class='n'>getCurrentDataFlow</span></h1><div class='re'><code>getCurrentDataFlow( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_fG' class='de'><h1>Method <span class='n'>getCurrentElement</span></h1><div class='re'><code>getCurrentElement( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_gG' class='de'><h1>Method <span class='n'>getCurrentFunction</span></h1><div class='re'><code>getCurrentFunction( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_hG' class='de'><h1>Method <span class='n'>getCurrentMethod</span></h1><div class='re'><code>getCurrentMethod( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_iG' class='de'><h1>Method <span class='n'>getCurrentModule</span></h1><div class='re'><code>getCurrentModule( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_jG' class='de'><h1>Method <span class='n'>getCurrentProcess</span></h1><div class='re'><code>getCurrentProcess( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_kG' class='de'><h1>Method <span class='n'>getFactory</span></h1><div class='re'><code>getFactory( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_lG' class='de'><h1>Method <span class='n'>getParentElement</span></h1><div class='re'><code>getParentElement( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_mG' class='de'><h1>Method <span class='n'>getProgram</span></h1><div class='re'><code>getProgram( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_nG' class='de'><h1>Method <span class='n'>handle</span></h1><div class='re'><code>handle( self, element )</code></div><div class='ds'><p>Handles a sungle element, without recursing through its children</p></div></div><div id='d_oG' class='de'><h1>Method <span class='n'>hasParentElement</span></h1><div class='re'><code>hasParentElement( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_pG' class='de'><h1>Method <span class='n'>isIn</span></h1><div class='re'><code>isIn( self, interface )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_qG' class='de'><h1>Method <span class='n'>resolve</span></h1><div class='re'><code>resolve( self, referenceOrName, contextOrDataFlow=None )</code></div><div class='ds'><p>Resolves the given <code>IReference</code> or String sing the given context (<code>IContext</code>) or dataflow (<code>IDataFlow</code>). This usually requires that you've applied a pass to create the dataflow (see the 'lambdafactory.resolution.BasicDataFlow' pass).</p></div></div><div id='d_rG' class='de'><h1>Method <span class='n'>resolveAbsolute</span></h1><div class='re'><code>resolveAbsolute( self, referenceOrName )</code></div><div class='ds'><p>Resolves the given reference or string expressed in absolute style (<code>.</code>-separated list of names), starting from the root dataflow (the program dataflow).</p></div></div><div id='d_sG' class='de'><h1>Method <span class='n'>resolveAbsoluteOrLocal</span></h1><div class='re'><code>resolveAbsoluteOrLocal( self, referenceOrName, contextOrDataFlow=None )</code></div><div class='ds'><p>Tries an absolute resolution first, then will look in the local scope if it fails.</p></div></div><div id='d_tG' class='de'><h1>Method <span class='n'>resolveLocalOrAbsolute</span></h1><div class='re'><code>resolveLocalOrAbsolute( self, referenceOrName, contextOrDataFlow=None )</code></div><div class='ds'><p>Tries a local resolution first, then will look in the program scope if it fails.</p></div></div><div id='d_uG' class='de'><h1>Method <span class='n'>run</span></h1><div class='re'><code>run( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_vG' class='de'><h1>Method <span class='n'>setEnvironment</span></h1><div class='re'><code>setEnvironment( self, environment )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_wG' class='de'><h1>Method <span class='n'>setPass</span></h1><div class='re'><code>setPass( self, programPass )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_xG' class='de'><h1>Method <span class='n'>walk</span></h1><div class='re'><code>walk( self, element )</code></div><div class='ds'><p>Walks the given element, recursively walking the child elements when the handler does not return False</p></div></div><div id='d_UF' class='de'><h1>Class <span class='n'>PassContext</span></h1><div class='re'></div><div class='ds'><p>The <code>PassContext</code> represents the current state of one or more passes when walking the program. It offers access to the <code>environment</code> (gives access to the program and various passes).</p><p>A single context can be shared among various passes.</p></div></div><div id='d_zG' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.passes.Pass at 0x1228030&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_AG' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_BG' class='de'><h1>Method <span class='n'>filter</span></h1><div class='re'><code>filter( self, list, interface )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_CG' class='de'><h1>Method <span class='n'>filterContext</span></h1><div class='re'><code>filterContext( self, interface )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_DG' class='de'><h1>Method <span class='n'>findInContext</span></h1><div class='re'><code>findInContext( self, interface )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_EG' class='de'><h1>Method <span class='n'>getCurrentClass</span></h1><div class='re'><code>getCurrentClass( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_FG' class='de'><h1>Method <span class='n'>getCurrentClassAncestors</span></h1><div class='re'><code>getCurrentClassAncestors( self, theClass=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_GG' class='de'><h1>Method <span class='n'>getCurrentClassParents</span></h1><div class='re'><code>getCurrentClassParents( self, theClass )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_HG' class='de'><h1>Method <span class='n'>getCurrentClosure</span></h1><div class='re'><code>getCurrentClosure( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_IG' class='de'><h1>Method <span class='n'>getCurrentContext</span></h1><div class='re'><code>getCurrentContext( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_JG' class='de'><h1>Method <span class='n'>getCurrentDataFlow</span></h1><div class='re'><code>getCurrentDataFlow( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_KG' class='de'><h1>Method <span class='n'>getCurrentElement</span></h1><div class='re'><code>getCurrentElement( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_LG' class='de'><h1>Method <span class='n'>getCurrentFunction</span></h1><div class='re'><code>getCurrentFunction( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_MG' class='de'><h1>Method <span class='n'>getCurrentMethod</span></h1><div class='re'><code>getCurrentMethod( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_NG' class='de'><h1>Method <span class='n'>getCurrentModule</span></h1><div class='re'><code>getCurrentModule( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_OG' class='de'><h1>Method <span class='n'>getCurrentProcess</span></h1><div class='re'><code>getCurrentProcess( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_PG' class='de'><h1>Method <span class='n'>getFactory</span></h1><div class='re'><code>getFactory( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_QG' class='de'><h1>Method <span class='n'>getHandle</span></h1><div class='re'><code>getHandle( self, element )</code></div><div class='ds'><p>Tells if the pass handles the given element. This basically iterates on the <code>handles</code> property values (which are interfaces), when one interface matches the given <code>element</code>, then the corresponding <code>onXXX</code> method is invoked, where <code>XXX</code> is the interface name (without the leading <code>I</code>).</p></div></div><div id='d_RG' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><p>Returns the name of this pass</p></div></div><div id='d_SG' class='de'><h1>Method <span class='n'>getParentElement</span></h1><div class='re'><code>getParentElement( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_TG' class='de'><h1>Method <span class='n'>getProgram</span></h1><div class='re'><code>getProgram( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_UG' class='de'><h1>Method <span class='n'>handle</span></h1><div class='re'><code>handle( self, element )</code></div><div class='ds'><p>Handles a sungle element, without recursing through its children</p></div></div><div id='d_VG' class='de'><h1>Method <span class='n'>hasParentElement</span></h1><div class='re'><code>hasParentElement( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_WG' class='de'><h1>Method <span class='n'>isIn</span></h1><div class='re'><code>isIn( self, interface )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_XG' class='de'><h1>Method <span class='n'>resolve</span></h1><div class='re'><code>resolve( self, referenceOrName, contextOrDataFlow=None )</code></div><div class='ds'><p>Resolves the given <code>IReference</code> or String sing the given context (<code>IContext</code>) or dataflow (<code>IDataFlow</code>). This usually requires that you've applied a pass to create the dataflow (see the 'lambdafactory.resolution.BasicDataFlow' pass).</p></div></div><div id='d_YG' class='de'><h1>Method <span class='n'>resolveAbsolute</span></h1><div class='re'><code>resolveAbsolute( self, referenceOrName )</code></div><div class='ds'><p>Resolves the given reference or string expressed in absolute style (<code>.</code>-separated list of names), starting from the root dataflow (the program dataflow).</p></div></div><div id='d_ZG' class='de'><h1>Method <span class='n'>resolveAbsoluteOrLocal</span></h1><div class='re'><code>resolveAbsoluteOrLocal( self, referenceOrName, contextOrDataFlow=None )</code></div><div class='ds'><p>Tries an absolute resolution first, then will look in the local scope if it fails.</p></div></div><div id='d_aH' class='de'><h1>Method <span class='n'>resolveLocalOrAbsolute</span></h1><div class='re'><code>resolveLocalOrAbsolute( self, referenceOrName, contextOrDataFlow=None )</code></div><div class='ds'><p>Tries a local resolution first, then will look in the program scope if it fails.</p></div></div><div id='d_bH' class='de'><h1>Method <span class='n'>run</span></h1><div class='re'><code>run( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_cH' class='de'><h1>Method <span class='n'>setEnvironment</span></h1><div class='re'><code>setEnvironment( self, environment )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_dH' class='de'><h1>Method <span class='n'>setPass</span></h1><div class='re'><code>setPass( self, programPass )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_eH' class='de'><h1>Method <span class='n'>walk</span></h1><div class='re'><code>walk( self, element )</code></div><div class='ds'><p>Walks the given element, recursively walking the child elements when the handler does not return False</p></div></div><div id='d_fH' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.IClosure at 0x7bf990&gt;]</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='d_gH' class='de'><h1>str</h1><div class='re'><code>'AsynchronousInvocationsExpansion'</code></div><div class='ds'><p>str(object) -&gt; string</p><p>Return a nice string representation of the object. If the argument is a string, the return value is the same object.</p></div></div><div id='d_yG' class='de'><h1>Class <span class='n'>TransformAsynchronousInvocations</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_QD' class='de'><h1>Module <span class='n'>lambdafactory.passes</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_jH' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_kH' class='de'><h1>Method <span class='n'>dedent</span></h1><div class='re'><code>dedent( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_lH' class='de'><h1>Method <span class='n'>echoError</span></h1><div class='re'><code>echoError( self, message )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_mH' class='de'><h1>Method <span class='n'>echoWarning</span></h1><div class='re'><code>echoWarning( self, message, element )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_nH' class='de'><h1>Method <span class='n'>error</span></h1><div class='re'><code>error( self, *message )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_oH' class='de'><h1>Method <span class='n'>indent</span></h1><div class='re'><code>indent( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_pH' class='de'><h1>Method <span class='n'>info</span></h1><div class='re'><code>info( self, *message )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_qH' class='de'><h1>Method <span class='n'>isDone</span></h1><div class='re'><code>isDone( self, message, element, update=True )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_rH' class='de'><h1>Method <span class='n'>onError</span></h1><div class='re'><code>onError( self, callback )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_sH' class='de'><h1>Method <span class='n'>onWarning</span></h1><div class='re'><code>onWarning( self, callback )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_tH' class='de'><h1>Method <span class='n'>warning</span></h1><div class='re'><code>warning( self, message, element=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_iH' class='de'><h1>Class <span class='n'>Reporter</span></h1><div class='re'></div><div class='ds'><p>The reporter aggregates error reports that may happen during model construction and the different phases (dataflowing, typing, writing, etc).</p></div></div><div id='d_uH' class='de'><h1>instance</h1><div class='re'></div><div class='ds'><p>The reporter aggregates error reports that may happen during model construction and the different phases (dataflowing, typing, writing, etc).</p></div></div><div id='d_hH' class='de'><h1>Module <span class='n'>lambdafactory.reporter</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div>
	<!-- descriptions-snip -->
</div>
<div id='hidden'>
	<!-- hidden-snip -->
	<div id='d_Wn' class='de'><h1>Method <span class='n'>getInstanceMethods</span></h1><div class='re'><code>getInstanceMethods( self )</code></div><div class='ds'><p>Returns the instance methods defined within this class.</p></div></div><div id='d_Wo' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_Wl' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IImportOperation at 0x7bfb10&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Wm' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><p>Performs a deep clone of this element. Any mutation to the original won't change the copy.</p></div></div><div id='d_Wj' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><p>Detaches the element from its parent (in case it was already attached). This should return this element, and set the parent to None.</p></div></div><div id='d_Wk' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_Wh' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_Wi' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><p>Sets the given argument of this operation, by argument index.</p></div></div><div id='d_Wf' class='de'><h1>Method <span class='n'>hasSlot</span></h1><div class='re'><code>hasSlot( self, name )</code></div><div class='ds'><p>Tells if the context has a slot with the given name.</p></div></div><div id='d_Wg' class='de'><h1>Method <span class='n'>getSlots</span></h1><div class='re'><code>getSlots( self )</code></div><div class='ds'><p>Returns (key, evaluable) pairs representing the slots within this context.</p></div></div><div id='d_Wd' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><p>Performs a deep clone of this element. Any mutation to the original won't change the copy.</p></div></div><div id='d_We' class='de'><h1>Method <span class='n'>getOperator</span></h1><div class='re'><code>getOperator( self )</code></div><div class='ds'><p>Gets the operator for this computation</p></div></div><div id='d_Wb' class='de'><h1>Class <span class='n'>IAnnotation</span></h1><div class='re'></div><div class='ds'><p>An annotation is some information that is not used for the actual program, but annotates/gives meta-information about is elements.</p></div></div><div id='d_Wc' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><p>Detaches the element from its parent (in case it was already attached). This should return this element, and set the parent to None.</p></div></div><div id='d_Wz' class='de'><h1>Method <span class='n'>setConcreteType</span></h1><div class='re'><code>setConcreteType( self, value )</code></div><div class='ds'><p>Sets the <span class='term'>concrete type</span> for this abstract type. The concrete type is a value which represents the type. For instance, if this type represents a class, then the concrete type would be the class instance.</p></div></div><div id='d_Wx' class='de'><h1>Method <span class='n'>comment</span></h1><div class='re'><code>comment( self, content )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Wy' class='de'><h1>Method <span class='n'>onProgram</span></h1><div class='re'><code>onProgram( self, element )</code></div><div class='ds'><p>Writes a Program element</p></div></div><div id='d_Wv' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns this element parent</p></div></div><div id='d_Ww' class='de'><h1>Method <span class='n'>getReturnedEvaluable</span></h1><div class='re'><code>getReturnedEvaluable( self )</code></div><div class='ds'><p>Returns the termination return evaluable.</p></div></div><div id='d_Wt' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_Wu' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IOperation at 0x7bfae0&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Wr' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_Ws' class='de'><h1>Method <span class='n'>getPriority</span></h1><div class='re'><code>getPriority( self )</code></div><div class='ds'><p>Gets the priority for this operator</p></div></div><div id='d_Wp' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_Wq' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_WF' class='de'><h1>Method <span class='n'>filter</span></h1><div class='re'><code>filter( self, list, interface )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_WG' class='de'><h1>Method <span class='n'>isIn</span></h1><div class='re'><code>isIn( self, interface )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_WD' class='de'><h1>Method <span class='n'>filter</span></h1><div class='re'><code>filter( self, list, interface )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_WE' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><p>Returns the name of this pass</p></div></div><div id='d_WB' class='de'><h1>Method <span class='n'>isLike</span></h1><div class='re'><code>isLike( self, otherType )</code></div><div class='ds'><p>The other type is like this one if the other is a sequence with the same length and that all elements are like the corresponding elements of this sequence.</p></div></div><div id='d_WC' class='de'><h1>Class <span class='n'>Type</span></h1><div class='re'></div><div class='ds'><p>Abstract class for all types.</p></div></div><div id='d_WA' class='de'><h1>Method <span class='n'>add</span></h1><div class='re'><code>add( self, name, theType )</code></div><div class='ds'><p>This is a <em>deprecated</em> methods that is simply an alias for <code>Map.set</code>.</p></div></div><div id='d_EA' class='de'><h1>Method <span class='n'>definedBy</span></h1><div class='re'><code>definedBy( self, definition=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_EB' class='de'><h1>Method <span class='n'>__call__</span></h1><div class='re'><code>__call__( self )</code></div><div class='ds'><p>A type instance can be used as a class to construct a new type, which will be cloned from the current type.</p></div></div><div id='d_EC' class='de'><h1>Method <span class='n'>subtype</span></h1><div class='re'><code>subtype( self, name )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_ED' class='de'><h1>Function <span class='n'>Interface</span></h1><div class='re'><code>Interface( Context )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_EE' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_EF' class='de'><h1>Method <span class='n'>getCurrentProcess</span></h1><div class='re'><code>getCurrentProcess( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_EG' class='de'><h1>Method <span class='n'>getCurrentClass</span></h1><div class='re'><code>getCurrentClass( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Ep' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns this element parent</p></div></div><div id='d_Eq' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_Er' class='de'><h1>Method <span class='n'>isAbstract</span></h1><div class='re'><code>isAbstract( self )</code></div><div class='ds'><p>Tells wether the given abstractable is abstract or not.</p></div></div><div id='d_Es' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IElement at 0x7bf3c0&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Et' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><p>Tells if this element has a parent or not</p></div></div><div id='d_Eu' class='de'><h1>Method <span class='n'>getProcess</span></h1><div class='re'><code>getProcess( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Ev' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_Ew' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_Ex' class='de'><h1>Method <span class='n'>_arg</span></h1><div class='re'><code>_arg( self, name, typeinfo=None, optional=False )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Ey' class='de'><h1>Method <span class='n'>select</span></h1><div class='re'><code>select( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Ez' class='de'><h1>Class <span class='n'>Arguments</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='Gy' class='cr'><div class='n'><a href='javascript:dS("Gy");'>ModelBadArgument</a></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("Gy","Hy");'><span class='special __init__'>constructor</span></a></div></div><div class='t'>Inhertied Values</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("Gy","Iy");'><span class='special __getitem__'>get item</span></a></div><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("Gy","Jy");'><span class='special __repr__'>string repr</span></a></div><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("Gy","Ky");'><span class='special __str__'>string conversion</span></a></div><div class='slot documented'><span
					class='prefix'>&sdot;</span><a href='javascript:dO("Gy","Ly");'>args</a></div><div class='slot documented'><span
					class='prefix'>&sdot;</span><a href='javascript:dO("Gy","My");'>message</a></div></div></div><div id='d_Eb' class='de'><h1>Method <span class='n'>getDefaultValue</span></h1><div class='re'><code>getDefaultValue( self )</code></div><div class='ds'><p>Returns the expression that assigns the @methodault value.</p></div></div><div id='d_Ec' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><p>Sets the given argument of this operation, by argument index.</p></div></div><div id='d_Ed' class='de'><h1>Method <span class='n'>getSlot</span></h1><div class='re'><code>getSlot( self, name )</code></div><div class='ds'><p>Returns the given evaluable bound to named slot.</p></div></div><div id='d_Ee' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns the parent context for this context (if any)</p></div></div><div id='d_Ef' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns the parent context for this context (if any)</p></div></div><div id='d_Eg' class='de'><h1>Method <span class='n'>getOperations</span></h1><div class='re'><code>getOperations( self )</code></div><div class='ds'><p>Returns the (ordered) list of operations that affected the slot. Operations usually constrain the dataflow abstract type, and exception/warnings/errors may be raised by the type system when a type constraint fails.</p></div></div><div id='d_Eh' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_Ei' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IOperation at 0x7bfae0&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Ej' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_Ek' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><p>Returns the arguments to this operation.</p></div></div><div id='d_El' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><p>Adds an argument to this operation. This should do checking of arguments (by expected internal type and number).</p></div></div><div id='d_Em' class='de'><h1>Method <span class='n'>getSlot</span></h1><div class='re'><code>getSlot( self, name )</code></div><div class='ds'><p>Returns the given evaluable bound to named slot.</p></div></div><div id='d_En' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_Eo' class='de'><h1>Class <span class='n'>IInvocable</span></h1><div class='re'></div><div class='ds'><p>An invocable can be used in an invocation operation.</p></div></div><div id='d_YD' class='de'><h1>Method <span class='n'>findInContext</span></h1><div class='re'><code>findInContext( self, interface )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_YE' class='de'><h1>Method <span class='n'>getProgram</span></h1><div class='re'><code>getProgram( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_YF' class='de'><h1>Method <span class='n'>findInContext</span></h1><div class='re'><code>findInContext( self, interface )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_YG' class='de'><h1>Method <span class='n'>resolveAbsolute</span></h1><div class='re'><code>resolveAbsolute( self, referenceOrName )</code></div><div class='ds'><p>Resolves the given reference or string expressed in absolute style (<code>.</code>-separated list of names), starting from the root dataflow (the program dataflow).</p></div></div><div id='d_YA' class='de'><h1>Method <span class='n'>concreteType</span></h1><div class='re'><code>concreteType( self )</code></div><div class='ds'><p>Returns the <span class='term'>concrete type</span> for this abstract type.</p></div></div><div id='d_YB' class='de'><h1>Method <span class='n'>isSubtypeOf</span></h1><div class='re'><code>isSubtypeOf( self, otherType )</code></div><div class='ds'><p>The other type is like this one if the other is a sequence with the same length and that all elements are like the corresponding elements of this sequence.</p></div></div><div id='d_YC' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self, name=None )</code></div><div class='ds'><p>Creates a new anonymous type</p></div></div><div id='d_Yd' class='de'><h1>Method <span class='n'>endsWithTermination</span></h1><div class='re'><code>endsWithTermination( self )</code></div><div class='ds'><p>Returns true if this function ends with a termination operation. This is especially useful for back-ends which want to know if they have to insert an explicit <code>return</code> at the end (like Java).</p></div></div><div id='d_Ye' class='de'><h1>Method <span class='n'>setLeftOperand</span></h1><div class='re'><code>setLeftOperand( self, operand )</code></div><div class='ds'><p>Sets the left operand of this computation.</p></div></div><div id='d_Yf' class='de'><h1>Method <span class='n'>setSlot</span></h1><div class='re'><code>setSlot( self, name, evaluable )</code></div><div class='ds'><p>Binds the given evaluable to the named slot.</p></div></div><div id='d_Yg' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><p>Tells if this element has a parent or not</p></div></div><div id='d_Yb' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><p>Returns the name of this annotation.</p></div></div><div id='d_Yc' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_Yl' class='de'><h1>Method <span class='n'>getImportedElements</span></h1><div class='re'><code>getImportedElements( self )</code></div><div class='ds'><p>Returns a reference or a resolution that will allow to get the imported element.</p></div></div><div id='d_Ym' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_Yn' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><p>Returns this class name. It can be <code>None</code> if the class is anonymous.</p></div></div><div id='d_Yo' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><p>Sets the given argument of this operation, by argument index.</p></div></div><div id='d_Yh' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><p>Returns the ith arguments to this operation.</p></div></div><div id='d_Yi' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.IEvaluable at 0x7bf450&gt;, &lt;class lambdafactory.interfaces.IEvaluable at 0x7bf450&gt;, &lt;class lambdafactory.interfaces.IEvaluable at 0x7bf450&gt;]</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='d_Yj' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_Yk' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><p>Returns the arguments to this operation.</p></div></div><div id='d_Yt' class='de'><h1>Method <span class='n'>getSlot</span></h1><div class='re'><code>getSlot( self, name )</code></div><div class='ds'><p>Returns the given evaluable bound to named slot.</p></div></div><div id='d_Yu' class='de'><h1>Method <span class='n'>getReference</span></h1><div class='re'><code>getReference( self )</code></div><div class='ds'><p>Returns the reference to be resolved.</p></div></div><div id='d_Yv' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><p>Tells if this element has a parent or not</p></div></div><div id='d_Yw' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><p>Performs a deep clone of this element. Any mutation to the original won't change the copy.</p></div></div><div id='d_Yp' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><p>Sets this element parent</p></div></div><div id='d_Yq' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_Yr' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns the parent context for this context (if any)</p></div></div><div id='d_Ys' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><p>Performs a deep clone of this element. Any mutation to the original won't change the copy.</p></div></div><div id='d_Yx' class='de'><h1>Method <span class='n'>createBlock</span></h1><div class='re'><code>createBlock( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Yy' class='de'><h1>Method <span class='n'>write</span></h1><div class='re'><code>write( self, element )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Yz' class='de'><h1>Method <span class='n'>subtype</span></h1><div class='re'><code>subtype( self, name )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='Zi' class='cr'><div class='n'><a href='javascript:dS("Zi");'>IEvaluable</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("Zi","c");'><span class='special __bases__'><i>Base class</i></span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Zi","aj");'>getResultAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Zi","bj");'>setResultAbstractType</a></div></div></div><div id='k' class='cr'><div class='n'><a href='javascript:dS("k");'>IAbsoluteReference</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("k","l");'><span class='special __bases__'>IReference</span></a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("k","m");'>copy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("k","n");'>detach</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("k","o");'>getAbsoluteName</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("k","p");'>getAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("k","q");'>getAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("k","r");'>getDataFlow</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("k","s");'>getName</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("k","t");'>getParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("k","u");'>getReferenceName</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("k","v");'>getResultAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("k","w");'>hasParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("k","x");'>setAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("k","y");'>setAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("k","z");'>setParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("k","A");'>setResultAbstractType</a></div></div></div><div id='Zb' class='cr'><div class='n'><a href='javascript:dS("Zb");'>IArgument</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("Zb","ac");'><span class='special __bases__'>ISlot</span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Zb","bc");'>getDefaultValue</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Zb","cc");'>isKeywordsRest</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Zb","dc");'>isOptional</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Zb","ec");'>isRest</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Zb","fc");'>setDefaultValue</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Zb","gc");'>setKeywordsRest</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Zb","hc");'>setOptional</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Zb","ic");'>setRest</a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Zb","jc");'>getAbsoluteName</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Zb","kc");'>getName</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Zb","lc");'>getTypeDescription</a></div></div></div><div id='Zz' class='cr'><div class='n'><a href='javascript:dS("Zz");'>Array</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("Zz","aA");'><span class='special __bases__'>Type</span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("Zz","bA");'><span class='special __init__'>constructor</span></a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Zz","cA");'>asString</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Zz","dA");'>content</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Zz","eA");'>isLike</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Zz","fA");'>isSameAs</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Zz","gA");'>isSubtypeOf</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Zz","hA");'>setContentType</a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("Zz","iA");'><span class='special __call__'>when invoked</span></a></div><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("Zz","jA");'><span class='special __str__'>string conversion</span></a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Zz","kA");'>clone</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Zz","lA");'>concreteType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Zz","mA");'>definedBy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Zz","nA");'>name</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Zz","oA");'>result</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Zz","pA");'>setConcreteType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Zz","qA");'>setName</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Zz","rA");'>subtype</a></div></div></div><div id='mD' class='cr'><div class='n'><a href='javascript:dS("mD");'>Unresolved</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("mD","nD");'><span class='special __bases__'>Symbolic</span></a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("mD","oD");'><span class='special __call__'>when invoked</span></a></div><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("mD","pD");'><span class='special __init__'>constructor</span></a></div><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("mD","qD");'><span class='special __str__'>string conversion</span></a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("mD","rD");'>asString</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("mD","sD");'>clone</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("mD","tD");'>concreteType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("mD","uD");'>definedBy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("mD","vD");'>isLike</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("mD","wD");'>isSameAs</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("mD","xD");'>isSubtypeOf</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("mD","yD");'>name</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("mD","zD");'>result</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("mD","AD");'>setConcreteType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("mD","BD");'>setName</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("mD","CD");'>subtype</a></div></div></div><div id='mF' class='cr'><div class='n'><a href='javascript:dS("mF");'>Pass</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("mF","nF");'><span class='special __bases__'>PassContext</span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("mF","oF");'><span class='special __init__'>constructor</span></a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("mF","pF");'>getHandle</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("mF","qF");'>getName</a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("mF","rF");'>filter</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("mF","sF");'>filterContext</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("mF","tF");'>findInContext</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("mF","uF");'>getCurrentClass</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("mF","vF");'>getCurrentClassAncestors</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("mF","wF");'>getCurrentClassParents</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("mF","xF");'>getCurrentClosure</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("mF","yF");'>getCurrentContext</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("mF","zF");'>getCurrentDataFlow</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("mF","AF");'>getCurrentElement</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("mF","BF");'>getCurrentFunction</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("mF","CF");'>getCurrentMethod</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("mF","DF");'>getCurrentModule</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("mF","EF");'>getCurrentProcess</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("mF","FF");'>getFactory</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("mF","GF");'>getParentElement</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("mF","HF");'>getProgram</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("mF","IF");'>handle</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("mF","JF");'>hasParentElement</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("mF","KF");'>isIn</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("mF","LF");'>resolve</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("mF","MF");'>resolveAbsolute</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("mF","NF");'>resolveAbsoluteOrLocal</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("mF","OF");'>resolveLocalOrAbsolute</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("mF","PF");'>run</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("mF","QF");'>setEnvironment</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("mF","RF");'>setPass</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("mF","SF");'>walk</a></div></div><div class='t'>Values</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&bull;</span><a href='javascript:dO("mF","TF");'>HANDLES</a></div><div class='slot documented'><span
					class='prefix'>&bull;</span><a href='javascript:dO("mF","az");'>NAME</a></div></div></div><div id='mc' class='cr'><div class='n'><a href='javascript:dS("mc");'>IAssignable</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("mc","c");'><span class='special __bases__'><i>Base class</i></span></a></div></div></div><div id='mz' class='cr'><div class='n'><a href='javascript:dS("mz");'>Data</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("mz","nz");'><span class='special __bases__'>TypeCollection</span></a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("mz","oz");'>getType</a></div></div></div><div id='d_Ly' class='de'><h1>getset_descriptor</h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='Lt' class='cr'><div class='n'><a href='javascript:dS("Lt");'>IProgram</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("Lt","Mt");'><span class='special __bases__'>IContext</span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Lt","Nt");'>addModule</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Lt","Ot");'>getFactory</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Lt","Pt");'>getModule</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Lt","Qt");'>getModules</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Lt","Rt");'>setFactory</a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Lt","St");'>copy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Lt","Tt");'>detach</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Lt","Ut");'>getAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Lt","Vt");'>getAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Lt","Wt");'>getDataFlow</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Lt","Xt");'>getParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Lt","Yt");'>getSlot</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Lt","Zt");'>getSlots</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Lt","au");'>hasParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Lt","bu");'>hasSlot</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Lt","cu");'>setAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Lt","du");'>setAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Lt","eu");'>setParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Lt","fu");'>setSlot</a></div></div></div><div id='d_Lx' class='de'><h1>Method <span class='n'>_number</span></h1><div class='re'><code>_number( self, number )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='Lr' class='cr'><div class='n'><a href='javascript:dS("Lr");'>IModule</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("Lr","Mr");'><span class='special __bases__'>IContext</span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Lr","Nr");'>addImportOperation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Lr","Or");'>getClasses</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Lr","Pr");'>getImportOperations</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Lr","Qr");'>getParentName</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Lr","Rr");'>isImported</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Lr","Sr");'>setImported</a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Lr","Tr");'>copy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Lr","Ur");'>detach</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Lr","Vr");'>getAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Lr","Wr");'>getAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Lr","Xr");'>getDataFlow</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Lr","Yr");'>getParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Lr","Zr");'>getSlot</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Lr","as");'>getSlots</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Lr","bs");'>hasParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Lr","cs");'>hasSlot</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Lr","ds");'>setAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Lr","es");'>setAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Lr","fs");'>setParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Lr","gs");'>setSlot</a></div></div></div><div id='Lp' class='cr'><div class='n'><a href='javascript:dS("Lp");'>ILiteral</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("Lp","Mp");'><span class='special __bases__'>IValue</span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Lp","Np");'>getActualValue</a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Lp","Op");'>copy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Lp","Pp");'>detach</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Lp","Qp");'>getAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Lp","Rp");'>getAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Lp","Sp");'>getDataFlow</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Lp","Tp");'>getParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Lp","Up");'>getResultAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Lp","Vp");'>hasParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Lp","Wp");'>setAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Lp","Xp");'>setAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Lp","Yp");'>setParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Lp","Zp");'>setResultAbstractType</a></div></div></div><div id='d_Ls' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><p>Detaches the element from its parent (in case it was already attached). This should return this element, and set the parent to None.</p></div></div><div id='d_Lr' class='de'><h1>Class <span class='n'>IModule</span></h1><div class='re'></div><div class='ds'><p>Note that a module <code>getName</code> function returns the module absolute name</p></div></div><div id='d_Lq' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_Lp' class='de'><h1>Class <span class='n'>ILiteral</span></h1><div class='re'></div><div class='ds'><p>A literal is a value that does not need a context to be evaluated. The evaluation is direct.</p></div></div><div id='d_Lw' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><p>Tells if this element has a parent or not</p></div></div><div id='d_Lv' class='de'><h1>Method <span class='n'>getSliceEnd</span></h1><div class='re'><code>getSliceEnd( self )</code></div><div class='ds'><p>Returns evaluable that will return the slice end</p></div></div><div id='d_Lu' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><p>Returns the ith arguments to this operation.</p></div></div><div id='d_Lt' class='de'><h1>Class <span class='n'>IProgram</span></h1><div class='re'></div><div class='ds'><p>The program is the core context and entry point for almost every operation offered by LambdaFactory.</p></div></div><div id='d_Lk' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><p>Sets this element parent</p></div></div><div id='d_Lj' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_Li' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><p>Detaches the element from its parent (in case it was already attached). This should return this element, and set the parent to None.</p></div></div><div id='d_Lh' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><p>Sets this element parent</p></div></div><div id='d_Lo' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><p>Adds an argument to this operation. This should do checking of arguments (by expected internal type and number).</p></div></div><div id='d_Ln' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><p>Performs a deep clone of this element. Any mutation to the original won't change the copy.</p></div></div><div id='d_Lm' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_Ll' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><p>Returns the arguments to this operation.</p></div></div><div id='d_xe' class='de'><h1>Method <span class='n'>addOperation</span></h1><div class='re'><code>addOperation( self, operation )</code></div><div class='ds'><p>Adds the given operation as a child of this process.</p></div></div><div id='d_DC' class='de'><h1>Method <span class='n'>setName</span></h1><div class='re'><code>setName( self, name )</code></div><div class='ds'><p>Sets the name of this type</p></div></div><div id='d_B' class='de'><h1>Class <span class='n'>IAbstractClass</span></h1><div class='re'></div><div class='ds'><p>An abstract @protocol is a @protocol that has at least one abstract element.</p></div></div><div id='d_DA' class='de'><h1>Method <span class='n'>concreteType</span></h1><div class='re'><code>concreteType( self )</code></div><div class='ds'><p>Returns the <span class='term'>concrete type</span> for this abstract type.</p></div></div><div id='d_DG' class='de'><h1>Method <span class='n'>findInContext</span></h1><div class='re'><code>findInContext( self, interface )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_DF' class='de'><h1>Method <span class='n'>getCurrentModule</span></h1><div class='re'><code>getCurrentModule( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_DE' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.passes.Pass at 0x1228030&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_C' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IClass at 0x7bf810&gt;, &lt;class lambdafactory.interfaces.IAbstractable at 0x7bf4e0&gt;)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Ds' class='de'><h1>Class <span class='n'>IOperation</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Dr' class='de'><h1>Method <span class='n'>hasSlot</span></h1><div class='re'><code>hasSlot( self, name )</code></div><div class='ds'><p>Tells if the context has a slot with the given name.</p></div></div><div id='d_Dq' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_Dp' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_Dw' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><p>Detaches the element from its parent (in case it was already attached). This should return this element, and set the parent to None.</p></div></div><div id='d_Dv' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><p>Tells if this element has a parent or not</p></div></div><div id='d_Du' class='de'><h1>Method <span class='n'>getCondition</span></h1><div class='re'><code>getCondition( self )</code></div><div class='ds'><p>Gets the expression that is the condition for this repetition.</p></div></div><div id='d_Dt' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns this element parent</p></div></div><div id='d_Lg' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><p>Detaches the element from its parent (in case it was already attached). This should return this element, and set the parent to None.</p></div></div><div id='d_Dy' class='de'><h1>Method <span class='n'>returns</span></h1><div class='re'><code>returns( self, evaluable )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Dx' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self, module=<module 'lambdafactory.model' from '/Users/sebastien/Local/Python/lambdafactory/model.pyc'> )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Lf' class='de'><h1>Method <span class='n'>setAbstract</span></h1><div class='re'><code>setAbstract( self, isAbstract )</code></div><div class='ds'><p>Sets wether the given abstractable is abstract or not.</p></div></div><div id='d_Dc' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_Db' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IOperation at 0x7bfae0&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Dg' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_D' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><p>Performs a deep clone of this element. Any mutation to the original won't change the copy.</p></div></div><div id='d_De' class='de'><h1>Method <span class='n'>getOperations</span></h1><div class='re'><code>getOperations( self )</code></div><div class='ds'><p>Returns the list of operations in this process.</p></div></div><div id='d_Dd' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns the parent context for this context (if any)</p></div></div><div id='d_Dk' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><p>Returns the ith arguments to this operation.</p></div></div><div id='d_Dj' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_Di' class='de'><h1>Class <span class='n'>IEnumeration</span></h1><div class='re'></div><div class='ds'><p>An enumeration produces values between a start and an end value, with the given step.</p></div></div><div id='d_Ld' class='de'><h1>Method <span class='n'>setSlot</span></h1><div class='re'><code>setSlot( self, name, evaluable )</code></div><div class='ds'><p>Binds the given evaluable to the named slot.</p></div></div><div id='d_Do' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><p>Sets this element parent</p></div></div><div id='d_Dn' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><p>Tells if this element has a parent or not</p></div></div><div id='d_Dm' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns the parent context for this context (if any)</p></div></div><div id='d_Dl' class='de'><h1>Method <span class='n'>getImportedElement</span></h1><div class='re'><code>getImportedElement( self )</code></div><div class='ds'><p>Returns a reference or a resolution that will allow to get the imported element.</p></div></div><div id='d_rE' class='de'><h1>Method <span class='n'>isIn</span></h1><div class='re'><code>isIn( self, interface )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_rD' class='de'><h1>Method <span class='n'>asString</span></h1><div class='re'><code>asString( self, fromType=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_rG' class='de'><h1>Method <span class='n'>resolveAbsolute</span></h1><div class='re'><code>resolveAbsolute( self, referenceOrName )</code></div><div class='ds'><p>Resolves the given reference or string expressed in absolute style (<code>.</code>-separated list of names), starting from the root dataflow (the program dataflow).</p></div></div><div id='d_rF' class='de'><h1>Method <span class='n'>filter</span></h1><div class='re'><code>filter( self, list, interface )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_rA' class='de'><h1>Method <span class='n'>subtype</span></h1><div class='re'><code>subtype( self, name )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_rC' class='de'><h1>Method <span class='n'>isLike</span></h1><div class='re'><code>isLike( self, otherType )</code></div><div class='ds'><p>The other type is like this one if the other is a sequence with the same length and that all elements are like the corresponding elements of this sequence.</p></div></div><div id='d_rB' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.typecast.Type at 0x120e900&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_rH' class='de'><h1>Method <span class='n'>onError</span></h1><div class='re'><code>onError( self, callback )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_re' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, context )</code></div><div class='ds'><p>Sets the parent context for this context.</p></div></div><div id='d_rd' class='de'><h1>Method <span class='n'>getInstanceMethods</span></h1><div class='re'><code>getInstanceMethods( self )</code></div><div class='ds'><p>Returns the instance methods defined within this class.</p></div></div><div id='d_rg' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns the list of parent dataflows for this dataflow.</p></div></div><div id='d_rf' class='de'><h1>Class <span class='n'>IConstructor</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_rc' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><p>Adds an argument to this operation. This should do checking of arguments (by expected internal type and number).</p></div></div><div id='d_rb' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><p>Returns the ith arguments to this operation.</p></div></div><div id='d_rm' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IMethod at 0x7bf9f0&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_rl' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><p>Returns the arguments to this operation.</p></div></div><div id='d_ro' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><p>Detaches the element from its parent (in case it was already attached). This should return this element, and set the parent to None.</p></div></div><div id='d_rn' class='de'><h1>Method <span class='n'>setIntercept</span></h1><div class='re'><code>setIntercept( self, process )</code></div><div class='ds'><p>Sets the process that will do the interception</p></div></div><div id='d_ri' class='de'><h1>Method <span class='n'>getLanguage</span></h1><div class='re'><code>getLanguage( self )</code></div><div class='ds'><p>Returns the language in which the emebedded code is written.</p></div></div><div id='d_rh' class='de'><h1>Method <span class='n'>getResultAbstractType</span></h1><div class='re'><code>getResultAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type of the result of the evaluation of this evaluable</p></div></div><div id='d_rk' class='de'><h1>Method <span class='n'>addOperation</span></h1><div class='re'><code>addOperation( self, operation )</code></div><div class='ds'><p>Adds the given operation as a child of this process.</p></div></div><div id='d_rj' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_ru' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_rt' class='de'><h1>Method <span class='n'>isAsList</span></h1><div class='re'><code>isAsList( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_rw' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns this element parent</p></div></div><div id='d_rv' class='de'><h1>Method <span class='n'>addRule</span></h1><div class='re'><code>addRule( self, evaluable )</code></div><div class='ds'><p>Adds a rule to this operation.</p></div></div><div id='d_rq' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_rp' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_rs' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><p>Detaches the element from its parent (in case it was already attached). This should return this element, and set the parent to None.</p></div></div><div id='d_rr' class='de'><h1>Method <span class='n'>getAbsoluteName</span></h1><div class='re'><code>getAbsoluteName( self )</code></div><div class='ds'><p>Returns the absolute name for this element</p></div></div><div id='d_ry' class='de'><h1>Method <span class='n'>importModule</span></h1><div class='re'><code>importModule( self, name, alias )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_rx' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_rz' class='de'><h1>Method <span class='n'>getType</span></h1><div class='re'><code>getType( self, name )</code></div><div class='ds'><p>Returns the type with the given name, or None if it does not exist.</p></div></div><div id='rf' class='cr'><div class='n'><a href='javascript:dS("rf");'>IConstructor</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("rf","sf");'><span class='special __bases__'>IMethod</span></a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("rf","tf");'>addOperation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("rf","uf");'>copy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("rf","vf");'>detach</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("rf","wf");'>endsWithTermination</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("rf","xf");'>getAbsoluteName</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("rf","yf");'>getAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("rf","zf");'>getAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("rf","Af");'>getArguments</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("rf","Bf");'>getDataFlow</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("rf","Cf");'>getName</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("rf","Df");'>getOperations</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("rf","Ef");'>getParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("rf","Ff");'>getSlot</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("rf","Gf");'>getSlots</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("rf","Hf");'>hasExplicitTermination</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("rf","If");'>hasParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("rf","Jf");'>hasSlot</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("rf","Kf");'>isAbstract</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("rf","Lf");'>setAbstract</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("rf","Mf");'>setAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("rf","Nf");'>setAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("rf","Of");'>setArguments</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("rf","Pf");'>setParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("rf","Qf");'>setSlot</a></div></div></div><div id='d_Vi' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_Vh' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_Vk' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_Vj' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><p>Performs a deep clone of this element. Any mutation to the original won't change the copy.</p></div></div><div id='d_Vm' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><p>Adds an argument to this operation. This should do checking of arguments (by expected internal type and number).</p></div></div><div id='d_Vl' class='de'><h1>Class <span class='n'>IImportSymbolsOperation</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Vo' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><p>Tells if this element has a parent or not</p></div></div><div id='d_Vn' class='de'><h1>Method <span class='n'>getDestructors</span></h1><div class='re'><code>getDestructors( self )</code></div><div class='ds'><p>Returns the destructors for this class</p></div></div><div id='d_Vc' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><p>Performs a deep clone of this element. Any mutation to the original won't change the copy.</p></div></div><div id='d_Vb' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.ISlot at 0x7bf6c0&gt;, &lt;class lambdafactory.interfaces.IEvaluable at 0x7bf450&gt;]</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='d_Ve' class='de'><h1>Method <span class='n'>getOperands</span></h1><div class='re'><code>getOperands( self )</code></div><div class='ds'><p>Returns the left (and right, if any) operands of this computation.</p></div></div><div id='d_Vd' class='de'><h1>Method <span class='n'>addOperation</span></h1><div class='re'><code>addOperation( self, operation )</code></div><div class='ds'><p>Adds the given operation as a child of this process.</p></div></div><div id='d_Vg' class='de'><h1>Method <span class='n'>getSlot</span></h1><div class='re'><code>getSlot( self, name )</code></div><div class='ds'><p>Returns the given evaluable bound to named slot.</p></div></div><div id='d_Vf' class='de'><h1>Method <span class='n'>getSlots</span></h1><div class='re'><code>getSlots( self )</code></div><div class='ds'><p>Returns (key, evaluable) pairs representing the slots within this context.</p></div></div><div id='d_Vy' class='de'><h1>Method <span class='n'>_unique</span></h1><div class='re'><code>_unique( self, name )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Vx' class='de'><h1>Method <span class='n'>breaks</span></h1><div class='re'><code>breaks( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Vz' class='de'><h1>Method <span class='n'>result</span></h1><div class='re'><code>result( self )</code></div><div class='ds'><p>Returns the result for this type. This is usually just the type itself, except for processes types.</p></div></div><div id='d_LB' class='de'><h1>Method <span class='n'>setName</span></h1><div class='re'><code>setName( self, name )</code></div><div class='ds'><p>Sets the name of this type</p></div></div><div id='d_Vq' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><p>Detaches the element from its parent (in case it was already attached). This should return this element, and set the parent to None.</p></div></div><div id='d_Vp' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><p>Tells if this element has a parent or not</p></div></div><div id='d_Vs' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IReference at 0x7bf630&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Vr' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_Vu' class='de'><h1>Class <span class='n'>IResolution</span></h1><div class='re'></div><div class='ds'><p>A resolution resolves a reference into a value.</p></div></div><div id='d_Vt' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_Vw' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IOperation at 0x7bfae0&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Vv' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><p>Returns the <em>internal types</em> for this operations arguments. This is typically the list of interfaces or @protocols that the arguments must comply to.</p></div></div><div id='d_VA' class='de'><h1>Method <span class='n'>__str__</span></h1><div class='re'><code>__str__( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_LG' class='de'><h1>Method <span class='n'>getCurrentFunction</span></h1><div class='re'><code>getCurrentFunction( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_VC' class='de'><h1>Method <span class='n'>subtype</span></h1><div class='re'><code>subtype( self, name )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_VB' class='de'><h1>Method <span class='n'>elements</span></h1><div class='re'><code>elements( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_VE' class='de'><h1>Method <span class='n'>getHandle</span></h1><div class='re'><code>getHandle( self, element )</code></div><div class='ds'><p>Tells if the pass handles the given element. This basically iterates on the <code>handles</code> property values (which are interfaces), when one interface matches the given <code>element</code>, then the corresponding <code>onXXX</code> method is invoked, where <code>XXX</code> is the interface name (without the leading <code>I</code>).</p></div></div><div id='d_VD' class='de'><h1>Method <span class='n'>onModule</span></h1><div class='re'><code>onModule( self, module )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_VG' class='de'><h1>Method <span class='n'>hasParentElement</span></h1><div class='re'><code>hasParentElement( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_LF' class='de'><h1>Method <span class='n'>resolve</span></h1><div class='re'><code>resolve( self, referenceOrName, contextOrDataFlow=None )</code></div><div class='ds'><p>Resolves the given <code>IReference</code> or String sing the given context (<code>IContext</code>) or dataflow (<code>IDataFlow</code>). This usually requires that you've applied a pass to create the dataflow (see the 'lambdafactory.resolution.BasicDataFlow' pass).</p></div></div><div id='d_LE' class='de'><h1>Method <span class='n'>getCurrentClassParents</span></h1><div class='re'><code>getCurrentClassParents( self, theClass )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_LD' class='de'><h1>Function <span class='n'>isType</span></h1><div class='re'><code>isType( a )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_XG' class='de'><h1>Method <span class='n'>resolve</span></h1><div class='re'><code>resolve( self, referenceOrName, contextOrDataFlow=None )</code></div><div class='ds'><p>Resolves the given <code>IReference</code> or String sing the given context (<code>IContext</code>) or dataflow (<code>IDataFlow</code>). This usually requires that you've applied a pass to create the dataflow (see the 'lambdafactory.resolution.BasicDataFlow' pass).</p></div></div><div id='d_XF' class='de'><h1>Method <span class='n'>filterContext</span></h1><div class='re'><code>filterContext( self, interface )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_XE' class='de'><h1>Method <span class='n'>getParentElement</span></h1><div class='re'><code>getParentElement( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='B' class='cr'><div class='n'><a href='javascript:dS("B");'>IAbstractClass</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("B","C");'><span class='special __bases__'>IClass, IAbstractable</span></a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("B","D");'>copy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("B","E");'>detach</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("B","F");'>getAbsoluteName</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("B","G");'>getAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("B","H");'>getAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("B","I");'>getAttributes</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("B","J");'>getClassAttributes</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("B","K");'>getClassMethods</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("B","L");'>getConstructors</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("B","M");'>getDataFlow</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("B","N");'>getDestructors</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("B","O");'>getInstanceMethods</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("B","P");'>getMethods</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("B","Q");'>getName</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("B","R");'>getOperations</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("B","S");'>getParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("B","T");'>getParentClasses</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("B","U");'>getSlot</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("B","V");'>getSlots</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("B","W");'>hasParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("B","X");'>hasSlot</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("B","Y");'>isAbstract</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("B","Z");'>setAbstract</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("B","ab");'>setAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("B","bb");'>setAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("B","cb");'>setParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("B","db");'>setParentClasses</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("B","eb");'>setSlot</a></div></div></div><div id='d_XC' class='de'><h1>Method <span class='n'>__call__</span></h1><div class='re'><code>__call__( self )</code></div><div class='ds'><p>A type instance can be used as a class to construct a new type, which will be cloned from the current type.</p></div></div><div id='d_XB' class='de'><h1>Method <span class='n'>isSameAs</span></h1><div class='re'><code>isSameAs( self, otherType )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_XA' class='de'><h1>Method <span class='n'>asString</span></h1><div class='re'><code>asString( self, fromTypes=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Xg' class='de'><h1>Method <span class='n'>hasExplicitTermination</span></h1><div class='re'><code>hasExplicitTermination( self )</code></div><div class='ds'><p>Returns true if this function has an operation with a termination, otherwise return false.</p></div></div><div id='d_Xf' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, context )</code></div><div class='ds'><p>Sets the parent context for this context.</p></div></div><div id='d_Xe' class='de'><h1>Method <span class='n'>getRightOperand</span></h1><div class='re'><code>getRightOperand( self )</code></div><div class='ds'><p>Returns the right operand of this computation (if any)</p></div></div><div id='d_Xd' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><p>Detaches the element from its parent (in case it was already attached). This should return this element, and set the parent to None.</p></div></div><div id='d_Xc' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_Xb' class='de'><h1>Method <span class='n'>getContent</span></h1><div class='re'><code>getContent( self )</code></div><div class='ds'><p>Returns the content of this annotation.</p></div></div><div id='d_Xo' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_Xn' class='de'><h1>Method <span class='n'>getMethods</span></h1><div class='re'><code>getMethods( self )</code></div><div class='ds'><p>Returns the methods defined within this class.</p></div></div><div id='d_Xm' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><p>Detaches the element from its parent (in case it was already attached). This should return this element, and set the parent to None.</p></div></div><div id='d_Xl' class='de'><h1>Method <span class='n'>getImportOrigin</span></h1><div class='re'><code>getImportOrigin( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Xk' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><p>Returns the ith arguments to this operation.</p></div></div><div id='d_Xj' class='de'><h1>Method <span class='n'>getAbsoluteName</span></h1><div class='re'><code>getAbsoluteName( self )</code></div><div class='ds'><p>Returns the absolute name for this element</p></div></div><div id='d_Xi' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><p>Sets this element parent</p></div></div><div id='d_Xh' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_Xw' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><p>Adds an argument to this operation. This should do checking of arguments (by expected internal type and number).</p></div></div><div id='d_Xv' class='de'><h1>Method <span class='n'>getTarget</span></h1><div class='re'><code>getTarget( self )</code></div><div class='ds'><p>Returns the operation target.</p></div></div><div id='d_Xu' class='de'><h1>Method <span class='n'>getContext</span></h1><div class='re'><code>getContext( self )</code></div><div class='ds'><p>Returns the (optional) context in which the resolution should occur.</p></div></div><div id='d_Xt' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns the parent context for this context (if any)</p></div></div><div id='d_Xs' class='de'><h1>Method <span class='n'>setPriority</span></h1><div class='re'><code>setPriority( self, priority )</code></div><div class='ds'><p>Sets the priority for this operator</p></div></div><div id='d_Xr' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_Xq' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_Xp' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_Xz' class='de'><h1>Method <span class='n'>setName</span></h1><div class='re'><code>setName( self, name )</code></div><div class='ds'><p>Sets the name of this type</p></div></div><div id='d_Xy' class='de'><h1>Method <span class='n'>run</span></h1><div class='re'><code>run( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Xx' class='de'><h1>Method <span class='n'>compute</span></h1><div class='re'><code>compute( self, operatorName, leftOperand, rightOperand=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_cj' class='de'><h1>Class <span class='n'>IEvaluation</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_ck' class='de'><h1>Method <span class='n'>getOperations</span></h1><div class='re'><code>getOperations( self )</code></div><div class='ds'><p>Returns the list of operations in this process.</p></div></div><div id='d_ch' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_ci' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><p>Tells if this element has a parent or not</p></div></div><div id='d_cn' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><p>Returns the arguments to this operation.</p></div></div><div id='d_co' class='de'><h1>Method <span class='n'>getSlot</span></h1><div class='re'><code>getSlot( self, name )</code></div><div class='ds'><p>Returns the given evaluable bound to named slot.</p></div></div><div id='d_cl' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_cm' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_cb' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, context )</code></div><div class='ds'><p>Sets the parent context for this context.</p></div></div><div id='d_cc' class='de'><h1>Method <span class='n'>isKeywordsRest</span></h1><div class='re'><code>isKeywordsRest( self )</code></div><div class='ds'><p>Tells if this arguments represents &ldquo;<span class='quote'>the rest</span>&rdquo; of the keyword argument in the invocation</p></div></div><div id='d_cf' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><p>Performs a deep clone of this element. Any mutation to the original won't change the copy.</p></div></div><div id='d_cg' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_cd' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><p>Returns the <em>internal types</em> for this operations arguments. This is typically the list of interfaces or @protocols that the arguments must comply to.</p></div></div><div id='d_ce' class='de'><h1>Method <span class='n'>getArguments</span></h1><div class='re'><code>getArguments( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_cz' class='de'><h1>Function <span class='n'>_format</span></h1><div class='re'><code>_format( value, level=None )</code></div><div class='ds'><p>Format helper operation. See @format</p></div></div><div id='d_cx' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_cy' class='de'><h1>Method <span class='n'>createConstructor</span></h1><div class='re'><code>createConstructor( self, arguments=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_cr' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns this element parent</p></div></div><div id='d_cs' class='de'><h1>Method <span class='n'>hasSlot</span></h1><div class='re'><code>hasSlot( self, name )</code></div><div class='ds'><p>Tells if the context has a slot with the given name.</p></div></div><div id='d_cp' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IOperation at 0x7bfae0&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_cq' class='de'><h1>Method <span class='n'>getExpression</span></h1><div class='re'><code>getExpression( self )</code></div><div class='ds'><p>Returns the process that will be executed if the rule matches.</p></div></div><div id='d_cv' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_cw' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><p>Sets this element parent</p></div></div><div id='d_ct' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_cu' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_cH' class='de'><h1>Method <span class='n'>setEnvironment</span></h1><div class='re'><code>setEnvironment( self, environment )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_cB' class='de'><h1>Method <span class='n'>isLike</span></h1><div class='re'><code>isLike( self, otherType )</code></div><div class='ds'><p>The other type is like this one if the other is a sequence with the same length and that all elements are like the corresponding elements of this sequence.</p></div></div><div id='d_cC' class='de'><h1>Method <span class='n'>__str__</span></h1><div class='re'><code>__str__( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_cA' class='de'><h1>Method <span class='n'>asString</span></h1><div class='re'><code>asString( self, fromTypes=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_cF' class='de'><h1>Method <span class='n'>resolve</span></h1><div class='re'><code>resolve( self, referenceOrName, contextOrDataFlow=None )</code></div><div class='ds'><p>Resolves the given <code>IReference</code> or String sing the given context (<code>IContext</code>) or dataflow (<code>IDataFlow</code>). This usually requires that you've applied a pass to create the dataflow (see the 'lambdafactory.resolution.BasicDataFlow' pass).</p></div></div><div id='d_cG' class='de'><h1>Method <span class='n'>getCurrentClosure</span></h1><div class='re'><code>getCurrentClosure( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_cD' class='de'><h1>Method <span class='n'>concreteType</span></h1><div class='re'><code>concreteType( self )</code></div><div class='ds'><p>Returns the <span class='term'>concrete type</span> for this abstract type.</p></div></div><div id='d_cE' class='de'><h1>Method <span class='n'>getCurrentClosure</span></h1><div class='re'><code>getCurrentClosure( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='Qw' class='cr'><div class='n'><a href='javascript:dS("Qw");'>ISyntactic</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("Qw","c");'><span class='special __bases__'><i>Base class</i></span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Qw","Rw");'>getColumn</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Qw","Sw");'>getLine</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Qw","Tw");'>getOffset</a></div></div></div><div id='Qy' class='ro'><div class='n'><a href='javascript:dS("Qy");'>lambdafactory.modelwriter</a></div><div class='t'>Classes</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("Qy","Ry");'>AbstractWriter</a></div></div><div class='t'>Functions</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&lambda;</span><a href='javascript:dO("Qy","bz");'><span class='protected'>_flatten</span></a></div><div class='slot documented'><span
					class='prefix'>&lambda;</span><a href='javascript:dO("Qy","cz");'><span class='protected'>_format</span></a></div><div class='slot documented'><span
					class='prefix'>&lambda;</span><a href='javascript:dO("Qy","dz");'>flatten</a></div><div class='slot documented'><span
					class='prefix'>&lambda;</span><a href='javascript:dO("Qy","ez");'>format</a></div><div class='slot documented'><span
					class='prefix'>&lambda;</span><a href='javascript:dO("Qy","fz");'>notEmpty</a></div></div><div class='t'>Values</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&bull;</span><a href='javascript:dO("Qy","gz");'>PREFIX</a></div><div class='slot documented'><span
					class='prefix'>&bull;</span><a href='javascript:dO("Qy","hz");'>SNIP</a></div></div></div><div id='Qm' class='cr'><div class='n'><a href='javascript:dS("Qm");'>IInstanciable</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("Qm","c");'><span class='special __bases__'><i>Base class</i></span></a></div></div></div><div id='QD' class='ro'><div class='n'><a href='javascript:dS("QD");'>lambdafactory.passes</a></div><div class='t'>Classes</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("QD","RD");'>DocumentationPass</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("QD","CE");'>ImportationPass</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("QD","mF");'>Pass</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("QD","UF");'>PassContext</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("QD","yG");'>TransformAsynchronousInvocations</a></div></div></div><div id='d_uA' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self, length, name=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_uB' class='de'><h1>Method <span class='n'>asString</span></h1><div class='re'><code>asString( self, fromTypes=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_uC' class='de'><h1>Method <span class='n'>length</span></h1><div class='re'><code>length( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_uD' class='de'><h1>Method <span class='n'>definedBy</span></h1><div class='re'><code>definedBy( self, definition=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_uE' class='de'><h1>Method <span class='n'>resolveAbsoluteOrLocal</span></h1><div class='re'><code>resolveAbsoluteOrLocal( self, referenceOrName, contextOrDataFlow=None )</code></div><div class='ds'><p>Tries an absolute resolution first, then will look in the local scope if it fails.</p></div></div><div id='d_uF' class='de'><h1>Method <span class='n'>getCurrentClass</span></h1><div class='re'><code>getCurrentClass( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_uG' class='de'><h1>Method <span class='n'>run</span></h1><div class='re'><code>run( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_uH' class='de'><h1>instance</h1><div class='re'></div><div class='ds'><p>The reporter aggregates error reports that may happen during model construction and the different phases (dataflowing, typing, writing, etc).</p></div></div><div id='d_ub' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns this element parent</p></div></div><div id='d_uc' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_ud' class='de'><h1>Method <span class='n'>getOperations</span></h1><div class='re'><code>getOperations( self )</code></div><div class='ds'><p>Returns the operations (methods and class methods) defined within this class.</p></div></div><div id='d_ue' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IProcess at 0x7bf900&gt;, &lt;class lambdafactory.interfaces.IContext at 0x7bf7e0&gt;)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_uf' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><p>Performs a deep clone of this element. Any mutation to the original won't change the copy.</p></div></div><div id='d_ug' class='de'><h1>Method <span class='n'>getSlots</span></h1><div class='re'><code>getSlots( self )</code></div><div class='ds'><p>Returns the lsit of slots @methodiend for this dataflow.</p></div></div><div id='d_uh' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_ui' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><p>Returns the <em>internal types</em> for this operations arguments. This is typically the list of interfaces or @protocols that the arguments must comply to.</p></div></div><div id='d_uj' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.IEvaluable at 0x7bf450&gt;, &lt;class lambdafactory.interfaces.IEvaluable at 0x7bf450&gt;]</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='d_uk' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IImportOperation at 0x7bfb10&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_ul' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><p>Tells if this element has a parent or not</p></div></div><div id='d_um' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><p>Detaches the element from its parent (in case it was already attached). This should return this element, and set the parent to None.</p></div></div><div id='d_un' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><p>Performs a deep clone of this element. Any mutation to the original won't change the copy.</p></div></div><div id='d_uo' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_up' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.IEvaluable at 0x7bf450&gt;, &lt;class lambdafactory.interfaces.IEvaluable at 0x7bf450&gt;]</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='d_uq' class='de'><h1>Method <span class='n'>setPredicate</span></h1><div class='re'><code>setPredicate( self, v )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_ur' class='de'><h1>Method <span class='n'>getArguments</span></h1><div class='re'><code>getArguments( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_us' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_ut' class='de'><h1>Method <span class='n'>setAsList</span></h1><div class='re'><code>setAsList( self, v=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_uu' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns this element parent</p></div></div><div id='d_uv' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><p>Performs a deep clone of this element. Any mutation to the original won't change the copy.</p></div></div><div id='d_uw' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_ux' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns this element parent</p></div></div><div id='d_uy' class='de'><h1>Method <span class='n'>importSymbols</span></h1><div class='re'><code>importSymbols( self, names, origin )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_uz' class='de'><h1>Method <span class='n'>getType</span></h1><div class='re'><code>getType( self, name )</code></div><div class='ds'><p>Returns the type with the given name, or None if it does not exist.</p></div></div><div id='d_It' class='de'><h1>Class <span class='n'>IProcess</span></h1><div class='re'></div><div class='ds'><p>A process is a sequence of operations.</p></div></div><div id='d_Iu' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_Iv' class='de'><h1>list</h1><div class='re'><code>[[&lt;class lambdafactory.interfaces.IMatchOperation at 0x7bfde0&gt;]]</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='d_Iw' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><p>Returns the arguments to this operation.</p></div></div><div id='d_Ip' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_Iq' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><p>Returns the <em>internal types</em> for this operations arguments. This is typically the list of interfaces or @protocols that the arguments must comply to.</p></div></div><div id='d_Ir' class='de'><h1>Method <span class='n'>setArguments</span></h1><div class='re'><code>setArguments( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Is' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><p>Returns the <em>internal types</em> for this operations arguments. This is typically the list of interfaces or @protocols that the arguments must comply to.</p></div></div><div id='d_Ix' class='de'><h1>Method <span class='n'>_getImplementation</span></h1><div class='re'><code>_getImplementation( self, name )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Iy' class='de'><h1>wrapper_descriptor</h1><div class='re'></div><div class='ds'><div class="section" level="1"><h1 class="heading"><span class="number"><span class="level0">1<span class="lastDot dot">.</span></span></span><span class='term'>getitem</span>_(y) &lt;==&gt; x[y]</h1><div class="level1"></div></div></div></div><div id='d_Iz' class='de'><h1>Method <span class='n'>__str__</span></h1><div class='re'><code>__str__( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Id' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_Ie' class='de'><h1>Method <span class='n'>hasSlot</span></h1><div class='re'><code>hasSlot( self, name )</code></div><div class='ds'><p>Tells if the context has a slot with the given name.</p></div></div><div id='d_If' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><p>Tells if this element has a parent or not</p></div></div><div id='d_Ig' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IMethod at 0x7bf9f0&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Ib' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><p>Detaches the element from its parent (in case it was already attached). This should return this element, and set the parent to None.</p></div></div><div id='d_Ic' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.ISlot at 0x7bf6c0&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Il' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_Im' class='de'><h1>Method <span class='n'>hasSlot</span></h1><div class='re'><code>hasSlot( self, name )</code></div><div class='ds'><p>Tells if the context has a slot with the given name.</p></div></div><div id='d_In' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.IProcess at 0x7bf900&gt;, &lt;class lambdafactory.interfaces.IProcess at 0x7bf900&gt;, &lt;class lambdafactory.interfaces.IProcess at 0x7bf900&gt;]</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='d_Io' class='de'><h1>Method <span class='n'>getArguments</span></h1><div class='re'><code>getArguments( self )</code></div><div class='ds'><p>Returns evaluable arguments.</p></div></div><div id='d_Ih' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><p>Tells if this element has a parent or not</p></div></div><div id='d_Ii' class='de'><h1>Method <span class='n'>setStep</span></h1><div class='re'><code>setStep( self, value )</code></div><div class='ds'><p>Sets this enumeration step</p></div></div><div id='d_Ij' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns this element parent</p></div></div><div id='d_Ik' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_ID' class='de'><h1>Function <span class='n'>isLike</span></h1><div class='re'><code>isLike( a, b )</code></div><div class='ds'><p>Type (b) is like type (a) if (b) can be used where (a) can be used. When two types are alike but not the same, this usually means that one type is composed at some level of <code>Any</code> or <code>Rest</code> types.</p><p>Not that isLike(a,b) does not imply isLike(b,a), as (a) may be a "broad" type (such as <code>Any</code>), and (b) a particular type (say <code>String</code>).</p></div></div><div id='d_IE' class='de'><h1>Method <span class='n'>findInContext</span></h1><div class='re'><code>findInContext( self, interface )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_IF' class='de'><h1>Method <span class='n'>handle</span></h1><div class='re'><code>handle( self, element )</code></div><div class='ds'><p>Handles a sungle element, without recursing through its children</p></div></div><div id='d_IG' class='de'><h1>Method <span class='n'>getCurrentContext</span></h1><div class='re'><code>getCurrentContext( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_IA' class='de'><h1>Method <span class='n'>setName</span></h1><div class='re'><code>setName( self, name )</code></div><div class='ds'><p>Sets the name of this type</p></div></div><div id='d_IB' class='de'><h1>Method <span class='n'>name</span></h1><div class='re'><code>name( self, name=None )</code></div><div class='ds'><p>Returns/sets the name for this type. By defaults, types are unnamed.</p></div></div><div id='d_IC' class='de'><h1>Method <span class='n'>asString</span></h1><div class='re'><code>asString( self, fromType=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='wj' class='cr'><div class='n'><a href='javascript:dS("wj");'>IExcept</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("wj","xj");'><span class='special __bases__'>IInterruption</span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("wj","yj");'>getValue</a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("wj","zj");'>addOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("wj","Aj");'>copy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("wj","Bj");'>detach</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("wj","Cj");'>getAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("wj","Dj");'>getAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("wj","Ej");'>getDataFlow</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("wj","Fj");'>getOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("wj","Gj");'>getOpArguments</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("wj","Hj");'>getOpArgumentsInternalTypes</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("wj","Ij");'>getParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("wj","Jj");'>hasParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("wj","Kj");'>setAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("wj","Lj");'>setAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("wj","Mj");'>setOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("wj","Nj");'>setParent</a></div></div><div class='t'>Values</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&bull;</span><a href='javascript:dO("wj","Oj");'>ARGS</a></div></div></div><div id='wq' class='cr'><div class='n'><a href='javascript:dS("wq");'>IMatchOperation</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("wq","xq");'><span class='special __bases__'>IOperation</span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("wq","yq");'>getPredicate</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("wq","zq");'>setPredicate</a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("wq","Aq");'>addOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("wq","Bq");'>copy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("wq","Cq");'>detach</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("wq","Dq");'>getAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("wq","Eq");'>getAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("wq","Fq");'>getDataFlow</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("wq","Gq");'>getOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("wq","Hq");'>getOpArguments</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("wq","Iq");'>getOpArgumentsInternalTypes</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("wq","Jq");'>getParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("wq","Kq");'>hasParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("wq","Lq");'>setAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("wq","Mq");'>setAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("wq","Nq");'>setOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("wq","Oq");'>setParent</a></div></div></div><div id='d_GF' class='de'><h1>Method <span class='n'>getParentElement</span></h1><div class='re'><code>getParentElement( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_GG' class='de'><h1>Method <span class='n'>getCurrentClassParents</span></h1><div class='re'><code>getCurrentClassParents( self, theClass )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_GD' class='de'><h1>Function <span class='n'>Sequence_make</span></h1><div class='re'><code>Sequence_make( args, sequenceclass=<class lambdafactory.typecast.Sequence at 0x120e9f0> )</code></div><div class='ds'><p>Tries to make a sequence from the given argumnents. This follows the following rules:</p><blockquote><div class='content'><p>len(args) == 0 -&gt; Nothing len(args) == 1 -&gt; args[1] otherwise -&gt; (args&hellip;.)</p></div></blockquote></div></div><div id='d_GE' class='de'><h1>Method <span class='n'>filter</span></h1><div class='re'><code>filter( self, list, interface )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_GB' class='de'><h1>Method <span class='n'>concreteType</span></h1><div class='re'><code>concreteType( self )</code></div><div class='ds'><p>Returns the <span class='term'>concrete type</span> for this abstract type.</p></div></div><div id='d_GC' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.typecast.Type at 0x120e900&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_GA' class='de'><h1>Method <span class='n'>result</span></h1><div class='re'><code>result( self )</code></div><div class='ds'><p>Returns the result for this type. This is usually just the type itself, except for processes types.</p></div></div><div id='d_Gz' class='de'><h1>Method <span class='n'>__call__</span></h1><div class='re'><code>__call__( self )</code></div><div class='ds'><p>A type instance can be used as a class to construct a new type, which will be cloned from the current type.</p></div></div><div id='d_Gx' class='de'><h1>Method <span class='n'>_classattr</span></h1><div class='re'><code>_classattr( self, name, typeinfo=None, value=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Gy' class='de'><h1>Class <span class='n'>ModelBadArgument</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Gv' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><p>Sets the given argument of this operation, by argument index.</p></div></div><div id='d_Gw' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_Gt' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_Gu' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><p>Performs a deep clone of this element. Any mutation to the original won't change the copy.</p></div></div><div id='d_Gr' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_Gs' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><p>Returns the ith arguments to this operation.</p></div></div><div id='d_Gp' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><p>Tells if this element has a parent or not</p></div></div><div id='d_Gq' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><p>Returns the ith arguments to this operation.</p></div></div><div id='d_Gn' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><p>Sets the given argument of this operation, by argument index.</p></div></div><div id='d_Go' class='de'><h1>Class <span class='n'>IInvocation</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Gl' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><p>Detaches the element from its parent (in case it was already attached). This should return this element, and set the parent to None.</p></div></div><div id='d_Gm' class='de'><h1>Method <span class='n'>hasExplicitTermination</span></h1><div class='re'><code>hasExplicitTermination( self )</code></div><div class='ds'><p>Returns true if this function has an operation with a termination, otherwise return false.</p></div></div><div id='d_Gj' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><p>Returns the arguments to this operation.</p></div></div><div id='d_Gk' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns this element parent</p></div></div><div id='d_Gh' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_Gi' class='de'><h1>Method <span class='n'>getStart</span></h1><div class='re'><code>getStart( self )</code></div><div class='ds'><p>Returns this enumeration start.</p></div></div><div id='d_Gf' class='de'><h1>Method <span class='n'>getSlots</span></h1><div class='re'><code>getSlots( self )</code></div><div class='ds'><p>Returns (key, evaluable) pairs representing the slots within this context.</p></div></div><div id='d_Gg' class='de'><h1>Method <span class='n'>getOriginalValue</span></h1><div class='re'><code>getOriginalValue( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Gd' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><p>Tells if this element has a parent or not</p></div></div><div id='d_Ge' class='de'><h1>Method <span class='n'>getSlots</span></h1><div class='re'><code>getSlots( self )</code></div><div class='ds'><p>Returns (key, evaluable) pairs representing the slots within this context.</p></div></div><div id='d_Gb' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><p>Adds an argument to this operation. This should do checking of arguments (by expected internal type and number).</p></div></div><div id='d_Gc' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.IEvaluable at 0x7bf450&gt;, &lt;class lambdafactory.interfaces.IEvaluable at 0x7bf450&gt;]</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='CE' class='cr'><div class='n'><a href='javascript:dS("CE");'>ImportationPass</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("CE","DE");'><span class='special __bases__'>Pass</span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("CE","EE");'><span class='special __init__'>constructor</span></a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("CE","FE");'>onModule</a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("CE","GE");'>filter</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("CE","HE");'>filterContext</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("CE","IE");'>findInContext</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("CE","JE");'>getCurrentClass</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("CE","KE");'>getCurrentClassAncestors</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("CE","LE");'>getCurrentClassParents</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("CE","ME");'>getCurrentClosure</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("CE","NE");'>getCurrentContext</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("CE","OE");'>getCurrentDataFlow</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("CE","PE");'>getCurrentElement</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("CE","QE");'>getCurrentFunction</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("CE","RE");'>getCurrentMethod</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("CE","SE");'>getCurrentModule</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("CE","TE");'>getCurrentProcess</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("CE","UE");'>getFactory</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("CE","VE");'>getHandle</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("CE","WE");'>getName</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("CE","XE");'>getParentElement</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("CE","YE");'>getProgram</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("CE","ZE");'>handle</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("CE","aF");'>hasParentElement</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("CE","bF");'>isIn</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("CE","cF");'>resolve</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("CE","dF");'>resolveAbsolute</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("CE","eF");'>resolveAbsoluteOrLocal</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("CE","fF");'>resolveLocalOrAbsolute</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("CE","gF");'>run</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("CE","hF");'>setEnvironment</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("CE","iF");'>setPass</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("CE","jF");'>walk</a></div></div><div class='t'>Values</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&bull;</span><a href='javascript:dO("CE","kF");'>HANDLES</a></div><div class='slot documented'><span
					class='prefix'>&bull;</span><a href='javascript:dO("CE","lF");'>NAME</a></div></div></div><div id='Cb' class='cr'><div class='n'><a href='javascript:dS("Cb");'>IAllocation</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("Cb","Db");'><span class='special __bases__'>IOperation</span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Cb","Eb");'>getDefaultValue</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Cb","Fb");'>getSlotToAllocate</a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Cb","Gb");'>addOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Cb","Hb");'>copy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Cb","Ib");'>detach</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Cb","Jb");'>getAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Cb","Kb");'>getAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Cb","Lb");'>getDataFlow</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Cb","Mb");'>getOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Cb","Nb");'>getOpArguments</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Cb","Ob");'>getOpArgumentsInternalTypes</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Cb","Pb");'>getParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Cb","Qb");'>hasParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Cb","Rb");'>setAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Cb","Sb");'>setAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Cb","Tb");'>setOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Cb","Ub");'>setParent</a></div></div><div class='t'>Values</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&bull;</span><a href='javascript:dO("Cb","Vb");'>ARGS</a></div></div></div><div id='Cx' class='cr'><div class='n'><a href='javascript:dS("Cx");'>Factory</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("Cx","c");'><span class='special __bases__'><i>Base class</i></span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("Cx","Dx");'><span class='special __init__'>constructor</span></a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Cx","Ex");'><span class='protected'>_arg</span></a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Cx","Fx");'><span class='protected'>_attr</span></a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Cx","Gx");'><span class='protected'>_classattr</span></a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Cx","Hx");'><span class='protected'>_dict</span></a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Cx","Ix");'><span class='protected'>_getImplementation</span></a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Cx","Jx");'><span class='protected'>_list</span></a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Cx","Kx");'><span class='protected'>_moduleattr</span></a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Cx","Lx");'><span class='protected'>_number</span></a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Cx","Mx");'><span class='protected'>_op</span></a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Cx","Nx");'><span class='protected'>_param</span></a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Cx","Ox");'><span class='protected'>_ref</span></a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Cx","Px");'><span class='protected'>_slot</span></a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Cx","Qx");'><span class='protected'>_string</span></a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Cx","Rx");'>access</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Cx","Sx");'>allocate</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Cx","Tx");'>annotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Cx","Ux");'>assign</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Cx","Vx");'>breaks</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Cx","Wx");'>comment</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Cx","Xx");'>compute</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Cx","Yx");'>createBlock</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Cx","Zx");'>createClass</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Cx","ay");'>createClassMethod</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Cx","by");'>createClosure</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Cx","cy");'>createConstructor</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Cx","dy");'>createDataFlow</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Cx","ey");'>createDataFlowSlot</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Cx","fy");'>createDestructor</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Cx","gy");'>createFunction</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Cx","hy");'>createInterface</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Cx","iy");'>createMethod</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Cx","jy");'>createModule</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Cx","ky");'>createProgram</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Cx","ly");'>doc</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Cx","my");'>embed</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Cx","ny");'>embedTemplate</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Cx","oy");'>enumerate</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Cx","py");'>evaluate</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Cx","qy");'>exception</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Cx","ry");'>importModule</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Cx","sy");'>importModules</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Cx","ty");'>importSymbol</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Cx","uy");'>importSymbols</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Cx","vy");'>instanciate</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Cx","wy");'>intercept</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Cx","xy");'>invoke</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Cx","yy");'>iterate</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Cx","zy");'>matchExpression</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Cx","Ay");'>matchProcess</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Cx","By");'>repeat</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Cx","Cy");'>resolve</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Cx","Dy");'>returns</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Cx","Ey");'>select</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Cx","Fy");'>slice</a></div></div></div><div id='iz' class='ro'><div class='n'><a href='javascript:dS("iz");'>lambdafactory.modeltypes</a></div><div class='t'>Classes</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("iz","jz");'>Behaviour</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("iz","mz");'>Data</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("iz","pz");'>Operations</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("iz","sz");'>Runtime</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("iz","vz");'>Structure</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("iz","yz");'>TypeCollection</a></div></div><div class='t'>Functions</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&lambda;</span><a href='javascript:dO("iz","Az");'>typeForValue</a></div></div><div class='t'>Values</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&bull;</span><a href='javascript:dO("iz","Bz");'>CATALOG</a></div><div class='slot documented'><span
					class='prefix'>&bull;</span><a href='javascript:dO("iz","Cz");'>COLLECTIONS</a></div></div></div><div id='ii' class='cr'><div class='n'><a href='javascript:dS("ii");'>IEmbedTemplate</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("ii","ji");'><span class='special __bases__'>IEmbed</span></a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ii","ki");'>addOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ii","li");'>copy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ii","mi");'>detach</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ii","ni");'>getAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ii","oi");'>getAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ii","pi");'>getCode</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ii","qi");'>getDataFlow</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ii","ri");'>getLanguage</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ii","si");'>getOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ii","ti");'>getOpArguments</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ii","ui");'>getOpArgumentsInternalTypes</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ii","vi");'>getParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ii","wi");'>hasParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ii","xi");'>setAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ii","yi");'>setAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ii","zi");'>setCode</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ii","Ai");'>setLanguage</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ii","Bi");'>setOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ii","Ci");'>setParent</a></div></div><div class='t'>Inhertied Values</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&bull;</span><a href='javascript:dO("ii","hi");'>ARGS</a></div></div></div><div id='il' class='cr'><div class='n'><a href='javascript:dS("il");'>IImportOperation</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("il","jl");'><span class='special __bases__'>IOperation</span></a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("il","kl");'>addOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("il","ll");'>copy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("il","ml");'>detach</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("il","nl");'>getAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("il","ol");'>getAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("il","pl");'>getDataFlow</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("il","ql");'>getOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("il","rl");'>getOpArguments</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("il","sl");'>getOpArgumentsInternalTypes</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("il","tl");'>getParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("il","ul");'>hasParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("il","vl");'>setAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("il","wl");'>setAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("il","xl");'>setOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("il","yl");'>setParent</a></div></div></div><div id='ib' class='cr'><div class='n'><a href='javascript:dS("ib");'>IAccessOperation</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("ib","jb");'><span class='special __bases__'>ISubsetOperation</span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ib","kb");'>getIndex</a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ib","lb");'>addOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ib","mb");'>copy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ib","nb");'>detach</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ib","ob");'>getAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ib","pb");'>getAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ib","qb");'>getDataFlow</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ib","rb");'>getOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ib","sb");'>getOpArguments</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ib","tb");'>getOpArgumentsInternalTypes</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ib","ub");'>getParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ib","vb");'>getTarget</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ib","wb");'>hasParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ib","xb");'>setAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ib","yb");'>setAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ib","zb");'>setOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ib","Ab");'>setParent</a></div></div><div class='t'>Values</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&bull;</span><a href='javascript:dO("ib","Bb");'>ARGS</a></div></div></div><div id='iH' class='cr'><div class='n'><a href='javascript:dS("iH");'>Reporter</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("iH","c");'><span class='special __bases__'><i>Base class</i></span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("iH","jH");'><span class='special __init__'>constructor</span></a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("iH","kH");'>dedent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("iH","lH");'>echoError</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("iH","mH");'>echoWarning</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("iH","nH");'>error</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("iH","oH");'>indent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("iH","pH");'>info</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("iH","qH");'>isDone</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("iH","rH");'>onError</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("iH","sH");'>onWarning</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("iH","tH");'>warning</a></div></div></div><div id='Vl' class='cr'><div class='n'><a href='javascript:dS("Vl");'>IImportSymbolsOperation</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("Vl","Wl");'><span class='special __bases__'>IImportOperation</span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Vl","Xl");'>getImportOrigin</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Vl","Yl");'>getImportedElements</a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Vl","Zl");'>addOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Vl","am");'>copy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Vl","bm");'>detach</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Vl","cm");'>getAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Vl","dm");'>getAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Vl","em");'>getDataFlow</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Vl","fm");'>getOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Vl","gm");'>getOpArguments</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Vl","hm");'>getOpArgumentsInternalTypes</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Vl","im");'>getParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Vl","jm");'>hasParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Vl","km");'>setAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Vl","lm");'>setAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Vl","mm");'>setOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Vl","nm");'>setParent</a></div></div><div class='t'>Values</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&bull;</span><a href='javascript:dO("Vl","om");'>ARGS</a></div><div class='slot documented'><span
					class='prefix'>&bull;</span><a href='javascript:dO("Vl","pm");'>ARG_NAMES</a></div></div></div><div id='Vu' class='cr'><div class='n'><a href='javascript:dS("Vu");'>IResolution</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("Vu","Wu");'><span class='special __bases__'>IOperation</span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Vu","Xu");'>getContext</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Vu","Yu");'>getReference</a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Vu","Zu");'>addOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Vu","av");'>copy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Vu","bv");'>detach</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Vu","cv");'>getAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Vu","dv");'>getAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Vu","ev");'>getDataFlow</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Vu","fv");'>getOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Vu","gv");'>getOpArguments</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Vu","hv");'>getOpArgumentsInternalTypes</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Vu","iv");'>getParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Vu","jv");'>hasParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Vu","kv");'>setAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Vu","lv");'>setAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Vu","mv");'>setOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Vu","nv");'>setParent</a></div></div><div class='t'>Values</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&bull;</span><a href='javascript:dO("Vu","ov");'>ARGS</a></div></div></div><div id='d_bu' class='de'><h1>Method <span class='n'>hasSlot</span></h1><div class='re'><code>hasSlot( self, name )</code></div><div class='ds'><p>Tells if the context has a slot with the given name.</p></div></div><div id='d_bt' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_bw' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><p>Sets the given argument of this operation, by argument index.</p></div></div><div id='d_bv' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><p>Detaches the element from its parent (in case it was already attached). This should return this element, and set the parent to None.</p></div></div><div id='d_bq' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IMatchOperation at 0x7bfde0&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_bp' class='de'><h1>Class <span class='n'>IIteration</span></h1><div class='re'></div><div class='ds'><p>An iteration is the multiple application of a process given a set of values produced by an iterator.</p></div></div><div id='d_bs' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><p>Tells if this element has a parent or not</p></div></div><div id='d_br' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><p>Returns the <em>internal types</em> for this operations arguments. This is typically the list of interfaces or @protocols that the arguments must comply to.</p></div></div><div id='d_by' class='de'><h1>Method <span class='n'>createClosure</span></h1><div class='re'><code>createClosure( self, arguments )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_bx' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_bz' class='de'><h1>Function <span class='n'>_flatten</span></h1><div class='re'><code>_flatten( value, res )</code></div><div class='ds'><p>Flatten helper operation. See <code>flatten</code></p></div></div><div id='d_be' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_bd' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><p>Returns the arguments to this operation.</p></div></div><div id='d_bg' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_bf' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><p>Adds an argument to this operation. This should do checking of arguments (by expected internal type and number).</p></div></div><div id='d_bc' class='de'><h1>Method <span class='n'>getDefaultValue</span></h1><div class='re'><code>getDefaultValue( self )</code></div><div class='ds'><p>Returns the @methodault value for this slot.</p></div></div><div id='d_bb' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_bm' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><p>Detaches the element from its parent (in case it was already attached). This should return this element, and set the parent to None.</p></div></div><div id='d_bl' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><p>Tells if this element has a parent or not</p></div></div><div id='d_bo' class='de'><h1>Method <span class='n'>getParentClasses</span></h1><div class='re'><code>getParentClasses( self )</code></div><div class='ds'><p>Returns the list of inherited classes references.</p></div></div><div id='d_bn' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><p>Returns the ith arguments to this operation.</p></div></div><div id='d_bi' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns this element parent</p></div></div><div id='d_bh' class='de'><h1>Method <span class='n'>setAbstract</span></h1><div class='re'><code>setAbstract( self, isAbstract )</code></div><div class='ds'><p>Sets wether the given abstractable is abstract or not.</p></div></div><div id='d_bk' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_bj' class='de'><h1>Method <span class='n'>setResultAbstractType</span></h1><div class='re'><code>setResultAbstractType( self, abstractType )</code></div><div class='ds'><p>Sets the abstract type for this operation result. This is usually invoked in the typing phase.</p></div></div><div id='d_bE' class='de'><h1>Method <span class='n'>getCurrentClassParents</span></h1><div class='re'><code>getCurrentClassParents( self, theClass )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_bD' class='de'><h1>Method <span class='n'>clone</span></h1><div class='re'><code>clone( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_bG' class='de'><h1>Method <span class='n'>getCurrentClassParents</span></h1><div class='re'><code>getCurrentClassParents( self, theClass )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_bF' class='de'><h1>Method <span class='n'>isIn</span></h1><div class='re'><code>isIn( self, interface )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_bA' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self, contentType, name=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_bC' class='de'><h1>Method <span class='n'>__call__</span></h1><div class='re'><code>__call__( self )</code></div><div class='ds'><p>A type instance can be used as a class to construct a new type, which will be cloned from the current type.</p></div></div><div id='d_bB' class='de'><h1>Method <span class='n'>get</span></h1><div class='re'><code>get( self, name )</code></div><div class='ds'><p>Returns the type for the slot with the given name.</p></div></div><div id='d_bH' class='de'><h1>Method <span class='n'>run</span></h1><div class='re'><code>run( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_FA' class='de'><h1>Method <span class='n'>name</span></h1><div class='re'><code>name( self, name=None )</code></div><div class='ds'><p>Returns/sets the name for this type. By defaults, types are unnamed.</p></div></div><div id='d_FC' class='de'><h1>Class <span class='n'>Symbolic</span></h1><div class='re'></div><div class='ds'><p>Symbolic types are types that have no physical counter part but play a role in the type system. This is for instance the case with Any or Nil.</p></div></div><div id='d_FB' class='de'><h1>Method <span class='n'>__str__</span></h1><div class='re'><code>__str__( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_FE' class='de'><h1>Method <span class='n'>onModule</span></h1><div class='re'><code>onModule( self, module )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_FD' class='de'><h1>Function <span class='n'>Sequence_combine</span></h1><div class='re'><code>Sequence_combine( a, b, sequenceclass=<class lambdafactory.typecast.Sequence at 0x120e9f0> )</code></div><div class='ds'><p>Combines the given arguments into a sequence. This follows the following rules: Nothing, Nothing -&gt; Nothing Nothing, A -&gt; A A, B -&gt; (A, B) (A, B), C -&gt; (A, B, C) ( type = type(a) ) (A, B), (C, D) -&gt; (A, B, C, D) ( type = type(a) ) A , (C, D) -&gt; (A, B, C) ( type = sequenceclass)</p></div></div><div id='d_FG' class='de'><h1>Method <span class='n'>getCurrentClassAncestors</span></h1><div class='re'><code>getCurrentClassAncestors( self, theClass=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_FF' class='de'><h1>Method <span class='n'>getFactory</span></h1><div class='re'><code>getFactory( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Fy' class='de'><h1>Method <span class='n'>slice</span></h1><div class='re'><code>slice( self, target, _start, _end=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Fx' class='de'><h1>Method <span class='n'>_attr</span></h1><div class='re'><code>_attr( self, name, typeinfo=None, value=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Fz' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.typecast.Sequence at 0x120e9f0&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Fq' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_Fp' class='de'><h1>Method <span class='n'>getResultAbstractType</span></h1><div class='re'><code>getResultAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type of the result of the evaluation of this evaluable</p></div></div><div id='d_Fs' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><p>Adds an argument to this operation. This should do checking of arguments (by expected internal type and number).</p></div></div><div id='d_Fr' class='de'><h1>Method <span class='n'>setAbstract</span></h1><div class='re'><code>setAbstract( self, isAbstract )</code></div><div class='ds'><p>Sets wether the given abstractable is abstract or not.</p></div></div><div id='d_Fu' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><p>Adds an argument to this operation. This should do checking of arguments (by expected internal type and number).</p></div></div><div id='d_Ft' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_Fw' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_Fv' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_Fi' class='de'><h1>Method <span class='n'>getEnd</span></h1><div class='re'><code>getEnd( self )</code></div><div class='ds'><p>Returns this enumeration end.</p></div></div><div id='d_Fh' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_Fk' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><p>Returns the <em>internal types</em> for this operations arguments. This is typically the list of interfaces or @protocols that the arguments must comply to.</p></div></div><div id='d_Fj' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><p>Returns the ith arguments to this operation.</p></div></div><div id='d_Fm' class='de'><h1>Method <span class='n'>getSlots</span></h1><div class='re'><code>getSlots( self )</code></div><div class='ds'><p>Returns (key, evaluable) pairs representing the slots within this context.</p></div></div><div id='d_Fl' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><p>Performs a deep clone of this element. Any mutation to the original won't change the copy.</p></div></div><div id='d_Fo' class='de'><h1>Method <span class='n'>getArguments</span></h1><div class='re'><code>getArguments( self )</code></div><div class='ds'><p>Returns a list of arguments (which are names associated with optional type information.</p></div></div><div id='d_Fn' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='Hc' class='cr'><div class='n'><a href='javascript:dS("Hc");'>IAttribute</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("Hc","Ic");'><span class='special __bases__'>ISlot</span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Hc","Jc");'>getDefaultValue</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Hc","Kc");'>setDefaultValue</a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Hc","Lc");'>getAbsoluteName</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Hc","Mc");'>getName</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Hc","Nc");'>getTypeDescription</a></div></div></div><div id='d_Fc' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><p>Sets this element parent</p></div></div><div id='d_Fb' class='de'><h1>Method <span class='n'>getSlotToAllocate</span></h1><div class='re'><code>getSlotToAllocate( self )</code></div><div class='ds'><p>Returns slot to be allocated by this operation.</p></div></div><div id='d_Fe' class='de'><h1>Method <span class='n'>getSlot</span></h1><div class='re'><code>getSlot( self, name )</code></div><div class='ds'><p>Returns the given evaluable bound to named slot.</p></div></div><div id='Hg' class='cr'><div class='n'><a href='javascript:dS("Hg");'>IDestructor</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("Hg","Ig");'><span class='special __bases__'>IMethod</span></a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Hg","Jg");'>addOperation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Hg","Kg");'>copy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Hg","Lg");'>detach</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Hg","Mg");'>endsWithTermination</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Hg","Ng");'>getAbsoluteName</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Hg","Og");'>getAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Hg","Pg");'>getAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Hg","Qg");'>getArguments</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Hg","Rg");'>getDataFlow</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Hg","Sg");'>getName</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Hg","Tg");'>getOperations</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Hg","Ug");'>getParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Hg","Vg");'>getSlot</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Hg","Wg");'>getSlots</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Hg","Xg");'>hasExplicitTermination</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Hg","Yg");'>hasParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Hg","Zg");'>hasSlot</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Hg","ah");'>isAbstract</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Hg","bh");'>setAbstract</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Hg","ch");'>setAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Hg","dh");'>setAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Hg","eh");'>setArguments</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Hg","fh");'>setParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Hg","gh");'>setSlot</a></div></div></div><div id='d_Fg' class='de'><h1>Method <span class='n'>getOrigin</span></h1><div class='re'><code>getOrigin( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Ff' class='de'><h1>Method <span class='n'>getSlot</span></h1><div class='re'><code>getSlot( self, name )</code></div><div class='ds'><p>Returns the given evaluable bound to named slot.</p></div></div><div id='d_tC' class='de'><h1>Method <span class='n'>isSubtypeOf</span></h1><div class='re'><code>isSubtypeOf( self, otherType )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_tB' class='de'><h1>Method <span class='n'>add</span></h1><div class='re'><code>add( self, name, theType )</code></div><div class='ds'><p>This is a <em>deprecated</em> methods that is simply an alias for <code>Map.set</code>.</p></div></div><div id='d_tA' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.typecast.Type at 0x120e900&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_tG' class='de'><h1>Method <span class='n'>resolveLocalOrAbsolute</span></h1><div class='re'><code>resolveLocalOrAbsolute( self, referenceOrName, contextOrDataFlow=None )</code></div><div class='ds'><p>Tries a local resolution first, then will look in the program scope if it fails.</p></div></div><div id='d_tF' class='de'><h1>Method <span class='n'>findInContext</span></h1><div class='re'><code>findInContext( self, interface )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_tE' class='de'><h1>Method <span class='n'>resolveAbsolute</span></h1><div class='re'><code>resolveAbsolute( self, referenceOrName )</code></div><div class='ds'><p>Resolves the given reference or string expressed in absolute style (<code>.</code>-separated list of names), starting from the root dataflow (the program dataflow).</p></div></div><div id='d_tD' class='de'><h1>Method <span class='n'>concreteType</span></h1><div class='re'><code>concreteType( self )</code></div><div class='ds'><p>Returns the <span class='term'>concrete type</span> for this abstract type.</p></div></div><div id='d_tH' class='de'><h1>Method <span class='n'>warning</span></h1><div class='re'><code>warning( self, message, element=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_tc' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><p>Detaches the element from its parent (in case it was already attached). This should return this element, and set the parent to None.</p></div></div><div id='d_tb' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><p>Returns the <em>internal types</em> for this operations arguments. This is typically the list of interfaces or @protocols that the arguments must comply to.</p></div></div><div id='d_tg' class='de'><h1>Method <span class='n'>getSlot</span></h1><div class='re'><code>getSlot( self, name )</code></div><div class='ds'><p>Returns the slot with the given name, if any.</p></div></div><div id='d_tf' class='de'><h1>Method <span class='n'>addOperation</span></h1><div class='re'><code>addOperation( self, operation )</code></div><div class='ds'><p>Adds the given operation as a child of this process.</p></div></div><div id='d_te' class='de'><h1>Class <span class='n'>IClosure</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_td' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><p>Returns this class name. It can be <code>None</code> if the class is anonymous.</p></div></div><div id='d_tk' class='de'><h1>Class <span class='n'>IImportModuleOperation</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_tj' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><p>Sets this element parent</p></div></div><div id='d_ti' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><p>Returns the arguments to this operation.</p></div></div><div id='d_th' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_to' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_tn' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><p>Adds an argument to this operation. This should do checking of arguments (by expected internal type and number).</p></div></div><div id='d_tm' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><p>Performs a deep clone of this element. Any mutation to the original won't change the copy.</p></div></div><div id='d_tl' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns this element parent</p></div></div><div id='d_ts' class='de'><h1>Method <span class='n'>getActualValue</span></h1><div class='re'><code>getActualValue( self )</code></div><div class='ds'><p>Returns the (implementation language) value for this literal</p></div></div><div id='d_tr' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_tq' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><p>Sets this element parent</p></div></div><div id='d_tp' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><p>Sets this element parent</p></div></div><div id='d_tw' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><p>Tells if this element has a parent or not</p></div></div><div id='d_tv' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><p>Adds an argument to this operation. This should do checking of arguments (by expected internal type and number).</p></div></div><div id='d_tu' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><p>Returns the local name for this referencable element</p></div></div><div id='d_tt' class='de'><h1>Method <span class='n'>isByName</span></h1><div class='re'><code>isByName( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_tz' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.modeltypes.TypeCollection at 0x120e0f0&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_ty' class='de'><h1>Method <span class='n'>importSymbol</span></h1><div class='re'><code>importSymbol( self, name, origin, alias )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_tx' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_Hw' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><p>Returns the ith arguments to this operation.</p></div></div><div id='d_Hv' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><p>Sets this element parent</p></div></div><div id='d_Hu' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><p>Detaches the element from its parent (in case it was already attached). This should return this element, and set the parent to None.</p></div></div><div id='d_Ht' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><p>Sets this element parent</p></div></div><div id='d_Hs' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><p>Returns the arguments to this operation.</p></div></div><div id='d_Hr' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_Hq' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><p>Returns the arguments to this operation.</p></div></div><div id='d_Hp' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_Hz' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self, *args )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Hy' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self, someClass, expectedClass, argument )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Hx' class='de'><h1>Method <span class='n'>_dict</span></h1><div class='re'><code>_dict( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Hg' class='de'><h1>Class <span class='n'>IDestructor</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Hf' class='de'><h1>Method <span class='n'>hasExplicitTermination</span></h1><div class='re'><code>hasExplicitTermination( self )</code></div><div class='ds'><p>Returns true if this function has an operation with a termination, otherwise return false.</p></div></div><div id='d_He' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><p>Tells if this element has a parent or not</p></div></div><div id='d_Hd' class='de'><h1>Method <span class='n'>hasSlot</span></h1><div class='re'><code>hasSlot( self, name )</code></div><div class='ds'><p>Tells if the context has a slot with the given name.</p></div></div><div id='d_Hc' class='de'><h1>Class <span class='n'>IAttribute</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Hb' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><p>Performs a deep clone of this element. Any mutation to the original won't change the copy.</p></div></div><div id='d_Ho' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IOperation at 0x7bfae0&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Hn' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><p>Sets this element parent</p></div></div><div id='d_Hm' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><p>Tells if this element has a parent or not</p></div></div><div id='d_Hl' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_Hk' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><p>Tells if this element has a parent or not</p></div></div><div id='d_Hj' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><p>Returns the <em>internal types</em> for this operations arguments. This is typically the list of interfaces or @protocols that the arguments must comply to.</p></div></div><div id='d_Hi' class='de'><h1>Method <span class='n'>getStep</span></h1><div class='re'><code>getStep( self )</code></div><div class='ds'><p>Returns this enumeration step.</p></div></div><div id='d_Hh' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns this element parent</p></div></div><div id='d_HG' class='de'><h1>Method <span class='n'>getCurrentClosure</span></h1><div class='re'><code>getCurrentClosure( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_HF' class='de'><h1>Method <span class='n'>getProgram</span></h1><div class='re'><code>getProgram( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_HE' class='de'><h1>Method <span class='n'>filterContext</span></h1><div class='re'><code>filterContext( self, interface )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_HD' class='de'><h1>Function <span class='n'>bits</span></h1><div class='re'><code>bits( size )</code></div><div class='ds'><p>Converts the given number of bits into bytes. This is simply for readibility purprose.</p></div></div><div id='d_HC' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self, name )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_HB' class='de'><h1>Method <span class='n'>definedBy</span></h1><div class='re'><code>definedBy( self, definition=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_HA' class='de'><h1>Method <span class='n'>setConcreteType</span></h1><div class='re'><code>setConcreteType( self, value )</code></div><div class='ds'><p>Sets the <span class='term'>concrete type</span> for this abstract type. The concrete type is a value which represents the type. For instance, if this type represents a class, then the concrete type would be the class instance.</p></div></div><div id='no' class='cr'><div class='n'><a href='javascript:dS("no");'>IInterruption</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("no","oo");'><span class='special __bases__'>IOperation</span></a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("no","po");'>addOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("no","qo");'>copy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("no","ro");'>detach</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("no","so");'>getAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("no","to");'>getAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("no","uo");'>getDataFlow</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("no","vo");'>getOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("no","wo");'>getOpArguments</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("no","xo");'>getOpArgumentsInternalTypes</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("no","yo");'>getParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("no","zo");'>hasParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("no","Ao");'>setAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("no","Bo");'>setAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("no","Co");'>setOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("no","Do");'>setParent</a></div></div></div><div id='nc' class='cr'><div class='n'><a href='javascript:dS("nc");'>IAssignation</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("nc","oc");'><span class='special __bases__'>IOperation</span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("nc","pc");'>getAssignedValue</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("nc","qc");'>getTarget</a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("nc","rc");'>addOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("nc","sc");'>copy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("nc","tc");'>detach</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("nc","uc");'>getAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("nc","vc");'>getAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("nc","wc");'>getDataFlow</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("nc","xc");'>getOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("nc","yc");'>getOpArguments</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("nc","zc");'>getOpArgumentsInternalTypes</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("nc","Ac");'>getParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("nc","Bc");'>hasParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("nc","Cc");'>setAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("nc","Dc");'>setAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("nc","Ec");'>setOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("nc","Fc");'>setParent</a></div></div><div class='t'>Values</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&bull;</span><a href='javascript:dO("nc","Gc");'>ARGS</a></div></div></div><div id='nx' class='cr'><div class='n'><a href='javascript:dS("nx");'>IValue</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("nx","ox");'><span class='special __bases__'>IElement, IEvaluable</span></a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("nx","px");'>copy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("nx","qx");'>detach</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("nx","rx");'>getAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("nx","sx");'>getAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("nx","tx");'>getDataFlow</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("nx","ux");'>getParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("nx","vx");'>getResultAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("nx","wx");'>hasParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("nx","xx");'>setAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("nx","yx");'>setAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("nx","zx");'>setParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("nx","Ax");'>setResultAbstractType</a></div></div></div><div id='nt' class='cr'><div class='n'><a href='javascript:dS("nt");'>IParameter</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("nt","ot");'><span class='special __bases__'>IElement</span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("nt","pt");'>getName</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("nt","qt");'>getValue</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("nt","rt");'>isAsList</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("nt","st");'>isAsMap</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("nt","tt");'>isByName</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("nt","ut");'>setAsList</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("nt","vt");'>setAsMap</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("nt","wt");'>setByName</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("nt","xt");'>setValue</a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("nt","yt");'>copy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("nt","zt");'>detach</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("nt","At");'>getAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("nt","Bt");'>getAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("nt","Ct");'>getDataFlow</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("nt","Dt");'>getParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("nt","Et");'>hasParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("nt","Ft");'>setAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("nt","Gt");'>setAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("nt","Ht");'>setParent</a></div></div></div><div id='d_ZE' class='de'><h1>Method <span class='n'>handle</span></h1><div class='re'><code>handle( self, element )</code></div><div class='ds'><p>Handles a sungle element, without recursing through its children</p></div></div><div id='d_ZD' class='de'><h1>Method <span class='n'>getCurrentClass</span></h1><div class='re'><code>getCurrentClass( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_ZG' class='de'><h1>Method <span class='n'>resolveAbsoluteOrLocal</span></h1><div class='re'><code>resolveAbsoluteOrLocal( self, referenceOrName, contextOrDataFlow=None )</code></div><div class='ds'><p>Tries an absolute resolution first, then will look in the local scope if it fails.</p></div></div><div id='d_ZF' class='de'><h1>Method <span class='n'>getCurrentClass</span></h1><div class='re'><code>getCurrentClass( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_ZA' class='de'><h1>Method <span class='n'>definedBy</span></h1><div class='re'><code>definedBy( self, definition=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_ZC' class='de'><h1>Method <span class='n'>__str__</span></h1><div class='re'><code>__str__( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_ZB' class='de'><h1>Method <span class='n'>peel</span></h1><div class='re'><code>peel( self )</code></div><div class='ds'><p>If this process is (A, B)-&gt;C, will return (B)-&gt;C. You cannot peel a process that is (B)-&gt;C.</p></div></div><div id='d_Zm' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_Zl' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><p>Adds an argument to this operation. This should do checking of arguments (by expected internal type and number).</p></div></div><div id='d_Zo' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><p>Sets this element parent</p></div></div><div id='d_Zn' class='de'><h1>Method <span class='n'>getOperations</span></h1><div class='re'><code>getOperations( self )</code></div><div class='ds'><p>Returns the operations (methods and class methods) defined within this class.</p></div></div><div id='d_Zi' class='de'><h1>Class <span class='n'>IEvaluable</span></h1><div class='re'></div><div class='ds'><p>An evaluable is an element that can produce a value. Evaluable elements then have associated type information.</p></div></div><div id='d_Zh' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><p>Returns the arguments to this operation.</p></div></div><div id='d_Zk' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><p>Returns the <em>internal types</em> for this operations arguments. This is typically the list of interfaces or @protocols that the arguments must comply to.</p></div></div><div id='d_Zj' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_Ze' class='de'><h1>Method <span class='n'>setOperator</span></h1><div class='re'><code>setOperator( self, operator )</code></div><div class='ds'><p>Sets the operator for this computation</p></div></div><div id='d_Zd' class='de'><h1>Method <span class='n'>getAbsoluteName</span></h1><div class='re'><code>getAbsoluteName( self )</code></div><div class='ds'><p>Returns the absolute name for this element</p></div></div><div id='d_Zg' class='de'><h1>Method <span class='n'>hasSlot</span></h1><div class='re'><code>hasSlot( self, name )</code></div><div class='ds'><p>Tells if the context has a slot with the given name.</p></div></div><div id='d_Zf' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><p>Performs a deep clone of this element. Any mutation to the original won't change the copy.</p></div></div><div id='d_Zc' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_Zb' class='de'><h1>Class <span class='n'>IArgument</span></h1><div class='re'></div><div class='ds'><p>Arguments are slots which can be interpreted in different ways.</p><p>When an argument is <span class='term'>optional</span>, it does not need to be defined in the invocation. When an argument is <span class='term'>variable</span>, it means it references the rest of the arguments lists. When an argument is <span class='term'>keywords</span>, it will reference the named arguments of the rest of the arguments list.</p></div></div><div id='d_Zy' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.IProgram at 0x7bf8d0&gt;, &lt;class lambdafactory.interfaces.IClass at 0x7bf810&gt;, &lt;class lambdafactory.interfaces.IModule at 0x7bf8a0&gt;, &lt;class lambdafactory.interfaces.IDestructor at 0x7bfa50&gt;, &lt;class lambdafactory.interfaces.IConstructor at 0x7bfa20&gt;, &lt;class lambdafactory.interfaces.IClassMethod at 0x7bfab0&gt;, &lt;class lambdafactory.interfaces.IMethod at 0x7bf9f0&gt;, &lt;class lambdafactory.interfaces.IFunction at 0x7bf9c0&gt;, &lt;class lambdafactory.interfaces.IClosure at 0x7bf990&gt;, &lt;class lambdafactory.interfaces.IBlock at 0x7bf960&gt;, &lt;class lambdafactory.interfaces.IModuleAttribute at 0x7bf780&gt;, &lt;class lambdafactory.interfaces.IClassAttribute at 0x7bf7b0&gt;, &lt;class lambdafactory.interfaces.IAttribute at 0x7bf750&gt;, &lt;class lambdafactory.interfaces.IArgument at 0x7bf6f0&gt;, &lt;class lambdafactory.interfaces.IParameter at 0x7bf720&gt;, &lt;class lambdafactory.interfaces.IOperator at 0x7bf690&gt;, &lt;class lambdafactory.interfaces.IReference at 0x7bf630&gt;, &lt;class lambdafactory.interfaces.INumber at 0x7bf570&gt;, &lt;class lambdafactory.interfaces.IString at 0x7bf5a0&gt;, &lt;class lambdafactory.interfaces.IList at 0x7bf5d0&gt;, &lt;class lambdafactory.interfaces.IDict at 0x7bf600&gt;, &lt;class lambdafactory.interfaces.IEnumeration at 0x7bfed0&gt;, &lt;class lambdafactory.interfaces.IAllocation at 0x7bfc60&gt;, &lt;class lambdafactory.interfaces.IAssignation at 0x7bfc30&gt;, &lt;class lambdafactory.interfaces.IComputation at 0x7bfcc0&gt;, &lt;class lambdafactory.interfaces.IInvocation at 0x7bfcf0&gt;, &lt;class lambdafactory.interfaces.IInstanciation at 0x7bfd20&gt;, &lt;class lambdafactory.interfaces.IResolution at 0x7bfc90&gt;, &lt;class lambdafactory.interfaces.ISelection at 0x7bfe70&gt;, &lt;class lambdafactory.interfaces.IRepetition at 0x7bff00&gt;, &lt;class lambdafactory.interfaces.IIteration at 0x7bfea0&gt;, &lt;class lambdafactory.interfaces.IAccessOperation at 0x7bfd80&gt;, &lt;class lambdafactory.interfaces.ISliceOperation at 0x7bfdb0&gt;, &lt;class lambdafactory.interfaces.IEvaluation at 0x7bfc00&gt;, &lt;class lambdafactory.interfaces.ITermination at 0x7bff30&gt;, &lt;class lambdafactory.interfaces.IBreaking at 0x7bff90&gt;, &lt;class lambdafactory.interfaces.IExcept at 0x7bffc0&gt;, &lt;class lambdafactory.interfaces.IInterception at 0x1174030&gt;, &lt;class lambdafactory.interfaces.IImportSymbolOperation at 0x7bfb40&gt;, &lt;class lambdafactory.interfaces.IImportSymbolsOperation at 0x7bfb70&gt;, &lt;class lambdafactory.interfaces.IImportModuleOperation at 0x7bfba0&gt;, &lt;class lambdafactory.interfaces.IImportModulesOperation at 0x7bfbd0&gt;, &lt;class lambdafactory.interfaces.IEmbed at 0x1174060&gt;]</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='d_Zx' class='de'><h1>Method <span class='n'>createClass</span></h1><div class='re'><code>createClass( self, name, inherited=() )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Zz' class='de'><h1>Class <span class='n'>Array</span></h1><div class='re'></div><div class='ds'><p>A sequence is simply an ordered set of types.</p></div></div><div id='d_Zu' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><p>Adds an argument to this operation. This should do checking of arguments (by expected internal type and number).</p></div></div><div id='d_Zt' class='de'><h1>Method <span class='n'>getSlots</span></h1><div class='re'><code>getSlots( self )</code></div><div class='ds'><p>Returns (key, evaluable) pairs representing the slots within this context.</p></div></div><div id='d_Zw' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><p>Detaches the element from its parent (in case it was already attached). This should return this element, and set the parent to None.</p></div></div><div id='d_Zv' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_Zq' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><p>Returns the ith arguments to this operation.</p></div></div><div id='d_Zp' class='de'><h1>Method <span class='n'>setResultAbstractType</span></h1><div class='re'><code>setResultAbstractType( self, abstractType )</code></div><div class='ds'><p>Sets the abstract type for this operation result. This is usually invoked in the typing phase.</p></div></div><div id='d_Zs' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><p>Detaches the element from its parent (in case it was already attached). This should return this element, and set the parent to None.</p></div></div><div id='d_Zr' class='de'><h1>Method <span class='n'>getSlot</span></h1><div class='re'><code>getSlot( self, name )</code></div><div class='ds'><p>Returns the given evaluable bound to named slot.</p></div></div><div id='d_ep' class='de'><h1>Method <span class='n'>getIterator</span></h1><div class='re'><code>getIterator( self )</code></div><div class='ds'><p>Returns this iteration iterator.</p></div></div><div id='d_eq' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><p>Adds an argument to this operation. This should do checking of arguments (by expected internal type and number).</p></div></div><div id='d_er' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><p>Tells if this element has a parent or not</p></div></div><div id='d_es' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_et' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><p>Returns the local name for this referencable element</p></div></div><div id='d_eu' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, context )</code></div><div class='ds'><p>Sets the parent context for this context.</p></div></div><div id='d_ev' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_ew' class='de'><h1>Class <span class='n'>ISlot</span></h1><div class='re'></div><div class='ds'><p>An argument is a reference with additional type information.</p></div></div><div id='d_ex' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><p>Returns the arguments to this operation.</p></div></div><div id='d_ey' class='de'><h1>Method <span class='n'>createDataFlowSlot</span></h1><div class='re'><code>createDataFlowSlot( self, name, value, origin, slotType )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_ez' class='de'><h1>Function <span class='n'>format</span></h1><div class='re'><code>format( *values )</code></div><div class='ds'><p>Formats a combination of string ang tuples. Strings are joined by newlines, and the content of the inner tuples gets indented</p></div></div><div id='d_eb' class='de'><h1>Method <span class='n'>setSlot</span></h1><div class='re'><code>setSlot( self, name, evaluable )</code></div><div class='ds'><p>Binds the given evaluable to the named slot.</p></div></div><div id='d_ec' class='de'><h1>Method <span class='n'>isRest</span></h1><div class='re'><code>isRest( self )</code></div><div class='ds'><p>Tells if this argument represents &ldquo;<span class='quote'>the rest</span>&rdquo; of arguments in the invocation</p></div></div><div id='d_ed' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><p>Tells if this element has a parent or not</p></div></div><div id='d_ee' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><p>Returns this @protocol name. It can be <code>None</code> if the @protocol is anonymous.</p></div></div><div id='d_ef' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_eg' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><p>Tells if this element has a parent or not</p></div></div><div id='d_eh' class='de'><h1>Method <span class='n'>setArguments</span></h1><div class='re'><code>setArguments( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_ei' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_ej' class='de'><h1>Method <span class='n'>getEvaluable</span></h1><div class='re'><code>getEvaluable( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_ek' class='de'><h1>Method <span class='n'>getSlot</span></h1><div class='re'><code>getSlot( self, name )</code></div><div class='ds'><p>Returns the given evaluable bound to named slot.</p></div></div><div id='d_el' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><p>Sets the given argument of this operation, by argument index.</p></div></div><div id='d_em' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_en' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns this element parent</p></div></div><div id='d_eo' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><p>Tells if this element has a parent or not</p></div></div><div id='d_eA' class='de'><h1>Method <span class='n'>isLike</span></h1><div class='re'><code>isLike( self, otherType )</code></div><div class='ds'><p>Othertype must be an Array with a content type that is the same type as the content type.</p></div></div><div id='d_eB' class='de'><h1>Method <span class='n'>isSubtypeOf</span></h1><div class='re'><code>isSubtypeOf( self, otherType )</code></div><div class='ds'><p>The other type is a subtype of this one if for each element of this type, we find that the other type has a subtype.</p></div></div><div id='d_eC' class='de'><h1>Method <span class='n'>definedBy</span></h1><div class='re'><code>definedBy( self, definition=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_eD' class='de'><h1>Method <span class='n'>isLike</span></h1><div class='re'><code>isLike( self, otherType )</code></div><div class='ds'><p>Generic implementation of isLike. You should always call this method in subclasses, as it implements basic type systems rules such as isLike(Any).</p></div></div><div id='d_eE' class='de'><h1>Method <span class='n'>getCurrentDataFlow</span></h1><div class='re'><code>getCurrentDataFlow( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_eF' class='de'><h1>Method <span class='n'>resolveAbsoluteOrLocal</span></h1><div class='re'><code>resolveAbsoluteOrLocal( self, referenceOrName, contextOrDataFlow=None )</code></div><div class='ds'><p>Tries an absolute resolution first, then will look in the local scope if it fails.</p></div></div><div id='d_eG' class='de'><h1>Method <span class='n'>getCurrentDataFlow</span></h1><div class='re'><code>getCurrentDataFlow( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_eH' class='de'><h1>Method <span class='n'>walk</span></h1><div class='re'><code>walk( self, element )</code></div><div class='ds'><p>Walks the given element, recursively walking the child elements when the handler does not return False</p></div></div><div id='d_Fd' class='de'><h1>Method <span class='n'>getSlots</span></h1><div class='re'><code>getSlots( self )</code></div><div class='ds'><p>Returns (key, evaluable) pairs representing the slots within this context.</p></div></div><div id='d_wF' class='de'><h1>Method <span class='n'>getCurrentClassParents</span></h1><div class='re'><code>getCurrentClassParents( self, theClass )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_wG' class='de'><h1>Method <span class='n'>setPass</span></h1><div class='re'><code>setPass( self, programPass )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_wD' class='de'><h1>Method <span class='n'>isSameAs</span></h1><div class='re'><code>isSameAs( self, otherType )</code></div><div class='ds'><p>Generic implementation of isSameAs. You should always call this method in subclasses.</p></div></div><div id='d_wE' class='de'><h1>Method <span class='n'>run</span></h1><div class='re'><code>run( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_wB' class='de'><h1>Method <span class='n'>element</span></h1><div class='re'><code>element( self, key )</code></div><div class='ds'><p>Returns the element associated to the given key.</p></div></div><div id='d_wC' class='de'><h1>Method <span class='n'>__str__</span></h1><div class='re'><code>__str__( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_wA' class='de'><h1>Method <span class='n'>clone</span></h1><div class='re'><code>clone( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_wn' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_wo' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><p>Returns the arguments to this operation.</p></div></div><div id='d_wl' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_wm' class='de'><h1>Method <span class='n'>getAbsoluteName</span></h1><div class='re'><code>getAbsoluteName( self )</code></div><div class='ds'><p>Returns the absolute name for this element</p></div></div><div id='d_wj' class='de'><h1>Class <span class='n'>IExcept</span></h1><div class='re'></div><div class='ds'><p>An interruption that raises some value</p></div></div><div id='d_wk' class='de'><h1>Method <span class='n'>getImportedModuleName</span></h1><div class='re'><code>getImportedModuleName( self )</code></div><div class='ds'><p>Returns the list of names representing the modules to load</p></div></div><div id='d_wh' class='de'><h1>Method <span class='n'>setResultAbstractType</span></h1><div class='re'><code>setResultAbstractType( self, abstractType )</code></div><div class='ds'><p>Sets the abstract type for this operation result. This is usually invoked in the typing phase.</p></div></div><div id='d_wi' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><p>Tells if this element has a parent or not</p></div></div><div id='d_wf' class='de'><h1>Method <span class='n'>endsWithTermination</span></h1><div class='re'><code>endsWithTermination( self )</code></div><div class='ds'><p>Returns true if this function ends with a termination operation. This is especially useful for back-ends which want to know if they have to insert an explicit <code>return</code> at the end (like Java).</p></div></div><div id='d_wg' class='de'><h1>Method <span class='n'>hasSlot</span></h1><div class='re'><code>hasSlot( self, name )</code></div><div class='ds'><p>Tells if this dataflow @methodines a slot with the given name.</p></div></div><div id='d_wd' class='de'><h1>Method <span class='n'>setParentClasses</span></h1><div class='re'><code>setParentClasses( self )</code></div><div class='ds'><p>gives the list of parent classes that will</p></div></div><div id='d_we' class='de'><h1>Method <span class='n'>setArguments</span></h1><div class='re'><code>setArguments( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_wb' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><p>Tells if this element has a parent or not</p></div></div><div id='d_wc' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_wz' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.modeltypes.TypeCollection at 0x120e0f0&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_wx' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><p>Tells if this element has a parent or not</p></div></div><div id='d_wy' class='de'><h1>Method <span class='n'>intercept</span></h1><div class='re'><code>intercept( self, tryProcess, catchProcess=None, finallyProcess=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_wv' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_ww' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><p>Sets this element parent</p></div></div><div id='d_wt' class='de'><h1>Method <span class='n'>setByName</span></h1><div class='re'><code>setByName( self, n )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_wu' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><p>Tells if this element has a parent or not</p></div></div><div id='d_wr' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><p>Returns this @protocol name. It can be <code>None</code> if the @protocol is anonymous.</p></div></div><div id='d_ws' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns this element parent</p></div></div><div id='d_wp' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IValue at 0x7bf510&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_wq' class='de'><h1>Class <span class='n'>IMatchOperation</span></h1><div class='re'></div><div class='ds'><p>A match operation is the binding of an expression and a process.</p></div></div><div id='Md' class='cr'><div class='n'><a href='javascript:dS("Md");'>IClassAttribute</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("Md","Nd");'><span class='special __bases__'>IAttribute</span></a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Md","Od");'>getAbsoluteName</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Md","Pd");'>getDefaultValue</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Md","Qd");'>getName</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Md","Rd");'>getTypeDescription</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Md","Sd");'>setDefaultValue</a></div></div></div><div id='Mh' class='cr'><div class='n'><a href='javascript:dS("Mh");'>IEmbed</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("Mh","Nh");'><span class='special __bases__'>IOperation</span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Mh","Oh");'>getCode</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Mh","Ph");'>getLanguage</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Mh","Qh");'>setCode</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Mh","Rh");'>setLanguage</a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Mh","Sh");'>addOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Mh","Th");'>copy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Mh","Uh");'>detach</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Mh","Vh");'>getAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Mh","Wh");'>getAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Mh","Xh");'>getDataFlow</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Mh","Yh");'>getOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Mh","Zh");'>getOpArguments</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Mh","ai");'>getOpArgumentsInternalTypes</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Mh","bi");'>getParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Mh","ci");'>hasParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Mh","di");'>setAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Mh","ei");'>setAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Mh","fi");'>setOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Mh","gi");'>setParent</a></div></div><div class='t'>Values</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&bull;</span><a href='javascript:dO("Mh","hi");'>ARGS</a></div></div></div><div id='d_Kr' class='de'><h1>Method <span class='n'>setSlot</span></h1><div class='re'><code>setSlot( self, name, evaluable )</code></div><div class='ds'><p>Binds the given evaluable to the named slot.</p></div></div><div id='d_Ks' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><p>Performs a deep clone of this element. Any mutation to the original won't change the copy.</p></div></div><div id='d_Kp' class='de'><h1>Method <span class='n'>setResultAbstractType</span></h1><div class='re'><code>setResultAbstractType( self, abstractType )</code></div><div class='ds'><p>Sets the abstract type for this operation result. This is usually invoked in the typing phase.</p></div></div><div id='d_Kq' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><p>Tells if this element has a parent or not</p></div></div><div id='d_Kv' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.ISubsetOperation at 0x7bfd50&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Kw' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns this element parent</p></div></div><div id='d_Kt' class='de'><h1>Method <span class='n'>getOperations</span></h1><div class='re'><code>getOperations( self )</code></div><div class='ds'><p>Returns the list of operations in this process.</p></div></div><div id='d_Ku' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_Kz' class='de'><h1>Method <span class='n'>asString</span></h1><div class='re'><code>asString( self, fromTypes=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Kx' class='de'><h1>Method <span class='n'>_moduleattr</span></h1><div class='re'><code>_moduleattr( self, name, typeinfo=None, value=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Ky' class='de'><h1>wrapper_descriptor</h1><div class='re'></div><div class='ds'><div class="section" level="1"><h1 class="heading"><span class="number"><span class="level0">1<span class="lastDot dot">.</span></span></span><span class='term'>str</span>_() &lt;==&gt; str(x)</h1><div class="level1"></div></div></div></div><div id='d_Kb' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_Kc' class='de'><h1>Method <span class='n'>setDefaultValue</span></h1><div class='re'><code>setDefaultValue( self )</code></div><div class='ds'><p>Sets the @methodault value for this attribute</p></div></div><div id='d_Kf' class='de'><h1>Method <span class='n'>isAbstract</span></h1><div class='re'><code>isAbstract( self )</code></div><div class='ds'><p>Tells wether the given abstractable is abstract or not.</p></div></div><div id='d_Kg' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><p>Performs a deep clone of this element. Any mutation to the original won't change the copy.</p></div></div><div id='d_Kd' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, context )</code></div><div class='ds'><p>Sets the parent context for this context.</p></div></div><div id='d_Ke' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_Kj' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_Kk' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><p>Sets the given argument of this operation, by argument index.</p></div></div><div id='d_Kh' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_Ki' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><p>Performs a deep clone of this element. Any mutation to the original won't change the copy.</p></div></div><div id='d_Kn' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IAbstractClass at 0x7bf840&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Ko' class='de'><h1>Method <span class='n'>isByPositionOnly</span></h1><div class='re'><code>isByPositionOnly( self )</code></div><div class='ds'><p>Tells if this invocation is only by position. Otherwise, some arguments are given by name, as list or as a map (and they should be handled in a specific way)</p></div></div><div id='d_Kl' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><p>Returns the ith arguments to this operation.</p></div></div><div id='d_Km' class='de'><h1>Method <span class='n'>setAbstract</span></h1><div class='re'><code>setAbstract( self, isAbstract )</code></div><div class='ds'><p>Sets wether the given abstractable is abstract or not.</p></div></div><div id='d_KB' class='de'><h1>Method <span class='n'>setConcreteType</span></h1><div class='re'><code>setConcreteType( self, value )</code></div><div class='ds'><p>Sets the <span class='term'>concrete type</span> for this abstract type. The concrete type is a value which represents the type. For instance, if this type represents a class, then the concrete type would be the class instance.</p></div></div><div id='d_KC' class='de'><h1>Method <span class='n'>__call__</span></h1><div class='re'><code>__call__( self )</code></div><div class='ds'><p>A type instance can be used as a class to construct a new type, which will be cloned from the current type.</p></div></div><div id='d_KA' class='de'><h1>Class <span class='n'>Context</span></h1><div class='re'></div><div class='ds'><p>The Context type is the type that will probably be the most used in OO languages. A context can inherit from other contexts, in which case there is an explicit subtyping relationship.</p></div></div><div id='d_KF' class='de'><h1>Method <span class='n'>isIn</span></h1><div class='re'><code>isIn( self, interface )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_KG' class='de'><h1>Method <span class='n'>getCurrentElement</span></h1><div class='re'><code>getCurrentElement( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_KD' class='de'><h1>Function <span class='n'>isSubtype</span></h1><div class='re'><code>isSubtype( a, b )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_KE' class='de'><h1>Method <span class='n'>getCurrentClassAncestors</span></h1><div class='re'><code>getCurrentClassAncestors( self, theClass=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_yd' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><p>Detaches the element from its parent (in case it was already attached). This should return this element, and set the parent to None.</p></div></div><div id='d_ye' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><p>Performs a deep clone of this element. Any mutation to the original won't change the copy.</p></div></div><div id='d_yf' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_yg' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, parent )</code></div><div class='ds'><p>Add the given dataflow as a parent of this dataflow.</p></div></div><div id='d_yb' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_yc' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><p>Returns the arguments to this operation.</p></div></div><div id='d_yl' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><p>Sets this element parent</p></div></div><div id='d_ym' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_yn' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_yo' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns this element parent</p></div></div><div id='d_yh' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IAnnotation at 0x7bf270&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_yi' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_yj' class='de'><h1>Method <span class='n'>getValue</span></h1><div class='re'><code>getValue( self )</code></div><div class='ds'><p>Returns the termination return evaluable.</p></div></div><div id='d_yk' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><p>Performs a deep clone of this element. Any mutation to the original won't change the copy.</p></div></div><div id='d_yt' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><p>Performs a deep clone of this element. Any mutation to the original won't change the copy.</p></div></div><div id='d_yu' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_yv' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_yw' class='de'><h1>Class <span class='n'>ISubsetOperation</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_yp' class='de'><h1>Method <span class='n'>getValues</span></h1><div class='re'><code>getValues( self )</code></div><div class='ds'><p>Returns the values within this list.</p></div></div><div id='d_yq' class='de'><h1>Method <span class='n'>getPredicate</span></h1><div class='re'><code>getPredicate( self )</code></div><div class='ds'><p>Returns the evaluable that acts as a predicate for this operation.</p></div></div><div id='d_yr' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns the parent context for this context (if any)</p></div></div><div id='d_ys' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><p>Tells if this element has a parent or not</p></div></div><div id='d_yx' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_yy' class='de'><h1>Method <span class='n'>iterate</span></h1><div class='re'><code>iterate( self, evaluable, process )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_yz' class='de'><h1>Class <span class='n'>TypeCollection</span></h1><div class='re'></div><div class='ds'><p>A type collection is a class that contains type definitions which can be easily retrieved using the @getType method.</p></div></div><div id='d_yD' class='de'><h1>Method <span class='n'>name</span></h1><div class='re'><code>name( self, name=None )</code></div><div class='ds'><p>Returns/sets the name for this type. By defaults, types are unnamed.</p></div></div><div id='d_yE' class='de'><h1>Method <span class='n'>setPass</span></h1><div class='re'><code>setPass( self, programPass )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_yF' class='de'><h1>Method <span class='n'>getCurrentContext</span></h1><div class='re'><code>getCurrentContext( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_yG' class='de'><h1>Class <span class='n'>TransformAsynchronousInvocations</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_yA' class='de'><h1>Method <span class='n'>isSameAs</span></h1><div class='re'><code>isSameAs( self, otherType )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_yB' class='de'><h1>Method <span class='n'>elements</span></h1><div class='re'><code>elements( self )</code></div><div class='ds'><p>Returns a dict of the elements in this map. Do not modify it.</p></div></div><div id='d_yC' class='de'><h1>Method <span class='n'>concreteType</span></h1><div class='re'><code>concreteType( self )</code></div><div class='ds'><p>Returns the <span class='term'>concrete type</span> for this abstract type.</p></div></div><div id='sA' class='cr'><div class='n'><a href='javascript:dS("sA");'>Cell</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("sA","tA");'><span class='special __bases__'>Type</span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("sA","uA");'><span class='special __init__'>constructor</span></a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("sA","vA");'>asString</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("sA","wA");'>clone</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("sA","xA");'>isLike</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("sA","yA");'>isSameAs</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("sA","zA");'>isSubtypeOf</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("sA","AA");'>length</a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("sA","BA");'><span class='special __call__'>when invoked</span></a></div><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("sA","CA");'><span class='special __str__'>string conversion</span></a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("sA","DA");'>concreteType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("sA","EA");'>definedBy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("sA","FA");'>name</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("sA","GA");'>result</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("sA","HA");'>setConcreteType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("sA","IA");'>setName</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("sA","JA");'>subtype</a></div></div></div><div id='sz' class='cr'><div class='n'><a href='javascript:dS("sz");'>Runtime</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("sz","tz");'><span class='special __bases__'>TypeCollection</span></a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("sz","uz");'>getType</a></div></div></div><div id='Ry' class='cr'><div class='n'><a href='javascript:dS("Ry");'>AbstractWriter</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("Ry","Sy");'><span class='special __bases__'>Pass</span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("Ry","Ty");'><span class='special __init__'>constructor</span></a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Ry","Uy");'><span class='protected'>_format</span></a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Ry","Vy");'><span class='protected'>_unique</span></a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Ry","Wy");'>onProgram</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Ry","Xy");'>run</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Ry","Yy");'>write</a></div></div><div class='t'>Values</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&bull;</span><a href='javascript:dO("Ry","Zy");'>HANDLES</a></div></div><div class='t'>Inhertied Values</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&bull;</span><a href='javascript:dO("Ry","az");'>NAME</a></div></div></div><div id='Re' class='cr'><div class='n'><a href='javascript:dS("Re");'>IComputation</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("Re","Se");'><span class='special __bases__'>IOperation</span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Re","Te");'>getLeftOperand</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Re","Ue");'>getOperand</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Re","Ve");'>getOperands</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Re","We");'>getOperator</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Re","Xe");'>getRightOperand</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Re","Ye");'>setLeftOperand</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Re","Ze");'>setOperator</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Re","af");'>setRightOperand</a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Re","bf");'>addOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Re","cf");'>copy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Re","df");'>detach</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Re","ef");'>getAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Re","ff");'>getAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Re","gf");'>getDataFlow</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Re","hf");'>getOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Re","if");'>getOpArguments</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Re","jf");'>getOpArgumentsInternalTypes</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Re","kf");'>getParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Re","lf");'>hasParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Re","mf");'>setAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Re","nf");'>setAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Re","of");'>setOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Re","pf");'>setParent</a></div></div><div class='t'>Values</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&bull;</span><a href='javascript:dO("Re","qf");'>ARGS</a></div></div></div><div id='Rf' class='cr'><div class='n'><a href='javascript:dS("Rf");'>IContext</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("Rf","Sf");'><span class='special __bases__'>IElement, IDataFlowOwner</span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Rf","Tf");'>getParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Rf","Uf");'>getSlot</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Rf","Vf");'>getSlots</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Rf","Wf");'>hasSlot</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Rf","Xf");'>setParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Rf","Yf");'>setSlot</a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Rf","Zf");'>copy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Rf","ag");'>detach</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Rf","bg");'>getAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Rf","cg");'>getAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Rf","dg");'>getDataFlow</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Rf","eg");'>hasParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Rf","fg");'>setAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Rf","gg");'>setAnnotation</a></div></div></div><div id='Rm' class='cr'><div class='n'><a href='javascript:dS("Rm");'>IInstanciation</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("Rm","Sm");'><span class='special __bases__'>IOperation</span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Rm","Tm");'>getArguments</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Rm","Um");'>getInstanciable</a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Rm","Vm");'>addOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Rm","Wm");'>copy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Rm","Xm");'>detach</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Rm","Ym");'>getAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Rm","Zm");'>getAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Rm","an");'>getDataFlow</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Rm","bn");'>getOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Rm","cn");'>getOpArguments</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Rm","dn");'>getOpArgumentsInternalTypes</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Rm","en");'>getParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Rm","fn");'>hasParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Rm","gn");'>setAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Rm","hn");'>setAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Rm","in");'>setOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Rm","jn");'>setParent</a></div></div><div class='t'>Values</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&bull;</span><a href='javascript:dO("Rm","kn");'>ARGS</a></div></div></div><div id='RD' class='cr'><div class='n'><a href='javascript:dS("RD");'>DocumentationPass</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("RD","SD");'><span class='special __bases__'>Pass</span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("RD","TD");'><span class='special __init__'>constructor</span></a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("RD","UD");'>asHTML</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("RD","VD");'>onModule</a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("RD","WD");'>filter</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("RD","XD");'>filterContext</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("RD","YD");'>findInContext</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("RD","ZD");'>getCurrentClass</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("RD","aE");'>getCurrentClassAncestors</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("RD","bE");'>getCurrentClassParents</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("RD","cE");'>getCurrentClosure</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("RD","dE");'>getCurrentContext</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("RD","eE");'>getCurrentDataFlow</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("RD","fE");'>getCurrentElement</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("RD","gE");'>getCurrentFunction</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("RD","hE");'>getCurrentMethod</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("RD","iE");'>getCurrentModule</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("RD","jE");'>getCurrentProcess</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("RD","kE");'>getFactory</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("RD","lE");'>getHandle</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("RD","mE");'>getName</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("RD","nE");'>getParentElement</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("RD","oE");'>getProgram</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("RD","pE");'>handle</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("RD","qE");'>hasParentElement</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("RD","rE");'>isIn</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("RD","sE");'>resolve</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("RD","tE");'>resolveAbsolute</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("RD","uE");'>resolveAbsoluteOrLocal</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("RD","vE");'>resolveLocalOrAbsolute</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("RD","wE");'>run</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("RD","xE");'>setEnvironment</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("RD","yE");'>setPass</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("RD","zE");'>walk</a></div></div><div class='t'>Values</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&bull;</span><a href='javascript:dO("RD","AE");'>HANDLES</a></div><div class='slot documented'><span
					class='prefix'>&bull;</span><a href='javascript:dO("RD","BE");'>NAME</a></div></div></div><div id='ew' class='cr'><div class='n'><a href='javascript:dS("ew");'>ISlot</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("ew","fw");'><span class='special __bases__'>IReferencable</span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ew","gw");'>getTypeDescription</a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ew","hw");'>getAbsoluteName</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ew","iw");'>getName</a></div></div></div><div id='d_ds' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_dr' class='de'><h1>Method <span class='n'>getPredicate</span></h1><div class='re'><code>getPredicate( self )</code></div><div class='ds'><p>Returns the evaluable that acts as a predicate for this operation.</p></div></div><div id='d_dq' class='de'><h1>Method <span class='n'>setExpression</span></h1><div class='re'><code>setExpression( self, v )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_dp' class='de'><h1>Method <span class='n'>getClosure</span></h1><div class='re'><code>getClosure( self )</code></div><div class='ds'><p>Returns the closure that will be applied to the iterator.</p></div></div><div id='d_dw' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.IEvaluable at 0x7bf450&gt;, &lt;class lambdafactory.interfaces.IEvaluable at 0x7bf450&gt;, &lt;class lambdafactory.interfaces.IEvaluable at 0x7bf450&gt;]</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='d_dv' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_du' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_dt' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_dz' class='de'><h1>Function <span class='n'>flatten</span></h1><div class='re'><code>flatten( *lists )</code></div><div class='ds'><p>Flattens the given lists in a single list</p></div></div><div id='d_dy' class='de'><h1>Method <span class='n'>createDataFlow</span></h1><div class='re'><code>createDataFlow( self, element, parent=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_dx' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><p>Returns the ith arguments to this operation.</p></div></div><div id='d_dc' class='de'><h1>Method <span class='n'>isOptional</span></h1><div class='re'><code>isOptional( self )</code></div><div class='ds'><p>Tells if the argument is optional or not.</p></div></div><div id='d_db' class='de'><h1>Method <span class='n'>setParentClasses</span></h1><div class='re'><code>setParentClasses( self )</code></div><div class='ds'><p>gives the list of parent classes that will</p></div></div><div id='d_dg' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_df' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><p>Detaches the element from its parent (in case it was already attached). This should return this element, and set the parent to None.</p></div></div><div id='d_de' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_dd' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns this element parent</p></div></div><div id='d_dk' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns the parent context for this context (if any)</p></div></div><div id='d_dj' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IOperation at 0x7bfae0&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_di' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_dh' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_do' class='de'><h1>Method <span class='n'>getSlots</span></h1><div class='re'><code>getSlots( self )</code></div><div class='ds'><p>Returns (key, evaluable) pairs representing the slots within this context.</p></div></div><div id='d_dn' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><p>Returns the <em>internal types</em> for this operations arguments. This is typically the list of interfaces or @protocols that the arguments must comply to.</p></div></div><div id='d_dm' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_dl' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_dC' class='de'><h1>Method <span class='n'>concreteType</span></h1><div class='re'><code>concreteType( self )</code></div><div class='ds'><p>Returns the <span class='term'>concrete type</span> for this abstract type.</p></div></div><div id='d_dB' class='de'><h1>Method <span class='n'>isSameAs</span></h1><div class='re'><code>isSameAs( self, otherType )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_dA' class='de'><h1>Method <span class='n'>content</span></h1><div class='re'><code>content( self )</code></div><div class='ds'><p>Returns the type for the content of this array.</p></div></div><div id='d_dG' class='de'><h1>Method <span class='n'>getCurrentContext</span></h1><div class='re'><code>getCurrentContext( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_dF' class='de'><h1>Method <span class='n'>resolveAbsolute</span></h1><div class='re'><code>resolveAbsolute( self, referenceOrName )</code></div><div class='ds'><p>Resolves the given reference or string expressed in absolute style (<code>.</code>-separated list of names), starting from the root dataflow (the program dataflow).</p></div></div><div id='d_dE' class='de'><h1>Method <span class='n'>getCurrentContext</span></h1><div class='re'><code>getCurrentContext( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_dD' class='de'><h1>Method <span class='n'>definedBy</span></h1><div class='re'><code>definedBy( self, definition=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_dH' class='de'><h1>Method <span class='n'>setPass</span></h1><div class='re'><code>setPass( self, programPass )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_xg' class='de'><h1>Method <span class='n'>resolve</span></h1><div class='re'><code>resolve( self, name )</code></div><div class='ds'><p>Returns a couple <code>(DataFlow slot, IElement)</code> or <code>(None,None)</code> corresponding to the resolution of the given <code>name</code> in this dataflow.</p></div></div><div id='d_xf' class='de'><h1>Method <span class='n'>getAbsoluteName</span></h1><div class='re'><code>getAbsoluteName( self )</code></div><div class='ds'><p>Returns the absolute name for this element</p></div></div><div id='xh' class='cr'><div class='n'><a href='javascript:dS("xh");'>IDocumentation</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("xh","yh");'><span class='special __bases__'>IAnnotation</span></a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("xh","zh");'>getContent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("xh","Ah");'>getName</a></div></div></div><div id='d_xd' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><p>Performs a deep clone of this element. Any mutation to the original won't change the copy.</p></div></div><div id='d_xc' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><p>Returns the ith arguments to this operation.</p></div></div><div id='d_xb' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_xo' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><p>Returns the <em>internal types</em> for this operations arguments. This is typically the list of interfaces or @protocols that the arguments must comply to.</p></div></div><div id='d_xn' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_xm' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_xl' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><p>Sets the given argument of this operation, by argument index.</p></div></div><div id='d_xk' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><p>Adds an argument to this operation. This should do checking of arguments (by expected internal type and number).</p></div></div><div id='d_xj' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IInterruption at 0x7bff60&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_xi' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_xh' class='de'><h1>Class <span class='n'>IDocumentation</span></h1><div class='re'></div><div class='ds'><p>Documentation is often attached to various language elements. Documentation can be found in coments (as in Java), or be directly embedded as values (as in Python).</p></div></div><div id='d_xw' class='de'><h1>Method <span class='n'>setResultAbstractType</span></h1><div class='re'><code>setResultAbstractType( self, abstractType )</code></div><div class='ds'><p>Sets the abstract type for this operation result. This is usually invoked in the typing phase.</p></div></div><div id='d_xv' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_xu' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_xt' class='de'><h1>Method <span class='n'>setValue</span></h1><div class='re'><code>setValue( self, v )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_xs' class='de'><h1>Method <span class='n'>getResultAbstractType</span></h1><div class='re'><code>getResultAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type of the result of the evaluation of this evaluable</p></div></div><div id='d_xr' class='de'><h1>Method <span class='n'>getOperations</span></h1><div class='re'><code>getOperations( self )</code></div><div class='ds'><p>Returns the list of operations in this process.</p></div></div><div id='d_xq' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IOperation at 0x7bfae0&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_xp' class='de'><h1>Method <span class='n'>addValue</span></h1><div class='re'><code>addValue( self, value )</code></div><div class='ds'><p>Adds a value to this list.</p></div></div><div id='d_xz' class='de'><h1>Method <span class='n'>getType</span></h1><div class='re'><code>getType( self, name )</code></div><div class='ds'><p>Returns the type with the given name, or None if it does not exist.</p></div></div><div id='d_xy' class='de'><h1>Method <span class='n'>invoke</span></h1><div class='re'><code>invoke( self, evaluable, *arguments )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_xx' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_xG' class='de'><h1>Method <span class='n'>walk</span></h1><div class='re'><code>walk( self, element )</code></div><div class='ds'><p>Walks the given element, recursively walking the child elements when the handler does not return False</p></div></div><div id='d_xF' class='de'><h1>Method <span class='n'>getCurrentClosure</span></h1><div class='re'><code>getCurrentClosure( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_xE' class='de'><h1>Method <span class='n'>setEnvironment</span></h1><div class='re'><code>setEnvironment( self, environment )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_xD' class='de'><h1>Method <span class='n'>isSubtypeOf</span></h1><div class='re'><code>isSubtypeOf( self, otherType )</code></div><div class='ds'><p>Generic implementation of isSubtypeOf. You should always call this method in subclasses, as it implements basic type systems rules such as isSubtypeOf(Any).</p></div></div><div id='d_xC' class='de'><h1>Method <span class='n'>clone</span></h1><div class='re'><code>clone( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_xB' class='de'><h1>Method <span class='n'>elementNames</span></h1><div class='re'><code>elementNames( self )</code></div><div class='ds'><p>Returns the list of slots/elements defined in this map.</p></div></div><div id='d_xA' class='de'><h1>Method <span class='n'>isLike</span></h1><div class='re'><code>isLike( self, otherType )</code></div><div class='ds'><p>The other type is like this Cell if the other type is a cell of the same length as this one.</p></div></div><div id='d_vA' class='de'><h1>Method <span class='n'>asString</span></h1><div class='re'><code>asString( self, fromType=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_vC' class='de'><h1>Method <span class='n'>__call__</span></h1><div class='re'><code>__call__( self )</code></div><div class='ds'><p>A type instance can be used as a class to construct a new type, which will be cloned from the current type.</p></div></div><div id='d_vB' class='de'><h1>Method <span class='n'>clone</span></h1><div class='re'><code>clone( self, clone=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_vE' class='de'><h1>Method <span class='n'>resolveLocalOrAbsolute</span></h1><div class='re'><code>resolveLocalOrAbsolute( self, referenceOrName, contextOrDataFlow=None )</code></div><div class='ds'><p>Tries a local resolution first, then will look in the program scope if it fails.</p></div></div><div id='d_vD' class='de'><h1>Method <span class='n'>isLike</span></h1><div class='re'><code>isLike( self, otherType )</code></div><div class='ds'><p>Generic implementation of isLike. You should always call this method in subclasses, as it implements basic type systems rules such as isLike(Any).</p></div></div><div id='d_vG' class='de'><h1>Method <span class='n'>setEnvironment</span></h1><div class='re'><code>setEnvironment( self, environment )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_vF' class='de'><h1>Method <span class='n'>getCurrentClassAncestors</span></h1><div class='re'><code>getCurrentClassAncestors( self, theClass=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_vi' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns this element parent</p></div></div><div id='d_vh' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><p>Sets this element parent</p></div></div><div id='d_vk' class='de'><h1>Method <span class='n'>getAlias</span></h1><div class='re'><code>getAlias( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_vj' class='de'><h1>list</h1><div class='re'><code>['Evaluable']</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='d_vm' class='de'><h1>Method <span class='n'>endsWithTermination</span></h1><div class='re'><code>endsWithTermination( self )</code></div><div class='ds'><p>Returns true if this function ends with a termination operation. This is especially useful for back-ends which want to know if they have to insert an explicit <code>return</code> at the end (like Java).</p></div></div><div id='d_vl' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_vo' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><p>Returns the ith arguments to this operation.</p></div></div><div id='d_vn' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><p>Detaches the element from its parent (in case it was already attached). This should return this element, and set the parent to None.</p></div></div><div id='d_vc' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_vb' class='de'><h1>Method <span class='n'>getTarget</span></h1><div class='re'><code>getTarget( self )</code></div><div class='ds'><p>Returns the operation target.</p></div></div><div id='d_ve' class='de'><h1>Method <span class='n'>getArguments</span></h1><div class='re'><code>getArguments( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_vd' class='de'><h1>Method <span class='n'>getParentClasses</span></h1><div class='re'><code>getParentClasses( self )</code></div><div class='ds'><p>Returns the list of inherited classes references.</p></div></div><div id='d_vg' class='de'><h1>Method <span class='n'>getSources</span></h1><div class='re'><code>getSources( self )</code></div><div class='ds'><p>Returns the dataflows that are <span class='term'>sources</span>, meaning that if a slot is not resolved by this dataflow, it will look in the parent and then in the sources (depending on the resolution scheme, but this is the default)</p></div></div><div id='d_vf' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><p>Detaches the element from its parent (in case it was already attached). This should return this element, and set the parent to None.</p></div></div><div id='d_vy' class='de'><h1>Method <span class='n'>instanciate</span></h1><div class='re'><code>instanciate( self, evaluable, *arguments )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_vx' class='de'><h1>Method <span class='n'>getResultAbstractType</span></h1><div class='re'><code>getResultAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type of the result of the evaluation of this evaluable</p></div></div><div id='d_vz' class='de'><h1>Class <span class='n'>Structure</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_vq' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.IEvaluable at 0x7bf450&gt;, &lt;class lambdafactory.interfaces.IEvaluable at 0x7bf450&gt;]</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='d_vp' class='de'><h1>Class <span class='n'>IList</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_vs' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_vr' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_vu' class='de'><h1>Method <span class='n'>getResultAbstractType</span></h1><div class='re'><code>getResultAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type of the result of the evaluation of this evaluable</p></div></div><div id='d_vt' class='de'><h1>Method <span class='n'>setAsMap</span></h1><div class='re'><code>setAsMap( self, v=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_vw' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_vv' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><p>Detaches the element from its parent (in case it was already attached). This should return this element, and set the parent to None.</p></div></div><div id='Di' class='cr'><div class='n'><a href='javascript:dS("Di");'>IEnumeration</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("Di","Ei");'><span class='special __bases__'>IOperation</span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Di","Fi");'>getEnd</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Di","Gi");'>getStart</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Di","Hi");'>getStep</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Di","Ii");'>setStep</a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Di","Ji");'>addOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Di","Ki");'>copy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Di","Li");'>detach</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Di","Mi");'>getAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Di","Ni");'>getAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Di","Oi");'>getDataFlow</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Di","Pi");'>getOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Di","Qi");'>getOpArguments</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Di","Ri");'>getOpArgumentsInternalTypes</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Di","Si");'>getParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Di","Ti");'>hasParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Di","Ui");'>setAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Di","Vi");'>setAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Di","Wi");'>setOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Di","Xi");'>setParent</a></div></div><div class='t'>Values</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&bull;</span><a href='javascript:dO("Di","Yi");'>ARGS</a></div></div></div><div id='Dz' class='ro'><div class='n'><a href='javascript:dS("Dz");'>lambdafactory.typecast</a></div><div class='t'>Classes</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("Dz","Ez");'>Arguments</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("Dz","Zz");'>Array</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("Dz","sA");'>Cell</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("Dz","KA");'>Context</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("Dz","lB");'>Environment</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("Dz","pB");'>InvalidArgument</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("Dz","qB");'>Map</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("Dz","NB");'>Process</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("Dz","jC");'>SemanticError</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("Dz","kC");'>Sequence</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("Dz","FC");'>Symbolic</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("Dz","WC");'>Type</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("Dz","mD");'>Unresolved</a></div></div><div class='t'>Functions</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&lambda;</span><a href='javascript:dO("Dz","DD");'>Class</a></div><div class='slot documented'><span
					class='prefix'>&lambda;</span><a href='javascript:dO("Dz","ED");'>Interface</a></div><div class='slot documented'><span
					class='prefix'>&lambda;</span><a href='javascript:dO("Dz","FD");'>Sequence_combine</a></div><div class='slot documented'><span
					class='prefix'>&lambda;</span><a href='javascript:dO("Dz","GD");'>Sequence_make</a></div><div class='slot documented'><span
					class='prefix'>&lambda;</span><a href='javascript:dO("Dz","HD");'>bits</a></div><div class='slot documented'><span
					class='prefix'>&lambda;</span><a href='javascript:dO("Dz","ID");'>isLike</a></div><div class='slot documented'><span
					class='prefix'>&lambda;</span><a href='javascript:dO("Dz","JD");'>isSame</a></div><div class='slot documented'><span
					class='prefix'>&lambda;</span><a href='javascript:dO("Dz","KD");'>isSubtype</a></div><div class='slot documented'><span
					class='prefix'>&lambda;</span><a href='javascript:dO("Dz","LD");'>isType</a></div></div><div class='t'>Values</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&sdot;</span><a href='javascript:dO("Dz","MD");'>Any</a></div><div class='slot documented'><span
					class='prefix'>&sdot;</span><a href='javascript:dO("Dz","ND");'>Nil</a></div><div class='slot documented'><span
					class='prefix'>&sdot;</span><a href='javascript:dO("Dz","OD");'>Nothing</a></div><div class='slot documented'><span
					class='prefix'>&sdot;</span><a href='javascript:dO("Dz","PD");'>Rest</a></div></div></div><div id='Ds' class='cr'><div class='n'><a href='javascript:dS("Ds");'>IOperation</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("Ds","Es");'><span class='special __bases__'>IElement</span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Ds","Fs");'>addOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Ds","Gs");'>getOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Ds","Hs");'>getOpArguments</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Ds","Is");'>getOpArgumentsInternalTypes</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Ds","Js");'>setOpArgument</a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Ds","Ks");'>copy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Ds","Ls");'>detach</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Ds","Ms");'>getAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Ds","Ns");'>getAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Ds","Os");'>getDataFlow</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Ds","Ps");'>getParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Ds","Qs");'>hasParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Ds","Rs");'>setAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Ds","Ss");'>setAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Ds","Ts");'>setParent</a></div></div></div><div id='d_Jy' class='de'><h1>wrapper_descriptor</h1><div class='re'></div><div class='ds'><div class="section" level="1"><h1 class="heading"><span class="number"><span class="level0">1<span class="lastDot dot">.</span></span></span><span class='term'>repr</span>_() &lt;==&gt; repr(x)</h1><div class="level1"></div></div></div></div><div id='d_Jx' class='de'><h1>Method <span class='n'>_list</span></h1><div class='re'><code>_list( self, *args )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Jz' class='de'><h1>Method <span class='n'>add</span></h1><div class='re'><code>add( self, theType )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Ju' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_Jt' class='de'><h1>Method <span class='n'>addOperation</span></h1><div class='re'><code>addOperation( self, operation )</code></div><div class='ds'><p>Adds the given operation as a child of this process.</p></div></div><div id='d_Jw' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><p>Returns the <em>internal types</em> for this operations arguments. This is typically the list of interfaces or @protocols that the arguments must comply to.</p></div></div><div id='d_Jv' class='de'><h1>Class <span class='n'>ISliceOperation</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Jq' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns this element parent</p></div></div><div id='d_Jp' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><p>Sets this element parent</p></div></div><div id='d_Js' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><p>Sets the given argument of this operation, by argument index.</p></div></div><div id='d_Jr' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, context )</code></div><div class='ds'><p>Sets the parent context for this context.</p></div></div><div id='d_Jm' class='de'><h1>Method <span class='n'>isAbstract</span></h1><div class='re'><code>isAbstract( self )</code></div><div class='ds'><p>Tells wether the given abstractable is abstract or not.</p></div></div><div id='d_Jl' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_Jo' class='de'><h1>Method <span class='n'>getTarget</span></h1><div class='re'><code>getTarget( self )</code></div><div class='ds'><p>Returns the invocation target reference.</p></div></div><div id='d_Jn' class='de'><h1>Class <span class='n'>IInterface</span></h1><div class='re'></div><div class='ds'><p>An interface is an abstract @protocol that only has abstract elements.</p></div></div><div id='d_Ji' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><p>Adds an argument to this operation. This should do checking of arguments (by expected internal type and number).</p></div></div><div id='d_Jh' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_Jk' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_Jj' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><p>Tells if this element has a parent or not</p></div></div><div id='d_Je' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_Jd' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_Jg' class='de'><h1>Method <span class='n'>addOperation</span></h1><div class='re'><code>addOperation( self, operation )</code></div><div class='ds'><p>Adds the given operation as a child of this process.</p></div></div><div id='d_Jf' class='de'><h1>Method <span class='n'>hasSlot</span></h1><div class='re'><code>hasSlot( self, name )</code></div><div class='ds'><p>Tells if the context has a slot with the given name.</p></div></div><div id='d_Jc' class='de'><h1>Method <span class='n'>getDefaultValue</span></h1><div class='re'><code>getDefaultValue( self )</code></div><div class='ds'><p>Gets the @methodault value for this attribute</p></div></div><div id='d_Jb' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_JE' class='de'><h1>Method <span class='n'>getCurrentClass</span></h1><div class='re'><code>getCurrentClass( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_JD' class='de'><h1>Function <span class='n'>isSame</span></h1><div class='re'><code>isSame( a, b )</code></div><div class='ds'><p>Type (b) is the same as (a) if (a) and (b) are identicial, that means that you can use b where you use a, and this also means that isSame(a,b) == isSame(b,a). Basically, when (b) is same as (a), (b) can be considered as an alias for (a).</p></div></div><div id='d_JG' class='de'><h1>Method <span class='n'>getCurrentDataFlow</span></h1><div class='re'><code>getCurrentDataFlow( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_JF' class='de'><h1>Method <span class='n'>hasParentElement</span></h1><div class='re'><code>hasParentElement( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_JA' class='de'><h1>Method <span class='n'>subtype</span></h1><div class='re'><code>subtype( self, name )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_JC' class='de'><h1>Method <span class='n'>clone</span></h1><div class='re'><code>clone( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_JB' class='de'><h1>Method <span class='n'>result</span></h1><div class='re'><code>result( self )</code></div><div class='ds'><p>Returns the result for this type. This is usually just the type itself, except for processes types.</p></div></div><div id='WC' class='cr'><div class='n'><a href='javascript:dS("WC");'>Type</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("WC","c");'><span class='special __bases__'><i>Base class</i></span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("WC","XC");'><span class='special __call__'>when invoked</span></a></div><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("WC","YC");'><span class='special __init__'>constructor</span></a></div><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("WC","ZC");'><span class='special __str__'>string conversion</span></a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("WC","aD");'>asString</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("WC","bD");'>clone</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("WC","cD");'>concreteType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("WC","dD");'>definedBy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("WC","eD");'>isLike</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("WC","fD");'>isSameAs</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("WC","gD");'>isSubtypeOf</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("WC","hD");'>name</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("WC","iD");'>result</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("WC","jD");'>setConcreteType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("WC","kD");'>setName</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("WC","lD");'>subtype</a></div></div></div><div id='Wb' class='cr'><div class='n'><a href='javascript:dS("Wb");'>IAnnotation</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("Wb","c");'><span class='special __bases__'><i>Base class</i></span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Wb","Xb");'>getContent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Wb","Yb");'>getName</a></div></div></div><div id='d_DB' class='de'><h1>Method <span class='n'>set</span></h1><div class='re'><code>set( self, name, theType )</code></div><div class='ds'><p>Sets the slot with the given <code>name</code> to have a value of the given type (<code>theType</code>).</p></div></div><div id='d_gz' class='de'><h1>str</h1><div class='re'><code>'\t'</code></div><div class='ds'><p>str(object) -&gt; string</p><p>Return a nice string representation of the object. If the argument is a string, the return value is the same object.</p></div></div><div id='d_gx' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns this element parent</p></div></div><div id='d_gy' class='de'><h1>Method <span class='n'>createFunction</span></h1><div class='re'><code>createFunction( self, name, arguments )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_gv' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><p>Returns the arguments to this operation.</p></div></div><div id='d_gw' class='de'><h1>Method <span class='n'>getTypeDescription</span></h1><div class='re'><code>getTypeDescription( self )</code></div><div class='ds'><p>Returns type information (constraints) that are associated to this argument.</p></div></div><div id='d_gt' class='de'><h1>Method <span class='n'>getReferenceName</span></h1><div class='re'><code>getReferenceName( self )</code></div><div class='ds'><p>Returns the name which this reference contains. The name is used by the resolution operation to actually resolve a value from the name.</p></div></div><div id='d_gu' class='de'><h1>Class <span class='n'>IReferencable</span></h1><div class='re'></div><div class='ds'><p>A referencable is an element that can be referenced either by id (it is unique and stable), or by a name (which is also not supposed to change).</p><p>Types are good examples of referencables: they have an <em>absolute name</em> (like <code>Data.List</code>), but can also be bound to slots within contexts which give them "local names" (like <code>List := Data.List</code>)</p></div></div><div id='d_gr' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_gs' class='de'><h1>Method <span class='n'>setSlot</span></h1><div class='re'><code>setSlot( self, name, evaluable )</code></div><div class='ds'><p>Binds the given evaluable to the named slot.</p></div></div><div id='d_gp' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><p>Performs a deep clone of this element. Any mutation to the original won't change the copy.</p></div></div><div id='d_gq' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><p>Detaches the element from its parent (in case it was already attached). This should return this element, and set the parent to None.</p></div></div><div id='d_gn' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_go' class='de'><h1>Method <span class='n'>isAbstract</span></h1><div class='re'><code>isAbstract( self )</code></div><div class='ds'><p>Tells wether the given abstractable is abstract or not.</p></div></div><div id='d_gl' class='de'><h1>list</h1><div class='re'><code>[[&lt;class lambdafactory.interfaces.IEvaluable at 0x7bf450&gt;]]</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='d_gm' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><p>Returns the arguments to this operation.</p></div></div><div id='d_gj' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><p>Performs a deep clone of this element. Any mutation to the original won't change the copy.</p></div></div><div id='d_gk' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><p>Tells if this element has a parent or not</p></div></div><div id='d_gh' class='de'><h1>Method <span class='n'>setSlot</span></h1><div class='re'><code>setSlot( self, name, evaluable )</code></div><div class='ds'><p>Binds the given evaluable to the named slot.</p></div></div><div id='d_gi' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><p>Sets this element parent</p></div></div><div id='d_gf' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_gg' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_gd' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_ge' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns the parent context for this context (if any)</p></div></div><div id='d_gb' class='de'><h1>Method <span class='n'>isAbstract</span></h1><div class='re'><code>isAbstract( self )</code></div><div class='ds'><p>Tells wether the given abstractable is abstract or not.</p></div></div><div id='d_gc' class='de'><h1>Method <span class='n'>setKeywordsRest</span></h1><div class='re'><code>setKeywordsRest( self, value )</code></div><div class='ds'><p>Tells this arguments represents &ldquo;<span class='quote'>the rest</span>&rdquo; of the keyword argument in the invocation</p></div></div><div id='d_gH' class='de'><h1>str</h1><div class='re'><code>'AsynchronousInvocationsExpansion'</code></div><div class='ds'><p>str(object) -&gt; string</p><p>Return a nice string representation of the object. If the argument is a string, the return value is the same object.</p></div></div><div id='d_gF' class='de'><h1>Method <span class='n'>run</span></h1><div class='re'><code>run( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_gG' class='de'><h1>Method <span class='n'>getCurrentFunction</span></h1><div class='re'><code>getCurrentFunction( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_gD' class='de'><h1>Method <span class='n'>isSubtypeOf</span></h1><div class='re'><code>isSubtypeOf( self, otherType )</code></div><div class='ds'><p>Generic implementation of isSubtypeOf. You should always call this method in subclasses, as it implements basic type systems rules such as isSubtypeOf(Any).</p></div></div><div id='d_gE' class='de'><h1>Method <span class='n'>getCurrentFunction</span></h1><div class='re'><code>getCurrentFunction( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_gB' class='de'><h1>Method <span class='n'>result</span></h1><div class='re'><code>result( self )</code></div><div class='ds'><p>Returns the result for this type. This is usually just the type itself, except for processes types.</p></div></div><div id='d_gC' class='de'><h1>Method <span class='n'>setConcreteType</span></h1><div class='re'><code>setConcreteType( self, value )</code></div><div class='ds'><p>Sets the <span class='term'>concrete type</span> for this abstract type. The concrete type is a value which represents the type. For instance, if this type represents a class, then the concrete type would be the class instance.</p></div></div><div id='d_gA' class='de'><h1>Method <span class='n'>isSubtypeOf</span></h1><div class='re'><code>isSubtypeOf( self, otherType )</code></div><div class='ds'><p>Othertype must be an Array with a content type that is a subtype of this content type.</p></div></div><div id='jz' class='cr'><div class='n'><a href='javascript:dS("jz");'>Behaviour</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("jz","kz");'><span class='special __bases__'>TypeCollection</span></a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("jz","lz");'>getType</a></div></div></div><div id='jw' class='cr'><div class='n'><a href='javascript:dS("jw");'>IString</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("jw","kw");'><span class='special __bases__'>ILiteral</span></a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("jw","lw");'>copy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("jw","mw");'>detach</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("jw","nw");'>getAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("jw","ow");'>getActualValue</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("jw","pw");'>getAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("jw","qw");'>getDataFlow</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("jw","rw");'>getParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("jw","sw");'>getResultAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("jw","tw");'>hasParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("jw","uw");'>setAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("jw","vw");'>setAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("jw","ww");'>setParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("jw","xw");'>setResultAbstractType</a></div></div></div><div id='d_Dz' class='de'><h1>Module <span class='n'>lambdafactory.typecast</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='jC' class='cr'><div class='n'><a href='javascript:dS("jC");'>SemanticError</a></div><div class='t'>Inhertied Values</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("jC","Iy");'><span class='special __getitem__'>get item</span></a></div><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("jC","Oy");'><span class='special __init__'>constructor</span></a></div><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("jC","Jy");'><span class='special __repr__'>string repr</span></a></div><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("jC","Ky");'><span class='special __str__'>string conversion</span></a></div><div class='slot documented'><span
					class='prefix'>&sdot;</span><a href='javascript:dO("jC","Ly");'>args</a></div><div class='slot documented'><span
					class='prefix'>&sdot;</span><a href='javascript:dO("jC","My");'>message</a></div></div></div><div id='d_iD' class='de'><h1>Method <span class='n'>result</span></h1><div class='re'><code>result( self )</code></div><div class='ds'><p>Returns the result for this type. This is usually just the type itself, except for processes types.</p></div></div><div id='d_iE' class='de'><h1>Method <span class='n'>getCurrentModule</span></h1><div class='re'><code>getCurrentModule( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_iF' class='de'><h1>Method <span class='n'>setPass</span></h1><div class='re'><code>setPass( self, programPass )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_iG' class='de'><h1>Method <span class='n'>getCurrentModule</span></h1><div class='re'><code>getCurrentModule( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_iA' class='de'><h1>Method <span class='n'>__call__</span></h1><div class='re'><code>__call__( self )</code></div><div class='ds'><p>A type instance can be used as a class to construct a new type, which will be cloned from the current type.</p></div></div><div id='d_iB' class='de'><h1>Method <span class='n'>setConcreteType</span></h1><div class='re'><code>setConcreteType( self, value )</code></div><div class='ds'><p>Sets the <span class='term'>concrete type</span> for this abstract type. The concrete type is a value which represents the type. For instance, if this type represents a class, then the concrete type would be the class instance.</p></div></div><div id='d_iC' class='de'><h1>Method <span class='n'>subtype</span></h1><div class='re'><code>subtype( self, name )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='Go' class='cr'><div class='n'><a href='javascript:dS("Go");'>IInvocation</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("Go","Ho");'><span class='special __bases__'>IOperation</span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Go","Io");'>getArguments</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Go","Jo");'>getTarget</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Go","Ko");'>isByPositionOnly</a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Go","Lo");'>addOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Go","Mo");'>copy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Go","No");'>detach</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Go","Oo");'>getAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Go","Po");'>getAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Go","Qo");'>getDataFlow</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Go","Ro");'>getOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Go","So");'>getOpArguments</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Go","To");'>getOpArgumentsInternalTypes</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Go","Uo");'>getParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Go","Vo");'>hasParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Go","Wo");'>setAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Go","Xo");'>setAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Go","Yo");'>setOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Go","Zo");'>setParent</a></div></div><div class='t'>Values</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&bull;</span><a href='javascript:dO("Go","ap");'>ARGS</a></div></div></div><div id='d_iH' class='de'><h1>Class <span class='n'>Reporter</span></h1><div class='re'></div><div class='ds'><p>The reporter aggregates error reports that may happen during model construction and the different phases (dataflowing, typing, writing, etc).</p></div></div><div id='d_it' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><p>Tells if this element has a parent or not</p></div></div><div id='d_iu' class='de'><h1>Method <span class='n'>getAbsoluteName</span></h1><div class='re'><code>getAbsoluteName( self )</code></div><div class='ds'><p>Returns the absolute name for this element</p></div></div><div id='d_iv' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns this element parent</p></div></div><div id='d_iw' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><p>Returns the local name for this referencable element</p></div></div><div id='d_ip' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_iq' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_ir' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><p>Sets this element parent</p></div></div><div id='d_is' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IAttribute at 0x7bf750&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_ix' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_iy' class='de'><h1>Method <span class='n'>createMethod</span></h1><div class='re'><code>createMethod( self, name, arguments=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_iz' class='de'><h1>Module <span class='n'>lambdafactory.modeltypes</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_id' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><p>Sets this element parent</p></div></div><div id='d_ie' class='de'><h1>Method <span class='n'>getSlots</span></h1><div class='re'><code>getSlots( self )</code></div><div class='ds'><p>Returns (key, evaluable) pairs representing the slots within this context.</p></div></div><div id='d_if' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><p>Returns the arguments to this operation.</p></div></div><div id='d_ig' class='de'><h1>Method <span class='n'>addChild</span></h1><div class='re'><code>addChild( self, child )</code></div><div class='ds'><p>Adds the given dataflow as a child of this dataflow.</p></div></div><div id='d_ib' class='de'><h1>Class <span class='n'>IAccessOperation</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_ic' class='de'><h1>Method <span class='n'>setRest</span></h1><div class='re'><code>setRest( self, value )</code></div><div class='ds'><p>Tells this argument represents &ldquo;<span class='quote'>the rest</span>&rdquo; of arguments in the invocation</p></div></div><div id='d_il' class='de'><h1>Class <span class='n'>IImportOperation</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_im' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns this element parent</p></div></div><div id='d_in' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><p>Sets the given argument of this operation, by argument index.</p></div></div><div id='d_io' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_ih' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IValue at 0x7bf510&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_ii' class='de'><h1>Class <span class='n'>IEmbedTemplate</span></h1><div class='re'></div><div class='ds'><p>The <code>EmbedTemplate</code> is embedded (<code>Embed</code>) that contains template expressions. It's up to the model writer to know how to expand the template to convert it to the target language.</p></div></div><div id='d_ij' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_Df' class='de'><h1>Method <span class='n'>getOperations</span></h1><div class='re'><code>getOperations( self )</code></div><div class='ds'><p>Returns the list of operations in this process.</p></div></div><div id='d_Dh' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><p>Detaches the element from its parent (in case it was already attached). This should return this element, and set the parent to None.</p></div></div><div id='d_Mx' class='de'><h1>Method <span class='n'>_op</span></h1><div class='re'><code>_op( self, symbol, priority=0 )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_My' class='de'><h1>member_descriptor</h1><div class='re'></div><div class='ds'><p>exception message</p></div></div><div id='d_Mz' class='de'><h1>Method <span class='n'>concreteType</span></h1><div class='re'><code>concreteType( self )</code></div><div class='ds'><p>Returns the <span class='term'>concrete type</span> for this abstract type.</p></div></div><div id='d_Mp' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IValue at 0x7bf510&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Mq' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_Mr' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IContext at 0x7bf7e0&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Ms' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_Mt' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IContext at 0x7bf7e0&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Mu' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><p>Returns the arguments to this operation.</p></div></div><div id='d_Mv' class='de'><h1>Method <span class='n'>getSliceStart</span></h1><div class='re'><code>getSliceStart( self )</code></div><div class='ds'><p>Returns evaluable that will return the slice start</p></div></div><div id='d_Mw' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_Mh' class='de'><h1>Class <span class='n'>IEmbed</span></h1><div class='re'></div><div class='ds'><p>An embedded operation represents a bit of verbatim code written in a different language. This allows for embedding code written specifically in a target language (which may happen for optimizing stuff, for instance).</p></div></div><div id='d_Mi' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_Mj' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><p>Sets the given argument of this operation, by argument index.</p></div></div><div id='d_Mk' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.IEvaluable at 0x7bf450&gt;, &lt;class lambdafactory.interfaces.IEvaluable at 0x7bf450&gt;]</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='d_Ml' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><p>Returns the <em>internal types</em> for this operations arguments. This is typically the list of interfaces or @protocols that the arguments must comply to.</p></div></div><div id='d_Mm' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_Mn' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><p>Detaches the element from its parent (in case it was already attached). This should return this element, and set the parent to None.</p></div></div><div id='d_Mo' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><p>Performs a deep clone of this element. Any mutation to the original won't change the copy.</p></div></div><div id='d_Mb' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><p>Returns the ith arguments to this operation.</p></div></div><div id='d_Mc' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><p>Returns the local name for this referencable element</p></div></div><div id='d_Md' class='de'><h1>Class <span class='n'>IClassAttribute</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Me' class='de'><h1>Method <span class='n'>setSlot</span></h1><div class='re'><code>setSlot( self, name, evaluable )</code></div><div class='ds'><p>Binds the given evaluable to the named slot.</p></div></div><div id='d_Mf' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_Mg' class='de'><h1>Method <span class='n'>endsWithTermination</span></h1><div class='re'><code>endsWithTermination( self )</code></div><div class='ds'><p>Returns true if this function ends with a termination operation. This is especially useful for back-ends which want to know if they have to insert an explicit <code>return</code> at the end (like Java).</p></div></div><div id='d_MA' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self, *args, **kwargs )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_MB' class='de'><h1>Method <span class='n'>subtype</span></h1><div class='re'><code>subtype( self, name )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_MC' class='de'><h1>Method <span class='n'>concreteType</span></h1><div class='re'><code>concreteType( self )</code></div><div class='ds'><p>Returns the <span class='term'>concrete type</span> for this abstract type.</p></div></div><div id='d_MD' class='de'><h1>instance</h1><div class='re'></div><div class='ds'><p>Symbolic types are types that have no physical counter part but play a role in the type system. This is for instance the case with Any or Nil.</p></div></div><div id='d_ME' class='de'><h1>Method <span class='n'>getCurrentClosure</span></h1><div class='re'><code>getCurrentClosure( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_MF' class='de'><h1>Method <span class='n'>resolveAbsolute</span></h1><div class='re'><code>resolveAbsolute( self, referenceOrName )</code></div><div class='ds'><p>Resolves the given reference or string expressed in absolute style (<code>.</code>-separated list of names), starting from the root dataflow (the program dataflow).</p></div></div><div id='d_MG' class='de'><h1>Method <span class='n'>getCurrentMethod</span></h1><div class='re'><code>getCurrentMethod( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='It' class='cr'><div class='n'><a href='javascript:dS("It");'>IProcess</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("It","c");'><span class='special __bases__'><i>Base class</i></span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("It","Jt");'>addOperation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("It","Kt");'>getOperations</a></div></div></div><div id='d_LC' class='de'><h1>Method <span class='n'>__str__</span></h1><div class='re'><code>__str__( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='os' class='cr'><div class='n'><a href='javascript:dS("os");'>INumber</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("os","ps");'><span class='special __bases__'>ILiteral</span></a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("os","qs");'>copy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("os","rs");'>detach</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("os","ss");'>getAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("os","ts");'>getActualValue</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("os","us");'>getAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("os","vs");'>getDataFlow</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("os","ws");'>getParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("os","xs");'>getResultAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("os","ys");'>hasParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("os","zs");'>setAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("os","As");'>setAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("os","Bs");'>setParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("os","Cs");'>setResultAbstractType</a></div></div></div><div id='Ne' class='cr'><div class='n'><a href='javascript:dS("Ne");'>IComment</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("Ne","Oe");'><span class='special __bases__'>IAnnotation</span></a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Ne","Pe");'>getContent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Ne","Qe");'>getName</a></div></div></div><div id='Ny' class='cr'><div class='n'><a href='javascript:dS("Ny");'>ModelException</a></div><div class='t'>Inhertied Values</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("Ny","Iy");'><span class='special __getitem__'>get item</span></a></div><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("Ny","Oy");'><span class='special __init__'>constructor</span></a></div><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("Ny","Jy");'><span class='special __repr__'>string repr</span></a></div><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("Ny","Ky");'><span class='special __str__'>string conversion</span></a></div><div class='slot documented'><span
					class='prefix'>&sdot;</span><a href='javascript:dO("Ny","Ly");'>args</a></div><div class='slot documented'><span
					class='prefix'>&sdot;</span><a href='javascript:dO("Ny","My");'>message</a></div></div></div><div id='NB' class='cr'><div class='n'><a href='javascript:dS("NB");'>Process</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("NB","OB");'><span class='special __bases__'>Type</span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("NB","PB");'><span class='special __init__'>constructor</span></a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("NB","QB");'><span class='protected'>_ensureIntegrity</span></a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("NB","RB");'>add</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("NB","SB");'>arguments</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("NB","TB");'>asString</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("NB","UB");'>clone</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("NB","VB");'>elements</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("NB","WB");'>isLike</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("NB","XB");'>isSameAs</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("NB","YB");'>isSubtypeOf</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("NB","ZB");'>peel</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("NB","aC");'>result</a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("NB","bC");'><span class='special __call__'>when invoked</span></a></div><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("NB","cC");'><span class='special __str__'>string conversion</span></a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("NB","dC");'>concreteType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("NB","eC");'>definedBy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("NB","fC");'>name</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("NB","gC");'>setConcreteType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("NB","hC");'>setName</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("NB","iC");'>subtype</a></div></div></div><div id='d_fy' class='de'><h1>Method <span class='n'>createDestructor</span></h1><div class='re'><code>createDestructor( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_fx' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><p>Returns the <em>internal types</em> for this operations arguments. This is typically the list of interfaces or @protocols that the arguments must comply to.</p></div></div><div id='d_fz' class='de'><h1>Function <span class='n'>notEmpty</span></h1><div class='re'><code>notEmpty( p )</code></div><div class='ds'><p>Returns None if the given parameter is empty.</p></div></div><div id='d_fq' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><p>Performs a deep clone of this element. Any mutation to the original won't change the copy.</p></div></div><div id='d_fp' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><p>Adds an argument to this operation. This should do checking of arguments (by expected internal type and number).</p></div></div><div id='d_fs' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, context )</code></div><div class='ds'><p>Sets the parent context for this context.</p></div></div><div id='d_fr' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_fu' class='de'><h1>Method <span class='n'>setSlot</span></h1><div class='re'><code>setSlot( self, name, evaluable )</code></div><div class='ds'><p>Binds the given evaluable to the named slot.</p></div></div><div id='d_ft' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns this element parent</p></div></div><div id='d_fw' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IReferencable at 0x7bf420&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_fv' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><p>Returns the ith arguments to this operation.</p></div></div><div id='d_fi' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><p>Sets the given argument of this operation, by argument index.</p></div></div><div id='d_fh' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, context )</code></div><div class='ds'><p>Sets the parent context for this context.</p></div></div><div id='d_fk' class='de'><h1>Method <span class='n'>getSlots</span></h1><div class='re'><code>getSlots( self )</code></div><div class='ds'><p>Returns (key, evaluable) pairs representing the slots within this context.</p></div></div><div id='d_fj' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><p>Adds an argument to this operation. This should do checking of arguments (by expected internal type and number).</p></div></div><div id='d_fm' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><p>Returns the ith arguments to this operation.</p></div></div><div id='d_fl' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><p>Sets this element parent</p></div></div><div id='d_fo' class='de'><h1>Method <span class='n'>hasSlot</span></h1><div class='re'><code>hasSlot( self, name )</code></div><div class='ds'><p>Tells if the context has a slot with the given name.</p></div></div><div id='d_fn' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><p>Tells if this element has a parent or not</p></div></div><div id='d_fc' class='de'><h1>Method <span class='n'>setDefaultValue</span></h1><div class='re'><code>setDefaultValue( self, value )</code></div><div class='ds'><p>Sets the @methodault value for this argument.</p></div></div><div id='d_fb' class='de'><h1>Class <span class='n'>IAbstractable</span></h1><div class='re'></div><div class='ds'><p>An abstractable element is an element that is allow to have no underlying implementation. Abstract element are typically interfaces, methods, functions, operations, and sometimes modules and @protocoles.</p></div></div><div id='d_fe' class='de'><h1>Method <span class='n'>getOperations</span></h1><div class='re'><code>getOperations( self )</code></div><div class='ds'><p>Returns the list of operations in this process.</p></div></div><div id='d_fd' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_fg' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_ff' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_fH' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.IClosure at 0x7bf990&gt;]</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='d_fA' class='de'><h1>Method <span class='n'>isSameAs</span></h1><div class='re'><code>isSameAs( self, otherType )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_fC' class='de'><h1>Method <span class='n'>name</span></h1><div class='re'><code>name( self, name=None )</code></div><div class='ds'><p>Returns/sets the name for this type. By defaults, types are unnamed.</p></div></div><div id='d_ik' class='de'><h1>Method <span class='n'>isAbstract</span></h1><div class='re'><code>isAbstract( self )</code></div><div class='ds'><p>Tells wether the given abstractable is abstract or not.</p></div></div><div id='d_fE' class='de'><h1>Method <span class='n'>getCurrentElement</span></h1><div class='re'><code>getCurrentElement( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_fD' class='de'><h1>Method <span class='n'>isSameAs</span></h1><div class='re'><code>isSameAs( self, otherType )</code></div><div class='ds'><p>Generic implementation of isSameAs. You should always call this method in subclasses.</p></div></div><div id='d_fG' class='de'><h1>Method <span class='n'>getCurrentElement</span></h1><div class='re'><code>getCurrentElement( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_fF' class='de'><h1>Method <span class='n'>resolveLocalOrAbsolute</span></h1><div class='re'><code>resolveLocalOrAbsolute( self, referenceOrName, contextOrDataFlow=None )</code></div><div class='ds'><p>Tries a local resolution first, then will look in the program scope if it fails.</p></div></div><div id='d_zm' class='de'><h1>Method <span class='n'>getArguments</span></h1><div class='re'><code>getArguments( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_zl' class='de'><h1>Class <span class='n'>IImportSymbolOperation</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_zo' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><p>Tells if this element has a parent or not</p></div></div><div id='d_zn' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><p>Returns the ith arguments to this operation.</p></div></div><div id='d_zi' class='de'><h1>Method <span class='n'>setCode</span></h1><div class='re'><code>setCode( self, code )</code></div><div class='ds'><p>Sets the code of this embed operation.</p></div></div><div id='d_zh' class='de'><h1>Method <span class='n'>getContent</span></h1><div class='re'><code>getContent( self )</code></div><div class='ds'><p>Returns the content of this annotation.</p></div></div><div id='d_zk' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><p>Detaches the element from its parent (in case it was already attached). This should return this element, and set the parent to None.</p></div></div><div id='d_zj' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><p>Adds an argument to this operation. This should do checking of arguments (by expected internal type and number).</p></div></div><div id='d_ze' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><p>Detaches the element from its parent (in case it was already attached). This should return this element, and set the parent to None.</p></div></div><div id='d_zd' class='de'><h1>Method <span class='n'>getAbsoluteName</span></h1><div class='re'><code>getAbsoluteName( self )</code></div><div class='ds'><p>Returns the absolute name for this element</p></div></div><div id='d_zg' class='de'><h1>Class <span class='n'>IDataFlowOwner</span></h1><div class='re'></div><div class='ds'><p>DataFlow owners are elements that have their own dataflow. IContext are typical examples of elements that are dataflow owners</p></div></div><div id='d_zf' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_zc' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><p>Returns the <em>internal types</em> for this operations arguments. This is typically the list of interfaces or @protocols that the arguments must comply to.</p></div></div><div id='d_zb' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><p>Sets the given argument of this operation, by argument index.</p></div></div><div id='aq' class='cr'><div class='n'><a href='javascript:dS("aq");'>IMatchExpressionOperation</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("aq","bq");'><span class='special __bases__'>IMatchOperation</span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("aq","cq");'>getExpression</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("aq","dq");'>setExpression</a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("aq","eq");'>addOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("aq","fq");'>copy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("aq","gq");'>detach</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("aq","hq");'>getAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("aq","iq");'>getAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("aq","jq");'>getDataFlow</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("aq","kq");'>getOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("aq","lq");'>getOpArguments</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("aq","mq");'>getOpArgumentsInternalTypes</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("aq","nq");'>getParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("aq","oq");'>getPredicate</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("aq","pq");'>hasParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("aq","qq");'>setAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("aq","rq");'>setAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("aq","sq");'>setOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("aq","tq");'>setParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("aq","uq");'>setPredicate</a></div></div><div class='t'>Values</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&bull;</span><a href='javascript:dO("aq","vq");'>ARGS</a></div></div></div><div id='d_zy' class='de'><h1>Method <span class='n'>matchExpression</span></h1><div class='re'><code>matchExpression( self, evaluable, expression )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_zx' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><p>Sets this element parent</p></div></div><div id='d_zz' class='de'><h1>Method <span class='n'>getType</span></h1><div class='re'><code>getType( self, name )</code></div><div class='ds'><p>Returns the type with the given name, or None if it does not exist.</p></div></div><div id='d_zu' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><p>Sets this element parent</p></div></div><div id='d_zt' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><p>Detaches the element from its parent (in case it was already attached). This should return this element, and set the parent to None.</p></div></div><div id='d_zw' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IOperation at 0x7bfae0&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_zv' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><p>Returns the ith arguments to this operation.</p></div></div><div id='d_zq' class='de'><h1>Method <span class='n'>setPredicate</span></h1><div class='re'><code>setPredicate( self, v )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_zp' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><p>Performs a deep clone of this element. Any mutation to the original won't change the copy.</p></div></div><div id='d_zs' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_zr' class='de'><h1>Method <span class='n'>getSlot</span></h1><div class='re'><code>getSlot( self, name )</code></div><div class='ds'><p>Returns the given evaluable bound to named slot.</p></div></div><div id='d_zE' class='de'><h1>Method <span class='n'>walk</span></h1><div class='re'><code>walk( self, element )</code></div><div class='ds'><p>Walks the given element, recursively walking the child elements when the handler does not return False</p></div></div><div id='d_zD' class='de'><h1>Method <span class='n'>result</span></h1><div class='re'><code>result( self )</code></div><div class='ds'><p>Returns the result for this type. This is usually just the type itself, except for processes types.</p></div></div><div id='d_zG' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.passes.Pass at 0x1228030&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_zF' class='de'><h1>Method <span class='n'>getCurrentDataFlow</span></h1><div class='re'><code>getCurrentDataFlow( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_zA' class='de'><h1>Method <span class='n'>isSubtypeOf</span></h1><div class='re'><code>isSubtypeOf( self, otherType )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_zC' class='de'><h1>Method <span class='n'>definedBy</span></h1><div class='re'><code>definedBy( self, definition=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_zB' class='de'><h1>Method <span class='n'>get</span></h1><div class='re'><code>get( self, name )</code></div><div class='ds'><p>Returns the type for the slot with the given name.</p></div></div><div id='d_DD' class='de'><h1>Function <span class='n'>Class</span></h1><div class='re'><code>Class( Context )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_hG' class='de'><h1>Method <span class='n'>getCurrentMethod</span></h1><div class='re'><code>getCurrentMethod( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_hF' class='de'><h1>Method <span class='n'>setEnvironment</span></h1><div class='re'><code>setEnvironment( self, environment )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_hE' class='de'><h1>Method <span class='n'>getCurrentMethod</span></h1><div class='re'><code>getCurrentMethod( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_hD' class='de'><h1>Method <span class='n'>name</span></h1><div class='re'><code>name( self, name=None )</code></div><div class='ds'><p>Returns/sets the name for this type. By defaults, types are unnamed.</p></div></div><div id='d_hC' class='de'><h1>Method <span class='n'>setName</span></h1><div class='re'><code>setName( self, name )</code></div><div class='ds'><p>Sets the name of this type</p></div></div><div id='d_hB' class='de'><h1>Method <span class='n'>set</span></h1><div class='re'><code>set( self, name, theType )</code></div><div class='ds'><p>Sets the slot with the given <code>name</code> to have a value of the given type (<code>theType</code>).</p></div></div><div id='d_hA' class='de'><h1>Method <span class='n'>setContentType</span></h1><div class='re'><code>setContentType( self, theType )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_hH' class='de'><h1>Module <span class='n'>lambdafactory.reporter</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_hw' class='de'><h1>Method <span class='n'>getAbsoluteName</span></h1><div class='re'><code>getAbsoluteName( self )</code></div><div class='ds'><p>Returns the absolute name for this element</p></div></div><div id='d_hv' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><p>Returns the <em>internal types</em> for this operations arguments. This is typically the list of interfaces or @protocols that the arguments must comply to.</p></div></div><div id='d_hu' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IAssignable at 0x7bf3f0&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_ht' class='de'><h1>Method <span class='n'>getResultAbstractType</span></h1><div class='re'><code>getResultAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type of the result of the evaluation of this evaluable</p></div></div><div id='d_hs' class='de'><h1>Class <span class='n'>IModuleAttribute</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_hr' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><p>Sets the given argument of this operation, by argument index.</p></div></div><div id='d_hq' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_hp' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><p>Detaches the element from its parent (in case it was already attached). This should return this element, and set the parent to None.</p></div></div><div id='d_hz' class='de'><h1>str</h1><div class='re'><code>'8&lt; ---[%s]---'</code></div><div class='ds'><p>str(object) -&gt; string</p><p>Return a nice string representation of the object. If the argument is a string, the return value is the same object.</p></div></div><div id='d_hy' class='de'><h1>Method <span class='n'>createInterface</span></h1><div class='re'><code>createInterface( self, name, inherited=() )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_hx' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><p>Tells if this element has a parent or not</p></div></div><div id='d_hg' class='de'><h1>Class <span class='n'>IDataFlow</span></h1><div class='re'></div><div class='ds'><p>The DataFlow are &ldquo;<span class='quote'>dynamic contexts</span>&rdquo; bound to the various program model elements. DataFlows are typically owned by elements which implement <code>IContext</code>, and are linked together by rules defined in the <code>Resolver</code> @protocol.</p><p>The dataflow bound to most expressions is the one of the enclosing closure (whether it is a function, or method. The dataflow of a method is bound to its parent @protocol, which dataflow is also bound to the parent @protocol dataflow.</p><p>While <code>DataFlow</code> and <code>Context</code> may appear very similar, they are not the same: contexts are elements that keep track of declared slots, while the dataflow make use of the context to weave the elements togeher.</p></div></div><div id='d_hf' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><p>Returns the ith arguments to this operation.</p></div></div><div id='d_he' class='de'><h1>Method <span class='n'>getSlot</span></h1><div class='re'><code>getSlot( self, name )</code></div><div class='ds'><p>Returns the given evaluable bound to named slot.</p></div></div><div id='d_hd' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><p>Sets the given argument of this operation, by argument index.</p></div></div><div id='d_hc' class='de'><h1>Method <span class='n'>setOptional</span></h1><div class='re'><code>setOptional( self, value )</code></div><div class='ds'><p>Sets this argument as optional or not.</p></div></div><div id='d_hb' class='de'><h1>Method <span class='n'>setAbstract</span></h1><div class='re'><code>setAbstract( self, isAbstract )</code></div><div class='ds'><p>Sets wether the given abstractable is abstract or not.</p></div></div><div id='d_ho' class='de'><h1>Method <span class='n'>setAbstract</span></h1><div class='re'><code>setAbstract( self, isAbstract )</code></div><div class='ds'><p>Sets wether the given abstractable is abstract or not.</p></div></div><div id='d_hn' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_hm' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><p>Returns the <em>internal types</em> for this operations arguments. This is typically the list of interfaces or @protocols that the arguments must comply to.</p></div></div><div id='d_hl' class='de'><h1>list</h1><div class='re'><code>['ImportedModuleNames']</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='d_hk' class='de'><h1>Method <span class='n'>hasSlot</span></h1><div class='re'><code>hasSlot( self, name )</code></div><div class='ds'><p>Tells if the context has a slot with the given name.</p></div></div><div id='d_hj' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><p>Detaches the element from its parent (in case it was already attached). This should return this element, and set the parent to None.</p></div></div><div id='d_hi' class='de'><h1>list</h1><div class='re'><code>[]</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='d_hh' class='de'><h1>Class <span class='n'>IDict</span></h1><div class='re'></div><div class='ds'><p>A dictionary is a binding of key to values. It may or may not be ordered, depending on the implementation/model semantics.</p></div></div><div id='tk' class='cr'><div class='n'><a href='javascript:dS("tk");'>IImportModuleOperation</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("tk","uk");'><span class='special __bases__'>IImportOperation</span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("tk","vk");'>getAlias</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("tk","wk");'>getImportedModuleName</a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("tk","xk");'>addOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("tk","yk");'>copy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("tk","zk");'>detach</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("tk","Ak");'>getAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("tk","Bk");'>getAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("tk","Ck");'>getDataFlow</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("tk","Dk");'>getOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("tk","Ek");'>getOpArguments</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("tk","Fk");'>getOpArgumentsInternalTypes</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("tk","Gk");'>getParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("tk","Hk");'>hasParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("tk","Ik");'>setAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("tk","Jk");'>setAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("tk","Kk");'>setOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("tk","Lk");'>setParent</a></div></div><div class='t'>Values</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&bull;</span><a href='javascript:dO("tk","Mk");'>ARGS</a></div><div class='slot documented'><span
					class='prefix'>&bull;</span><a href='javascript:dO("tk","Nk");'>ARG_NAMES</a></div></div></div><div id='te' class='cr'><div class='n'><a href='javascript:dS("te");'>IClosure</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("te","ue");'><span class='special __bases__'>IProcess, IContext</span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("te","ve");'>getArguments</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("te","we");'>setArguments</a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("te","xe");'>addOperation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("te","ye");'>copy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("te","ze");'>detach</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("te","Ae");'>getAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("te","Be");'>getAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("te","Ce");'>getDataFlow</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("te","De");'>getOperations</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("te","Ee");'>getParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("te","Fe");'>getSlot</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("te","Ge");'>getSlots</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("te","He");'>hasParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("te","Ie");'>hasSlot</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("te","Je");'>setAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("te","Ke");'>setAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("te","Le");'>setParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("te","Me");'>setSlot</a></div></div></div><div id='d_Z' class='de'><h1>Method <span class='n'>setAbstract</span></h1><div class='re'><code>setAbstract( self, isAbstract )</code></div><div class='ds'><p>Sets wether the given abstractable is abstract or not.</p></div></div><div id='d_Lz' class='de'><h1>Method <span class='n'>clone</span></h1><div class='re'><code>clone( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_X' class='de'><h1>Method <span class='n'>hasSlot</span></h1><div class='re'><code>hasSlot( self, name )</code></div><div class='ds'><p>Tells if the context has a slot with the given name.</p></div></div><div id='d_Y' class='de'><h1>Method <span class='n'>isAbstract</span></h1><div class='re'><code>isAbstract( self )</code></div><div class='ds'><p>Tells wether the given abstractable is abstract or not.</p></div></div><div id='d_R' class='de'><h1>Method <span class='n'>getOperations</span></h1><div class='re'><code>getOperations( self )</code></div><div class='ds'><p>Returns the operations (methods and class methods) defined within this class.</p></div></div><div id='d_S' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns the parent context for this context (if any)</p></div></div><div id='d_P' class='de'><h1>Method <span class='n'>getMethods</span></h1><div class='re'><code>getMethods( self )</code></div><div class='ds'><p>Returns the methods defined within this class.</p></div></div><div id='d_Q' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><p>Returns this class name. It can be <code>None</code> if the class is anonymous.</p></div></div><div id='d_V' class='de'><h1>Method <span class='n'>getSlots</span></h1><div class='re'><code>getSlots( self )</code></div><div class='ds'><p>Returns (key, evaluable) pairs representing the slots within this context.</p></div></div><div id='d_W' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><p>Tells if this element has a parent or not</p></div></div><div id='d_T' class='de'><h1>Method <span class='n'>getParentClasses</span></h1><div class='re'><code>getParentClasses( self )</code></div><div class='ds'><p>Returns the list of inherited classes references.</p></div></div><div id='d_U' class='de'><h1>Method <span class='n'>getSlot</span></h1><div class='re'><code>getSlot( self, name )</code></div><div class='ds'><p>Returns the given evaluable bound to named slot.</p></div></div><div id='d_J' class='de'><h1>Method <span class='n'>getClassAttributes</span></h1><div class='re'><code>getClassAttributes( self )</code></div><div class='ds'><p>Returns the class attributes defined within this class.</p></div></div><div id='d_K' class='de'><h1>Method <span class='n'>getClassMethods</span></h1><div class='re'><code>getClassMethods( self )</code></div><div class='ds'><p>Returns the class method defined within this class.</p></div></div><div id='d_H' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_I' class='de'><h1>Method <span class='n'>getAttributes</span></h1><div class='re'><code>getAttributes( self )</code></div><div class='ds'><p>Returns the (non-class) attributes defined within this class.</p></div></div><div id='d_N' class='de'><h1>Method <span class='n'>getDestructors</span></h1><div class='re'><code>getDestructors( self )</code></div><div class='ds'><p>Returns the destructors for this class</p></div></div><div id='d_O' class='de'><h1>Method <span class='n'>getInstanceMethods</span></h1><div class='re'><code>getInstanceMethods( self )</code></div><div class='ds'><p>Returns the instance methods defined within this class.</p></div></div><div id='d_L' class='de'><h1>Method <span class='n'>getConstructors</span></h1><div class='re'><code>getConstructors( self )</code></div><div class='ds'><p>Returns the constructors for this class</p></div></div><div id='d_M' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_Lc' class='de'><h1>Method <span class='n'>getAbsoluteName</span></h1><div class='re'><code>getAbsoluteName( self )</code></div><div class='ds'><p>Returns the absolute name for this element</p></div></div><div id='d_Lb' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_A' class='de'><h1>Method <span class='n'>setResultAbstractType</span></h1><div class='re'><code>setResultAbstractType( self, abstractType )</code></div><div class='ds'><p>Sets the abstract type for this operation result. This is usually invoked in the typing phase.</p></div></div><div id='d_F' class='de'><h1>Method <span class='n'>getAbsoluteName</span></h1><div class='re'><code>getAbsoluteName( self )</code></div><div class='ds'><p>Returns the absolute name for this element</p></div></div><div id='d_G' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_Le' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, context )</code></div><div class='ds'><p>Sets the parent context for this context.</p></div></div><div id='d_E' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><p>Detaches the element from its parent (in case it was already attached). This should return this element, and set the parent to None.</p></div></div><div id='d_z' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><p>Sets this element parent</p></div></div><div id='d_x' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_y' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_r' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_s' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><p>Returns the local name for this referencable element</p></div></div><div id='d_p' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_q' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_v' class='de'><h1>Method <span class='n'>getResultAbstractType</span></h1><div class='re'><code>getResultAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type of the result of the evaluation of this evaluable</p></div></div><div id='d_w' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><p>Tells if this element has a parent or not</p></div></div><div id='d_t' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns this element parent</p></div></div><div id='d_u' class='de'><h1>Method <span class='n'>getReferenceName</span></h1><div class='re'><code>getReferenceName( self )</code></div><div class='ds'><p>Returns the name which this reference contains. The name is used by the resolution operation to actually resolve a value from the name.</p></div></div><div id='d_j' class='de'><h1>int</h1><div class='re'></div><div class='ds'><p>int(x<a href="#,-BASE" class="internal">, base</a>) -&gt; integer</p><p>Convert a string or number to an integer, if possible. A floating point argument will be truncated towards zero (this does not include a string representation of a floating point number!) When converting a string, use the optional base. It is an error to supply a base when converting a non-string. If the argument is outside the integer range a long object will be returned instead.</p></div></div><div id='d_k' class='de'><h1>Class <span class='n'>IAbsoluteReference</span></h1><div class='re'></div><div class='ds'><p>An absolute reference is a specific kind of reference that does not necessarily resolve in the current context, but will rather use the program root context as a starting point.</p></div></div><div id='d_h' class='de'><h1>str</h1><div class='re'><code>'__main__'</code></div><div class='ds'><p>str(object) -&gt; string</p><p>Return a nice string representation of the object. If the argument is a string, the return value is the same object.</p></div></div><div id='d_i' class='de'><h1>str</h1><div class='re'><code>'__moduleinit__'</code></div><div class='ds'><p>str(object) -&gt; string</p><p>Return a nice string representation of the object. If the argument is a string, the return value is the same object.</p></div></div><div id='d_n' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><p>Detaches the element from its parent (in case it was already attached). This should return this element, and set the parent to None.</p></div></div><div id='d_o' class='de'><h1>Method <span class='n'>getAbsoluteName</span></h1><div class='re'><code>getAbsoluteName( self )</code></div><div class='ds'><p>Returns the absolute name for this element</p></div></div><div id='d_l' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IReference at 0x7bf630&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_m' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><p>Performs a deep clone of this element. Any mutation to the original won't change the copy.</p></div></div><div id='d_b' class='de'><h1>Class <span class='n'>Constants</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_c' class='de'><h1>tuple</h1><div class='re'><code>()</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_LA' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.typecast.Map at 0x120ea80&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_a' class='de'><h1>Module <span class='n'>lambdafactory.interfaces</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_f' class='de'><h1>str</h1><div class='re'><code>'__currentvalue__'</code></div><div class='ds'><p>str(object) -&gt; string</p><p>Return a nice string representation of the object. If the argument is a string, the return value is the same object.</p></div></div><div id='d_g' class='de'><h1>str</h1><div class='re'><code>'__destroy__'</code></div><div class='ds'><p>str(object) -&gt; string</p><p>Return a nice string representation of the object. If the argument is a string, the return value is the same object.</p></div></div><div id='d_d' class='de'><h1>str</h1><div class='re'><code>'__init__'</code></div><div class='ds'><p>str(object) -&gt; string</p><p>Return a nice string representation of the object. If the argument is a string, the return value is the same object.</p></div></div><div id='d_e' class='de'><h1>str</h1><div class='re'><code>'__current__'</code></div><div class='ds'><p>str(object) -&gt; string</p><p>Return a nice string representation of the object. If the argument is a string, the return value is the same object.</p></div></div><div id='Eo' class='cr'><div class='n'><a href='javascript:dS("Eo");'>IInvocable</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("Eo","c");'><span class='special __bases__'><i>Base class</i></span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Eo","Fo");'>getArguments</a></div></div></div><div id='Sc' class='cr'><div class='n'><a href='javascript:dS("Sc");'>IBreaking</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("Sc","Tc");'><span class='special __bases__'>IInterruption</span></a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Sc","Uc");'>addOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Sc","Vc");'>copy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Sc","Wc");'>detach</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Sc","Xc");'>getAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Sc","Yc");'>getAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Sc","Zc");'>getDataFlow</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Sc","ad");'>getOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Sc","bd");'>getOpArguments</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Sc","cd");'>getOpArgumentsInternalTypes</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Sc","dd");'>getParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Sc","ed");'>hasParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Sc","fd");'>setAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Sc","gd");'>setAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Sc","hd");'>setOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Sc","id");'>setParent</a></div></div><div class='t'>Values</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&bull;</span><a href='javascript:dO("Sc","jd");'>ARGS</a></div></div></div><div id='d_BE' class='de'><h1>str</h1><div class='re'><code>'Documentation'</code></div><div class='ds'><p>str(object) -&gt; string</p><p>Return a nice string representation of the object. If the argument is a string, the return value is the same object.</p></div></div><div id='d_kB' class='de'><h1>Method <span class='n'>subtype</span></h1><div class='re'><code>subtype( self, name )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_kC' class='de'><h1>Class <span class='n'>Sequence</span></h1><div class='re'></div><div class='ds'><p>A sequence is simply an ordered set of types.</p></div></div><div id='d_kA' class='de'><h1>Method <span class='n'>clone</span></h1><div class='re'><code>clone( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_kF' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.IModule at 0x7bf8a0&gt;]</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='d_kG' class='de'><h1>Method <span class='n'>getFactory</span></h1><div class='re'><code>getFactory( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_kD' class='de'><h1>Method <span class='n'>setName</span></h1><div class='re'><code>setName( self, name )</code></div><div class='ds'><p>Sets the name of this type</p></div></div><div id='d_kE' class='de'><h1>Method <span class='n'>getFactory</span></h1><div class='re'><code>getFactory( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_kH' class='de'><h1>Method <span class='n'>dedent</span></h1><div class='re'><code>dedent( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_VF' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self, environment=None, programPass=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_kr' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.IEvaluable at 0x7bf450&gt;, &lt;class lambdafactory.interfaces.IProcess at 0x7bf900&gt;]</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='d_ks' class='de'><h1>Method <span class='n'>getDefaultValue</span></h1><div class='re'><code>getDefaultValue( self )</code></div><div class='ds'><p>Gets the @methodault value for this attribute</p></div></div><div id='d_kp' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_kq' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><p>Returns the ith arguments to this operation.</p></div></div><div id='d_kv' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_kw' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.ILiteral at 0x7bf540&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_kt' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_ku' class='de'><h1>Class <span class='n'>IReference</span></h1><div class='re'></div><div class='ds'><p>A reference is a name that can be converted into a value using a resolution operation (for instance).</p></div></div><div id='d_kz' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.modeltypes.TypeCollection at 0x120e0f0&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_kx' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><p>Sets the given argument of this operation, by argument index.</p></div></div><div id='d_ky' class='de'><h1>Method <span class='n'>createProgram</span></h1><div class='re'><code>createProgram( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_kb' class='de'><h1>Method <span class='n'>getIndex</span></h1><div class='re'><code>getIndex( self )</code></div><div class='ds'><p>Returns evaluable that will return the access index</p></div></div><div id='d_kc' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><p>Returns the local name for this referencable element</p></div></div><div id='d_kf' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns this element parent</p></div></div><div id='d_kg' class='de'><h1>Method <span class='n'>addSource</span></h1><div class='re'><code>addSource( self, dataflow )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_kd' class='de'><h1>Class <span class='n'>IClass</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_ke' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><p>Tells if this element has a parent or not</p></div></div><div id='d_kj' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_kk' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_kh' class='de'><h1>Method <span class='n'>setValue</span></h1><div class='re'><code>setValue( self, key, value )</code></div><div class='ds'><p>Sets the value to be associated to the given key (which must be an evaluable).</p></div></div><div id='d_ki' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><p>Adds an argument to this operation. This should do checking of arguments (by expected internal type and number).</p></div></div><div id='d_kn' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.IEvaluable at 0x7bf450&gt;, [&lt;class lambdafactory.interfaces.IEvaluable at 0x7bf450&gt;]]</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='d_ko' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, context )</code></div><div class='ds'><p>Sets the parent context for this context.</p></div></div><div id='d_kl' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><p>Adds an argument to this operation. This should do checking of arguments (by expected internal type and number).</p></div></div><div id='d_km' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='Ez' class='cr'><div class='n'><a href='javascript:dS("Ez");'>Arguments</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("Ez","Fz");'><span class='special __bases__'>Sequence</span></a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("Ez","Gz");'><span class='special __call__'>when invoked</span></a></div><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("Ez","Hz");'><span class='special __init__'>constructor</span></a></div><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("Ez","Iz");'><span class='special __str__'>string conversion</span></a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Ez","Jz");'>add</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Ez","Kz");'>asString</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Ez","Lz");'>clone</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Ez","Mz");'>concreteType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Ez","Nz");'>definedBy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Ez","Oz");'>elements</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Ez","Pz");'>extend</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Ez","Qz");'>isLike</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Ez","Rz");'>isSameAs</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Ez","Sz");'>isSubtypeOf</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Ez","Tz");'>length</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Ez","Uz");'>name</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Ez","Vz");'>result</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Ez","Wz");'>setConcreteType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Ez","Xz");'>setName</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Ez","Yz");'>subtype</a></div></div></div><div id='fb' class='cr'><div class='n'><a href='javascript:dS("fb");'>IAbstractable</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("fb","c");'><span class='special __bases__'><i>Base class</i></span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("fb","gb");'>isAbstract</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("fb","hb");'>setAbstract</a></div></div></div><div id='a' class='ro'><div class='n'><a href='javascript:dS("a");'>lambdafactory.interfaces</a></div><div class='t'>Classes</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","b");'>Constants</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","k");'>IAbsoluteReference</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","B");'>IAbstractClass</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","fb");'>IAbstractable</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","ib");'>IAccessOperation</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","Cb");'>IAllocation</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","Wb");'>IAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","Zb");'>IArgument</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","mc");'>IAssignable</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","nc");'>IAssignation</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","Hc");'>IAttribute</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","Oc");'>IBlock</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","Sc");'>IBreaking</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","kd");'>IClass</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","Md");'>IClassAttribute</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","Td");'>IClassMethod</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","te");'>IClosure</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","Ne");'>IComment</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","Re");'>IComputation</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","rf");'>IConstructor</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","Rf");'>IContext</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","hg");'>IDataFlow</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","zg");'>IDataFlowOwner</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","Ag");'>IDataFlowSlot</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","Hg");'>IDestructor</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","hh");'>IDict</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","xh");'>IDocumentation</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","Bh");'>IElement</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","Mh");'>IEmbed</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","ii");'>IEmbedTemplate</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","Di");'>IEnumeration</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","Zi");'>IEvaluable</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","cj");'>IEvaluation</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","wj");'>IExcept</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","Pj");'>IFunction</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","pk");'>IGroup</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","tk");'>IImportModuleOperation</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","Ok");'>IImportModulesOperation</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","il");'>IImportOperation</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","zl");'>IImportSymbolOperation</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","Vl");'>IImportSymbolsOperation</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","qm");'>IInstanceMethod</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","Qm");'>IInstanciable</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","Rm");'>IInstanciation</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","ln");'>IInterception</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","Jn");'>IInterface</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","no");'>IInterruption</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","Eo");'>IInvocable</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","Go");'>IInvocation</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","bp");'>IIteration</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","vp");'>IList</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","Lp");'>ILiteral</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","aq");'>IMatchExpressionOperation</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","wq");'>IMatchOperation</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","Pq");'>IMatchProcessOperation</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","lr");'>IMethod</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","Lr");'>IModule</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","hs");'>IModuleAttribute</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","os");'>INumber</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","Ds");'>IOperation</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","Us");'>IOperator</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","nt");'>IParameter</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","It");'>IProcess</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","Lt");'>IProgram</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","gu");'>IReferencable</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","ku");'>IReference</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","Bu");'>IRepetition</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","Vu");'>IResolution</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","pv");'>ISelection</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","Jv");'>ISliceOperation</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","ew");'>ISlot</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","jw");'>IString</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","yw");'>ISubsetOperation</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","Qw");'>ISyntactic</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","Uw");'>ITermination</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("a","nx");'>IValue</a></div></div></div><div id='yz' class='cr'><div class='n'><a href='javascript:dS("yz");'>TypeCollection</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("yz","c");'><span class='special __bases__'><i>Base class</i></span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("yz","zz");'>getType</a></div></div></div><div id='yw' class='cr'><div class='n'><a href='javascript:dS("yw");'>ISubsetOperation</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("yw","zw");'><span class='special __bases__'>IOperation</span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("yw","Aw");'>getTarget</a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("yw","Bw");'>addOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("yw","Cw");'>copy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("yw","Dw");'>detach</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("yw","Ew");'>getAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("yw","Fw");'>getAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("yw","Gw");'>getDataFlow</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("yw","Hw");'>getOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("yw","Iw");'>getOpArguments</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("yw","Jw");'>getOpArgumentsInternalTypes</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("yw","Kw");'>getParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("yw","Lw");'>hasParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("yw","Mw");'>setAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("yw","Nw");'>setAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("yw","Ow");'>setOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("yw","Pw");'>setParent</a></div></div></div><div id='yG' class='cr'><div class='n'><a href='javascript:dS("yG");'>TransformAsynchronousInvocations</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("yG","zG");'><span class='special __bases__'>Pass</span></a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("yG","AG");'><span class='special __init__'>constructor</span></a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("yG","BG");'>filter</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("yG","CG");'>filterContext</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("yG","DG");'>findInContext</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("yG","EG");'>getCurrentClass</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("yG","FG");'>getCurrentClassAncestors</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("yG","GG");'>getCurrentClassParents</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("yG","HG");'>getCurrentClosure</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("yG","IG");'>getCurrentContext</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("yG","JG");'>getCurrentDataFlow</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("yG","KG");'>getCurrentElement</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("yG","LG");'>getCurrentFunction</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("yG","MG");'>getCurrentMethod</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("yG","NG");'>getCurrentModule</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("yG","OG");'>getCurrentProcess</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("yG","PG");'>getFactory</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("yG","QG");'>getHandle</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("yG","RG");'>getName</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("yG","SG");'>getParentElement</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("yG","TG");'>getProgram</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("yG","UG");'>handle</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("yG","VG");'>hasParentElement</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("yG","WG");'>isIn</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("yG","XG");'>resolve</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("yG","YG");'>resolveAbsolute</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("yG","ZG");'>resolveAbsoluteOrLocal</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("yG","aH");'>resolveLocalOrAbsolute</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("yG","bH");'>run</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("yG","cH");'>setEnvironment</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("yG","dH");'>setPass</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("yG","eH");'>walk</a></div></div><div class='t'>Values</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&bull;</span><a href='javascript:dO("yG","fH");'>HANDLES</a></div><div class='slot documented'><span
					class='prefix'>&bull;</span><a href='javascript:dO("yG","gH");'>NAME</a></div></div></div><div id='d_QD' class='de'><h1>Module <span class='n'>lambdafactory.passes</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_QE' class='de'><h1>Method <span class='n'>getCurrentFunction</span></h1><div class='re'><code>getCurrentFunction( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_QF' class='de'><h1>Method <span class='n'>setEnvironment</span></h1><div class='re'><code>setEnvironment( self, environment )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_QG' class='de'><h1>Method <span class='n'>getHandle</span></h1><div class='re'><code>getHandle( self, element )</code></div><div class='ds'><p>Tells if the pass handles the given element. This basically iterates on the <code>handles</code> property values (which are interfaces), when one interface matches the given <code>element</code>, then the corresponding <code>onXXX</code> method is invoked, where <code>XXX</code> is the interface name (without the leading <code>I</code>).</p></div></div><div id='d_QA' class='de'><h1>Method <span class='n'>extends</span></h1><div class='re'><code>extends( self, parent )</code></div><div class='ds'><p>Add a new parent from which this Context inherits.</p></div></div><div id='d_QB' class='de'><h1>Method <span class='n'>_ensureIntegrity</span></h1><div class='re'><code>_ensureIntegrity( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_QC' class='de'><h1>Method <span class='n'>isSubtypeOf</span></h1><div class='re'><code>isSubtypeOf( self, otherType )</code></div><div class='ds'><p>Generic implementation of isSubtypeOf. You should always call this method in subclasses, as it implements basic type systems rules such as isSubtypeOf(Any).</p></div></div><div id='d_Qx' class='de'><h1>Method <span class='n'>_string</span></h1><div class='re'><code>_string( self, value )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Qy' class='de'><h1>Module <span class='n'>lambdafactory.modelwriter</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Qz' class='de'><h1>Method <span class='n'>isLike</span></h1><div class='re'><code>isLike( self, otherType )</code></div><div class='ds'><p>The other type is like this one if the other is a sequence with the same length and that all elements are like the corresponding elements of this sequence.</p></div></div><div id='d_Qt' class='de'><h1>Method <span class='n'>getModules</span></h1><div class='re'><code>getModules( self )</code></div><div class='ds'><p>Returns the list of modules declared/imported in this program</p></div></div><div id='d_Qu' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_Qv' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_Qw' class='de'><h1>Class <span class='n'>ISyntactic</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Qp' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_Qq' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IMatchOperation at 0x7bfde0&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Qr' class='de'><h1>Method <span class='n'>getParentName</span></h1><div class='re'><code>getParentName( self )</code></div><div class='ds'><p>Returns the parent name of this module (if any)</p></div></div><div id='d_Qs' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><p>Tells if this element has a parent or not</p></div></div><div id='d_Ql' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_Qm' class='de'><h1>Class <span class='n'>IInstanciable</span></h1><div class='re'></div><div class='ds'><p>Instanciable is a property of some elements that allows them to be instanciated. Conceptually, an instanciation could be considered as a specific kind of invocation.</p></div></div><div id='d_Qn' class='de'><h1>Method <span class='n'>getAttributes</span></h1><div class='re'><code>getAttributes( self )</code></div><div class='ds'><p>Returns the (non-class) attributes defined within this class.</p></div></div><div id='d_Qo' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_Qh' class='de'><h1>Method <span class='n'>setCode</span></h1><div class='re'><code>setCode( self, code )</code></div><div class='ds'><p>Sets the code of this embed operation.</p></div></div><div id='d_Qi' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><p>Returns the arguments to this operation.</p></div></div><div id='d_Qj' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IClosure at 0x7bf990&gt;, &lt;class lambdafactory.interfaces.IReferencable at 0x7bf420&gt;, &lt;class lambdafactory.interfaces.IAbstractable at 0x7bf4e0&gt;)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Qk' class='de'><h1>Method <span class='n'>getImportedModuleNames</span></h1><div class='re'><code>getImportedModuleNames( self )</code></div><div class='ds'><p>Returns the list of names representing the modules to load</p></div></div><div id='d_Qd' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><p>Returns the local name for this referencable element</p></div></div><div id='d_Qe' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><p>Returns the name of this annotation.</p></div></div><div id='d_Qf' class='de'><h1>Method <span class='n'>setSlot</span></h1><div class='re'><code>setSlot( self, name, evaluable )</code></div><div class='ds'><p>Binds the given evaluable to the named slot.</p></div></div><div id='d_Qg' class='de'><h1>Method <span class='n'>getArguments</span></h1><div class='re'><code>getArguments( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Qb' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><p>Tells if this element has a parent or not</p></div></div><div id='d_Qc' class='de'><h1>Method <span class='n'>addOperation</span></h1><div class='re'><code>addOperation( self, operation )</code></div><div class='ds'><p>Adds the given operation as a child of this process.</p></div></div><div id='d_OF' class='de'><h1>Method <span class='n'>resolveLocalOrAbsolute</span></h1><div class='re'><code>resolveLocalOrAbsolute( self, referenceOrName, contextOrDataFlow=None )</code></div><div class='ds'><p>Tries a local resolution first, then will look in the program scope if it fails.</p></div></div><div id='d_OG' class='de'><h1>Method <span class='n'>getCurrentProcess</span></h1><div class='re'><code>getCurrentProcess( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_OD' class='de'><h1>instance</h1><div class='re'></div><div class='ds'><p>Symbolic types are types that have no physical counter part but play a role in the type system. This is for instance the case with Any or Nil.</p></div></div><div id='d_OE' class='de'><h1>Method <span class='n'>getCurrentDataFlow</span></h1><div class='re'><code>getCurrentDataFlow( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_OB' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.typecast.Type at 0x120e900&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_OC' class='de'><h1>Method <span class='n'>isLike</span></h1><div class='re'><code>isLike( self, otherType )</code></div><div class='ds'><p>Generic implementation of isLike. You should always call this method in subclasses, as it implements basic type systems rules such as isLike(Any).</p></div></div><div id='d_OA' class='de'><h1>Method <span class='n'>element</span></h1><div class='re'><code>element( self, key )</code></div><div class='ds'><p>Returns the element associated with the given key, or <code>None</code> if it does not exist.</p></div></div><div id='d_Of' class='de'><h1>Method <span class='n'>setArguments</span></h1><div class='re'><code>setArguments( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Og' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_Od' class='de'><h1>Method <span class='n'>getAbsoluteName</span></h1><div class='re'><code>getAbsoluteName( self )</code></div><div class='ds'><p>Returns the absolute name for this element</p></div></div><div id='d_Oe' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IAnnotation at 0x7bf270&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Ob' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><p>Returns the <em>internal types</em> for this operations arguments. This is typically the list of interfaces or @protocols that the arguments must comply to.</p></div></div><div id='d_Oc' class='de'><h1>Class <span class='n'>IBlock</span></h1><div class='re'></div><div class='ds'><p>A block is a specific type of (sub) process.</p></div></div><div id='d_On' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_Oo' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_Ol' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><p>Tells if this element has a parent or not</p></div></div><div id='d_Om' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, context )</code></div><div class='ds'><p>Sets the parent context for this context.</p></div></div><div id='d_Oj' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.IEvaluable at 0x7bf450&gt;]</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='d_Ok' class='de'><h1>Class <span class='n'>IImportModulesOperation</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Oh' class='de'><h1>Method <span class='n'>getCode</span></h1><div class='re'><code>getCode( self )</code></div><div class='ds'><p>Returns the embedded code string.</p></div></div><div id='d_Oi' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_Ov' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><p>Performs a deep clone of this element. Any mutation to the original won't change the copy.</p></div></div><div id='d_Ow' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><p>Sets the given argument of this operation, by argument index.</p></div></div><div id='d_Ot' class='de'><h1>Method <span class='n'>getFactory</span></h1><div class='re'><code>getFactory( self )</code></div><div class='ds'><p>Gets the factory that was used to create this program. It can be used to create more elements in the program.</p></div></div><div id='d_Ou' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns this element parent</p></div></div><div id='d_Or' class='de'><h1>Method <span class='n'>getClasses</span></h1><div class='re'><code>getClasses( self )</code></div><div class='ds'><p>Returns the list of classes defined in this module. This is mainly a convenience function.</p></div></div><div id='d_Os' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_Op' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><p>Performs a deep clone of this element. Any mutation to the original won't change the copy.</p></div></div><div id='d_Oq' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><p>Sets this element parent</p></div></div><div id='d_Oz' class='de'><h1>Method <span class='n'>elements</span></h1><div class='re'><code>elements( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Ox' class='de'><h1>Method <span class='n'>_ref</span></h1><div class='re'><code>_ref( self, name )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Oy' class='de'><h1>wrapper_descriptor</h1><div class='re'></div><div class='ds'><div class="section" level="1"><h1 class="heading"><span class="number"><span class="level0">1<span class="lastDot dot">.</span></span></span><span class='term'>init</span><span class='term'>(...) initializes x; see x.</span><span class='term'>class</span><span class='term'>.</span><span class='term'>doc</span>_ for signature</h1><div class="level1"></div></div></div></div><div id='b' class='cr'><div class='n'><a href='javascript:dS("b");'>Constants</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("b","c");'><span class='special __bases__'><i>Base class</i></span></a></div></div><div class='t'>Values</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&sdot;</span><a href='javascript:dO("b","d");'>Constructor</a></div><div class='slot documented'><span
					class='prefix'>&sdot;</span><a href='javascript:dO("b","e");'>CurrentModule</a></div><div class='slot documented'><span
					class='prefix'>&sdot;</span><a href='javascript:dO("b","f");'>CurrentValue</a></div><div class='slot documented'><span
					class='prefix'>&sdot;</span><a href='javascript:dO("b","g");'>Destructor</a></div><div class='slot documented'><span
					class='prefix'>&sdot;</span><a href='javascript:dO("b","h");'>MainFunction</a></div><div class='slot documented'><span
					class='prefix'>&sdot;</span><a href='javascript:dO("b","i");'>ModuleInit</a></div><div class='slot documented'><span
					class='prefix'>&bull;</span><a href='javascript:dO("b","j");'>PARENS_PRIORITY</a></div></div></div><div id='d_XD' class='de'><h1>Method <span class='n'>filterContext</span></h1><div class='re'><code>filterContext( self, interface )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='kC' class='cr'><div class='n'><a href='javascript:dS("kC");'>Sequence</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("kC","lC");'><span class='special __bases__'>Type</span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("kC","mC");'><span class='special __init__'>constructor</span></a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("kC","nC");'>add</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("kC","oC");'>asString</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("kC","pC");'>elements</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("kC","qC");'>extend</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("kC","rC");'>isLike</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("kC","sC");'>isSameAs</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("kC","tC");'>isSubtypeOf</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("kC","uC");'>length</a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("kC","vC");'><span class='special __call__'>when invoked</span></a></div><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("kC","wC");'><span class='special __str__'>string conversion</span></a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("kC","xC");'>clone</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("kC","yC");'>concreteType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("kC","zC");'>definedBy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("kC","AC");'>name</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("kC","BC");'>result</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("kC","CC");'>setConcreteType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("kC","DC");'>setName</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("kC","EC");'>subtype</a></div></div></div><div id='kd' class='cr'><div class='n'><a href='javascript:dS("kd");'>IClass</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("kd","ld");'><span class='special __bases__'>IContext, IReferencable</span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("kd","md");'>getAttributes</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("kd","nd");'>getClassAttributes</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("kd","od");'>getClassMethods</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("kd","pd");'>getConstructors</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("kd","qd");'>getDestructors</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("kd","rd");'>getInstanceMethods</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("kd","sd");'>getMethods</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("kd","td");'>getName</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("kd","ud");'>getOperations</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("kd","vd");'>getParentClasses</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("kd","wd");'>setParentClasses</a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("kd","xd");'>copy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("kd","yd");'>detach</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("kd","zd");'>getAbsoluteName</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("kd","Ad");'>getAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("kd","Bd");'>getAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("kd","Cd");'>getDataFlow</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("kd","Dd");'>getParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("kd","Ed");'>getSlot</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("kd","Fd");'>getSlots</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("kd","Gd");'>hasParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("kd","Hd");'>hasSlot</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("kd","Id");'>setAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("kd","Jd");'>setAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("kd","Kd");'>setParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("kd","Ld");'>setSlot</a></div></div></div><div id='ku' class='cr'><div class='n'><a href='javascript:dS("ku");'>IReference</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("ku","lu");'><span class='special __bases__'>IValue, IReferencable</span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ku","mu");'>getReferenceName</a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ku","nu");'>copy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ku","ou");'>detach</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ku","pu");'>getAbsoluteName</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ku","qu");'>getAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ku","ru");'>getAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ku","su");'>getDataFlow</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ku","tu");'>getName</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ku","uu");'>getParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ku","vu");'>getResultAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ku","wu");'>hasParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ku","xu");'>setAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ku","yu");'>setAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ku","zu");'>setParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ku","Au");'>setResultAbstractType</a></div></div></div><div id='Jv' class='cr'><div class='n'><a href='javascript:dS("Jv");'>ISliceOperation</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("Jv","Kv");'><span class='special __bases__'>ISubsetOperation</span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Jv","Lv");'>getSliceEnd</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Jv","Mv");'>getSliceStart</a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Jv","Nv");'>addOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Jv","Ov");'>copy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Jv","Pv");'>detach</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Jv","Qv");'>getAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Jv","Rv");'>getAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Jv","Sv");'>getDataFlow</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Jv","Tv");'>getOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Jv","Uv");'>getOpArguments</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Jv","Vv");'>getOpArgumentsInternalTypes</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Jv","Wv");'>getParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Jv","Xv");'>getTarget</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Jv","Yv");'>hasParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Jv","Zv");'>setAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Jv","aw");'>setAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Jv","bw");'>setOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Jv","cw");'>setParent</a></div></div><div class='t'>Values</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&bull;</span><a href='javascript:dO("Jv","dw");'>ARGS</a></div></div></div><div id='Jn' class='cr'><div class='n'><a href='javascript:dS("Jn");'>IInterface</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("Jn","Kn");'><span class='special __bases__'>IAbstractClass</span></a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Jn","Ln");'>copy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Jn","Mn");'>detach</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Jn","Nn");'>getAbsoluteName</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Jn","On");'>getAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Jn","Pn");'>getAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Jn","Qn");'>getAttributes</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Jn","Rn");'>getClassAttributes</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Jn","Sn");'>getClassMethods</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Jn","Tn");'>getConstructors</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Jn","Un");'>getDataFlow</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Jn","Vn");'>getDestructors</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Jn","Wn");'>getInstanceMethods</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Jn","Xn");'>getMethods</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Jn","Yn");'>getName</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Jn","Zn");'>getOperations</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Jn","ao");'>getParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Jn","bo");'>getParentClasses</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Jn","co");'>getSlot</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Jn","do");'>getSlots</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Jn","eo");'>hasParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Jn","fo");'>hasSlot</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Jn","go");'>isAbstract</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Jn","ho");'>setAbstract</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Jn","io");'>setAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Jn","jo");'>setAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Jn","ko");'>setParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Jn","lo");'>setParentClasses</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Jn","mo");'>setSlot</a></div></div></div><div id='d_jH' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_jE' class='de'><h1>Method <span class='n'>getCurrentProcess</span></h1><div class='re'><code>getCurrentProcess( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_jD' class='de'><h1>Method <span class='n'>setConcreteType</span></h1><div class='re'><code>setConcreteType( self, value )</code></div><div class='ds'><p>Sets the <span class='term'>concrete type</span> for this abstract type. The concrete type is a value which represents the type. For instance, if this type represents a class, then the concrete type would be the class instance.</p></div></div><div id='d_jG' class='de'><h1>Method <span class='n'>getCurrentProcess</span></h1><div class='re'><code>getCurrentProcess( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_jF' class='de'><h1>Method <span class='n'>walk</span></h1><div class='re'><code>walk( self, element )</code></div><div class='ds'><p>Walks the given element, recursively walking the child elements when the handler does not return False</p></div></div><div id='d_jA' class='de'><h1>Method <span class='n'>__str__</span></h1><div class='re'><code>__str__( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_jC' class='de'><h1>Class <span class='n'>SemanticError</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_jB' class='de'><h1>Method <span class='n'>setName</span></h1><div class='re'><code>setName( self, name )</code></div><div class='ds'><p>Sets the name of this type</p></div></div><div id='d_jy' class='de'><h1>Method <span class='n'>createModule</span></h1><div class='re'><code>createModule( self, name )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_jx' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_jz' class='de'><h1>Class <span class='n'>Behaviour</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_ju' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><p>Returns the local name for this referencable element</p></div></div><div id='d_jt' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_jw' class='de'><h1>Class <span class='n'>IString</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_jv' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><p>Tells if this element has a parent or not</p></div></div><div id='d_jq' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_jp' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_js' class='de'><h1>Method <span class='n'>getAbsoluteName</span></h1><div class='re'><code>getAbsoluteName( self )</code></div><div class='ds'><p>Returns the absolute name for this element</p></div></div><div id='d_jr' class='de'><h1>Method <span class='n'>setPredicate</span></h1><div class='re'><code>setPredicate( self, v )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_jm' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><p>Tells if this element has a parent or not</p></div></div><div id='d_jl' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IOperation at 0x7bfae0&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_jo' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_jn' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><p>Sets this element parent</p></div></div><div id='d_ji' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IEmbed at 0x1174060&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_jh' class='de'><h1>Method <span class='n'>getItems</span></h1><div class='re'><code>getItems( self )</code></div><div class='ds'><p>Returns the items contained in this dict</p></div></div><div id='d_jk' class='de'><h1>Method <span class='n'>setAbstract</span></h1><div class='re'><code>setAbstract( self, isAbstract )</code></div><div class='ds'><p>Sets wether the given abstractable is abstract or not.</p></div></div><div id='d_jj' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_je' class='de'><h1>Method <span class='n'>hasExplicitTermination</span></h1><div class='re'><code>hasExplicitTermination( self )</code></div><div class='ds'><p>Returns true if this function has an operation with a termination, otherwise return false.</p></div></div><div id='d_jd' class='de'><h1>list</h1><div class='re'><code>[]</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='d_jg' class='de'><h1>Method <span class='n'>addDestination</span></h1><div class='re'><code>addDestination( self, dataflow )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_jf' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><p>Returns the <em>internal types</em> for this operations arguments. This is typically the list of interfaces or @protocols that the arguments must comply to.</p></div></div><div id='d_jc' class='de'><h1>Method <span class='n'>getAbsoluteName</span></h1><div class='re'><code>getAbsoluteName( self )</code></div><div class='ds'><p>Returns the absolute name for this element</p></div></div><div id='d_jb' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.ISubsetOperation at 0x7bfd50&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_NA' class='de'><h1>Method <span class='n'>clone</span></h1><div class='re'><code>clone( self, clone=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_NC' class='de'><h1>Method <span class='n'>definedBy</span></h1><div class='re'><code>definedBy( self, definition=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_NB' class='de'><h1>Class <span class='n'>Process</span></h1><div class='re'></div><div class='ds'><p>A process generates values by processing (optional) arguments.</p></div></div><div id='d_NE' class='de'><h1>Method <span class='n'>getCurrentContext</span></h1><div class='re'><code>getCurrentContext( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_ND' class='de'><h1>instance</h1><div class='re'></div><div class='ds'><p>Symbolic types are types that have no physical counter part but play a role in the type system. This is for instance the case with Any or Nil.</p></div></div><div id='d_NG' class='de'><h1>Method <span class='n'>getCurrentModule</span></h1><div class='re'><code>getCurrentModule( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_NF' class='de'><h1>Method <span class='n'>resolveAbsoluteOrLocal</span></h1><div class='re'><code>resolveAbsoluteOrLocal( self, referenceOrName, contextOrDataFlow=None )</code></div><div class='ds'><p>Tries an absolute resolution first, then will look in the local scope if it fails.</p></div></div><div id='d_Nc' class='de'><h1>Method <span class='n'>getTypeDescription</span></h1><div class='re'><code>getTypeDescription( self )</code></div><div class='ds'><p>Returns type information (constraints) that are associated to this argument.</p></div></div><div id='d_Nb' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><p>Returns the arguments to this operation.</p></div></div><div id='d_Ne' class='de'><h1>Class <span class='n'>IComment</span></h1><div class='re'></div><div class='ds'><p>A comment is an annotation that can occur anywhere in a source file.</p></div></div><div id='d_Nd' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IAttribute at 0x7bf750&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Ng' class='de'><h1>Method <span class='n'>getAbsoluteName</span></h1><div class='re'><code>getAbsoluteName( self )</code></div><div class='ds'><p>Returns the absolute name for this element</p></div></div><div id='d_Nf' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_Ni' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_Nh' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IOperation at 0x7bfae0&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Nk' class='de'><h1>list</h1><div class='re'><code>['ImportedModuleName', 'Alias']</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='d_Nj' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><p>Sets this element parent</p></div></div><div id='d_Nm' class='de'><h1>Method <span class='n'>setArguments</span></h1><div class='re'><code>setArguments( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Nl' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns this element parent</p></div></div><div id='d_No' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><p>Detaches the element from its parent (in case it was already attached). This should return this element, and set the parent to None.</p></div></div><div id='d_Nn' class='de'><h1>Method <span class='n'>getAbsoluteName</span></h1><div class='re'><code>getAbsoluteName( self )</code></div><div class='ds'><p>Returns the absolute name for this element</p></div></div><div id='d_Nq' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><p>Sets the given argument of this operation, by argument index.</p></div></div><div id='d_Np' class='de'><h1>Method <span class='n'>getActualValue</span></h1><div class='re'><code>getActualValue( self )</code></div><div class='ds'><p>Returns the (implementation language) value for this literal</p></div></div><div id='d_Ns' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_Nr' class='de'><h1>Method <span class='n'>addImportOperation</span></h1><div class='re'><code>addImportOperation( self, operation )</code></div><div class='ds'><p>Returns the list of import operations declared in this module</p></div></div><div id='d_Nu' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><p>Returns the <em>internal types</em> for this operations arguments. This is typically the list of interfaces or @protocols that the arguments must comply to.</p></div></div><div id='d_Nt' class='de'><h1>Method <span class='n'>addModule</span></h1><div class='re'><code>addModule( self, module )</code></div><div class='ds'><p>Adds a module to this program. The module will be registered in the global module catalogue.</p></div></div><div id='d_Nw' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_Nv' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><p>Adds an argument to this operation. This should do checking of arguments (by expected internal type and number).</p></div></div><div id='d_Ny' class='de'><h1>Class <span class='n'>ModelException</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Nx' class='de'><h1>Method <span class='n'>_param</span></h1><div class='re'><code>_param( self, name=None, value=None, asList=False, asMap=False )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Nz' class='de'><h1>Method <span class='n'>definedBy</span></h1><div class='re'><code>definedBy( self, definition=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='pB' class='cr'><div class='n'><a href='javascript:dS("pB");'>InvalidArgument</a></div><div class='t'>Inhertied Values</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("pB","Iy");'><span class='special __getitem__'>get item</span></a></div><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("pB","Oy");'><span class='special __init__'>constructor</span></a></div><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("pB","Jy");'><span class='special __repr__'>string repr</span></a></div><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("pB","Ky");'><span class='special __str__'>string conversion</span></a></div><div class='slot documented'><span
					class='prefix'>&sdot;</span><a href='javascript:dO("pB","Ly");'>args</a></div><div class='slot documented'><span
					class='prefix'>&sdot;</span><a href='javascript:dO("pB","My");'>message</a></div></div></div><div id='pv' class='cr'><div class='n'><a href='javascript:dS("pv");'>ISelection</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("pv","qv");'><span class='special __bases__'>IOperation</span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("pv","rv");'>addRule</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("pv","sv");'>getRules</a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("pv","tv");'>addOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("pv","uv");'>copy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("pv","vv");'>detach</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("pv","wv");'>getAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("pv","xv");'>getAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("pv","yv");'>getDataFlow</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("pv","zv");'>getOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("pv","Av");'>getOpArguments</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("pv","Bv");'>getOpArgumentsInternalTypes</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("pv","Cv");'>getParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("pv","Dv");'>hasParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("pv","Ev");'>setAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("pv","Fv");'>setAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("pv","Gv");'>setOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("pv","Hv");'>setParent</a></div></div><div class='t'>Values</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&bull;</span><a href='javascript:dO("pv","Iv");'>ARGS</a></div></div></div><div id='pz' class='cr'><div class='n'><a href='javascript:dS("pz");'>Operations</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("pz","qz");'><span class='special __bases__'>TypeCollection</span></a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("pz","rz");'>getType</a></div></div></div><div id='pk' class='cr'><div class='n'><a href='javascript:dS("pk");'>IGroup</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("pk","qk");'><span class='special __bases__'>IProcess</span></a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("pk","rk");'>addOperation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("pk","sk");'>getOperations</a></div></div></div><div id='d_PG' class='de'><h1>Method <span class='n'>getFactory</span></h1><div class='re'><code>getFactory( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_PF' class='de'><h1>Method <span class='n'>run</span></h1><div class='re'><code>run( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_PE' class='de'><h1>Method <span class='n'>getCurrentElement</span></h1><div class='re'><code>getCurrentElement( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_PD' class='de'><h1>instance</h1><div class='re'></div><div class='ds'><p>Symbolic types are types that have no physical counter part but play a role in the type system. This is for instance the case with Any or Nil.</p></div></div><div id='d_PC' class='de'><h1>Method <span class='n'>isSameAs</span></h1><div class='re'><code>isSameAs( self, otherType )</code></div><div class='ds'><p>Generic implementation of isSameAs. You should always call this method in subclasses.</p></div></div><div id='d_PB' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self, *args )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_PA' class='de'><h1>Method <span class='n'>elements</span></h1><div class='re'><code>elements( self )</code></div><div class='ds'><p>Returns a dict of the elements in this map.</p></div></div><div id='d_Pz' class='de'><h1>Method <span class='n'>extend</span></h1><div class='re'><code>extend( self, othertype )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Py' class='de'><h1>Function <span class='n'>assertImplements</span></h1><div class='re'><code>assertImplements( v, i )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Px' class='de'><h1>Method <span class='n'>_slot</span></h1><div class='re'><code>_slot( self, name, typeinfo=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Pw' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><p>Sets this element parent</p></div></div><div id='d_Pv' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><p>Detaches the element from its parent (in case it was already attached). This should return this element, and set the parent to None.</p></div></div><div id='d_Pu' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><p>Tells if this element has a parent or not</p></div></div><div id='d_Pt' class='de'><h1>Method <span class='n'>getModule</span></h1><div class='re'><code>getModule( self, moduleAbsoluteName )</code></div><div class='ds'><p>Returns the module (if any) with the given absolute name</p></div></div><div id='d_Ps' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns this element parent</p></div></div><div id='d_Pr' class='de'><h1>Method <span class='n'>getImportOperations</span></h1><div class='re'><code>getImportOperations( self )</code></div><div class='ds'><p>Returns the list of import operations declared in this module</p></div></div><div id='d_Pq' class='de'><h1>Class <span class='n'>IMatchProcessOperation</span></h1><div class='re'></div><div class='ds'><p>A match process is a predicate associate to a process, which is typically used for implementing <code>if</code>, <code>else</code>, etc.</p></div></div><div id='d_Pp' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><p>Detaches the element from its parent (in case it was already attached). This should return this element, and set the parent to None.</p></div></div><div id='d_Po' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_Pn' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_Pm' class='de'><h1>Method <span class='n'>setSlot</span></h1><div class='re'><code>setSlot( self, name, evaluable )</code></div><div class='ds'><p>Binds the given evaluable to the named slot.</p></div></div><div id='d_Pl' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_Pk' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IImportOperation at 0x7bfb10&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Pj' class='de'><h1>Class <span class='n'>IFunction</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Pi' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><p>Returns the ith arguments to this operation.</p></div></div><div id='d_Ph' class='de'><h1>Method <span class='n'>getLanguage</span></h1><div class='re'><code>getLanguage( self )</code></div><div class='ds'><p>Returns the language in which the emebedded code is written.</p></div></div><div id='d_Pg' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_Pf' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, context )</code></div><div class='ds'><p>Sets the parent context for this context.</p></div></div><div id='d_Pe' class='de'><h1>Method <span class='n'>getContent</span></h1><div class='re'><code>getContent( self )</code></div><div class='ds'><p>Returns the content of this annotation.</p></div></div><div id='d_Pd' class='de'><h1>Method <span class='n'>getDefaultValue</span></h1><div class='re'><code>getDefaultValue( self )</code></div><div class='ds'><p>Gets the @methodault value for this attribute</p></div></div><div id='d_Pc' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IGroup at 0x7bf930&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Pb' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns this element parent</p></div></div><div id='d_mH' class='de'><h1>Method <span class='n'>echoWarning</span></h1><div class='re'><code>echoWarning( self, message, element )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_mA' class='de'><h1>Method <span class='n'>definedBy</span></h1><div class='re'><code>definedBy( self, definition=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_mB' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_mC' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self, *args )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_mD' class='de'><h1>Class <span class='n'>Unresolved</span></h1><div class='re'></div><div class='ds'><p>Unresolved types are temporary types that can be resolved later when necessary.</p></div></div><div id='d_mE' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><p>Returns the name of this pass</p></div></div><div id='d_mF' class='de'><h1>Class <span class='n'>Pass</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_mG' class='de'><h1>Method <span class='n'>getProgram</span></h1><div class='re'><code>getProgram( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_mx' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.IEvaluable at 0x7bf450&gt;]</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='d_my' class='de'><h1>Method <span class='n'>embed</span></h1><div class='re'><code>embed( self, lang, code )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_mz' class='de'><h1>Class <span class='n'>Data</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_mp' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><p>Returns the arguments to this operation.</p></div></div><div id='d_mq' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><p>Returns the <em>internal types</em> for this operations arguments. This is typically the list of interfaces or @protocols that the arguments must comply to.</p></div></div><div id='d_mr' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IFunction at 0x7bf9c0&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_ms' class='de'><h1>Method <span class='n'>getTypeDescription</span></h1><div class='re'><code>getTypeDescription( self )</code></div><div class='ds'><p>Returns type information (constraints) that are associated to this argument.</p></div></div><div id='d_mt' class='de'><h1>Method <span class='n'>setResultAbstractType</span></h1><div class='re'><code>setResultAbstractType( self, abstractType )</code></div><div class='ds'><p>Sets the abstract type for this operation result. This is usually invoked in the typing phase.</p></div></div><div id='d_mu' class='de'><h1>Method <span class='n'>getReferenceName</span></h1><div class='re'><code>getReferenceName( self )</code></div><div class='ds'><p>Returns the name which this reference contains. The name is used by the resolution operation to actually resolve a value from the name.</p></div></div><div id='d_mv' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><p>Sets the given argument of this operation, by argument index.</p></div></div><div id='d_mw' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><p>Detaches the element from its parent (in case it was already attached). This should return this element, and set the parent to None.</p></div></div><div id='d_mh' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><p>Detaches the element from its parent (in case it was already attached). This should return this element, and set the parent to None.</p></div></div><div id='d_mi' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><p>Detaches the element from its parent (in case it was already attached). This should return this element, and set the parent to None.</p></div></div><div id='d_mj' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><p>Returns the arguments to this operation.</p></div></div><div id='d_mk' class='de'><h1>Method <span class='n'>setArguments</span></h1><div class='re'><code>setArguments( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_ml' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><p>Detaches the element from its parent (in case it was already attached). This should return this element, and set the parent to None.</p></div></div><div id='d_mm' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><p>Sets the given argument of this operation, by argument index.</p></div></div><div id='d_mn' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IOperation at 0x7bfae0&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_mo' class='de'><h1>Method <span class='n'>setSlot</span></h1><div class='re'><code>setSlot( self, name, evaluable )</code></div><div class='ds'><p>Binds the given evaluable to the named slot.</p></div></div><div id='d_mb' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><p>Performs a deep clone of this element. Any mutation to the original won't change the copy.</p></div></div><div id='d_mc' class='de'><h1>Class <span class='n'>IAssignable</span></h1><div class='re'></div><div class='ds'><p>Assignable elements are elements that can be bound to slots. In many languages, only a subset of elements can be assigned. For instance, in Java, you cannot assign a package to something:</p><pre>  Object my_package = java.lang.Object</pre><p>while in some other languages (like JavaScript), you could do that.</p></div></div><div id='d_md' class='de'><h1>Method <span class='n'>getAttributes</span></h1><div class='re'><code>getAttributes( self )</code></div><div class='ds'><p>Returns the (non-class) attributes defined within this class.</p></div></div><div id='d_me' class='de'><h1>Method <span class='n'>isAbstract</span></h1><div class='re'><code>isAbstract( self )</code></div><div class='ds'><p>Tells wether the given abstractable is abstract or not.</p></div></div><div id='d_mf' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_mg' class='de'><h1>Method <span class='n'>declareEnvironment</span></h1><div class='re'><code>declareEnvironment( self, name, value )</code></div><div class='ds'><p>Declares an environment variable with the given name, value and origin.</p></div></div><div id='Ok' class='cr'><div class='n'><a href='javascript:dS("Ok");'>IImportModulesOperation</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("Ok","Pk");'><span class='special __bases__'>IImportOperation</span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Ok","Qk");'>getImportedModuleNames</a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Ok","Rk");'>addOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Ok","Sk");'>copy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Ok","Tk");'>detach</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Ok","Uk");'>getAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Ok","Vk");'>getAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Ok","Wk");'>getDataFlow</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Ok","Xk");'>getOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Ok","Yk");'>getOpArguments</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Ok","Zk");'>getOpArgumentsInternalTypes</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Ok","al");'>getParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Ok","bl");'>hasParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Ok","cl");'>setAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Ok","dl");'>setAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Ok","el");'>setOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Ok","fl");'>setParent</a></div></div><div class='t'>Values</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&bull;</span><a href='javascript:dO("Ok","gl");'>ARGS</a></div><div class='slot documented'><span
					class='prefix'>&bull;</span><a href='javascript:dO("Ok","hl");'>ARG_NAMES</a></div></div></div><div id='Oc' class='cr'><div class='n'><a href='javascript:dS("Oc");'>IBlock</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("Oc","Pc");'><span class='special __bases__'>IGroup</span></a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Oc","Qc");'>addOperation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Oc","Rc");'>getOperations</a></div></div></div><div id='bp' class='cr'><div class='n'><a href='javascript:dS("bp");'>IIteration</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("bp","cp");'><span class='special __bases__'>IOperation</span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("bp","dp");'>getClosure</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("bp","ep");'>getIterator</a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("bp","fp");'>addOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("bp","gp");'>copy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("bp","hp");'>detach</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("bp","ip");'>getAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("bp","jp");'>getAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("bp","kp");'>getDataFlow</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("bp","lp");'>getOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("bp","mp");'>getOpArguments</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("bp","np");'>getOpArgumentsInternalTypes</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("bp","op");'>getParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("bp","pp");'>hasParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("bp","qp");'>setAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("bp","rp");'>setAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("bp","sp");'>setOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("bp","tp");'>setParent</a></div></div><div class='t'>Values</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&bull;</span><a href='javascript:dO("bp","up");'>ARGS</a></div></div></div><div id='d_SB' class='de'><h1>Method <span class='n'>arguments</span></h1><div class='re'><code>arguments( self, args=None )</code></div><div class='ds'><p>Returns the arguments of this process encapsulated in a sequence if there is more than one argument.</p></div></div><div id='d_SC' class='de'><h1>Method <span class='n'>result</span></h1><div class='re'><code>result( self )</code></div><div class='ds'><p>Returns the result for this type. This is usually just the type itself, except for processes types.</p></div></div><div id='d_SA' class='de'><h1>Method <span class='n'>parent</span></h1><div class='re'><code>parent( self, parent=None )</code></div><div class='ds'><p>Returns the main parent for this context.</p></div></div><div id='d_SF' class='de'><h1>Method <span class='n'>walk</span></h1><div class='re'><code>walk( self, element )</code></div><div class='ds'><p>Walks the given element, recursively walking the child elements when the handler does not return False</p></div></div><div id='d_SG' class='de'><h1>Method <span class='n'>getParentElement</span></h1><div class='re'><code>getParentElement( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_SD' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.passes.Pass at 0x1228030&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_SE' class='de'><h1>Method <span class='n'>getCurrentModule</span></h1><div class='re'><code>getCurrentModule( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Sz' class='de'><h1>Method <span class='n'>isSubtypeOf</span></h1><div class='re'><code>isSubtypeOf( self, otherType )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Sx' class='de'><h1>Method <span class='n'>allocate</span></h1><div class='re'><code>allocate( self, slot, value=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Sy' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.passes.Pass at 0x1228030&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Sr' class='de'><h1>Method <span class='n'>setImported</span></h1><div class='re'><code>setImported( self, value=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Ss' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_Sp' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_Sq' class='de'><h1>Method <span class='n'>setProcess</span></h1><div class='re'><code>setProcess( self, v )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Sv' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_Sw' class='de'><h1>Method <span class='n'>getLine</span></h1><div class='re'><code>getLine( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_St' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><p>Performs a deep clone of this element. Any mutation to the original won't change the copy.</p></div></div><div id='d_Su' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><p>Sets the given argument of this operation, by argument index.</p></div></div><div id='d_Sj' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><p>Returns this @protocol name. It can be <code>None</code> if the @protocol is anonymous.</p></div></div><div id='d_Sk' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><p>Performs a deep clone of this element. Any mutation to the original won't change the copy.</p></div></div><div id='d_Sh' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><p>Adds an argument to this operation. This should do checking of arguments (by expected internal type and number).</p></div></div><div id='d_Si' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns this element parent</p></div></div><div id='d_Sn' class='de'><h1>Method <span class='n'>getClassMethods</span></h1><div class='re'><code>getClassMethods( self )</code></div><div class='ds'><p>Returns the class method defined within this class.</p></div></div><div id='d_So' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><p>Returns the arguments to this operation.</p></div></div><div id='d_Sl' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><p>Sets this element parent</p></div></div><div id='d_Sm' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IOperation at 0x7bfae0&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Sb' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_Sc' class='de'><h1>Class <span class='n'>IBreaking</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Sf' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IElement at 0x7bf3c0&gt;, &lt;class lambdafactory.interfaces.IDataFlowOwner at 0x7bf390&gt;)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Sg' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><p>Returns this @protocol name. It can be <code>None</code> if the @protocol is anonymous.</p></div></div><div id='d_Sd' class='de'><h1>Method <span class='n'>setDefaultValue</span></h1><div class='re'><code>setDefaultValue( self )</code></div><div class='ds'><p>Sets the @methodault value for this attribute</p></div></div><div id='d_Se' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IOperation at 0x7bfae0&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_AD' class='de'><h1>Method <span class='n'>setConcreteType</span></h1><div class='re'><code>setConcreteType( self, value )</code></div><div class='ds'><p>Sets the <span class='term'>concrete type</span> for this abstract type. The concrete type is a value which represents the type. For instance, if this type represents a class, then the concrete type would be the class instance.</p></div></div><div id='d_AE' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.IModule at 0x7bf8a0&gt;]</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='d_AF' class='de'><h1>Method <span class='n'>getCurrentElement</span></h1><div class='re'><code>getCurrentElement( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_AG' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_AA' class='de'><h1>Method <span class='n'>length</span></h1><div class='re'><code>length( self )</code></div><div class='ds'><p>Returns the length (in bytes) for this cell.</p></div></div><div id='d_AB' class='de'><h1>Method <span class='n'>isLike</span></h1><div class='re'><code>isLike( self, otherType )</code></div><div class='ds'><p>The other type is like this one if the other is a sequence with the same length and that all elements are like the corresponding elements of this sequence.</p></div></div><div id='d_AC' class='de'><h1>Method <span class='n'>name</span></h1><div class='re'><code>name( self, name=None )</code></div><div class='ds'><p>Returns/sets the name for this type. By defaults, types are unnamed.</p></div></div><div id='d_Al' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IImportOperation at 0x7bfb10&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Am' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_An' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><p>Returns the arguments to this operation.</p></div></div><div id='d_Ao' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_Ah' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><p>Returns the name of this annotation.</p></div></div><div id='d_Ai' class='de'><h1>Method <span class='n'>setLanguage</span></h1><div class='re'><code>setLanguage( self, language )</code></div><div class='ds'><p>Sets the language in which the emebedded code is written.</p></div></div><div id='d_Aj' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><p>Performs a deep clone of this element. Any mutation to the original won't change the copy.</p></div></div><div id='d_Ak' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_Ad' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_Ae' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_Af' class='de'><h1>Method <span class='n'>getArguments</span></h1><div class='re'><code>getArguments( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Ag' class='de'><h1>Class <span class='n'>IDataFlowSlot</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Ab' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><p>Sets this element parent</p></div></div><div id='d_Ac' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns this element parent</p></div></div><div id='d_Ax' class='de'><h1>Method <span class='n'>setResultAbstractType</span></h1><div class='re'><code>setResultAbstractType( self, abstractType )</code></div><div class='ds'><p>Sets the abstract type for this operation result. This is usually invoked in the typing phase.</p></div></div><div id='d_Ay' class='de'><h1>Method <span class='n'>matchProcess</span></h1><div class='re'><code>matchProcess( self, evaluable, process )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Az' class='de'><h1>Function <span class='n'>typeForValue</span></h1><div class='re'><code>typeForValue( value, noneIs=<lambdafactory.typecast.Symbolic instance at 0x11f83c8> )</code></div><div class='ds'><p>Associates a type with the given value. This basically creates a typecast instance/subtype, using the types defined in this module, using the given value which is a program element (implements interfaces defined in LF <code>interfaces</code> module).</p></div></div><div id='d_At' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_Au' class='de'><h1>Method <span class='n'>setResultAbstractType</span></h1><div class='re'><code>setResultAbstractType( self, abstractType )</code></div><div class='ds'><p>Sets the abstract type for this operation result. This is usually invoked in the typing phase.</p></div></div><div id='d_Av' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><p>Returns the arguments to this operation.</p></div></div><div id='d_Aw' class='de'><h1>Method <span class='n'>getTarget</span></h1><div class='re'><code>getTarget( self )</code></div><div class='ds'><p>Returns the operation target.</p></div></div><div id='d_Ap' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><p>Detaches the element from its parent (in case it was already attached). This should return this element, and set the parent to None.</p></div></div><div id='d_Aq' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><p>Adds an argument to this operation. This should do checking of arguments (by expected internal type and number).</p></div></div><div id='d_Ar' class='de'><h1>Method <span class='n'>getSlots</span></h1><div class='re'><code>getSlots( self )</code></div><div class='ds'><p>Returns (key, evaluable) pairs representing the slots within this context.</p></div></div><div id='d_As' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='Td' class='cr'><div class='n'><a href='javascript:dS("Td");'>IClassMethod</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("Td","Ud");'><span class='special __bases__'>IMethod</span></a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Td","Vd");'>addOperation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Td","Wd");'>copy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Td","Xd");'>detach</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Td","Yd");'>endsWithTermination</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Td","Zd");'>getAbsoluteName</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Td","ae");'>getAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Td","be");'>getAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Td","ce");'>getArguments</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Td","de");'>getDataFlow</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Td","ee");'>getName</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Td","fe");'>getOperations</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Td","ge");'>getParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Td","he");'>getSlot</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Td","ie");'>getSlots</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Td","je");'>hasExplicitTermination</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Td","ke");'>hasParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Td","le");'>hasSlot</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Td","me");'>isAbstract</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Td","ne");'>setAbstract</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Td","oe");'>setAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Td","pe");'>setAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Td","qe");'>setArguments</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Td","re");'>setParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Td","se");'>setSlot</a></div></div></div><div id='Ag' class='cr'><div class='n'><a href='javascript:dS("Ag");'>IDataFlowSlot</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("Ag","c");'><span class='special __bases__'><i>Base class</i></span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Ag","Bg");'>addOperation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Ag","Cg");'>getAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Ag","Dg");'>getName</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Ag","Eg");'>getOperations</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Ag","Fg");'>getOrigin</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Ag","Gg");'>getOriginalValue</a></div></div></div><div id='gu' class='cr'><div class='n'><a href='javascript:dS("gu");'>IReferencable</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("gu","hu");'><span class='special __bases__'>IAssignable</span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("gu","iu");'>getAbsoluteName</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("gu","ju");'>getName</a></div></div></div><div id='zl' class='cr'><div class='n'><a href='javascript:dS("zl");'>IImportSymbolOperation</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("zl","Al");'><span class='special __bases__'>IImportOperation</span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("zl","Bl");'>getAlias</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("zl","Cl");'>getImportOrigin</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("zl","Dl");'>getImportedElement</a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("zl","El");'>addOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("zl","Fl");'>copy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("zl","Gl");'>detach</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("zl","Hl");'>getAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("zl","Il");'>getAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("zl","Jl");'>getDataFlow</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("zl","Kl");'>getOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("zl","Ll");'>getOpArguments</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("zl","Ml");'>getOpArgumentsInternalTypes</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("zl","Nl");'>getParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("zl","Ol");'>hasParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("zl","Pl");'>setAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("zl","Ql");'>setAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("zl","Rl");'>setOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("zl","Sl");'>setParent</a></div></div><div class='t'>Values</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&bull;</span><a href='javascript:dO("zl","Tl");'>ARGS</a></div><div class='slot documented'><span
					class='prefix'>&bull;</span><a href='javascript:dO("zl","Ul");'>ARG_NAMES</a></div></div></div><div id='zg' class='cr'><div class='n'><a href='javascript:dS("zg");'>IDataFlowOwner</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("zg","c");'><span class='special __bases__'><i>Base class</i></span></a></div></div></div><div id='d_lH' class='de'><h1>Method <span class='n'>echoError</span></h1><div class='re'><code>echoError( self, message )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_lC' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.typecast.Type at 0x120e900&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_lB' class='de'><h1>Class <span class='n'>Environment</span></h1><div class='re'></div><div class='ds'><p>The environment stores types and names them. This allows to easily retrieve types from a given name.</p></div></div><div id='d_lA' class='de'><h1>Method <span class='n'>concreteType</span></h1><div class='re'><code>concreteType( self )</code></div><div class='ds'><p>Returns the <span class='term'>concrete type</span> for this abstract type.</p></div></div><div id='d_lG' class='de'><h1>Method <span class='n'>getParentElement</span></h1><div class='re'><code>getParentElement( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_lF' class='de'><h1>str</h1><div class='re'><code>'Importation'</code></div><div class='ds'><p>str(object) -&gt; string</p><p>Return a nice string representation of the object. If the argument is a string, the return value is the same object.</p></div></div><div id='d_lE' class='de'><h1>Method <span class='n'>getHandle</span></h1><div class='re'><code>getHandle( self, element )</code></div><div class='ds'><p>Tells if the pass handles the given element. This basically iterates on the <code>handles</code> property values (which are interfaces), when one interface matches the given <code>element</code>, then the corresponding <code>onXXX</code> method is invoked, where <code>XXX</code> is the interface name (without the leading <code>I</code>).</p></div></div><div id='d_lD' class='de'><h1>Method <span class='n'>subtype</span></h1><div class='re'><code>subtype( self, name )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_lz' class='de'><h1>Method <span class='n'>getType</span></h1><div class='re'><code>getType( self, name )</code></div><div class='ds'><p>Returns the type with the given name, or None if it does not exist.</p></div></div><div id='d_ly' class='de'><h1>Method <span class='n'>doc</span></h1><div class='re'><code>doc( self, content )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_lx' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><p>Sets this element parent</p></div></div><div id='d_ls' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><p>Returns the local name for this referencable element</p></div></div><div id='d_lr' class='de'><h1>Class <span class='n'>IMethod</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_lq' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><p>Returns the arguments to this operation.</p></div></div><div id='d_lp' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><p>Returns the ith arguments to this operation.</p></div></div><div id='d_lw' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><p>Performs a deep clone of this element. Any mutation to the original won't change the copy.</p></div></div><div id='d_lv' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_lu' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IValue at 0x7bf510&gt;, &lt;class lambdafactory.interfaces.IReferencable at 0x7bf420&gt;)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_lt' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><p>Sets this element parent</p></div></div><div id='d_lk' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_lj' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><p>Returns the ith arguments to this operation.</p></div></div><div id='d_li' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><p>Performs a deep clone of this element. Any mutation to the original won't change the copy.</p></div></div><div id='d_lh' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><p>Performs a deep clone of this element. Any mutation to the original won't change the copy.</p></div></div><div id='d_lo' class='de'><h1>Method <span class='n'>setParentClasses</span></h1><div class='re'><code>setParentClasses( self )</code></div><div class='ds'><p>gives the list of parent classes that will</p></div></div><div id='d_ln' class='de'><h1>Class <span class='n'>IInterception</span></h1><div class='re'></div><div class='ds'><p>An interception allows to intercept interruptions that propagage from an enclosed process to parent contexts.</p></div></div><div id='d_lm' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_ll' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><p>Performs a deep clone of this element. Any mutation to the original won't change the copy.</p></div></div><div id='d_lc' class='de'><h1>Method <span class='n'>getTypeDescription</span></h1><div class='re'><code>getTypeDescription( self )</code></div><div class='ds'><p>Returns type information (constraints) that are associated to this argument.</p></div></div><div id='d_lb' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><p>Adds an argument to this operation. This should do checking of arguments (by expected internal type and number).</p></div></div><div id='d_lg' class='de'><h1>Method <span class='n'>declareArgument</span></h1><div class='re'><code>declareArgument( self, name, value )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_lf' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><p>Tells if this element has a parent or not</p></div></div><div id='d_le' class='de'><h1>Method <span class='n'>hasSlot</span></h1><div class='re'><code>hasSlot( self, name )</code></div><div class='ds'><p>Tells if the context has a slot with the given name.</p></div></div><div id='d_ld' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IContext at 0x7bf7e0&gt;, &lt;class lambdafactory.interfaces.IReferencable at 0x7bf420&gt;)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='FC' class='cr'><div class='n'><a href='javascript:dS("FC");'>Symbolic</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("FC","GC");'><span class='special __bases__'>Type</span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("FC","HC");'><span class='special __init__'>constructor</span></a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("FC","IC");'>asString</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("FC","JC");'>clone</a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("FC","KC");'><span class='special __call__'>when invoked</span></a></div><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("FC","LC");'><span class='special __str__'>string conversion</span></a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("FC","MC");'>concreteType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("FC","NC");'>definedBy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("FC","OC");'>isLike</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("FC","PC");'>isSameAs</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("FC","QC");'>isSubtypeOf</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("FC","RC");'>name</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("FC","SC");'>result</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("FC","TC");'>setConcreteType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("FC","UC");'>setName</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("FC","VC");'>subtype</a></div></div></div><div id='d_Re' class='de'><h1>Class <span class='n'>IComputation</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Rd' class='de'><h1>Method <span class='n'>getTypeDescription</span></h1><div class='re'><code>getTypeDescription( self )</code></div><div class='ds'><p>Returns type information (constraints) that are associated to this argument.</p></div></div><div id='d_Rg' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_Rf' class='de'><h1>Class <span class='n'>IContext</span></h1><div class='re'></div><div class='ds'><p>A context is an element that has slots, which bind evaluable elements (aka values) to names.</p></div></div><div id='d_Rc' class='de'><h1>Method <span class='n'>getOperations</span></h1><div class='re'><code>getOperations( self )</code></div><div class='ds'><p>Returns the list of operations in this process.</p></div></div><div id='d_Rb' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_Rm' class='de'><h1>Class <span class='n'>IInstanciation</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Rl' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><p>Sets the given argument of this operation, by argument index.</p></div></div><div id='d_Ro' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><p>Returns the ith arguments to this operation.</p></div></div><div id='d_Rn' class='de'><h1>Method <span class='n'>getClassAttributes</span></h1><div class='re'><code>getClassAttributes( self )</code></div><div class='ds'><p>Returns the class attributes defined within this class.</p></div></div><div id='d_Ri' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><p>Returns the <em>internal types</em> for this operations arguments. This is typically the list of interfaces or @protocols that the arguments must comply to.</p></div></div><div id='d_Rh' class='de'><h1>Method <span class='n'>setLanguage</span></h1><div class='re'><code>setLanguage( self, language )</code></div><div class='ds'><p>Sets the language in which the emebedded code is written.</p></div></div><div id='d_Rk' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><p>Adds an argument to this operation. This should do checking of arguments (by expected internal type and number).</p></div></div><div id='d_Rj' class='de'><h1>Method <span class='n'>endsWithTermination</span></h1><div class='re'><code>endsWithTermination( self )</code></div><div class='ds'><p>Returns true if this function ends with a termination operation. This is especially useful for back-ends which want to know if they have to insert an explicit <code>return</code> at the end (like Java).</p></div></div><div id='d_Ru' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_Rt' class='de'><h1>Method <span class='n'>setFactory</span></h1><div class='re'><code>setFactory( self, factory )</code></div><div class='ds'><p>Sets the factory that was used to create this program</p></div></div><div id='d_Rw' class='de'><h1>Method <span class='n'>getColumn</span></h1><div class='re'><code>getColumn( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Rv' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_Rq' class='de'><h1>Method <span class='n'>getProcess</span></h1><div class='re'><code>getProcess( self )</code></div><div class='ds'><p>Returns the process that will be executed if the rule matches.</p></div></div><div id='d_Rp' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_Rs' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_Rr' class='de'><h1>Method <span class='n'>isImported</span></h1><div class='re'><code>isImported( self )</code></div><div class='ds'><p>A stub module is a module that does not have any bound implementation. Stub modules are typically used by Programs when adding a module such as <code>a.b.c</code> where <code>a</code> and <code>a.b</code> will be stub modules unless they were or will be imported.</p></div></div><div id='d_Ry' class='de'><h1>Class <span class='n'>AbstractWriter</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Rx' class='de'><h1>Method <span class='n'>access</span></h1><div class='re'><code>access( self, target, _index )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Rz' class='de'><h1>Method <span class='n'>isSameAs</span></h1><div class='re'><code>isSameAs( self, otherType )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_RE' class='de'><h1>Method <span class='n'>getCurrentMethod</span></h1><div class='re'><code>getCurrentMethod( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_RD' class='de'><h1>Class <span class='n'>DocumentationPass</span></h1><div class='re'></div><div class='ds'><p>The documentation pass will run SDoc on all the modules declared in this program, creating an HTML file.</p></div></div><div id='d_RG' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><p>Returns the name of this pass</p></div></div><div id='d_RF' class='de'><h1>Method <span class='n'>setPass</span></h1><div class='re'><code>setPass( self, programPass )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_RA' class='de'><h1>Method <span class='n'>fullName</span></h1><div class='re'><code>fullName( self )</code></div><div class='ds'><p>Returns the fully qualified name for this context, by concateniating the chain of parents name with <code>.</code></p></div></div><div id='d_RC' class='de'><h1>Method <span class='n'>name</span></h1><div class='re'><code>name( self, name=None )</code></div><div class='ds'><p>Returns/sets the name for this type. By defaults, types are unnamed.</p></div></div><div id='d_RB' class='de'><h1>Method <span class='n'>add</span></h1><div class='re'><code>add( self, theType )</code></div><div class='ds'><p>Adds the given type as an element to this process. The last added type becomes the result if one type was already added, the argument otherwise.</p></div></div><div id='lB' class='cr'><div class='n'><a href='javascript:dS("lB");'>Environment</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("lB","c");'><span class='special __bases__'><i>Base class</i></span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("lB","mB");'><span class='special __init__'>constructor</span></a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("lB","nB");'>register</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("lB","oB");'>resolve</a></div></div></div><div id='ln' class='cr'><div class='n'><a href='javascript:dS("ln");'>IInterception</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("ln","mn");'><span class='special __bases__'>IOperation</span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ln","nn");'>getConclusion</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ln","on");'>getIntercept</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ln","pn");'>getProcess</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ln","qn");'>setConclusion</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ln","rn");'>setIntercept</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ln","sn");'>setProcess</a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ln","tn");'>addOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ln","un");'>copy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ln","vn");'>detach</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ln","wn");'>getAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ln","xn");'>getAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ln","yn");'>getDataFlow</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ln","zn");'>getOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ln","An");'>getOpArguments</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ln","Bn");'>getOpArgumentsInternalTypes</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ln","Cn");'>getParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ln","Dn");'>hasParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ln","En");'>setAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ln","Fn");'>setAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ln","Gn");'>setOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("ln","Hn");'>setParent</a></div></div><div class='t'>Values</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&bull;</span><a href='javascript:dO("ln","In");'>ARGS</a></div></div></div><div id='lr' class='cr'><div class='n'><a href='javascript:dS("lr");'>IMethod</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("lr","mr");'><span class='special __bases__'>IFunction</span></a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("lr","nr");'>addOperation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("lr","or");'>copy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("lr","pr");'>detach</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("lr","qr");'>endsWithTermination</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("lr","rr");'>getAbsoluteName</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("lr","sr");'>getAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("lr","tr");'>getAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("lr","ur");'>getArguments</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("lr","vr");'>getDataFlow</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("lr","wr");'>getName</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("lr","xr");'>getOperations</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("lr","yr");'>getParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("lr","zr");'>getSlot</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("lr","Ar");'>getSlots</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("lr","Br");'>hasExplicitTermination</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("lr","Cr");'>hasParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("lr","Dr");'>hasSlot</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("lr","Er");'>isAbstract</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("lr","Fr");'>setAbstract</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("lr","Gr");'>setAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("lr","Hr");'>setAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("lr","Ir");'>setArguments</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("lr","Jr");'>setParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("lr","Kr");'>setSlot</a></div></div></div><div id='d_of' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><p>Sets the given argument of this operation, by argument index.</p></div></div><div id='d_og' class='de'><h1>Method <span class='n'>defines</span></h1><div class='re'><code>defines( self, name )</code></div><div class='ds'><p>Tells if this dataflow, or any of its child dataflows defines the given name (symbol)</p></div></div><div id='d_od' class='de'><h1>Method <span class='n'>getClassMethods</span></h1><div class='re'><code>getClassMethods( self )</code></div><div class='ds'><p>Returns the class method defined within this class.</p></div></div><div id='d_oe' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_ob' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_oc' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IOperation at 0x7bfae0&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_on' class='de'><h1>Method <span class='n'>getIntercept</span></h1><div class='re'><code>getIntercept( self )</code></div><div class='ds'><p>Returns the process that will do the interception</p></div></div><div id='d_oo' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IOperation at 0x7bfae0&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_ol' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_om' class='de'><h1>list</h1><div class='re'><code>[[&lt;class lambdafactory.interfaces.IEvaluable at 0x7bf450&gt;], &lt;class lambdafactory.interfaces.IEvaluable at 0x7bf450&gt;]</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='d_oj' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns this element parent</p></div></div><div id='d_ok' class='de'><h1>Method <span class='n'>setSlot</span></h1><div class='re'><code>setSlot( self, name, evaluable )</code></div><div class='ds'><p>Binds the given evaluable to the named slot.</p></div></div><div id='d_oh' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_oi' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_ov' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.IReferencable at 0x7bf420&gt;, &lt;class lambdafactory.interfaces.IEvaluable at 0x7bf450&gt;]</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='d_ow' class='de'><h1>Method <span class='n'>getActualValue</span></h1><div class='re'><code>getActualValue( self )</code></div><div class='ds'><p>Returns the (implementation language) value for this literal</p></div></div><div id='d_ot' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IElement at 0x7bf3c0&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_ou' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><p>Detaches the element from its parent (in case it was already attached). This should return this element, and set the parent to None.</p></div></div><div id='d_or' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><p>Performs a deep clone of this element. Any mutation to the original won't change the copy.</p></div></div><div id='d_os' class='de'><h1>Class <span class='n'>INumber</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_op' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns this element parent</p></div></div><div id='d_oq' class='de'><h1>Method <span class='n'>getPredicate</span></h1><div class='re'><code>getPredicate( self )</code></div><div class='ds'><p>Returns the evaluable that acts as a predicate for this operation.</p></div></div><div id='d_oz' class='de'><h1>Method <span class='n'>getType</span></h1><div class='re'><code>getType( self, name )</code></div><div class='ds'><p>Returns the type with the given name, or None if it does not exist.</p></div></div><div id='d_ox' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IElement at 0x7bf3c0&gt;, &lt;class lambdafactory.interfaces.IEvaluable at 0x7bf450&gt;)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_oy' class='de'><h1>Method <span class='n'>enumerate</span></h1><div class='re'><code>enumerate( self, start, end, step=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_oF' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_oG' class='de'><h1>Method <span class='n'>hasParentElement</span></h1><div class='re'><code>hasParentElement( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_oD' class='de'><h1>Method <span class='n'>__call__</span></h1><div class='re'><code>__call__( self )</code></div><div class='ds'><p>A type instance can be used as a class to construct a new type, which will be cloned from the current type.</p></div></div><div id='d_oE' class='de'><h1>Method <span class='n'>getProgram</span></h1><div class='re'><code>getProgram( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_oB' class='de'><h1>Method <span class='n'>resolve</span></h1><div class='re'><code>resolve( self, typeName )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_oC' class='de'><h1>Method <span class='n'>asString</span></h1><div class='re'><code>asString( self, fromTypes=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_oA' class='de'><h1>Method <span class='n'>result</span></h1><div class='re'><code>result( self )</code></div><div class='ds'><p>Returns the result for this type. This is usually just the type itself, except for processes types.</p></div></div><div id='d_oH' class='de'><h1>Method <span class='n'>indent</span></h1><div class='re'><code>indent( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_qx' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><p>Detaches the element from its parent (in case it was already attached). This should return this element, and set the parent to None.</p></div></div><div id='d_qy' class='de'><h1>Method <span class='n'>exception</span></h1><div class='re'><code>exception( self, exception )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_qz' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.modeltypes.TypeCollection at 0x120e0f0&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_qt' class='de'><h1>Method <span class='n'>getValue</span></h1><div class='re'><code>getValue( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_qu' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_qv' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IOperation at 0x7bfae0&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_qw' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_qp' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_qq' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_qr' class='de'><h1>Method <span class='n'>endsWithTermination</span></h1><div class='re'><code>endsWithTermination( self )</code></div><div class='ds'><p>Returns true if this function ends with a termination operation. This is especially useful for back-ends which want to know if they have to insert an explicit <code>return</code> at the end (like Java).</p></div></div><div id='d_qs' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><p>Performs a deep clone of this element. Any mutation to the original won't change the copy.</p></div></div><div id='d_ql' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><p>Returns the ith arguments to this operation.</p></div></div><div id='d_qm' class='de'><h1>Class <span class='n'>IInstanceMethod</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_qn' class='de'><h1>Method <span class='n'>setConclusion</span></h1><div class='re'><code>setConclusion( self, process )</code></div><div class='ds'><p>Sets the process that will conclude the interception (finally)</p></div></div><div id='d_qo' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><p>Performs a deep clone of this element. Any mutation to the original won't change the copy.</p></div></div><div id='d_qh' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns this element parent</p></div></div><div id='d_qi' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_qj' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_qk' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IProcess at 0x7bf900&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_qd' class='de'><h1>Method <span class='n'>getDestructors</span></h1><div class='re'><code>getDestructors( self )</code></div><div class='ds'><p>Returns the destructors for this class</p></div></div><div id='d_qe' class='de'><h1>Method <span class='n'>setArguments</span></h1><div class='re'><code>setArguments( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_qf' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.IOperator at 0x7bf690&gt;, &lt;class lambdafactory.interfaces.IEvaluable at 0x7bf450&gt;, &lt;class lambdafactory.interfaces.IEvaluable at 0x7bf450&gt;]</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='d_qg' class='de'><h1>Method <span class='n'>getDestinations</span></h1><div class='re'><code>getDestinations( self )</code></div><div class='ds'><p>Returns the dataflows that are <span class='term'>destinations</span>, meaning that these dataflows will resolve if this dataflow if resolution fails, according tot the resolution scheme used.</p></div></div><div id='d_qb' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_qc' class='de'><h1>Method <span class='n'>getTarget</span></h1><div class='re'><code>getTarget( self )</code></div><div class='ds'><p>Returns this assignation target reference, which can be an evaluable (in case you assign to self.something, or a reference)</p></div></div><div id='KA' class='cr'><div class='n'><a href='javascript:dS("KA");'>Context</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("KA","LA");'><span class='special __bases__'>Map</span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("KA","MA");'><span class='special __init__'>constructor</span></a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("KA","NA");'>clone</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("KA","OA");'>element</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("KA","PA");'>elements</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("KA","QA");'>extends</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("KA","RA");'>fullName</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("KA","SA");'>parent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("KA","TA");'>parents</a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("KA","UA");'><span class='special __call__'>when invoked</span></a></div><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("KA","VA");'><span class='special __str__'>string conversion</span></a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("KA","WA");'>add</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("KA","XA");'>asString</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("KA","YA");'>concreteType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("KA","ZA");'>definedBy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("KA","aB");'>elementNames</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("KA","bB");'>get</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("KA","cB");'>isLike</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("KA","dB");'>isSameAs</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("KA","eB");'>isSubtypeOf</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("KA","fB");'>name</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("KA","gB");'>result</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("KA","hB");'>set</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("KA","iB");'>setConcreteType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("KA","jB");'>setName</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("KA","kB");'>subtype</a></div></div></div><div id='d_qH' class='de'><h1>Method <span class='n'>isDone</span></h1><div class='re'><code>isDone( self, message, element, update=True )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_qD' class='de'><h1>Method <span class='n'>__str__</span></h1><div class='re'><code>__str__( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_qE' class='de'><h1>Method <span class='n'>hasParentElement</span></h1><div class='re'><code>hasParentElement( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_qF' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><p>Returns the name of this pass</p></div></div><div id='d_qG' class='de'><h1>Method <span class='n'>resolve</span></h1><div class='re'><code>resolve( self, referenceOrName, contextOrDataFlow=None )</code></div><div class='ds'><p>Resolves the given <code>IReference</code> or String sing the given context (<code>IContext</code>) or dataflow (<code>IDataFlow</code>). This usually requires that you've applied a pass to create the dataflow (see the 'lambdafactory.resolution.BasicDataFlow' pass).</p></div></div><div id='d_qA' class='de'><h1>Method <span class='n'>setName</span></h1><div class='re'><code>setName( self, name )</code></div><div class='ds'><p>Sets the name of this type</p></div></div><div id='d_qB' class='de'><h1>Class <span class='n'>Map</span></h1><div class='re'></div><div class='ds'><p>A map is simply an unordered set of types, mapped to names.</p></div></div><div id='d_qC' class='de'><h1>Method <span class='n'>extend</span></h1><div class='re'><code>extend( self, othertype )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Ub' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><p>Sets this element parent</p></div></div><div id='d_Uc' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><p>Adds an argument to this operation. This should do checking of arguments (by expected internal type and number).</p></div></div><div id='d_Ud' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IMethod at 0x7bf9f0&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Ue' class='de'><h1>Method <span class='n'>getOperand</span></h1><div class='re'><code>getOperand( self )</code></div><div class='ds'><p>Returns the left operand of this computation.</p></div></div><div id='d_Uf' class='de'><h1>Method <span class='n'>getSlot</span></h1><div class='re'><code>getSlot( self, name )</code></div><div class='ds'><p>Returns the given evaluable bound to named slot.</p></div></div><div id='d_Ug' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns the parent context for this context (if any)</p></div></div><div id='d_Uh' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><p>Detaches the element from its parent (in case it was already attached). This should return this element, and set the parent to None.</p></div></div><div id='d_Ui' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_Uj' class='de'><h1>Method <span class='n'>addOperation</span></h1><div class='re'><code>addOperation( self, operation )</code></div><div class='ds'><p>Adds the given operation as a child of this process.</p></div></div><div id='d_Uk' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_Ul' class='de'><h1>list</h1><div class='re'><code>['ImportedElement', 'ImportOrigin', 'Alias']</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='d_Um' class='de'><h1>Method <span class='n'>getInstanciable</span></h1><div class='re'><code>getInstanciable( self )</code></div><div class='ds'><p>Returns the instanciable used in this operation.</p></div></div><div id='d_Un' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_Uo' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns this element parent</p></div></div><div id='d_Up' class='de'><h1>Method <span class='n'>getResultAbstractType</span></h1><div class='re'><code>getResultAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type of the result of the evaluation of this evaluable</p></div></div><div id='d_Uq' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><p>Performs a deep clone of this element. Any mutation to the original won't change the copy.</p></div></div><div id='d_Ur' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><p>Detaches the element from its parent (in case it was already attached). This should return this element, and set the parent to None.</p></div></div><div id='d_Us' class='de'><h1>Class <span class='n'>IOperator</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Ut' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_Uu' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.IEvaluable at 0x7bf450&gt;, &lt;class lambdafactory.interfaces.IProcess at 0x7bf900&gt;]</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='d_Uv' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><p>Returns the arguments to this operation.</p></div></div><div id='d_Uw' class='de'><h1>Class <span class='n'>ITermination</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Ux' class='de'><h1>Method <span class='n'>assign</span></h1><div class='re'><code>assign( self, name, evaluable )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Uy' class='de'><h1>Method <span class='n'>_format</span></h1><div class='re'><code>_format( self, *values )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Uz' class='de'><h1>Method <span class='n'>name</span></h1><div class='re'><code>name( self, name=None )</code></div><div class='ds'><p>Returns/sets the name for this type. By defaults, types are unnamed.</p></div></div><div id='d_UA' class='de'><h1>Method <span class='n'>__call__</span></h1><div class='re'><code>__call__( self )</code></div><div class='ds'><p>A type instance can be used as a class to construct a new type, which will be cloned from the current type.</p></div></div><div id='d_UB' class='de'><h1>Method <span class='n'>clone</span></h1><div class='re'><code>clone( self, clone=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_UC' class='de'><h1>Method <span class='n'>setName</span></h1><div class='re'><code>setName( self, name )</code></div><div class='ds'><p>Sets the name of this type</p></div></div><div id='d_UD' class='de'><h1>Method <span class='n'>asHTML</span></h1><div class='re'><code>asHTML( self, title=None )</code></div><div class='ds'><p>Returns the HTML document generated by this pass</p></div></div><div id='d_UE' class='de'><h1>Method <span class='n'>getFactory</span></h1><div class='re'><code>getFactory( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_UF' class='de'><h1>Class <span class='n'>PassContext</span></h1><div class='re'></div><div class='ds'><p>The <code>PassContext</code> represents the current state of one or more passes when walking the program. It offers access to the <code>environment</code> (gives access to the program and various passes).</p><p>A single context can be shared among various passes.</p></div></div><div id='d_UG' class='de'><h1>Method <span class='n'>handle</span></h1><div class='re'><code>handle( self, element )</code></div><div class='ds'><p>Handles a sungle element, without recursing through its children</p></div></div><div id='d_CB' class='de'><h1>Method <span class='n'>isSubtypeOf</span></h1><div class='re'><code>isSubtypeOf( self, otherType )</code></div><div class='ds'><p>The other type is a subtype of this one if for each element of this type, we find that the other type has a subtype.</p></div></div><div id='d_CC' class='de'><h1>Method <span class='n'>setConcreteType</span></h1><div class='re'><code>setConcreteType( self, value )</code></div><div class='ds'><p>Sets the <span class='term'>concrete type</span> for this abstract type. The concrete type is a value which represents the type. For instance, if this type represents a class, then the concrete type would be the class instance.</p></div></div><div id='d_CA' class='de'><h1>Method <span class='n'>__str__</span></h1><div class='re'><code>__str__( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_CF' class='de'><h1>Method <span class='n'>getCurrentMethod</span></h1><div class='re'><code>getCurrentMethod( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_CG' class='de'><h1>Method <span class='n'>filterContext</span></h1><div class='re'><code>filterContext( self, interface )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_CD' class='de'><h1>Method <span class='n'>subtype</span></h1><div class='re'><code>subtype( self, name )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_CE' class='de'><h1>Class <span class='n'>ImportationPass</span></h1><div class='re'></div><div class='ds'><p>The importation pass will look for importation operations (<code>IImportation</code>), will try to resolve the importations (according to the current environment) and will trigger the loading and parsing of each module into the current program.</p></div></div><div id='d_Cj' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_Ck' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_Ch' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><p>Performs a deep clone of this element. Any mutation to the original won't change the copy.</p></div></div><div id='d_Ci' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><p>Sets this element parent</p></div></div><div id='d_Cn' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns this element parent</p></div></div><div id='d_Co' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><p>Sets the given argument of this operation, by argument index.</p></div></div><div id='d_Cl' class='de'><h1>Method <span class='n'>getImportOrigin</span></h1><div class='re'><code>getImportOrigin( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Cm' class='de'><h1>Method <span class='n'>getOperations</span></h1><div class='re'><code>getOperations( self )</code></div><div class='ds'><p>Returns the list of operations in this process.</p></div></div><div id='d_Cb' class='de'><h1>Class <span class='n'>IAllocation</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Cc' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_Cf' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><p>Returns this @protocol name. It can be <code>None</code> if the @protocol is anonymous.</p></div></div><div id='d_Cg' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Cd' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_Ce' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_Cz' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.modeltypes.Data at 0x120e6c0&gt;, &lt;class lambdafactory.modeltypes.Operations at 0x120eb10&gt;, &lt;class lambdafactory.modeltypes.Structure at 0x120eb40&gt;, &lt;class lambdafactory.modeltypes.Behaviour at 0x120eb70&gt;, &lt;class lambdafactory.modeltypes.Runtime at 0x120eba0&gt;)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Cx' class='de'><h1>Class <span class='n'>Factory</span></h1><div class='re'></div><div class='ds'><p>This class takes a module and look for classes with the same name as the <code>createXXX</code> methods and instanciates them.</p><p>For instance, if you define a module with classes like <code>Value</code>, <code>Literal</code>, <code>Invocation</code>, <code>Function</code>, etc. you just have to give this module to the factory constructor and it will be used to generate the given element.</p></div></div><div id='d_Cy' class='de'><h1>Method <span class='n'>resolve</span></h1><div class='re'><code>resolve( self, reference, context=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Cr' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><p>Tells if this element has a parent or not</p></div></div><div id='d_Cs' class='de'><h1>Method <span class='n'>setResultAbstractType</span></h1><div class='re'><code>setResultAbstractType( self, abstractType )</code></div><div class='ds'><p>Sets the abstract type for this operation result. This is usually invoked in the typing phase.</p></div></div><div id='d_Cp' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_Cq' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><p>Detaches the element from its parent (in case it was already attached). This should return this element, and set the parent to None.</p></div></div><div id='d_Cv' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns this element parent</p></div></div><div id='d_Cw' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><p>Performs a deep clone of this element. Any mutation to the original won't change the copy.</p></div></div><div id='d_Ct' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_Cu' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IOperation at 0x7bfae0&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='qB' class='cr'><div class='n'><a href='javascript:dS("qB");'>Map</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("qB","rB");'><span class='special __bases__'>Type</span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("qB","sB");'><span class='special __init__'>constructor</span></a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("qB","tB");'>add</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("qB","uB");'>asString</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("qB","vB");'>clone</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("qB","wB");'>element</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("qB","xB");'>elementNames</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("qB","yB");'>elements</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("qB","zB");'>get</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("qB","AB");'>isLike</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("qB","BB");'>isSameAs</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("qB","CB");'>isSubtypeOf</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("qB","DB");'>set</a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("qB","EB");'><span class='special __call__'>when invoked</span></a></div><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("qB","FB");'><span class='special __str__'>string conversion</span></a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("qB","GB");'>concreteType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("qB","HB");'>definedBy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("qB","IB");'>name</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("qB","JB");'>result</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("qB","KB");'>setConcreteType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("qB","LB");'>setName</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("qB","MB");'>subtype</a></div></div></div><div id='qm' class='cr'><div class='n'><a href='javascript:dS("qm");'>IInstanceMethod</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("qm","rm");'><span class='special __bases__'>IMethod</span></a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("qm","sm");'>addOperation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("qm","tm");'>copy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("qm","um");'>detach</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("qm","vm");'>endsWithTermination</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("qm","wm");'>getAbsoluteName</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("qm","xm");'>getAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("qm","ym");'>getAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("qm","zm");'>getArguments</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("qm","Am");'>getDataFlow</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("qm","Bm");'>getName</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("qm","Cm");'>getOperations</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("qm","Dm");'>getParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("qm","Em");'>getSlot</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("qm","Fm");'>getSlots</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("qm","Gm");'>hasExplicitTermination</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("qm","Hm");'>hasParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("qm","Im");'>hasSlot</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("qm","Jm");'>isAbstract</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("qm","Km");'>setAbstract</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("qm","Lm");'>setAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("qm","Mm");'>setAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("qm","Nm");'>setArguments</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("qm","Om");'>setParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("qm","Pm");'>setSlot</a></div></div></div><div id='Pq' class='cr'><div class='n'><a href='javascript:dS("Pq");'>IMatchProcessOperation</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("Pq","Qq");'><span class='special __bases__'>IMatchOperation</span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Pq","Rq");'>getProcess</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Pq","Sq");'>setProcess</a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Pq","Tq");'>addOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Pq","Uq");'>copy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Pq","Vq");'>detach</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Pq","Wq");'>getAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Pq","Xq");'>getAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Pq","Yq");'>getDataFlow</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Pq","Zq");'>getOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Pq","ar");'>getOpArguments</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Pq","br");'>getOpArgumentsInternalTypes</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Pq","cr");'>getParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Pq","dr");'>getPredicate</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Pq","er");'>hasParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Pq","fr");'>setAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Pq","gr");'>setAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Pq","hr");'>setOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Pq","ir");'>setParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Pq","jr");'>setPredicate</a></div></div><div class='t'>Values</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&bull;</span><a href='javascript:dO("Pq","kr");'>ARGS</a></div></div></div><div id='Pj' class='cr'><div class='n'><a href='javascript:dS("Pj");'>IFunction</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("Pj","Qj");'><span class='special __bases__'>IClosure, IReferencable, IAbstractable</span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Pj","Rj");'>endsWithTermination</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Pj","Sj");'>getName</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Pj","Tj");'>hasExplicitTermination</a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Pj","Uj");'>addOperation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Pj","Vj");'>copy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Pj","Wj");'>detach</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Pj","Xj");'>getAbsoluteName</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Pj","Yj");'>getAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Pj","Zj");'>getAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Pj","ak");'>getArguments</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Pj","bk");'>getDataFlow</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Pj","ck");'>getOperations</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Pj","dk");'>getParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Pj","ek");'>getSlot</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Pj","fk");'>getSlots</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Pj","gk");'>hasParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Pj","hk");'>hasSlot</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Pj","ik");'>isAbstract</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Pj","jk");'>setAbstract</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Pj","kk");'>setAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Pj","lk");'>setAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Pj","mk");'>setArguments</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Pj","nk");'>setParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Pj","ok");'>setSlot</a></div></div></div><div id='d_fB' class='de'><h1>Method <span class='n'>name</span></h1><div class='re'><code>name( self, name=None )</code></div><div class='ds'><p>Returns/sets the name for this type. By defaults, types are unnamed.</p></div></div><div id='cj' class='cr'><div class='n'><a href='javascript:dS("cj");'>IEvaluation</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("cj","dj");'><span class='special __bases__'>IOperation</span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("cj","ej");'>getEvaluable</a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("cj","fj");'>addOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("cj","gj");'>copy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("cj","hj");'>detach</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("cj","ij");'>getAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("cj","jj");'>getAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("cj","kj");'>getDataFlow</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("cj","lj");'>getOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("cj","mj");'>getOpArguments</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("cj","nj");'>getOpArgumentsInternalTypes</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("cj","oj");'>getParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("cj","pj");'>hasParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("cj","qj");'>setAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("cj","rj");'>setAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("cj","sj");'>setOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("cj","tj");'>setParent</a></div></div><div class='t'>Values</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&bull;</span><a href='javascript:dO("cj","uj");'>ARGS</a></div><div class='slot documented'><span
					class='prefix'>&bull;</span><a href='javascript:dO("cj","vj");'>ARG_NAMES</a></div></div></div><div id='d_pz' class='de'><h1>Class <span class='n'>Operations</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_py' class='de'><h1>Method <span class='n'>evaluate</span></h1><div class='re'><code>evaluate( self, evaluable )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_px' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><p>Performs a deep clone of this element. Any mutation to the original won't change the copy.</p></div></div><div id='d_pw' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_pv' class='de'><h1>Class <span class='n'>ISelection</span></h1><div class='re'></div><div class='ds'><p>Selections are the abstract objects behind <code>if</code>, <code>select</code> or pattern-matching operations. Each selection has match operations as arguments, which bind a subprocess to a predicate expression.</p></div></div><div id='d_pu' class='de'><h1>Method <span class='n'>getAbsoluteName</span></h1><div class='re'><code>getAbsoluteName( self )</code></div><div class='ds'><p>Returns the absolute name for this element</p></div></div><div id='d_pt' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_ps' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.ILiteral at 0x7bf540&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_pr' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><p>Detaches the element from its parent (in case it was already attached). This should return this element, and set the parent to None.</p></div></div><div id='d_pq' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><p>Tells if this element has a parent or not</p></div></div><div id='d_pp' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><p>Tells if this element has a parent or not</p></div></div><div id='d_po' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><p>Adds an argument to this operation. This should do checking of arguments (by expected internal type and number).</p></div></div><div id='d_pn' class='de'><h1>Method <span class='n'>getProcess</span></h1><div class='re'><code>getProcess( self )</code></div><div class='ds'><p>Returns the process that we will intercept interruptions from.</p></div></div><div id='d_pm' class='de'><h1>list</h1><div class='re'><code>['ImportedElements', 'ImportOrigin']</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='d_pl' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_pk' class='de'><h1>Class <span class='n'>IGroup</span></h1><div class='re'></div><div class='ds'><p>A block is a group of operations that share a common aspect. Groups are more likely to be used by program passes to further structure the program.</p><p>Groups should generally not have their own context, as opposed to blocks which generally have a context of their own.</p></div></div><div id='d_pj' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><p>Tells if this element has a parent or not</p></div></div><div id='d_pi' class='de'><h1>Method <span class='n'>getCode</span></h1><div class='re'><code>getCode( self )</code></div><div class='ds'><p>Returns the embedded code string.</p></div></div><div id='d_ph' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_pg' class='de'><h1>Method <span class='n'>getChildren</span></h1><div class='re'><code>getChildren( self )</code></div><div class='ds'><p>Returns a list of the child dataflows for this dataflow.</p></div></div><div id='d_pf' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><p>Sets this element parent</p></div></div><div id='d_pe' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_pd' class='de'><h1>Method <span class='n'>getConstructors</span></h1><div class='re'><code>getConstructors( self )</code></div><div class='ds'><p>Returns the constructors for this class</p></div></div><div id='d_pc' class='de'><h1>Method <span class='n'>getAssignedValue</span></h1><div class='re'><code>getAssignedValue( self )</code></div><div class='ds'><p>Returns this assigned evaluable.</p></div></div><div id='d_pb' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_pH' class='de'><h1>Method <span class='n'>info</span></h1><div class='re'><code>info( self, *message )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_pG' class='de'><h1>Method <span class='n'>isIn</span></h1><div class='re'><code>isIn( self, interface )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_pF' class='de'><h1>Method <span class='n'>getHandle</span></h1><div class='re'><code>getHandle( self, element )</code></div><div class='ds'><p>Tells if the pass handles the given element. This basically iterates on the <code>handles</code> property values (which are interfaces), when one interface matches the given <code>element</code>, then the corresponding <code>onXXX</code> method is invoked, where <code>XXX</code> is the interface name (without the leading <code>I</code>).</p></div></div><div id='d_pE' class='de'><h1>Method <span class='n'>handle</span></h1><div class='re'><code>handle( self, element )</code></div><div class='ds'><p>Handles a sungle element, without recursing through its children</p></div></div><div id='d_pD' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self, name )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_pC' class='de'><h1>Method <span class='n'>elements</span></h1><div class='re'><code>elements( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_pB' class='de'><h1>Class <span class='n'>InvalidArgument</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_pA' class='de'><h1>Method <span class='n'>setConcreteType</span></h1><div class='re'><code>setConcreteType( self, value )</code></div><div class='ds'><p>Sets the <span class='term'>concrete type</span> for this abstract type. The concrete type is a value which represents the type. For instance, if this type represents a class, then the concrete type would be the class instance.</p></div></div><div id='d_nc' class='de'><h1>Class <span class='n'>IAssignation</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_nb' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><p>Detaches the element from its parent (in case it was already attached). This should return this element, and set the parent to None.</p></div></div><div id='d_ne' class='de'><h1>Method <span class='n'>setAbstract</span></h1><div class='re'><code>setAbstract( self, isAbstract )</code></div><div class='ds'><p>Sets wether the given abstractable is abstract or not.</p></div></div><div id='d_nd' class='de'><h1>Method <span class='n'>getClassAttributes</span></h1><div class='re'><code>getClassAttributes( self )</code></div><div class='ds'><p>Returns the class attributes defined within this class.</p></div></div><div id='d_ng' class='de'><h1>Method <span class='n'>declareVariable</span></h1><div class='re'><code>declareVariable( self, name, value, origin=None )</code></div><div class='ds'><p>Declares a (local) variable with the given name, value and origin</p></div></div><div id='d_nf' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_ni' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_nh' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_nk' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, context )</code></div><div class='ds'><p>Sets the parent context for this context.</p></div></div><div id='d_nj' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><p>Returns the <em>internal types</em> for this operations arguments. This is typically the list of interfaces or @protocols that the arguments must comply to.</p></div></div><div id='d_nm' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><p>Sets this element parent</p></div></div><div id='d_nl' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_no' class='de'><h1>Class <span class='n'>IInterruption</span></h1><div class='re'></div><div class='ds'><p>An interruption can be be used to halt the process.</p></div></div><div id='d_nn' class='de'><h1>Method <span class='n'>getConclusion</span></h1><div class='re'><code>getConclusion( self )</code></div><div class='ds'><p>Returns the process that will conclude the interception (finally)</p></div></div><div id='d_nq' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns this element parent</p></div></div><div id='d_np' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><p>Returns the <em>internal types</em> for this operations arguments. This is typically the list of interfaces or @protocols that the arguments must comply to.</p></div></div><div id='d_ns' class='de'><h1>Method <span class='n'>setDefaultValue</span></h1><div class='re'><code>setDefaultValue( self )</code></div><div class='ds'><p>Sets the @methodault value for this attribute</p></div></div><div id='d_nr' class='de'><h1>Method <span class='n'>addOperation</span></h1><div class='re'><code>addOperation( self, operation )</code></div><div class='ds'><p>Adds the given operation as a child of this process.</p></div></div><div id='d_nu' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><p>Performs a deep clone of this element. Any mutation to the original won't change the copy.</p></div></div><div id='d_nt' class='de'><h1>Class <span class='n'>IParameter</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_nw' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_nv' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><p>Sets this element parent</p></div></div><div id='d_ny' class='de'><h1>Method <span class='n'>embedTemplate</span></h1><div class='re'><code>embedTemplate( self, lang, code )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_nx' class='de'><h1>Class <span class='n'>IValue</span></h1><div class='re'></div><div class='ds'><p>A value represents an atomic element of the language, like a number, a string, or a name (that can resolved by the language, acts as key for data structures, etc.).</p></div></div><div id='d_nz' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.modeltypes.TypeCollection at 0x120e0f0&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_nA' class='de'><h1>Method <span class='n'>name</span></h1><div class='re'><code>name( self, name=None )</code></div><div class='ds'><p>Returns/sets the name for this type. By defaults, types are unnamed.</p></div></div><div id='d_nC' class='de'><h1>Method <span class='n'>add</span></h1><div class='re'><code>add( self, theType )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_nB' class='de'><h1>Method <span class='n'>register</span></h1><div class='re'><code>register( self, name, _type )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_nE' class='de'><h1>Method <span class='n'>getParentElement</span></h1><div class='re'><code>getParentElement( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_nD' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.typecast.Symbolic at 0x120e930&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_nG' class='de'><h1>Method <span class='n'>handle</span></h1><div class='re'><code>handle( self, element )</code></div><div class='ds'><p>Handles a sungle element, without recursing through its children</p></div></div><div id='d_nF' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.passes.PassContext at 0x1219f30&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_nH' class='de'><h1>Method <span class='n'>error</span></h1><div class='re'><code>error( self, *message )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='vp' class='cr'><div class='n'><a href='javascript:dS("vp");'>IList</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("vp","wp");'><span class='special __bases__'>IValue</span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("vp","xp");'>addValue</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("vp","yp");'>getValues</a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("vp","zp");'>copy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("vp","Ap");'>detach</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("vp","Bp");'>getAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("vp","Cp");'>getAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("vp","Dp");'>getDataFlow</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("vp","Ep");'>getParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("vp","Fp");'>getResultAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("vp","Gp");'>hasParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("vp","Hp");'>setAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("vp","Ip");'>setAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("vp","Jp");'>setParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("vp","Kp");'>setResultAbstractType</a></div></div></div><div id='d_BD' class='de'><h1>Method <span class='n'>setName</span></h1><div class='re'><code>setName( self, name )</code></div><div class='ds'><p>Sets the name of this type</p></div></div><div id='d_BG' class='de'><h1>Method <span class='n'>filter</span></h1><div class='re'><code>filter( self, list, interface )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_BF' class='de'><h1>Method <span class='n'>getCurrentFunction</span></h1><div class='re'><code>getCurrentFunction( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_BA' class='de'><h1>Method <span class='n'>__call__</span></h1><div class='re'><code>__call__( self )</code></div><div class='ds'><p>A type instance can be used as a class to construct a new type, which will be cloned from the current type.</p></div></div><div id='d_BC' class='de'><h1>Method <span class='n'>result</span></h1><div class='re'><code>result( self )</code></div><div class='ds'><p>Returns the result for this type. This is usually just the type itself, except for processes types.</p></div></div><div id='d_BB' class='de'><h1>Method <span class='n'>isSameAs</span></h1><div class='re'><code>isSameAs( self, otherType )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='vz' class='cr'><div class='n'><a href='javascript:dS("vz");'>Structure</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("vz","wz");'><span class='special __bases__'>TypeCollection</span></a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("vz","xz");'>getType</a></div></div></div><div id='d_Bu' class='de'><h1>Class <span class='n'>IRepetition</span></h1><div class='re'></div><div class='ds'><p>A repetition is the repetitive execution of a process according to a predicate expression which can be modified by the process.</p></div></div><div id='d_Bt' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_Bw' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><p>Adds an argument to this operation. This should do checking of arguments (by expected internal type and number).</p></div></div><div id='d_Bv' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><p>Returns the <em>internal types</em> for this operations arguments. This is typically the list of interfaces or @protocols that the arguments must comply to.</p></div></div><div id='d_Bq' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><p>Performs a deep clone of this element. Any mutation to the original won't change the copy.</p></div></div><div id='d_Bp' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_Bs' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><p>Sets this element parent</p></div></div><div id='d_Br' class='de'><h1>Method <span class='n'>hasExplicitTermination</span></h1><div class='re'><code>hasExplicitTermination( self )</code></div><div class='ds'><p>Returns true if this function has an operation with a termination, otherwise return false.</p></div></div><div id='d_By' class='de'><h1>Method <span class='n'>repeat</span></h1><div class='re'><code>repeat( self, condition, process )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Bx' class='de'><h1>Module <span class='n'>lambdafactory.modelbase</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Bz' class='de'><h1>NoneType</h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Be' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_Bd' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_Bg' class='de'><h1>Method <span class='n'>addOperation</span></h1><div class='re'><code>addOperation( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Bf' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_Bc' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><p>Tells if this element has a parent or not</p></div></div><div id='d_Bb' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.IEvaluable at 0x7bf450&gt;, &lt;class lambdafactory.interfaces.IEvaluable at 0x7bf450&gt;]</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='d_Bm' class='de'><h1>Method <span class='n'>getName</span></h1><div class='re'><code>getName( self )</code></div><div class='ds'><p>Returns this @protocol name. It can be <code>None</code> if the @protocol is anonymous.</p></div></div><div id='d_Bl' class='de'><h1>Method <span class='n'>getAlias</span></h1><div class='re'><code>getAlias( self )</code></div><div class='ds'><p>Returns the (optional) alias which will allow to reference the element.</p></div></div><div id='d_Bo' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_Bn' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><p>Returns the <em>internal types</em> for this operations arguments. This is typically the list of interfaces or @protocols that the arguments must comply to.</p></div></div><div id='d_Bi' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><p>Sets the given argument of this operation, by argument index.</p></div></div><div id='d_Bh' class='de'><h1>Class <span class='n'>IElement</span></h1><div class='re'></div><div class='ds'><p>The core @protocol for every element.</p></div></div><div id='d_Bk' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_Bj' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><p>Detaches the element from its parent (in case it was already attached). This should return this element, and set the parent to None.</p></div></div><div id='Bh' class='cr'><div class='n'><a href='javascript:dS("Bh");'>IElement</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("Bh","c");'><span class='special __bases__'><i>Base class</i></span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Bh","Ch");'>copy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Bh","Dh");'>detach</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Bh","Eh");'>getAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Bh","Fh");'>getAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Bh","Gh");'>getDataFlow</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Bh","Hh");'>getParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Bh","Ih");'>hasParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Bh","Jh");'>setAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Bh","Kh");'>setAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Bh","Lh");'>setParent</a></div></div></div><div id='Bu' class='cr'><div class='n'><a href='javascript:dS("Bu");'>IRepetition</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("Bu","Cu");'><span class='special __bases__'>IOperation</span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Bu","Du");'>getCondition</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Bu","Eu");'>getProcess</a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Bu","Fu");'>addOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Bu","Gu");'>copy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Bu","Hu");'>detach</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Bu","Iu");'>getAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Bu","Ju");'>getAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Bu","Ku");'>getDataFlow</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Bu","Lu");'>getOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Bu","Mu");'>getOpArguments</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Bu","Nu");'>getOpArgumentsInternalTypes</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Bu","Ou");'>getParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Bu","Pu");'>hasParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Bu","Qu");'>setAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Bu","Ru");'>setAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Bu","Su");'>setOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Bu","Tu");'>setParent</a></div></div><div class='t'>Values</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&bull;</span><a href='javascript:dO("Bu","Uu");'>ARGS</a></div></div></div><div id='Bx' class='ro'><div class='n'><a href='javascript:dS("Bx");'>lambdafactory.modelbase</a></div><div class='t'>Classes</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("Bx","Cx");'>Factory</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("Bx","Gy");'>ModelBadArgument</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("Bx","Ny");'>ModelException</a></div></div><div class='t'>Functions</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&lambda;</span><a href='javascript:dO("Bx","Py");'>assertImplements</a></div></div></div><div id='d_Tc' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IInterruption at 0x7bff60&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Tb' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><p>Sets the given argument of this operation, by argument index.</p></div></div><div id='d_Tg' class='de'><h1>Method <span class='n'>getOperations</span></h1><div class='re'><code>getOperations( self )</code></div><div class='ds'><p>Returns the list of operations in this process.</p></div></div><div id='d_Tf' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns the parent context for this context (if any)</p></div></div><div id='d_Te' class='de'><h1>Method <span class='n'>getLeftOperand</span></h1><div class='re'><code>getLeftOperand( self )</code></div><div class='ds'><p>Returns the left operand of this computation.</p></div></div><div id='d_Td' class='de'><h1>Class <span class='n'>IClassMethod</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Tk' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><p>Detaches the element from its parent (in case it was already attached). This should return this element, and set the parent to None.</p></div></div><div id='d_Tj' class='de'><h1>Method <span class='n'>hasExplicitTermination</span></h1><div class='re'><code>hasExplicitTermination( self )</code></div><div class='ds'><p>Returns true if this function has an operation with a termination, otherwise return false.</p></div></div><div id='d_Ti' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><p>Tells if this element has a parent or not</p></div></div><div id='d_Th' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><p>Performs a deep clone of this element. Any mutation to the original won't change the copy.</p></div></div><div id='d_To' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><p>Returns the <em>internal types</em> for this operations arguments. This is typically the list of interfaces or @protocols that the arguments must comply to.</p></div></div><div id='d_Tn' class='de'><h1>Method <span class='n'>getConstructors</span></h1><div class='re'><code>getConstructors( self )</code></div><div class='ds'><p>Returns the constructors for this class</p></div></div><div id='d_Tm' class='de'><h1>Method <span class='n'>getArguments</span></h1><div class='re'><code>getArguments( self )</code></div><div class='ds'><p>Returns evaluable arguments.</p></div></div><div id='d_Tl' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.IEvaluable at 0x7bf450&gt;, &lt;class lambdafactory.interfaces.IEvaluable at 0x7bf450&gt;, &lt;class lambdafactory.interfaces.IEvaluable at 0x7bf450&gt;]</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='d_Ts' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><p>Sets this element parent</p></div></div><div id='d_Tr' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><p>Performs a deep clone of this element. Any mutation to the original won't change the copy.</p></div></div><div id='d_Tq' class='de'><h1>Method <span class='n'>addOpArgument</span></h1><div class='re'><code>addOpArgument( self, argument )</code></div><div class='ds'><p>Adds an argument to this operation. This should do checking of arguments (by expected internal type and number).</p></div></div><div id='d_Tp' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns this element parent</p></div></div><div id='d_Tw' class='de'><h1>Method <span class='n'>getOffset</span></h1><div class='re'><code>getOffset( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Tv' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><p>Returns the ith arguments to this operation.</p></div></div><div id='d_Tu' class='de'><h1>Method <span class='n'>setParent</span></h1><div class='re'><code>setParent( self, element )</code></div><div class='ds'><p>Sets this element parent</p></div></div><div id='d_Tt' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><p>Detaches the element from its parent (in case it was already attached). This should return this element, and set the parent to None.</p></div></div><div id='d_Tz' class='de'><h1>Method <span class='n'>length</span></h1><div class='re'><code>length( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Ty' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Tx' class='de'><h1>Method <span class='n'>annotation</span></h1><div class='re'><code>annotation( self, name, content )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_TC' class='de'><h1>Method <span class='n'>setConcreteType</span></h1><div class='re'><code>setConcreteType( self, value )</code></div><div class='ds'><p>Sets the <span class='term'>concrete type</span> for this abstract type. The concrete type is a value which represents the type. For instance, if this type represents a class, then the concrete type would be the class instance.</p></div></div><div id='d_TB' class='de'><h1>Method <span class='n'>asString</span></h1><div class='re'><code>asString( self, fromTypes=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_TA' class='de'><h1>Method <span class='n'>parents</span></h1><div class='re'><code>parents( self )</code></div><div class='ds'><p>Returns a context parents, as a mutable list.</p></div></div><div id='d_TG' class='de'><h1>Method <span class='n'>getProgram</span></h1><div class='re'><code>getProgram( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_TF' class='de'><h1>list</h1><div class='re'><code>[]</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='d_TE' class='de'><h1>Method <span class='n'>getCurrentProcess</span></h1><div class='re'><code>getCurrentProcess( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_TD' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self, args=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='Uw' class='cr'><div class='n'><a href='javascript:dS("Uw");'>ITermination</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("Uw","Vw");'><span class='special __bases__'>IOperation</span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Uw","Ww");'>getReturnedEvaluable</a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Uw","Xw");'>addOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Uw","Yw");'>copy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Uw","Zw");'>detach</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Uw","ax");'>getAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Uw","bx");'>getAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Uw","cx");'>getDataFlow</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Uw","dx");'>getOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Uw","ex");'>getOpArguments</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Uw","fx");'>getOpArgumentsInternalTypes</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Uw","gx");'>getParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Uw","hx");'>hasParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Uw","ix");'>setAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Uw","jx");'>setAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Uw","kx");'>setOpArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Uw","lx");'>setParent</a></div></div><div class='t'>Values</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&bull;</span><a href='javascript:dO("Uw","mx");'>ARGS</a></div></div></div><div id='Us' class='cr'><div class='n'><a href='javascript:dS("Us");'>IOperator</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("Us","Vs");'><span class='special __bases__'>IReference</span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Us","Ws");'>getPriority</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Us","Xs");'>setPriority</a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Us","Ys");'>copy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Us","Zs");'>detach</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Us","at");'>getAbsoluteName</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Us","bt");'>getAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Us","ct");'>getAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Us","dt");'>getDataFlow</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Us","et");'>getName</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Us","ft");'>getParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Us","gt");'>getReferenceName</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Us","ht");'>getResultAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Us","it");'>hasParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Us","jt");'>setAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Us","kt");'>setAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Us","lt");'>setParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("Us","mt");'>setResultAbstractType</a></div></div></div><div id='UF' class='cr'><div class='n'><a href='javascript:dS("UF");'>PassContext</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("UF","c");'><span class='special __bases__'><i>Base class</i></span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("UF","VF");'><span class='special __init__'>constructor</span></a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("UF","WF");'>filter</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("UF","XF");'>filterContext</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("UF","YF");'>findInContext</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("UF","ZF");'>getCurrentClass</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("UF","aG");'>getCurrentClassAncestors</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("UF","bG");'>getCurrentClassParents</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("UF","cG");'>getCurrentClosure</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("UF","dG");'>getCurrentContext</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("UF","eG");'>getCurrentDataFlow</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("UF","fG");'>getCurrentElement</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("UF","gG");'>getCurrentFunction</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("UF","hG");'>getCurrentMethod</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("UF","iG");'>getCurrentModule</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("UF","jG");'>getCurrentProcess</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("UF","kG");'>getFactory</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("UF","lG");'>getParentElement</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("UF","mG");'>getProgram</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("UF","nG");'>handle</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("UF","oG");'>hasParentElement</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("UF","pG");'>isIn</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("UF","qG");'>resolve</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("UF","rG");'>resolveAbsolute</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("UF","sG");'>resolveAbsoluteOrLocal</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("UF","tG");'>resolveLocalOrAbsolute</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("UF","uG");'>run</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("UF","vG");'>setEnvironment</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("UF","wG");'>setPass</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("UF","xG");'>walk</a></div></div></div><div id='d_al' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns this element parent</p></div></div><div id='d_am' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><p>Performs a deep clone of this element. Any mutation to the original won't change the copy.</p></div></div><div id='d_an' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_ao' class='de'><h1>Method <span class='n'>getParent</span></h1><div class='re'><code>getParent( self )</code></div><div class='ds'><p>Returns the parent context for this context (if any)</p></div></div><div id='d_ah' class='de'><h1>Method <span class='n'>isAbstract</span></h1><div class='re'><code>isAbstract( self )</code></div><div class='ds'><p>Tells wether the given abstractable is abstract or not.</p></div></div><div id='d_ai' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><p>Returns the <em>internal types</em> for this operations arguments. This is typically the list of interfaces or @protocols that the arguments must comply to.</p></div></div><div id='d_aj' class='de'><h1>Method <span class='n'>getResultAbstractType</span></h1><div class='re'><code>getResultAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type of the result of the evaluation of this evaluable</p></div></div><div id='d_ak' class='de'><h1>Method <span class='n'>getArguments</span></h1><div class='re'><code>getArguments( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_ad' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><p>Returns the ith arguments to this operation.</p></div></div><div id='d_ae' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_af' class='de'><h1>Method <span class='n'>setRightOperand</span></h1><div class='re'><code>setRightOperand( self, operand )</code></div><div class='ds'><p>Sets the right operand of this computation</p></div></div><div id='d_ag' class='de'><h1>Method <span class='n'>detach</span></h1><div class='re'><code>detach( self )</code></div><div class='ds'><p>Detaches the element from its parent (in case it was already attached). This should return this element, and set the parent to None.</p></div></div><div id='d_ab' class='de'><h1>Method <span class='n'>setAbstractType</span></h1><div class='re'><code>setAbstractType( self, type )</code></div><div class='ds'><p>Sets the abstract type for this element</p></div></div><div id='d_ac' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.ISlot at 0x7bf6c0&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_ax' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_ay' class='de'><h1>Method <span class='n'>createClassMethod</span></h1><div class='re'><code>createClassMethod( self, name, arguments=() )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_az' class='de'><h1>str</h1><div class='re'><code>''</code></div><div class='ds'><p>str(object) -&gt; string</p><p>Return a nice string representation of the object. If the argument is a string, the return value is the same object.</p></div></div><div id='d_at' class='de'><h1>Method <span class='n'>getAbsoluteName</span></h1><div class='re'><code>getAbsoluteName( self )</code></div><div class='ds'><p>Returns the absolute name for this element</p></div></div><div id='d_au' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><p>Tells if this element has a parent or not</p></div></div><div id='d_av' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><p>Performs a deep clone of this element. Any mutation to the original won't change the copy.</p></div></div><div id='d_aw' class='de'><h1>Method <span class='n'>setAnnotation</span></h1><div class='re'><code>setAnnotation( self, name, annotation )</code></div><div class='ds'><p>Sets the annotation with the given name to this element</p></div></div><div id='d_ap' class='de'><h1>list</h1><div class='re'><code>[&lt;class lambdafactory.interfaces.IEvaluable at 0x7bf450&gt;, [&lt;class lambdafactory.interfaces.IEvaluable at 0x7bf450&gt;]]</code></div><div class='ds'><p>list() -&gt; new list list(sequence) -&gt; new list initialized from sequence's items</p></div></div><div id='d_aq' class='de'><h1>Class <span class='n'>IMatchExpressionOperation</span></h1><div class='re'></div><div class='ds'><p>A match expression is a predicate that is associated to an expression. This is typically used in conditional expressions like in C:</p><pre>int a = ( b==2 ? 1 : 2 )</pre></div></div><div id='d_ar' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><p>Returns the arguments to this operation.</p></div></div><div id='d_as' class='de'><h1>Method <span class='n'>getSlots</span></h1><div class='re'><code>getSlots( self )</code></div><div class='ds'><p>Returns (key, evaluable) pairs representing the slots within this context.</p></div></div><div id='d_aH' class='de'><h1>Method <span class='n'>resolveLocalOrAbsolute</span></h1><div class='re'><code>resolveLocalOrAbsolute( self, referenceOrName, contextOrDataFlow=None )</code></div><div class='ds'><p>Tries a local resolution first, then will look in the program scope if it fails.</p></div></div><div id='d_aD' class='de'><h1>Method <span class='n'>asString</span></h1><div class='re'><code>asString( self, fromTypes=None )</code></div><div class='ds'><p>Returns a string representation of this type.</p></div></div><div id='d_aE' class='de'><h1>Method <span class='n'>getCurrentClassAncestors</span></h1><div class='re'><code>getCurrentClassAncestors( self, theClass=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_aF' class='de'><h1>Method <span class='n'>hasParentElement</span></h1><div class='re'><code>hasParentElement( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_aG' class='de'><h1>Method <span class='n'>getCurrentClassAncestors</span></h1><div class='re'><code>getCurrentClassAncestors( self, theClass=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_aA' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.typecast.Type at 0x120e900&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_aB' class='de'><h1>Method <span class='n'>elementNames</span></h1><div class='re'><code>elementNames( self )</code></div><div class='ds'><p>Returns the list of slots/elements defined in this map.</p></div></div><div id='d_aC' class='de'><h1>Method <span class='n'>result</span></h1><div class='re'><code>result( self, result=None )</code></div><div class='ds'><p>If there is not at least 2 addded types, the result is Nothing.</p></div></div><div id='hs' class='cr'><div class='n'><a href='javascript:dS("hs");'>IModuleAttribute</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("hs","is");'><span class='special __bases__'>IAttribute</span></a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("hs","js");'>getAbsoluteName</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("hs","ks");'>getDefaultValue</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("hs","ls");'>getName</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("hs","ms");'>getTypeDescription</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("hs","ns");'>setDefaultValue</a></div></div></div><div id='hh' class='cr'><div class='n'><a href='javascript:dS("hh");'>IDict</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("hh","ih");'><span class='special __bases__'>IValue</span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("hh","jh");'>getItems</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("hh","kh");'>setValue</a></div></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("hh","lh");'>copy</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("hh","mh");'>detach</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("hh","nh");'>getAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("hh","oh");'>getAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("hh","ph");'>getDataFlow</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("hh","qh");'>getParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("hh","rh");'>getResultAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("hh","sh");'>hasParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("hh","th");'>setAbstractType</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("hh","uh");'>setAnnotation</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("hh","vh");'>setParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("hh","wh");'>setResultAbstractType</a></div></div></div><div id='hg' class='cr'><div class='n'><a href='javascript:dS("hg");'>IDataFlow</a></div><div class='t'>Bases</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:dO("hg","c");'><span class='special __bases__'><i>Base class</i></span></a></div></div><div class='t'>Methods</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("hg","ig");'>addChild</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("hg","jg");'>addDestination</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("hg","kg");'>addSource</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("hg","lg");'>declareArgument</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("hg","mg");'>declareEnvironment</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("hg","ng");'>declareVariable</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("hg","og");'>defines</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("hg","pg");'>getChildren</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("hg","qg");'>getDestinations</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("hg","rg");'>getParent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("hg","sg");'>getRoot</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("hg","tg");'>getSlot</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("hg","ug");'>getSlots</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("hg","vg");'>getSources</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("hg","wg");'>hasSlot</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("hg","xg");'>resolve</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:dO("hg","yg");'>setParent</a></div></div></div><div id='hH' class='ro'><div class='n'><a href='javascript:dS("hH");'>lambdafactory.reporter</a></div><div class='t'>Classes</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:dO("hH","iH");'>Reporter</a></div></div><div class='t'>Values</div class='t'><div class='g'><div class='slot documented'><span
					class='prefix'>&sdot;</span><a href='javascript:dO("hH","uH");'>DefaultReporter</a></div></div></div><div id='d_sz' class='de'><h1>Class <span class='n'>Runtime</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_sx' class='de'><h1>Method <span class='n'>getAnnotation</span></h1><div class='re'><code>getAnnotation( self, name )</code></div><div class='ds'><p>Gets the annotation with the given name associated to this element</p></div></div><div id='d_sy' class='de'><h1>Method <span class='n'>importModules</span></h1><div class='re'><code>importModules( self, names )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_sr' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_ss' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_sp' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><p>Sets the given argument of this operation, by argument index.</p></div></div><div id='d_sq' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><p>Sets the given argument of this operation, by argument index.</p></div></div><div id='d_sv' class='de'><h1>Method <span class='n'>getRules</span></h1><div class='re'><code>getRules( self )</code></div><div class='ds'><p>Returns the ordered set of rule for this selection.</p></div></div><div id='d_sw' class='de'><h1>Method <span class='n'>getResultAbstractType</span></h1><div class='re'><code>getResultAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type of the result of the evaluation of this evaluable</p></div></div><div id='d_st' class='de'><h1>Method <span class='n'>isAsMap</span></h1><div class='re'><code>isAsMap( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_su' class='de'><h1>Method <span class='n'>getDataFlow</span></h1><div class='re'><code>getDataFlow( self )</code></div><div class='ds'><p>Returns the dataflow accessible/bound to this element</p></div></div><div id='d_sj' class='de'><h1>Method <span class='n'>setOpArgument</span></h1><div class='re'><code>setOpArgument( self, i, value )</code></div><div class='ds'><p>Sets the given argument of this operation, by argument index.</p></div></div><div id='d_sk' class='de'><h1>Method <span class='n'>getOperations</span></h1><div class='re'><code>getOperations( self )</code></div><div class='ds'><p>Returns the list of operations in this process.</p></div></div><div id='d_sh' class='de'><h1>Method <span class='n'>hasParent</span></h1><div class='re'><code>hasParent( self )</code></div><div class='ds'><p>Tells if this element has a parent or not</p></div></div><div id='d_si' class='de'><h1>Method <span class='n'>getOpArgument</span></h1><div class='re'><code>getOpArgument( self, i )</code></div><div class='ds'><p>Returns the ith arguments to this operation.</p></div></div><div id='d_sn' class='de'><h1>Method <span class='n'>setProcess</span></h1><div class='re'><code>setProcess( self, process )</code></div><div class='ds'><p>Sets the process from which interruptions will be intercepted.</p></div></div><div id='d_so' class='de'><h1>Method <span class='n'>getAbstractType</span></h1><div class='re'><code>getAbstractType( self )</code></div><div class='ds'><p>Returns the abstract type for this element</p></div></div><div id='d_sl' class='de'><h1>Method <span class='n'>getOpArgumentsInternalTypes</span></h1><div class='re'><code>getOpArgumentsInternalTypes( self )</code></div><div class='ds'><p>Returns the <em>internal types</em> for this operations arguments. This is typically the list of interfaces or @protocols that the arguments must comply to.</p></div></div><div id='d_sm' class='de'><h1>Method <span class='n'>addOperation</span></h1><div class='re'><code>addOperation( self, operation )</code></div><div class='ds'><p>Adds the given operation as a child of this process.</p></div></div><div id='d_sb' class='de'><h1>Method <span class='n'>getOpArguments</span></h1><div class='re'><code>getOpArguments( self )</code></div><div class='ds'><p>Returns the arguments to this operation.</p></div></div><div id='d_sc' class='de'><h1>Method <span class='n'>copy</span></h1><div class='re'><code>copy( self )</code></div><div class='ds'><p>Performs a deep clone of this element. Any mutation to the original won't change the copy.</p></div></div><div id='d_sf' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class lambdafactory.interfaces.IMethod at 0x7bf9f0&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_sg' class='de'><h1>Method <span class='n'>getRoot</span></h1><div class='re'><code>getRoot( self )</code></div><div class='ds'><p>Returns the root of this dataflow (the root of the parent or this dataflow if it has no parent)</p></div></div><div id='d_sd' class='de'><h1>Method <span class='n'>getMethods</span></h1><div class='re'><code>getMethods( self )</code></div><div class='ds'><p>Returns the methods defined within this class.</p></div></div><div id='d_se' class='de'><h1>Method <span class='n'>setSlot</span></h1><div class='re'><code>setSlot( self, name, evaluable )</code></div><div class='ds'><p>Binds the given evaluable to the named slot.</p></div></div><div id='d_sH' class='de'><h1>Method <span class='n'>onWarning</span></h1><div class='re'><code>onWarning( self, callback )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_sB' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self, **kwargs )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_sC' class='de'><h1>Method <span class='n'>isSameAs</span></h1><div class='re'><code>isSameAs( self, otherType )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_sA' class='de'><h1>Class <span class='n'>Cell</span></h1><div class='re'></div><div class='ds'><p>A cell type represents a memory unit. It has a size (in bytes) the represents the length in memory.</p></div></div><div id='d_sF' class='de'><h1>Method <span class='n'>filterContext</span></h1><div class='re'><code>filterContext( self, interface )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_sG' class='de'><h1>Method <span class='n'>resolveAbsoluteOrLocal</span></h1><div class='re'><code>resolveAbsoluteOrLocal( self, referenceOrName, contextOrDataFlow=None )</code></div><div class='ds'><p>Tries an absolute resolution first, then will look in the local scope if it fails.</p></div></div><div id='d_sD' class='de'><h1>Method <span class='n'>clone</span></h1><div class='re'><code>clone( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_sE' class='de'><h1>Method <span class='n'>resolve</span></h1><div class='re'><code>resolve( self, referenceOrName, contextOrDataFlow=None )</code></div><div class='ds'><p>Resolves the given <code>IReference</code> or String sing the given context (<code>IContext</code>) or dataflow (<code>IDataFlow</code>). This usually requires that you've applied a pass to create the dataflow (see the 'lambdafactory.resolution.BasicDataFlow' pass).</p></div></div>
	<!-- hidden-snip -->
	<!-- hidden nodes will be moved here -->
</div>
</div>
<!-- body -->
</body>
</html>
